<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>5</title>
<!-- 2017-05-02 Tue 10:45 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">5</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 56: Sockets: Introduction</a>
<ul>
<li><a href="#sec-1-1">Overview</a></li>
<li><a href="#sec-1-2">Creating a Socket: socket()</a></li>
<li><a href="#sec-1-3">Binding a Socket to an Address: bind()</a></li>
<li><a href="#sec-1-4">Generic Socket Address Structures: struct sockaddr</a></li>
<li><a href="#sec-1-5">Stream Sockets</a>
<ul>
<li><a href="#sec-1-5-1">Listening for Incoming Connections: listen()</a></li>
<li><a href="#sec-1-5-2">Accepting a Connection: accept()</a></li>
<li><a href="#sec-1-5-3">Connection to a Peer Socket: connect()</a></li>
<li><a href="#sec-1-5-4">I/O on Stream Sockets</a></li>
<li><a href="#sec-1-5-5">Connection Termination: close()</a></li>
</ul>
</li>
<li><a href="#sec-1-6">Datagram Sockets</a>
<ul>
<li><a href="#sec-1-6-1">Exchanging Datagrams: recvfrom() and sendto()</a></li>
<li><a href="#sec-1-6-2">Using connect() with Datagram Sockets</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">Chapter 57: Sockets: Unix Domain</a>
<ul>
<li><a href="#sec-2-1">UNIX Domain Socket Addresses: struct sockaddr_un</a></li>
<li><a href="#sec-2-2">Stream Socket in the UNIX Domain</a></li>
<li><a href="#sec-2-3">Datagram Socketin the UNIX Domain</a></li>
<li><a href="#sec-2-4">Unix Domain Socket Permissions</a></li>
<li><a href="#sec-2-5">Creating a Connected Socket Pair: socketpair()</a></li>
<li><a href="#sec-2-6">The Linux Abstract Socket Namespace</a></li>
</ul>
</li>
<li><a href="#sec-3">Chapter 58: Sockets: Fundamentals of TCP/IP Networks</a>
<ul>
<li><a href="#sec-3-1">Internets</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 56: Sockets: Introduction</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Socket是IPC的一种,用来在application之间传递数据, 而这些不同的application可以
是在同一台机器上面,也可以是在不同的机器上面(但是必须在同一个network)
</li>
<li>第一个版本的socker API是在1983发布的4.2BSD, 并且以后广泛的存在于各个版本的Unix
系统里面
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Overview</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>常见的client-server系统中, 需要用到socket的场景如下:
<ul class="org-ul">
<li>每一个application都创建一个socket. socket是一种工具需要"沟通"双方都需要的
工具,所以每个application都需要一个socket
</li>
<li>server把自己的socket绑定到一个well-known port, 这样一来, client就可以通过
&lt;IP&gt;:&lt;Port&gt;
</li>
</ul>
</li>
<li>socket的创建是通过socket() system call.这个system call会返回file descriptor
用来指代这个socket(一切皆文件)
<div class="org-src-container">

<pre class="src src-c">fd = socket<span style="color: #2aa198;">(</span>domain, type, protocol<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>我们逐一来看看这些参数:
<ul class="org-ul">
<li>domain: 常见的domain有如下三种
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Domain</th>
<th scope="col" class="left">Communication preformed</th>
<th scope="col" class="left">Communication between applications</th>
<th scope="col" class="left">Address format</th>
<th scope="col" class="left">Address Structure</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">AF_UNIX</td>
<td class="left">within kernel</td>
<td class="left">on same host</td>
<td class="left">pathname</td>
<td class="left">sockaddr_un</td>
</tr>

<tr>
<td class="left">AF_INET</td>
<td class="left">via IPv4</td>
<td class="left">on hosts connected via an IPv4 network</td>
<td class="left">32-bit IPv4 + 16-bit port</td>
<td class="left">sockaddr_in</td>
</tr>

<tr>
<td class="left">AF_INET6</td>
<td class="left">via IPv6</td>
<td class="left">on hotts connected via an IPv6 network</td>
<td class="left">128-bit IPv6+16-bit port</td>
<td class="left">sockaddr_in6</td>
</tr>
</tbody>
</table>
</li>
<li>type: 说的是socket type, 不同的domain都会提供如下两种socket type: Stream
和Datagram, 它俩的特点如下
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Property</th>
<th scope="col" class="left">Stream</th>
<th scope="col" class="left">Datagram</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Reliable delivery?</td>
<td class="left">Y</td>
<td class="left">N</td>
</tr>

<tr>
<td class="left">Message boundaries preserved?</td>
<td class="left">N</td>
<td class="left">Y</td>
</tr>

<tr>
<td class="left">Connection-oriented?</td>
<td class="left">Y</td>
<td class="left">N</td>
</tr>
</tbody>
</table>
</li>
<li>protocol一般都是0, 早期这个protocol是用来使用default protocol用的,但是现
在已经被废弃, 设置为0的意思就是不使用任何default protocol
</li>
</ul>
</li>
<li>这些参数里面,比较难以理解的是Stream这个概念, Stream socket(SOCK_STREAM) 提供
了reliable, bidirectional, byte-stream channel, 这些概念的意义如下:
<ul class="org-ul">
<li>reliable:意味着要么,我们成功的把数据完整的传递给对方,要么,我传递的不完整的
话,我肯定知道,我要"警告对方"数据可能损坏
</li>
<li>bidirectional: 意味着数据都是双向传递的, client端有一个socket, server端有
另外一个socket, 这两个socket之间,无论哪个方向都是可以传递信息的(后面阅读有感)
</li>
<li>byte-stream: 就是没有message boundaries的概念
</li>
</ul>
</li>
<li>其实stream socket就像是network上的pipe(管道)传递
</li>
<li>stream socket总是在connected 的通道上活动,所以stream socket也叫做connection-oriented
</li>
<li>stream socket只能connect一个peer
</li>
<li>Datagram socket是让data以datagram(一种message)为载体进行传播的,所以datagram
socket肯定是有message boundary的.
</li>
<li>message传播的特点不仅仅是以message为载体,还包括传输可能存在:
<ul class="org-ul">
<li>out of order
</li>
<li>duplicated
</li>
<li>根本没有传输到对方
</li>
</ul>
</li>
<li>和stream socket不一样的是, datagram socket都不需要建立connection之后才发送
它是一种connectionless socket
</li>
<li>socket领域的system call主要有:
<ul class="org-ul">
<li>socket():创建new socket
</li>
<li>bind():bind一个socket到一个address,通常是server才需要这个步骤,因为server要
绑定一个well-known的 address,client才能找到. client就不需要一个特别著名的地址
</li>
<li>listen(): listen允许stream socket来接听incoming connection
</li>
<li>accept(): accept用来接受从peer application传来的connection请求, 必须首先是
一个listening socket,才能accept其他connection
</li>
<li>connect(): 就是client一端的socket,去拼命的联系server端的socket, 当然了,因
为"忙音"的存在,不一定能联系成功(后面阅读有感)
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Creating a Socket: socket()</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>创建新的socket的system call
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">sys/socket.h</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">socket</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">domain</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">type</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">protocol</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Returns file descriptor on success, or -1 on error  </span><span style="color: #93a1a1;">*/</span>
</pre>
</div>
</li>
<li>主要部分前面都介绍过了, 就是protocol比较特殊,其非0值不太常用
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Binding a Socket to an Address: bind()</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>获得了新的socket之后,一般都要"配置"这个socket, 配置的第一步,就是把这个socket
"联系"上某个address. 通常这个动作也只有server会做, 因为server要做到地址为人
所知
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">sys/socket.h</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">bind</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">sockfd</span>, <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span>* <span style="color: #268bd2;">addr</span>, <span style="color: #b58900;">socklen_t</span> <span style="color: #268bd2;">addrlen</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Returns 0 on success, or -1 on error </span><span style="color: #93a1a1;">*/</span>
</pre>
</div>
</li>
<li>sockfd就是我们前面socket()后得到的fd
</li>
<li>addr是一个指向"well known地址的变量"的指针
</li>
<li>addrlen是这个"well known地址的变量"的长度
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Generic Socket Address Structures: struct sockaddr</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>我们前面在socket()里面看到了,Linux上面存在不同的domain. 而不同的domain是使用
不同的address format的.比如, Unix domain socket就是使用pathname, Internet domain
就是使用IP加port
</li>
<li>bind()是system call,所以它要接受各种不同的address format. 为了让bind()可以
接受不同的address format, socket API定义了一个generic address structure,叫做
struct sockaddr, 其作用就是为了cast不同的address format
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">sa_family_t</span>   <span style="color: #268bd2;">sa_family</span>;
    <span style="color: #b58900;">char</span>          <span style="color: #268bd2;">sa_data</span><span style="color: #b58900;">[</span>4<span style="color: #b58900;">]</span>;
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Stream Sockets</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>stream socket的通信过程,是和telephone system非常相似的:
<ul class="org-ul">
<li>socket() 是建立socket,这就和"安装电话"一样.为了让两个地方的人通信,两个地方
都必须安装电话. 为了让两个application通信,两个application也都必须create
socket!!(这个是我第一次对socket有了正确的理解!!)
</li>
<li>在真正的"打电话(传递数据)"之前,还是有一些工作要做:
<ul class="org-ul">
<li>server端: 必须使用bind()把自己绑定在一个well-known 地址,然后listen()等待
新的connection来访问. 对比telephone就是为自己的电话申请一个well-known的
号码,比如123,然后还要把电话打开,这样其他电话才能打进来
</li>
<li>client端(首先也要socket()安装电话), 它在知道server端号码的情况下, 可以直接
拨打,也就是connect(), 然后就是等待接通啦
</li>
<li>server端的listen()在有其他incomming connection来临的情况下,会调用accept()
来接听connection,就好比我们听到电话响,就拿起电话和client对话. 注意,一旦
你接听了一个电话,另外其他像打进来的电话就是"忙音"了
</li>
</ul>
</li>
<li>一旦电话接通,那么就可以对话了,一旦两个socket建立了connection,那么就可以在
两个方向进行数据传输了.
</li>
</ul>
</li>
<li>stream socket可以分成passive或者active两种:
<ul class="org-ul">
<li>使用connect()去主动联系其他socket的,叫做active open socket
</li>
<li>使用listen()等待其他socket, 然后accept() block直到其他socket来临的socket叫做
passive open socket.
</li>
</ul>
</li>
<li>一般来说server是passive open, client是active open

<div class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/org_dot/master/notes/linux/socket-passive-active.png" alt="socket-passive-active.png" />
</p>
<p><span class="figure-number">Figure 1:</span> socket-passive-active.png</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">Listening for Incoming Connections: listen()</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li>listen() system call 是把sockfd指向的socket变成passive的,然后这个socket后面
会被accept()调用来迎接incoming connection
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">sys/socket.h</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">listen</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">sockfd</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">backlog</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Returns 0 on success, or -1 on error </span><span style="color: #93a1a1;">*/</span>
</pre>
</div>
</li>
<li>我们的listen只能调用"还没有connected"的socket, 如果这个socket已经和其他机
器上的别的socket建立过联系了,那么我们就不能再使用listen来把它变成passive了
</li>
<li>这个函数有点诡异的地方在于参数backlog,这个参数的诞生是因为如下的场景:
<ul class="org-ul">
<li>server在调用accept()之前,就已经收到client发过来的connect()了, 这是非常可
能的, 特别是在client有很多访问的时候:
<ol class="org-ol">
<li>从server端来看,accept()会block,直到有新的client访问,这是server"先准备
好"的情况
</li>
<li>从client端来看,connect()会block,知道server忙完其他connection, 这是client
端"先准备好"的情况
</li>
</ol>
</li>
<li>server端需要一个"缓冲取"来记录下"自己没有准备好"的情况下,进来的connection,
这个数目肯定是有上限的,我们不可能无限制的记录来不及处理的client connection
这个上限就是由backlog参数决定的.
</li>
<li>当然了,操作系统也不是傻瓜,你把backlog设置成任何数它都认,它有一个最大的限度:
<ol class="org-ol">
<li>早期是5, immutable
</li>
<li>后来到了128, immutable
</li>
<li>Linux 2.4.25以后可以通过/proc/sys/net/core/somaxconn来动态更改
</li>
</ol>
</li>
<li>backlog设定的这个"缓冲"区,其实是为accept()准备的,每次accept()其实都来这个
"缓冲区(queue)"里面,寻找最老的一个connection
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">Accepting a Connection: accept()</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li>accept()其实就是从backlog设定的"缓冲区queue"里面寻找最老的一个connection,
如果有,就创建一个新的connected socket, 否则就block
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">sys/socket.h</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">accept</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">sockfd</span>, <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span> *<span style="color: #268bd2;">addr</span>, <span style="color: #b58900;">socklen_t</span> *<span style="color: #268bd2;">addrlen</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Returns file descriptor on success, or -1 on error </span><span style="color: #93a1a1;">*/</span>
</pre>
</div>
</li>
<li>对于accept()理解的关键,在于这个system call创建了一个"新的socket",换句话说,
就是发现有新的电话进来以后,不是立刻接当前的电话,而是马上"创建"了一个分机,用
分机接电话.
</li>
<li>当然了,当前的server还是不能相应其他的calling的. 除非,你创建一个新的process
去处理这个call,然后parent的accept()马上返回,就又可以受理其他calling的服务了
</li>
<li>千万注意,fork()之后child会有自己的一份listening socket fd 和一份accepted
socket fd. 它在处理完之后都会马上关掉,但是parent里面的listening fd不能关掉
因为下一次的循环还会使用这个listening fd. 而"正是因为每次connection都创建
新的accept socket fd",所以parent里面的accept socket fd,也要关掉!
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b58900;">pid_t</span> <span style="color: #268bd2;">pid</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">listenfd</span>, <span style="color: #268bd2;">connfd</span>;

listenfd = Socket<span style="color: #2aa198;">(</span> ... <span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">fill in sockaddr_in{} with server's well-known port </span><span style="color: #93a1a1;">*/</span>
Bind<span style="color: #2aa198;">(</span>listenfd, ... <span style="color: #2aa198;">)</span>;
Listen<span style="color: #2aa198;">(</span>listenfd, LISTENQ<span style="color: #2aa198;">)</span>;
<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span> ; ; <span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    connfd = Accept <span style="color: #b58900;">(</span>listenfd, ... <span style="color: #b58900;">)</span>;    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">probably blocks </span><span style="color: #93a1a1;">*/</span>
    <span style="color: #859900; font-weight: bold;">if</span><span style="color: #b58900;">(</span> <span style="color: #268bd2;">(</span>pid = Fork<span style="color: #6c71c4;">()</span><span style="color: #268bd2;">)</span> == 0<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        Close<span style="color: #268bd2;">(</span>listenfd<span style="color: #268bd2;">)</span>;    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">child closes listening socket </span><span style="color: #93a1a1;">*/</span>
        doit<span style="color: #268bd2;">(</span>connfd<span style="color: #268bd2;">)</span>;       <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">process the request </span><span style="color: #93a1a1;">*/</span>
        Close<span style="color: #268bd2;">(</span>connfd<span style="color: #268bd2;">)</span>;      <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">done with this client </span><span style="color: #93a1a1;">*/</span>
        exit<span style="color: #268bd2;">(</span>0<span style="color: #268bd2;">)</span>;            <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">child terminates </span><span style="color: #93a1a1;">*/</span>
    <span style="color: #b58900;">}</span>
    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">listenfd is still working, child only close its OWN open fd </span><span style="color: #93a1a1;">*/</span>
    Close<span style="color: #b58900;">(</span>connfd<span style="color: #b58900;">)</span>;         <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">parent closes connected socket </span><span style="color: #93a1a1;">*/</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>accept()剩下的两个参数是获取remote server的address和port信息的,当然可以值为
NULL和0. 因为这些参数还可以通过getpeername() system call 获取.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3">Connection to a Peer Socket: connect()</h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li>connect() system call 是把sockfd所代表的socket和remote server上面处于listening
状态的socket联系起来. remote server的信息通过addr, addrlen来表示
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">sys/socket.h</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">connect</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">sockfd</span>, <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span>* <span style="color: #268bd2;">addr</span>, <span style="color: #b58900;">socklen_t</span> <span style="color: #268bd2;">addrlen</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Returns 0 on success, or -1 on error </span><span style="color: #93a1a1;">*/</span>
</pre>
</div>
</li>
<li>如果connect()失败,我们"最好"close失败的本地socket,重新创建一个socket,然后
再次尝试连接
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-4" class="outline-4">
<h4 id="sec-1-5-4">I/O on Stream Sockets</h4>
<div class="outline-text-4" id="text-1-5-4">
<ul class="org-ul">
<li>一旦socket connected起来以后,我们可以像使用fd一样,使用read(), write().我们
可以把写入connected socket理解为"写入remote机器上的一个文件",读取也一样
</li>
<li>一个socket可以被关闭,通过close() system call, 而且关闭是两边不同的host可以
分别选择不同的时候关闭的.
</li>
<li>这是个稍微诡异的地方,因为你一旦关闭了connected socket.是对方无法进行读取(会
返回EOF)你们的socket 文件了,因为你的close说明你没东西再写入了(如果你不小心
忘了刚才close了,并且再写入,也是会出错的). 而对方还没close,说明对方还有东西
要写入.所以你还是可以读取的.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-5" class="outline-4">
<h4 id="sec-1-5-5">Connection Termination: close()</h4>
<div class="outline-text-4" id="text-1-5-5">
<ul class="org-ul">
<li>close()是关闭socket的方法,但是close()并不能保证对方收到我们的数据,这需要协
议层面的支持
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Datagram Sockets</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>对于datagram的操作,可以解释成"老式的邮政系统":
<ul class="org-ul">
<li>如果两者希望通信,那么必须要通信双方都要有邮局(得通邮),所以通信双方都使用socket()
来各自建立一个邮局
</li>
<li>为了让对方知道自己的地址,需要使用bind()来把自己的邮局和一个well-known的地
址联系起来.一般来收,只是server端需要bind(), 但是如果希望server回信给client
那么client也得进行bind()
</li>
<li>client端一般都会"发起"一次通信,通过sendto(), 当然了server端的回信也是sendto()
</li>
<li>server端读取client的通信是通过recvfrom()
</li>
<li>当没有通信需求的时候,使用close()关闭socket

<div class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/org_dot/master/notes/linux/datagram-socket.png" alt="datagram-socket.png" />
</p>
<p><span class="figure-number">Figure 2:</span> datagram-socket.png</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">Exchanging Datagrams: recvfrom() and sendto()</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>我们刚才看到了,在datagram的传输中,起到"实质性"传输作用的是recvfrom和sendto
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">sys/socket.h</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">ssize_t</span> <span style="color: #268bd2;">recvfrom</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">sockfd</span>, <span style="color: #b58900;">void</span> *<span style="color: #268bd2;">buffer</span>, <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">length</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">flags</span>,
                 <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span> *<span style="color: #268bd2;">src_addr</span>, <span style="color: #b58900;">socklen_t</span> *<span style="color: #268bd2;">addrlen</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Returns number of bytes received, 0 on EOF, or -1 on error </span><span style="color: #93a1a1;">*/</span>

<span style="color: #b58900;">ssize_t</span> <span style="color: #268bd2;">sendto</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">sockfd</span>, <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">void</span> *<span style="color: #268bd2;">buffer</span>, <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">length</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">flags</span>,
               <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span> *<span style="color: #268bd2;">dest_addr</span>, <span style="color: #b58900;">socklen_t</span> <span style="color: #268bd2;">addrlen</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Returns number of bytes sent, or -1 on error </span><span style="color: #93a1a1;">*/</span>
</pre>
</div>
</li>
<li>前三个参数两者是一样的
</li>
<li>第四个参数是一个bit mask flag
</li>
<li>对于recvfrom来说src_addr, addrlen是发送者的"地址和长度"
</li>
<li>对于sendto来说dest_addr, addrlen是对方的"地址和长度"
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2">Using connect() with Datagram Sockets</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 57: Sockets: Unix Domain</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">UNIX Domain Socket Addresses: struct sockaddr_un</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>socket里面如果domain设置为UNIX,那么说明这个是local的两个socket之间的通信,那
么domain-specific socket address structure定义如下
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">sa_family_t</span> <span style="color: #268bd2;">sun_family</span>;     <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Always AF_UNIX </span><span style="color: #93a1a1;">*/</span>
    <span style="color: #b58900;">char</span> <span style="color: #268bd2;">sun_path</span><span style="color: #b58900;">[</span>108<span style="color: #b58900;">]</span>;         <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Null-terminated socket pathname </span><span style="color: #93a1a1;">*/</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>需要注意的是:
<ul class="org-ul">
<li>AF_是family的前缀(ipv4, ipv6都用这个)意思是Address Family
</li>
<li>sun_意思是socket unix
</li>
<li>SUSv3并没有规定sun_path的长度,因为历史上有92, 104, 108等多种默认值
</li>
</ul>
</li>
<li>sockaddr_un使用方法总结起来就是1清零2赋值3cast成sockaddr传入bind()
<div class="org-src-container">

<pre class="src src-c"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">SOCKNAME</span> = <span style="color: #2aa198;">"/tmp/mysock"</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">sfd</span>;
<span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span> <span style="color: #268bd2;">addr</span>;

sfd = socket<span style="color: #2aa198;">(</span>AF_UNIX, SOCK_STREAM, 0<span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">create socket </span><span style="color: #93a1a1;">*/</span>
<span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>sfd == -1<span style="color: #2aa198;">)</span>
    errExit<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"socket"</span><span style="color: #2aa198;">)</span>;

memset<span style="color: #2aa198;">(</span>&amp;addr, 0, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Clear structure </span><span style="color: #93a1a1;">*/</span>
addr.sun_family = AF_UNIX;
strncpy<span style="color: #2aa198;">(</span>addr.sun_path, SOCKNAME, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #b58900;">(</span>addr.sun_path<span style="color: #b58900;">)</span> - 1<span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>bind<span style="color: #b58900;">(</span>sfd, <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span> *<span style="color: #268bd2;">)</span>&amp;addr, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span> == -1<span style="color: #2aa198;">)</span>
    errExit<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"bind"</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>Unix domain总是会和一个pathname相关联.所有对这个socket的权限操作,其实都是对
这个文件的权限操作
</li>
<li>创建Unix domain socket还需要注意如下几点:
<ul class="org-ul">
<li>不能bind 一个socket到existing pathname(bind() fails with the error EADDRINUSE)
</li>
<li>最好bind一个socket到absolute pathname. 因为更不容易出错
</li>
<li>一个socket只能bound to 一个pathname,一个pathname也只能对应一个socket
</li>
<li>不能使用open()来打开一个socket
</li>
<li>如果一个socket不再需要了, pathname entry可以使用unlink()来移除
</li>
</ul>
</li>
<li>我们的例子都是使用/tmp文件夹下的pathname,但是这并不是一个很好的选择
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Stream Socket in the UNIX Domain</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>下面是一个在本机(和client同机)运行的iterative server(每次只能处理一个client
请求), 因为是在本机,所以使用Unix Domain就可以,传输介质使用的是stream socket
代码如下:
<ul class="org-ul">
<li>先是client和server都使用的header file
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">sys/un.h</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">sys/socket.h</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"tlpi_hr.h"</span>

<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">SV_SOCK_PATH</span> <span style="color: #2aa198;">"/tmp/us_xfr"</span>
<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">BUF_SIZE</span> 100
</pre>
</div>
</li>
<li>UNIX domain下使用stream socket传递的server
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"us_xfr.h"</span>

<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">BACKLOG</span> 5

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span> <span style="color: #268bd2;">addr</span>;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sfd</span>, <span style="color: #268bd2;">cfd</span>;
    <span style="color: #b58900;">ssize_t</span> <span style="color: #268bd2;">numRead</span>;
    <span style="color: #b58900;">char</span> <span style="color: #268bd2;">buf</span><span style="color: #b58900;">[</span>BUF_SIZE<span style="color: #b58900;">]</span>;

    sfd = socket<span style="color: #b58900;">(</span>AF_UNIX, SOCK_STREAM, 0<span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>sfd == -1<span style="color: #b58900;">)</span>
        errExit<span style="color: #b58900;">(</span><span style="color: #2aa198;">"socket"</span><span style="color: #b58900;">)</span>;

    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Construct server socket address, bind socket to it,</span>
<span style="color: #93a1a1;">       and make this a listeing socket.</span>
<span style="color: #93a1a1;">     </span><span style="color: #93a1a1;">*/</span>

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>remove<span style="color: #268bd2;">(</span>SV_SOCK_PATH<span style="color: #268bd2;">)</span> == -1 &amp;&amp; errno != ENOENT<span style="color: #b58900;">)</span>
        errExit<span style="color: #b58900;">(</span><span style="color: #2aa198;">"remove-%s"</span>, SV_SOCK_PATH<span style="color: #b58900;">)</span>;

    memset<span style="color: #b58900;">(</span>&amp;addr, 0, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;
    addr.sun_family = AF_UNIX;
    strncpy<span style="color: #b58900;">(</span>addr.sun_path, SV_SOCK_PATH, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #268bd2;">(</span>addr.sun_path<span style="color: #268bd2;">)</span> - 1<span style="color: #b58900;">)</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>bind<span style="color: #268bd2;">(</span>sfd, <span style="color: #6c71c4;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span> *<span style="color: #6c71c4;">)</span>&amp;addr, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #6c71c4;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> == -1<span style="color: #b58900;">)</span>
        errExit<span style="color: #b58900;">(</span><span style="color: #2aa198;">"bind"</span><span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>listen<span style="color: #268bd2;">(</span>sfd, BACKLOG<span style="color: #268bd2;">)</span> == -1<span style="color: #b58900;">)</span>
        errExit<span style="color: #b58900;">(</span><span style="color: #2aa198;">"listen"</span><span style="color: #b58900;">)</span>;

    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span>;;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>                  <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Hendle client connections iteratively </span><span style="color: #93a1a1;">*/</span>
        <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Accept a connection. The connection is returned on a new</span>
<span style="color: #93a1a1;">           socket, 'cfd'; the listening socket('sfd') remains open and can</span>
<span style="color: #93a1a1;">           be used to accept further connections</span>
<span style="color: #93a1a1;">         </span><span style="color: #93a1a1;">*/</span>

        cfd = accept<span style="color: #268bd2;">(</span>sfd, <span style="color: #268bd2; font-weight: bold;">NULL</span>, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #268bd2;">)</span>;
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>cfd == -1<span style="color: #268bd2;">)</span>
            errExit<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"accept"</span><span style="color: #268bd2;">)</span>;

        <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Transfer data from connected socket to stdout until EOF </span><span style="color: #93a1a1;">*/</span>

        <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2;">(</span><span style="color: #6c71c4;">(</span>numRead = read<span style="color: #859900;">(</span>cfd, buf, BUF_SIZE<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span> &gt; 0<span style="color: #268bd2;">)</span>
            <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>write<span style="color: #6c71c4;">(</span>STDOUT_FILENO, buf, numRead<span style="color: #6c71c4;">)</span> != numRead<span style="color: #268bd2;">)</span>
                fatal<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"partial/failed write"</span><span style="color: #268bd2;">)</span>;

        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>numRead == -1<span style="color: #268bd2;">)</span>
            errExit<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"read"</span><span style="color: #268bd2;">)</span>;

        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>close<span style="color: #6c71c4;">(</span>cfd<span style="color: #6c71c4;">)</span> == -1<span style="color: #268bd2;">)</span>
            errMsg<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"close"</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>client端代码如下
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"us_xfr.h"</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span> <span style="color: #268bd2;">addr</span>;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sfd</span>;
    <span style="color: #b58900;">ssize_t</span> <span style="color: #268bd2;">numRead</span>;
    <span style="color: #b58900;">char</span> <span style="color: #268bd2;">buf</span><span style="color: #b58900;">[</span>BUF_SIZE<span style="color: #b58900;">]</span>;

    sfd = socket<span style="color: #b58900;">(</span>AF_UNIX, SOCK_STREAM, 0<span style="color: #b58900;">)</span>; <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Create client socket </span><span style="color: #93a1a1;">*/</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>sfd == -1<span style="color: #b58900;">)</span>
        errExit<span style="color: #b58900;">(</span><span style="color: #2aa198;">"socket"</span><span style="color: #b58900;">)</span>;

    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Construct server address, and make the connection </span><span style="color: #93a1a1;">*/</span>
    memset<span style="color: #b58900;">(</span>&amp;addr, 0, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;
    addr.sun_family = AF_UNIX;
    strncpy<span style="color: #b58900;">(</span>addr.sun_path, SV_SOCK_PATH, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #268bd2;">(</span>addr.<span style="color: #268bd2; font-weight: bold;">sun_path</span><span style="color: #268bd2;">)</span> - 1<span style="color: #b58900;">)</span>:

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>connect<span style="color: #268bd2;">(</span>sfd, <span style="color: #6c71c4;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span> *<span style="color: #6c71c4;">)</span>&amp;addr,
                <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #6c71c4;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> == -1<span style="color: #b58900;">)</span>
        errExit<span style="color: #b58900;">(</span><span style="color: #2aa198;">"connect"</span><span style="color: #b58900;">)</span>;

    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Copy stdin to socket </span><span style="color: #93a1a1;">*/</span>
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span><span style="color: #268bd2;">(</span>numRead = read<span style="color: #6c71c4;">(</span>STDIN_FILENO, buf, BUF_SIZE<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> &gt; 0<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>write<span style="color: #268bd2;">(</span>sfd, buf, numRead<span style="color: #268bd2;">)</span> != numRead<span style="color: #b58900;">)</span>
            fatal<span style="color: #b58900;">(</span><span style="color: #2aa198;">"partial/failed write"</span><span style="color: #b58900;">)</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>numRead == -1<span style="color: #b58900;">)</span>
        errExit<span style="color: #b58900;">(</span><span style="color: #2aa198;">"read"</span><span style="color: #b58900;">)</span>;
    exit<span style="color: #b58900;">(</span>EXIT_SUCCESS<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Datagram Socketin the UNIX Domain</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>前面,我们过对datagram socket的如下描述
<pre class="example">
Communication using datagram sockets is unreliable
</pre>
</li>
<li>上述描述的场景是基于AF_INET或者AF_INET6, 换句话说就是Internet上使用datagram
socket传播才不可靠呢,在本机的AF_UNIX传输是经过kernel,是可靠的(而且是in order
并且undeuplicated)
</li>
<li>我们来看看一个本机的Unix Domain的datagram socket例子
<ul class="org-ul">
<li>头文件
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">sys/un.h</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">sys/socket.h</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">ctype.h</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"tlpi_hdr.h"</span>

<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">BUF_SIZE</span> 10

<span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">SV_SOCK_PATH</span> <span style="color: #2aa198;">"/tmp/un_ucase"</span>
</pre>
</div>
</li>
<li>server端代码
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"ud_ucase.h"</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span> <span style="color: #268bd2;">svaddr</span>, <span style="color: #268bd2;">claddr</span>;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sfd</span>, <span style="color: #268bd2;">j</span>;
    <span style="color: #b58900;">ssize_t</span> <span style="color: #268bd2;">numBytes</span>;
    <span style="color: #b58900;">socklen_t</span> <span style="color: #268bd2;">len</span>;
    <span style="color: #b58900;">char</span> <span style="color: #268bd2;">buf</span><span style="color: #b58900;">[</span>BUF_SIZE<span style="color: #b58900;">]</span>;

    sfd = socket<span style="color: #b58900;">(</span>AF_UNIX, SOCK_DGRAM, 0<span style="color: #b58900;">)</span>; <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Create server socket </span><span style="color: #93a1a1;">*/</span>

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>sfd == -1<span style="color: #b58900;">)</span>
        errExit<span style="color: #b58900;">(</span><span style="color: #2aa198;">"socket"</span><span style="color: #b58900;">)</span>;

    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Construct well-known address and bind server socket to it </span><span style="color: #93a1a1;">*/</span>

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>remove<span style="color: #268bd2;">(</span>SV_SOCK_PATH<span style="color: #268bd2;">)</span> == -1 &amp;&amp; errno != ENOENT<span style="color: #b58900;">)</span>
        errExit<span style="color: #b58900;">(</span><span style="color: #2aa198;">"remove-%s"</span>, SV_SOCK_PATH<span style="color: #b58900;">)</span>;

    memset<span style="color: #b58900;">(</span>&amp;svaddr, 0, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;
    svaddr.sun_family = AF_UNIX;
    strncpy<span style="color: #b58900;">(</span>svaddr.sun_path, SV_SOCK_PATH, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #268bd2;">(</span>svaddr.sun_path<span style="color: #268bd2;">)</span> - 1<span style="color: #b58900;">)</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>bind<span style="color: #268bd2;">(</span>sfd, <span style="color: #6c71c4;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span> *<span style="color: #6c71c4;">)</span>&amp;svaddr, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #6c71c4;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> == -1<span style="color: #b58900;">)</span>
        errExit<span style="color: #b58900;">(</span><span style="color: #2aa198;">"bind"</span><span style="color: #b58900;">)</span>;

    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Eeceive messages, convertto uppercase, and return to client </span><span style="color: #93a1a1;">*/</span>

    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span>;;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        len = <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #268bd2;">)</span>;
        numBytes = recvfrom<span style="color: #268bd2;">(</span>sfd, buf, BUF_SIZE, 0
                            <span style="color: #6c71c4;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span> *<span style="color: #6c71c4;">)</span>&amp;claddr, &amp;len<span style="color: #268bd2;">)</span>;
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>numBytes == -1<span style="color: #268bd2;">)</span>
            errExit<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"recvfrom"</span><span style="color: #268bd2;">)</span>;

        printf<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Server received %ld bytes from %s\n"</span>, <span style="color: #6c71c4;">(</span><span style="color: #b58900;">long</span><span style="color: #6c71c4;">)</span> numBytes,
               claddr.sun_path<span style="color: #268bd2;">)</span>;

        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #268bd2;">(</span>j = 0; j &lt; numBytes; j++<span style="color: #268bd2;">)</span>
            buf<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span> = toupper<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">(</span><span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">char</span><span style="color: #6c71c4;">)</span> buf<span style="color: #6c71c4;">[</span>j<span style="color: #6c71c4;">]</span><span style="color: #268bd2;">)</span>;

        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>sendto<span style="color: #6c71c4;">(</span>sfd, buf, numBytes, 0, <span style="color: #859900;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span>*<span style="color: #859900;">)</span>&amp;claddr, len<span style="color: #6c71c4;">)</span> != numBytes<span style="color: #268bd2;">)</span>
            fatal<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"sendto"</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>client端代码
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#incude</span> <span style="color: #2aa198;">"ud_ucase.h"</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span> <span style="color: #268bd2;">svaddr</span>, <span style="color: #268bd2;">claddr</span>;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sfd</span>, <span style="color: #268bd2;">j</span>;
    <span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">msgLen</span>;
    <span style="color: #b58900;">ssize_t</span> <span style="color: #268bd2;">numBytes</span>;
    <span style="color: #b58900;">char</span> <span style="color: #268bd2;">resp</span><span style="color: #b58900;">[</span>BUF_SIZE<span style="color: #b58900;">]</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>argc &lt; 2 || strcmp<span style="color: #268bd2;">(</span>argv<span style="color: #6c71c4;">[</span>1<span style="color: #6c71c4;">]</span>, <span style="color: #2aa198;">"--help"</span><span style="color: #268bd2;">)</span> == 0<span style="color: #b58900;">)</span>
        usageErr<span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s msg...\n"</span>, argv<span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;

    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Crate client socke; bindto unique pathname (Base on PID) </span><span style="color: #93a1a1;">*/</span>
    sfd = socket<span style="color: #b58900;">(</span>AF_UNIX, SOCK_DGRAM, 0<span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>sfd == -1<span style="color: #b58900;">)</span>
        errExit<span style="color: #b58900;">(</span><span style="color: #2aa198;">"socket"</span><span style="color: #b58900;">)</span>;

    memset<span style="color: #b58900;">(</span>&amp;claddr, 0, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;
    claddr.sun_family = AF_UNIX;

    snprintf<span style="color: #b58900;">(</span>claddr.sun_path, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #268bd2;">(</span>claddr.sun_path<span style="color: #268bd2;">)</span>,
             <span style="color: #2aa198;">"/tmp/ud_ucase_cl.%ld"</span>, <span style="color: #268bd2;">(</span><span style="color: #b58900;">long</span><span style="color: #268bd2;">)</span>getpid<span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>bind<span style="color: #268bd2;">(</span>sfd, <span style="color: #6c71c4;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span>*<span style="color: #6c71c4;">)</span>&amp;claddr, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #6c71c4;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> == -1<span style="color: #b58900;">)</span>
        errExit<span style="color: #b58900;">(</span><span style="color: #2aa198;">"bind"</span><span style="color: #b58900;">)</span>;

    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Construct addressof server </span><span style="color: #93a1a1;">*/</span>

    memset<span style="color: #b58900;">(</span>&amp;svaddr, 0, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;
    svaddr.sun_family = AF_UNIX;
    strncpy<span style="color: #b58900;">(</span>svaddr.sun_path, SV_SOCK_PATH, <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #268bd2;">(</span>svaddr.sun_path<span style="color: #268bd2;">)</span> - 1<span style="color: #b58900;">)</span>;

    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Send messages to server;echo responseson stdout </span><span style="color: #93a1a1;">*/</span>

    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span>j = 1; j &lt; argc; j++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        msgLen = strlen<span style="color: #268bd2;">(</span>argv<span style="color: #6c71c4;">[</span>j<span style="color: #6c71c4;">]</span><span style="color: #268bd2;">)</span>;
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>sendto<span style="color: #6c71c4;">(</span>sfd, argv<span style="color: #859900;">[</span>j<span style="color: #859900;">]</span>, msgLen, 0, <span style="color: #859900;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr</span>*<span style="color: #859900;">)</span>&amp;svaddr,
                   <span style="color: #859900; font-weight: bold;">sizeof</span><span style="color: #859900;">(</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockaddr_un</span><span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span> != msgLen<span style="color: #268bd2;">)</span>
            fatal<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"sendto"</span><span style="color: #268bd2;">)</span>;

        numBytes = recvfrom<span style="color: #268bd2;">(</span>sfd, resp, BUF_SIZE, 0, <span style="color: #268bd2; font-weight: bold;">NULL</span>, <span style="color: #268bd2; font-weight: bold;">NULL</span><span style="color: #268bd2;">)</span>;
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>numBytes == -1<span style="color: #268bd2;">)</span>
            errExit<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"recvfrom"</span><span style="color: #268bd2;">)</span>;
        printf<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Response %d: %.*s\n"</span>, j, <span style="color: #6c71c4;">(</span><span style="color: #b58900;">int</span><span style="color: #6c71c4;">)</span>numBytes, resp<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    remove<span style="color: #b58900;">(</span>claddr.sun_path<span style="color: #b58900;">)</span>;
    exit<span style="color: #b58900;">(</span>EXIT_SUCCESS<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Unix Domain Socket Permissions</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>socket file其实就是一个文件,而其他process对这个这个文件的一些ownership 和
permission决定了哪些process可以和那个socket进行通信:
<ul class="org-ul">
<li>为了能够和一个Unix domain stream socket connect, process需要对这个file有
write permission
</li>
<li>为了能够在一个Unix domain datagram socket上传输数据, process需要对这个file
有write permission
</li>
</ul>
</li>
<li>一个socket创建的时候,所有的owner和group和other都被授予了all permission, 如果
这个不是我们想要的,我们可以使用umask()来disable 这种permission
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Creating a Connected Socket Pair: socketpair()</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>有时候,我们希望一个process创建两个socket,并且把这两个socket联系起来,当然可以
调用两次socket()等,我们还可以使用socketpair()来"一次性"调用这些system calls
<div class="org-src-container">

<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">sys/socket.h</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">sockepair</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">domain</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">type</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">protocol</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sockfd</span><span style="color: #b58900;">[</span>2<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Returns 0 on success, or -1 on error </span><span style="color: #93a1a1;">*/</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">The Linux Abstract Socket Namespace</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>Linux-specific有个特殊的feature叫做abstract namespace.就是可以bind一个Unix
domain socket到一个pathname, 但是并不真正的创建这个pathname.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 58: Sockets: Fundamentals of TCP/IP Networks</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Internets</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
