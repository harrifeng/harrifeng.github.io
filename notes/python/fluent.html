<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>fluent</title>
<!-- 2017-05-10 Wed 15:34 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">fluent</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 01: The Python Data Model</a>
<ul>
<li><a href="#sec-1-1">A Pythonic Card Deck</a></li>
<li><a href="#sec-1-2">How Special Methods Are Used</a>
<ul>
<li><a href="#sec-1-2-1">Emulating Numeric Types</a></li>
<li><a href="#sec-1-2-2">String Representation</a></li>
<li><a href="#sec-1-2-3">Arithmetic Operators</a></li>
<li><a href="#sec-1-2-4">Boolean Value of Custom Type</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Overview of Special Methods</a></li>
<li><a href="#sec-1-4">Why Len Is Not a Method</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 02: An Array of Sequences</a>
<ul>
<li><a href="#sec-2-1">Overview of Built-In Sequences</a></li>
<li><a href="#sec-2-2">List Comprehensions and Generator Expressions</a>
<ul>
<li><a href="#sec-2-2-1">List Comprehensions and Readability</a></li>
<li><a href="#sec-2-2-2">Listcomps Versus map and filter</a></li>
<li><a href="#sec-2-2-3">Cartesian Products</a></li>
<li><a href="#sec-2-2-4">Generator Expressions</a></li>
</ul>
</li>
<li><a href="#sec-2-3">Tuples Are Not Just Immutable Lists</a>
<ul>
<li><a href="#sec-2-3-1">Tuples as Records</a></li>
<li><a href="#sec-2-3-2">Tuple Unpacking</a></li>
<li><a href="#sec-2-3-3">Nested Tuple Unpacking</a></li>
<li><a href="#sec-2-3-4">Named Tuples</a></li>
<li><a href="#sec-2-3-5">Tuples as Immutable lists</a></li>
</ul>
</li>
<li><a href="#sec-2-4">Slicing</a>
<ul>
<li><a href="#sec-2-4-1">Why Slices and Range Exclude the Last Item</a></li>
<li><a href="#sec-2-4-2">Slice Objects</a></li>
<li><a href="#sec-2-4-3">Multidimensional Slicing and Ellipsis</a></li>
<li><a href="#sec-2-4-4">Assigning to Slices</a></li>
</ul>
</li>
<li><a href="#sec-2-5">Using + and * with Sequences</a>
<ul>
<li><a href="#sec-2-5-1">Building Lists of Lists</a></li>
</ul>
</li>
<li><a href="#sec-2-6">Augmented Assignment with Sequences</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 01: The Python Data Model</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>python的最大特质就是consistency,当你在python上面工作了一段时间以后,你可以通过
"猜测"来完成学习新的feature
</li>
<li>但是,如果你原来学习过其他的oo语言,那么当你开始使用python的时候会有些困惑,比如,
为什么使用len(collection)而不是collection.len()
</li>
<li>而这种看起来很奇怪的东西(其实就是Python data model的一个例子),一旦理解了以后,
可以对我们理解Pythonic起到关键作用.
</li>
<li>所谓的python data model,它描述了一套API,如果你的object也能符合这个API,那么你
的object也可以和python其他的语言特性融合的很好
</li>
<li>无论是web开发还是GUI开发,都会有很多的framework,当你使用一个framework的时候,
你其实是实现了很多的method,让framework来call
</li>
<li>如果你把python看成是一个framework的话,那么data model其实规定了我们经常需要实
现的函数的接口,比如后面要说的__getitem__()
</li>
<li>Python解析器在遇到某些syntax的时候,就去调用某些接口,这些接口往往是以两个下划
线开始和结尾的,比如在遇到obj[key]的时候,解析器就会去调用__getitem__.你想和python
其他object玩得好,你的的object如果是线性存储的,那么也要实现"这些特殊接口"
</li>
<li>"这些特殊接口"能够覆盖的语言特性有:
<ul class="org-ul">
<li>Iteration
</li>
<li>Collections
</li>
<li>Attribute access
</li>
<li>Function and method invocation
</li>
<li>Object creation and destruction
</li>
<li>String representation and formatting
</li>
<li>Managed context(with block)
</li>
</ul>
</li>
<li>"特殊接口"其实真正的名字叫做magic method,但是其真正的完整发音应该是"under-under-getitem-under-under"
显然这个名字太长了,所以业界比较喜欢用的称呼是"dunder-getitem"(double under
get item)的叫法
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">A Pythonic Card Deck</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>下面是一个非常简单的例子,我们可以用来证明实现了special method(__getitem__,
__len__)的威力
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> collections

<span style="color: #268bd2;">Card</span> = collections.namedtuple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Card'</span>, <span style="color: #b58900;">[</span><span style="color: #2aa198;">'rank'</span>, <span style="color: #2aa198;">'suit'</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>


<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">FrenchDeck</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">ranks</span> = <span style="color: #2aa198;">[</span><span style="color: #657b83; font-weight: bold;">str</span><span style="color: #b58900;">(</span>n<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> n <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #b58900;">(</span>2, 11<span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span> + <span style="color: #657b83; font-weight: bold;">list</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'JQKA'</span><span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">suits</span> = <span style="color: #2aa198;">'spades diamonds clubs hearts'</span>.split<span style="color: #2aa198;">()</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">self</span>._cards = <span style="color: #2aa198;">[</span>
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   Card<span style="color: #b58900;">(</span>rank, suit<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> suit <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #859900; font-weight: bold;">self</span>.suits <span style="color: #859900; font-weight: bold;">for</span> rank <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #859900; font-weight: bold;">self</span>.ranks
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #2aa198;">]</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__len__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>._cards<span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__getitem__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, position<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>._cards<span style="color: #2aa198;">[</span>position<span style="color: #2aa198;">]</span>


<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">deck</span> = FrenchDeck<span style="color: #2aa198;">()</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>deck<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>deck<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>deck<span style="color: #b58900;">[</span>-1<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>


<span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">__name__</span> == <span style="color: #2aa198;">'__main__'</span>:
<span style="background-color: #eee8d5;"> </span>   main<span style="color: #2aa198;">()</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">52</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Card(rank='2', suit='spades')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Card(rank='A', suit='hearts')</span>
</pre>
</div>
</li>
<li>当然了,这个例子最主要的一个令初学者费解的地方就是collections.namedtuple啦,
这个是python的特性:namedtuple可以用来创建只有attribute,而没有custom method
的class,最常见的用法就是database record
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> collections

<span style="color: #268bd2;">Card</span> = collections.namedtuple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Card'</span>, <span style="color: #b58900;">[</span><span style="color: #2aa198;">'rank'</span>, <span style="color: #2aa198;">'suit'</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>Card<span style="color: #b58900;">(</span><span style="color: #2aa198;">'7'</span>, <span style="color: #2aa198;">'diamonds'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Card(rank='7', suit='diamonds')</span>
</pre>
</div>
</li>
<li>了解了namedtuple以后,其他的代码比较容易理解:我们通过实现不同的special method
来获得了不同的能力:
<ul class="org-ul">
<li>通过实现__getitem__来获得了[]的能力
</li>
<li>通过实现__len__来获得了len()的能力
</li>
</ul>
</li>
<li>实现了special method不仅仅能够获得"相应"的能力(比如[]),还可以和其他的python
library完美的配合,比如当我们需要"随机"取出一个card的时候,我们不需要自己再造
一次轮子,我们只要使用python library的random.choice就可以了.记住,能够把random.choice
直接使用,是因为我们实现了special method!
<div class="org-src-container">

<pre class="src src-python">In <span style="color: #2aa198;">[</span>20<span style="color: #2aa198;">]</span>: <span style="color: #268bd2;">deck</span> = FrenchDeck<span style="color: #2aa198;">()</span>

In <span style="color: #2aa198;">[</span>21<span style="color: #2aa198;">]</span>: <span style="color: #859900; font-weight: bold;">from</span> random <span style="color: #859900; font-weight: bold;">import</span> choice

In <span style="color: #2aa198;">[</span>22<span style="color: #2aa198;">]</span>: choice<span style="color: #2aa198;">(</span>deck<span style="color: #2aa198;">)</span>
Out<span style="color: #2aa198;">[</span>22<span style="color: #2aa198;">]</span>: Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'4'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #2aa198;">)</span>

In <span style="color: #2aa198;">[</span>23<span style="color: #2aa198;">]</span>: choice<span style="color: #2aa198;">(</span>deck<span style="color: #2aa198;">)</span>
Out<span style="color: #2aa198;">[</span>23<span style="color: #2aa198;">]</span>: Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'3'</span>, suit=<span style="color: #2aa198;">'hearts'</span><span style="color: #2aa198;">)</span>

In <span style="color: #2aa198;">[</span>24<span style="color: #2aa198;">]</span>: choice<span style="color: #2aa198;">(</span>deck<span style="color: #2aa198;">)</span>
Out<span style="color: #2aa198;">[</span>24<span style="color: #2aa198;">]</span>: Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'A'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>不仅仅如此,获得了"相应"的能力(比如[])之后,这个能力的附加能力也会获得,比如我
们通过__getitem__获得了[], 与此同时,我们还获得了slicing.下面就是两个例子:
<ul class="org-ul">
<li>前三个card
<div class="org-src-container">

<pre class="src src-python">In <span style="color: #2aa198;">[</span>25<span style="color: #2aa198;">]</span>: deck<span style="color: #2aa198;">[</span>:3<span style="color: #2aa198;">]</span>
Out<span style="color: #2aa198;">[</span>25<span style="color: #2aa198;">]</span>:
<span style="color: #2aa198;">[</span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'2'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #b58900;">)</span>,
<span style="background-color: #eee8d5;"> </span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'3'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #b58900;">)</span>,
<span style="background-color: #eee8d5;"> </span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'4'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
<li>从第12个开始,每13个取一个deck显示
<div class="org-src-container">

<pre class="src src-python">In <span style="color: #2aa198;">[</span>26<span style="color: #2aa198;">]</span>: deck<span style="color: #2aa198;">[</span>12::13<span style="color: #2aa198;">]</span>
Out<span style="color: #2aa198;">[</span>26<span style="color: #2aa198;">]</span>:
<span style="color: #2aa198;">[</span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'A'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #b58900;">)</span>,
<span style="background-color: #eee8d5;"> </span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'A'</span>, suit=<span style="color: #2aa198;">'diamonds'</span><span style="color: #b58900;">)</span>,
<span style="background-color: #eee8d5;"> </span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'A'</span>, suit=<span style="color: #2aa198;">'clubs'</span><span style="color: #b58900;">)</span>,
<span style="background-color: #eee8d5;"> </span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'A'</span>, suit=<span style="color: #2aa198;">'hearts'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
</ul>
</li>
<li>实现了__getitem__之后,deck还变得iterable
<div class="org-src-container">

<pre class="src src-python">In <span style="color: #2aa198;">[</span>32<span style="color: #2aa198;">]</span>: <span style="color: #859900; font-weight: bold;">for</span> card <span style="color: #859900; font-weight: bold;">in</span> deck: <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>card<span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'2'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'3'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'4'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'5'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
</pre>
</div>
</li>
<li>reverse iterable也拥有了
<div class="org-src-container">

<pre class="src src-python">In <span style="color: #2aa198;">[</span>33<span style="color: #2aa198;">]</span>: <span style="color: #859900; font-weight: bold;">for</span> card <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">reversed</span><span style="color: #2aa198;">(</span>deck<span style="color: #2aa198;">)</span>: <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>card<span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'A'</span>, suit=<span style="color: #2aa198;">'hearts'</span><span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'K'</span>, suit=<span style="color: #2aa198;">'hearts'</span><span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'Q'</span>, suit=<span style="color: #2aa198;">'hearts'</span><span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
</pre>
</div>
</li>
<li>实现了__getitem__的好处还有:可以自动识别in operator(虽然要遍历一遍,如果有
__contains__的话,就不用遍历了,会快很多)
<div class="org-src-container">

<pre class="src src-python">In <span style="color: #2aa198;">[</span>34<span style="color: #2aa198;">]</span>: Card<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Q'</span>, <span style="color: #2aa198;">'hearts'</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">in</span> deck
Out<span style="color: #2aa198;">[</span>34<span style="color: #2aa198;">]</span>: <span style="color: #268bd2; font-weight: bold;">True</span>

In <span style="color: #2aa198;">[</span>35<span style="color: #2aa198;">]</span>: Card<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'7'</span>, <span style="color: #2aa198;">'beasts'</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">in</span> deck
Out<span style="color: #2aa198;">[</span>35<span style="color: #2aa198;">]</span>: <span style="color: #268bd2; font-weight: bold;">False</span>
</pre>
</div>
</li>
<li>我们还可以实现排序,不过要借助一些函数TODO
</li>
<li>虽然FrenchDeck是继承自object,但是它的功能(functionality)却不是通过继承获得
的而是通过实现special method(类似于composition)来完成的.实现这些special
method让我们自己写的函数和python的library看起来,用起来都很像
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">How Special Methods Are Used</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>首先,我们需要明确的是,special method是设计用来被python interpreter来调用的,
而不是程序员!换句话说,你不可以使用my_object.__len__()这种代码,而是应该使用
len(my_object),如果my_object是user defined的class的instance话python interpreter
会为你调用__len__
</li>
<li>为什么会说"如果my_object是user defined的class的instance话"这句话呢?这是因为
如果不是user defined的class,python可以采用一些优化的手段来避免调用函数,而直
接返回field值,因为函数调用更"昂贵".
</li>
<li>比如内置的类型,比如list, str,我们写了len(some_list)函数的时候,python interpreter
不会去直接调用__len__,而是直接返回ob_szie这个域
</li>
<li>special method也不是每个都是像函数一样被interpreter调用,一个反例就是in operator,
在内部interpreter对于形如i in x的代码,其实是先转换成iter(x),然后再调用x.__iter__()
</li>
<li>对于用户来说,唯一一个可能频繁调用的special method就是__init__
</li>
<li>对于用户来说,也不要去创建类似__foo__的函数名,因为虽然现在看起来滑稽,但是保
不齐以后python真的会实现这样一个函数
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Emulating Numeric Types</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>前面讲了special method会提供类型in operator的功能,其实在python里面,连+ operator
都是使用special method完成的
</li>
<li>下面我们就来实现一个二维vector类,能够满足二维加减法,比如vector(2,4) + vector(2,1)
得到vector(4,5)
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">from</span> math <span style="color: #859900; font-weight: bold;">import</span> hypot


<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Vector</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, x=0, y=0<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">self</span>.x = x
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">self</span>.y = y

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__repr__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">'Vector(%r, %r)'</span> % <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.x, <span style="color: #859900; font-weight: bold;">self</span>.y<span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__abs__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> hypot<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.x, <span style="color: #859900; font-weight: bold;">self</span>.y<span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__bool__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">bool</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">abs</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__add__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, other<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">x</span> = <span style="color: #859900; font-weight: bold;">self</span>.x + other.x
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">y</span> = <span style="color: #859900; font-weight: bold;">self</span>.y + other.y
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> Vector<span style="color: #2aa198;">(</span>x, y<span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__mul__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, scalar<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> Vector<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.x * scalar, <span style="color: #859900; font-weight: bold;">self</span>.y * scalar<span style="color: #2aa198;">)</span>


<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">v1</span> = Vector<span style="color: #2aa198;">(</span>2, 4<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">v2</span> = Vector<span style="color: #2aa198;">(</span>2, 1<span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>v1 + v2<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">v</span> = Vector<span style="color: #2aa198;">(</span>3, 4<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">abs</span><span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>v * 3<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">abs</span><span style="color: #b58900;">(</span>v * 3<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>


<span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">__name__</span> == <span style="color: #2aa198;">'__main__'</span>:
<span style="background-color: #eee8d5;"> </span>   main<span style="color: #2aa198;">()</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Vector(4, 5)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">5.0</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Vector(9, 12)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">15.0</span>
</pre>
</div>
</li>
<li>注意,我们的例子除了__init__以外,实现了四个special method,但是在main()函数
里面,没有主动调用过一次
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">String Representation</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>__repr__这个special method的用法,比较基础,就是内置的repr()函数会调用它,这个
repr()函数是干啥的呢,这个函数是返回某个instance的名字给"解释器"看的,因为是
给解释器看的,所以唯一的要求就是要"独一无二"让解释器不会认错人
</li>
<li>其实你不实现__repr__也没事的,"解释器"会自己生成一个,让repr唯一的办法就是使
用内存地址,所以不实现__repr__的结果就是会出现类似&lt;Vector object ax 0x10e100070&gt;
这种结果
</li>
<li>我们上面对__repr__的实现使用了%r来表现我们的attribute,就是对repr使用的一种
"清醒认识",因为只有使用repr,才能区分出Vector(1, 2)和Vector('1', '2')
</li>
<li>__str__也是存在的,会被str()调用,不同的是str()是给用户看的,而repr()是给机器
看的.
</li>
<li>如果你指向实现__str__和__repr__里面的一个,那么请实现后者.因为在找不到__str__
的情况下,str()会去调用__repr__
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Arithmetic Operators</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>前面我们实现了两个运算符的special method:
<ul class="org-ul">
<li>__add__被+ operator调用
</li>
<li>__mul__被* operator调用
</li>
</ul>
</li>
<li>需要注意的是,我们的运算符special method都是返回了新的instance,而没有改动
"参与计算"的其他instance,比如self和other,这是和运算函数的预期相同的
</li>
<li>还是需要注意的是,我们支持 vector * 3这种运算,但是不支持 3 * vector,这不符合
乘法的交换律,这需要到13章的__rmul__来解决
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">Boolean Value of Custom Type</h4>
<div class="outline-text-4" id="text-1-2-4">
<ul class="org-ul">
<li>虽然Python自己有bool type,但是在需要boolean的情形中,它却允许所有的object,这
点和java不一样,但是和c却是一样的.
</li>
<li>如果我们想知道任何一个object是会被认为是true还是false,我们需要bool(x)
</li>
<li>除非__bool__或者__len__被实现,否则,我们会认为user-defined的class是True:
<ul class="org-ul">
<li>如果__bool__实现了的话bool(x)返回__bool__的值
</li>
<li>如果__len__实现了的话,__len__ 的值为0的话,bool(x)为False
</li>
</ul>
</li>
<li>我们的__bool__实现非常简单,判断绝对值是否为0
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__bool__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">bool</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">abs</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Overview of Special Methods</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>常见的special method一共有83种,其中
<ul class="org-ul">
<li>47种用来实现各种operator
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">category</td>
<td class="left">Method names and related operators</td>
</tr>

<tr>
<td class="left">Unary numeric operators</td>
<td class="left">__neg__-,__pos__+,__abs__abs()</td>
</tr>

<tr>
<td class="left">Rich comparison operators</td>
<td class="left">__lt__&gt;,__le__&lt;=,__eq__==,__ne__!=,__gt__&gt;,__ge__&gt;=</td>
</tr>

<tr>
<td class="left">Arithmetic operators</td>
<td class="left">__add__+,__sub__-,__mul__*,__truediv__/,__floordiv__//,__mod__%,</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">__divmod__divmod(),__pow__**,__round_round()</td>
</tr>

<tr>
<td class="left">Reversed arithmetic operators</td>
<td class="left">__radd__,__rsub__,__rmul__,__rtruediv__,__rfloordiv__,__rmod__,</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">__rdivmod__,__rpow__</td>
</tr>

<tr>
<td class="left">Augmented assignment arithmetic operators</td>
<td class="left">__iadd__,__isub__,__imul__,__itruediv__,__ifloordiv__,__imod__,</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">__ipow__</td>
</tr>

<tr>
<td class="left">Bitwise operators</td>
<td class="left">__invert__~,__lshift__<a id="__rshift__" name="__rshift__"></a>,__and__&amp;amp;,__or__!,__xor__^</td>
</tr>

<tr>
<td class="left">Reversed bitwise operators</td>
<td class="left">__rlshift__, __rrshift__, __rand__, __rxor__, __ror__</td>
</tr>

<tr>
<td class="left">Augmented assignment bitwise operators</td>
<td class="left">__ilshift__, __irshift__, __iand__, __ixor__, __ior__</td>
</tr>
</tbody>
</table>
</li>
<li>36种用来表示非operator
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">category</th>
<th scope="col" class="left">Method names(operators excluded)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">String/bytes representation</td>
<td class="left">__repr__, __str__, __format__, bytes__</td>
</tr>

<tr>
<td class="left">Conversiont to number</td>
<td class="left">__abs__, __bool__, __complex__,__int__,</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">__float__,__hash__,__index__</td>
</tr>

<tr>
<td class="left">Emulating collections</td>
<td class="left">__len__,__getitem__,__setitem__,__delitem__,__contains__</td>
</tr>

<tr>
<td class="left">Iteration</td>
<td class="left">__iter__,__reversed__,__next__</td>
</tr>

<tr>
<td class="left">Emulating callables</td>
<td class="left">__call__</td>
</tr>

<tr>
<td class="left">Context management</td>
<td class="left">__enter__,__exit__</td>
</tr>

<tr>
<td class="left">Instance creation and destruction</td>
<td class="left">__new__,__init__,__del__</td>
</tr>

<tr>
<td class="left">Attribute management</td>
<td class="left">__getattr__,__getattribute__,__setattr__,__delattr__,__dir__</td>
</tr>

<tr>
<td class="left">Attribute descriptors</td>
<td class="left">__get__,__set__,__delete__</td>
</tr>

<tr>
<td class="left">Class services</td>
<td class="left">__prepare__,__instancecheck__,__subclasscheck__</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Why Len Is Not a Method</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>len被实现成了special method,而不是作为一个普通的method,通过object.len来调用
显然object.len的样式更加的"OO",但是python毕竟不是ruby,对于python来说实用性
比纯洁性更重要
<pre class="example">
practicality beats purity
</pre>
</li>
<li>对python来说len(x)的设计更加的"实用",因为len()是被频繁调用的模块,python把它
设计成special method以后,可以使用比method call更加经济的方式来调用它&#x2013;直接
读取struct的length field
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 02: An Array of Sequences</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Overview of Built-In Sequences</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>python std提供了一系列丰富的sequence types,它们都是使用C来实现的
</li>
<li>从container成员的类型来区分可以分成两类:
<ul class="org-ul">
<li>Container sequences:因为存储的是reference,所以可以存储一系列不同类型的成员:
<ol class="org-ol">
<li>list
</li>
<li>tuple
</li>
<li>collections.deque
</li>
</ol>
</li>
<li>Flat sequences:因为是把成员数据value(不是reference),所以存储的成员类型必须
一致
<ol class="org-ol">
<li>str
</li>
<li>bytes
</li>
<li>bytearray
</li>
<li>memoryview
</li>
<li>array.array
</li>
</ol>
</li>
</ul>
</li>
<li>从成员的是否mutable,也可以分成两类:
<ul class="org-ul">
<li>成员可变的:list,bytearray,array.array,collections.deque,memoryview
</li>
<li>成员不可变的:tuple,str,bytes
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">List Comprehensions and Generator Expressions</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>这个题目看起来有点难以理解,因为它说的是两种"快速而优雅"的创建sequence的方法:
<ul class="org-ul">
<li>如果最终的sequence是list的话,我们可以使用list comprehension(简称listcomps)
</li>
<li>如果最终的sequence是出来list以外的sequence的话,我们就使用generator
expression(简称genexps)
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">List Comprehensions and Readability</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>先来看一个不使用listcomps的例子
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'abcde'</span>
<span style="color: #268bd2;">codes</span> = <span style="color: #2aa198;">[]</span>
<span style="color: #859900; font-weight: bold;">for</span> symbol <span style="color: #859900; font-weight: bold;">in</span> symbols:
<span style="background-color: #eee8d5;"> </span>   codes.append<span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #b58900;">(</span>symbol<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>codes<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[97, 98, 99, 100, 101]</span>
</pre>
</div>
</li>
<li>看起来也没有那么麻烦,只不过python可以更简略,可以把codes的声明和赋值在一行
搞定,这就是所谓的list comprehension(listcomps)
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'abcde'</span>
<span style="color: #268bd2;">codes</span> = <span style="color: #2aa198;">[</span><span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #b58900;">(</span>symbol<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> symbol <span style="color: #859900; font-weight: bold;">in</span> symbols<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>codes<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[97, 98, 99, 100, 101]</span>
</pre>
</div>
</li>
<li>listcomps的优点不仅仅在于其短了一行,还在于其语意的唯一性:listcomps就是用来
初始化一个新的list的,而第一种方法里面的for loop却可能有很多种用途,这里只不
过是使用了第一种用途:初始化
</li>
<li>这也给我们提了醒,listcomps应该永远只用在初始化list的时候,而且同时我们要去
listcomps应该不能超过一行,超过一行的话,从可读性的角度,还是使用for循环比较好
</li>
<li>既然说到了跨行,那再多说一句,在python的[], {}, ()里面, line break是被ignore的
<pre class="example">
In Python code, line breaks are ignored inside pairs of [], {}, or ().
So you can build multiline lists, listcomps, genexps, dictionaries and
the like without using the ugly \ line continuation escape.
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">Listcomps Versus map and filter</h4>
<div class="outline-text-4" id="text-2-2-2">
<ul class="org-ul">
<li>在创建新list这个功能上面listcomps肯定是最好的选择,虽然funtional的filter和
map也可以起到同样的作用,但是显然它们太麻烦了:
<ul class="org-ul">
<li>麻烦的filter+map.其中filter函数的原型是filter(function, iterable),对iterable
里面的所有成员调用function,返回true的组成一个新的iterable返回.map的函数原
型就简单了map(function, iterable),对所有的iterable调用function.所以我们
函数式的创建一个list的代码如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'$&#162;&#163;&#165;&#8364;&#164;'</span>
<span style="color: #268bd2;">beyond_ascii</span> = <span style="color: #657b83; font-weight: bold;">list</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">filter</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">lambda</span> c: c &gt; 127, <span style="color: #657b83; font-weight: bold;">map</span><span style="color: #268bd2;">(</span><span style="color: #657b83; font-weight: bold;">ord</span>, symbols<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>beyond_ascii<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[162, 163, 165, 8364, 164]</span>
</pre>
</div>
</li>
<li>而listcomps的代码肯定简单的多啦
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'$&#162;&#163;&#165;&#8364;&#164;'</span>
<span style="color: #268bd2;">beyond_ascii</span> = <span style="color: #2aa198;">[</span><span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> s <span style="color: #859900; font-weight: bold;">in</span> symbols <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span> &gt; 127<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>beyond_ascii<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[162, 163, 165, 8364, 164]</span>
</pre>
</div>
</li>
</ul>
</li>
<li>而且更重要的是listcomps的效率并不比"函数式方法"的差
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">Cartesian Products</h4>
<div class="outline-text-4" id="text-2-2-3">
<ul class="org-ul">
<li>笛卡尔积,这个题目比较吓人,其实就是全排列,我们来看看笛卡尔积的定义
<pre class="example">
假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为
{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}
</pre>
</li>
<li>我们用一个例子来理解下笛卡尔积,比如我们要做T恤,有两种颜色和三种大小的T恤,所
以最常见的使用for循环来初始化的方法如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">colors</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'black'</span>, <span style="color: #2aa198;">'white'</span><span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">sizes</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'S'</span>, <span style="color: #2aa198;">'M'</span>, <span style="color: #2aa198;">'L'</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">for</span> color <span style="color: #859900; font-weight: bold;">in</span> colors:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">for</span> size <span style="color: #859900; font-weight: bold;">in</span> sizes:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>color, size<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('black', 'S')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('black', 'M')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('black', 'L')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'S')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'M')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'L')</span>
</pre>
</div>
</li>
<li>如果使用listcomps,会是一种更加简洁的写法
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">colors</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'black'</span>, <span style="color: #2aa198;">'white'</span><span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">sizes</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'S'</span>, <span style="color: #2aa198;">'M'</span>, <span style="color: #2aa198;">'L'</span><span style="color: #2aa198;">]</span>

<span style="color: #268bd2;">tshirts</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">(</span>color, size<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> color <span style="color: #859900; font-weight: bold;">in</span> colors <span style="color: #859900; font-weight: bold;">for</span> size <span style="color: #859900; font-weight: bold;">in</span> sizes<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tshirts<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[('black', 'S'), ('black', 'M'), ('black', 'L'),</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'S'), ('white', 'M'), ('white', 'L')]</span>
</pre>
</div>
</li>
<li>listcomps的优势还在于可以在[]内部进行换行提高可读性
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">colors</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'black'</span>, <span style="color: #2aa198;">'white'</span><span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">sizes</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'S'</span>, <span style="color: #2aa198;">'M'</span>, <span style="color: #2aa198;">'L'</span><span style="color: #2aa198;">]</span>

<span style="color: #268bd2;">tshirts</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">(</span>color, size<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> size <span style="color: #859900; font-weight: bold;">in</span> sizes
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>  <span style="color: #859900; font-weight: bold;">for</span> color <span style="color: #859900; font-weight: bold;">in</span> colors<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tshirts<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[('black', 'S'), ('white', 'S'), ('black', 'M'),</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">('white', 'M'), ('black', 'L'), ('white', 'L')]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4">Generator Expressions</h4>
<div class="outline-text-4" id="text-2-2-4">
<ul class="org-ul">
<li>如果想初始化tuple, array或者其他类型的sequence,你当然可以先使用listcomps初
始化一个list,然后在作为ctor的参赛来初始化一个sequence,比如tuple
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">t_from_l</span> = <span style="color: #657b83; font-weight: bold;">tuple</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[</span>n <span style="color: #859900; font-weight: bold;">for</span> n <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #268bd2;">(</span>5<span style="color: #268bd2;">)</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>t_from_l<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">(0, 1, 2, 3, 4)</span>
</pre>
</div>
</li>
<li>但这样做代价太大,因为某个"临时的list",其主要作用,就是用来初始化另外一个sequence
</li>
<li>最经济的创建非list sequence的方法就是generator expression(genexp).
</li>
<li>从样子上来看,你肯定可以发现genexp其实就是"去掉中括号"的listcomps:
<ul class="org-ul">
<li>listcomp:
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'abcde'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[</span><span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #268bd2;">(</span>symbol<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">for</span> symbol <span style="color: #859900; font-weight: bold;">in</span> symbols<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[97, 98, 99, 100, 101]</span>
</pre>
</div>
</li>
<li>genexp for tuple:
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'abcde'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">tuple</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #268bd2;">(</span>symbol<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">for</span> symbol <span style="color: #859900; font-weight: bold;">in</span> symbols<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">(97, 98, 99, 100, 101)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>在上面的例子中tuple()这个ctor只有一个参数,所以我们的genexp是"去掉中括号"的
listcomps,如果某个sequence的ctor有两个参数,那么我们的genexp就是"去掉中括号
换上小括号"的listcomps
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> array
<span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'abcde'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>array.array<span style="color: #b58900;">(</span><span style="color: #2aa198;">'I'</span>, <span style="color: #268bd2;">(</span><span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #6c71c4;">(</span>symbol<span style="color: #6c71c4;">)</span> <span style="color: #859900; font-weight: bold;">for</span> symbol <span style="color: #859900; font-weight: bold;">in</span> symbols<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">array('I', [97, 98, 99, 100, 101])</span>
</pre>
</div>
</li>
<li>genexp相比于传统的for循环也有优势,比如前面我们使用两层for循环来打印T恤代码
如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">colors</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'black'</span>, <span style="color: #2aa198;">'white'</span><span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">sizes</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'S'</span>, <span style="color: #2aa198;">'M'</span>, <span style="color: #2aa198;">'L'</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">for</span> color <span style="color: #859900; font-weight: bold;">in</span> colors:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">for</span> size <span style="color: #859900; font-weight: bold;">in</span> sizes:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>color, size<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('black', 'S')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('black', 'M')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('black', 'L')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'S')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'M')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'L')</span>
</pre>
</div>
</li>
<li>上述做法没有什么不对,但是所有的成员都是先存储在内存里面,然后让print读取的,
如果笛卡尔积的个数比较大(比如各有1000个成员),那么讲使用非常大一块内存.genexp
就能够解决这个问题,因为genexp是每次生成一个就传递给print
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">colors</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'black'</span>, <span style="color: #2aa198;">'white'</span><span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">sizes</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'S'</span>, <span style="color: #2aa198;">'M'</span>, <span style="color: #2aa198;">'L'</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">for</span> tshirt <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #2aa198;">(</span><span style="color: #2aa198;">'%s %s'</span> % <span style="color: #b58900;">(</span>c, s<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> c <span style="color: #859900; font-weight: bold;">in</span> colors <span style="color: #859900; font-weight: bold;">for</span> s <span style="color: #859900; font-weight: bold;">in</span> sizes<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tshirt<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">black S</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">black M</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">black L</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">white S</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">white M</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">white L</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Tuples Are Not Just Immutable Lists</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>很多的python入门教材都会把tuple描述成"immutable list",但是这只是tuple两个重
要特性中的一个,另外一个重要的特性是:records with no field names
</li>
</ul>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Tuples as Records</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>tuple的成员可以看成是record,但是要从一个抽象的维度去看:
<ul class="org-ul">
<li>首先tuple的成员每个都是可以看成是这个record的field
</li>
<li>每个tuple的成员还有一个position,这个potion也会给予它特殊的意义,虽然这个意
义不像filed name那么好,但也总算是有个区别
</li>
</ul>
</li>
<li>如果仅仅把tuple看成是immutable list的话,那么其成员的个数,和每个成员的position
是不重要的,但是你要是把tuple看成是record的话,这两者就都非常重要啦
</li>
<li>我们来看看下面的例子,下面例子中的position都有其确定的意义,更改每个tuple里面
成员的位置都会是破坏性的
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">lax_coordinates</span> = <span style="color: #2aa198;">(</span>33.9425, -118.408056<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">city</span>, <span style="color: #268bd2;">year</span>, <span style="color: #268bd2;">pop</span>, <span style="color: #268bd2;">chg</span>, <span style="color: #268bd2;">area</span> = <span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Tokyo'</span>, 2003, 32450, 0.66, 8014<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">traveler_ids</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">'USA'</span>, <span style="color: #2aa198;">'31195855'</span><span style="color: #b58900;">)</span>,
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #b58900;">(</span><span style="color: #2aa198;">'BAR'</span>, <span style="color: #2aa198;">'CE342567'</span><span style="color: #b58900;">)</span>, <span style="color: #b58900;">(</span><span style="color: #2aa198;">'ESP'</span>, <span style="color: #2aa198;">'XDA205856'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">for</span> passport <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">sorted</span><span style="color: #2aa198;">(</span>traveler_ids<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'%s/%s'</span> % passport<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">for</span> country, _ <span style="color: #859900; font-weight: bold;">in</span> traveler_ids:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>country<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">BAR/CE342567</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">ESP/XDA205856</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">USA/31195855</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">USA</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">BAR</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">ESP</span>
</pre>
</div>
</li>
<li>我们在这个例子里面可以看到,python和tuple相处的特别好:
<ul class="org-ul">
<li>% 可以理解tuple,并且知道把tuple"展开"来使用
</li>
<li>for也知道每一次循环的时候,把tuple"展开"返回
</li>
</ul>
</li>
<li>python能够理解tuple的原因,在于tuple unpacking mechanism
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Tuple Unpacking</h4>
<div class="outline-text-4" id="text-2-3-2">
<ul class="org-ul">
<li>tuple unpacking最常见的地方是parallel assignment:也就是把一个iterable的值
赋给a tuple of variable:
<ul class="org-ul">
<li>把iterable赋给tuple of variable,那么等号右边肯定是iterable(这里是list),
左边肯定是tuple of varialb
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span>1, 2<span style="color: #2aa198;">]</span>
<span style="color: #2aa198;">(</span>b, c<span style="color: #2aa198;">)</span> = a
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
</pre>
</div>
</li>
<li>只要是iterable就可以,那么其实等号的右边也肯定是tuple,只不过是tuple付给tuple
啦
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">(</span>1, 2<span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">(</span>b, c<span style="color: #2aa198;">)</span> = a
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
</pre>
</div>
</li>
<li>左边的tuple可以其实不用加括号,那就转化成了我们最常见的tuple unpacking:一
个陌生的iterable变量返回给N个值给一个"去掉括号的tuple"
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">(</span>1, 2<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">b</span>, <span style="color: #268bd2;">c</span> = a
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
</pre>
</div>
</li>
<li>如果右边是"纯"的tuple的话,那么右边其实也不用括号,这就转换成了我们常见的
swapping the values of variables without using a temporary variable
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = 1
<span style="color: #268bd2;">b</span> = 2

<span style="color: #268bd2;">b</span>, <span style="color: #268bd2;">a</span> = a, b
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
</pre>
</div>
</li>
<li>当tuple作为函数的参数的时候,你必须在传参的时候,明确的告诉function,tuple
的成员要"展开"使用,否则函数是不知道你要怎样使用的.明确"展开"tuple的方法是
在tuple前面加一个*
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">foo</span><span style="color: #2aa198;">(</span>a, b=<span style="color: #2aa198;">'not set'</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>


foo<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>1, 2<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
foo<span style="color: #2aa198;">(</span>*<span style="color: #b58900;">(</span>1, 2<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">(1, 2)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">not set</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
</pre>
</div>
</li>
<li>函数的返回值其实也就是一个变量,如果函数的返回值是一个iterable的话,那么肯
定可以是可以利用tuple unpacking把结果传递给多个参数的
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">foo</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">[</span>1, 2<span style="color: #2aa198;">]</span>


<span style="color: #268bd2;">a</span>, <span style="color: #268bd2;">b</span> = foo<span style="color: #2aa198;">()</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
</pre>
</div>
</li>
<li>函数返回值有时候返回了很多的信息,但是我们不是对所有信息都有兴趣,那么我可
以使用variable `_`(注意`_`也是一个变量,这和golang里面是不一样的)来作为
placeholder
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">foo</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">[</span>1, 2, 3<span style="color: #2aa198;">]</span>


<span style="color: #268bd2;">_</span>, <span style="color: #268bd2;">a</span>, <span style="color: #268bd2;">_</span> = foo<span style="color: #2aa198;">()</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>_<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">3</span>
</pre>
</div>
</li>
<li>有时候我们不确定有多少的返回值，或者说我们希望把某些“连续”的返回值存储在
同一个list里面.这个时候,还是用*来提醒python解释器,把"剩下的"都以list的形
式都装到某个变量里面
<div class="org-src-container">

<pre class="src src-python">a, b, *<span style="color: #268bd2;">rest</span> = <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>5<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a, b, rest<span style="color: #2aa198;">)</span>
a, b, *<span style="color: #268bd2;">rest</span> = <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>3<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a, b, rest<span style="color: #2aa198;">)</span>
a, b, *<span style="color: #268bd2;">rest</span> = <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a, b, rest<span style="color: #2aa198;">)</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">0 1 [2, 3, 4]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">0 1 [2]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">0 1 []</span>
</pre>
</div>
</li>
<li>*prefix出现且只能出现一次,但是并不一定是在最后,还是可以在其他位置的
<div class="org-src-container">

<pre class="src src-python">a, *<span style="color: #268bd2;">body</span>, <span style="color: #268bd2;">c</span>, <span style="color: #268bd2;">d</span> = <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>5<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a, body, c, d<span style="color: #2aa198;">)</span>
*<span style="color: #268bd2;">head</span>, <span style="color: #268bd2;">b</span>, <span style="color: #268bd2;">c</span>, <span style="color: #268bd2;">d</span> = <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>5<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>head, b, c, d<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">0 [1, 2] 3 4</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, 1] 2 3 4</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3">Nested Tuple Unpacking</h4>
<div class="outline-text-4" id="text-2-3-3">
<ul class="org-ul">
<li>tuple unpacking更智能一步的可以让我们的receiver tuple nested(当然也就意味着
提供tuple的iterable也是nested的)
<div class="org-src-container">

<pre class="src src-python">a, <span style="color: #2aa198;">(</span>b1, b2<span style="color: #2aa198;">)</span>, <span style="color: #268bd2;">c</span> = <span style="color: #2aa198;">[</span>1, <span style="color: #b58900;">[</span>2, 3<span style="color: #b58900;">]</span>, 4<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b1<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b2<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">3</span>
</pre>
</div>
</li>
<li>值得注意的是,在python2里面,函数的参数在定义的时候,是允许使用nested tuple的
换句话说,如下的函数定义在python2里面是合法的
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">fn</span><span style="color: #2aa198;">(</span>a, <span style="color: #b58900;">(</span>b, c<span style="color: #b58900;">)</span>, d<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">pass</span>
</pre>
</div>
</li>
<li>但是从python3开始,这种定义方法变得非法了PEP3113详细说明了原因
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-4" class="outline-4">
<h4 id="sec-2-3-4">Named Tuples</h4>
<div class="outline-text-4" id="text-2-3-4">
<ul class="org-ul">
<li>tuple的position(0, 1, 2, 3等)为tuple成员value提供了一个比较"模糊"的name,但
是在调试的时候,这个name往往不容易辨识,所以python后来又提供了collections.namedtuple
你可以认为这是一个带name的tuple
</li>
<li>collections.namedtuple的实现方法比较独特(主要是为了节省内存):namedtuple返回
一个tuple的subclass(通过工厂模式),但是带有名字,名字存在了class里面,所以一
个namedtuple instance和一个普通的tuple instance的内存大小是一样的
</li>
<li>一个namedtuple的例子如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">from</span> collections <span style="color: #859900; font-weight: bold;">import</span> namedtuple

<span style="color: #268bd2;">City</span> = namedtuple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'City'</span>, <span style="color: #2aa198;">'name country population coordinates'</span><span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">tokyo</span> = City<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Tokyo'</span>, <span style="color: #2aa198;">'JP'</span>, 36.933, <span style="color: #b58900;">(</span>35.689722, 139.691667<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tokyo<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tokyo.population<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tokyo.coordinates<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tokyo<span style="color: #b58900;">[</span>1<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667))</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">36.933</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">(35.689722, 139.691667)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">JP</span>
</pre>
</div>
</li>
<li>可以看到,我们的namedtuple的返回值是一个新的class,namedtuple的参数有两个:
<ul class="org-ul">
<li>第一个是class的名字
</li>
<li>第二个是一个"空格分割"的字符串,来描述每个域.当然了从前面的例子中我们可以
看到,第二个参数还可以是一个字符串数组
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">Card</span> = collections.namedtuple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Card'</span>, <span style="color: #b58900;">[</span><span style="color: #2aa198;">'rank'</span>, <span style="color: #2aa198;">'suit'</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>另外所有的namedtuple class,都会有如下三个属性:
<ul class="org-ul">
<li>_fields: 就是named tuple所有的name
</li>
<li>_make(): 使用iterable来初始化某个named tuple
</li>
<li>_asdict(): 主要返回利于打印的数据格式
</li>
</ul>
</li>
<li>三个属性的例子如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">from</span> collections <span style="color: #859900; font-weight: bold;">import</span> namedtuple

<span style="color: #268bd2;">City</span> = namedtuple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'City'</span>, <span style="color: #2aa198;">'name country population coordinates'</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>City._fields<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">LatLong</span> = namedtuple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'LatLong'</span>, <span style="color: #2aa198;">'lat long'</span><span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">delhi_data</span> = <span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Delhi NCR'</span>, <span style="color: #2aa198;">'IN'</span>, 21.935, LatLong<span style="color: #b58900;">(</span>28.613889, 77.208889<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">delhi</span> = City._make<span style="color: #2aa198;">(</span>delhi_data<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>delhi<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">for</span> key, value <span style="color: #859900; font-weight: bold;">in</span> delhi._asdict<span style="color: #2aa198;">()</span>.items<span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>key + <span style="color: #2aa198;">":"</span>, value<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('name', 'country', 'population', 'coordinates')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">City(name='Delhi NCR', country='IN', population=21.935, coordinates=LatLong(lat=28.613889, long=77.208889))</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">name: Delhi NCR</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">country: IN</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">population: 21.935</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">coordinates: LatLong(lat=28.613889, long=77.208889)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-5" class="outline-4">
<h4 id="sec-2-3-5">Tuples as Immutable lists</h4>
<div class="outline-text-4" id="text-2-3-5">
<ul class="org-ul">
<li>另外,tuple实现了所有的list的函数,除了能更改成员数目的函数,比如add, remove等
</li>
<li>tuple没有实现__reverse__,但是这也只是由于为了提高性能,我们可以使用reverse(tuple)
来替代
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span>1, 2, 3<span style="color: #2aa198;">]</span>
a.reverse<span style="color: #2aa198;">()</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>

<span style="color: #268bd2;">b</span> = <span style="color: #2aa198;">(</span>1, 2, 3<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">b</span> = <span style="color: #657b83; font-weight: bold;">tuple</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">reversed</span><span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[3, 2, 1]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">(3, 2, 1)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Slicing</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>一个list,tuple,str乃至所有的sequence type都有的特性,就是slice操作.这个操作
非常有用,甚至影响了其他语言的设计,比如golang
</li>
</ul>
</div>
<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1">Why Slices and Range Exclude the Last Item</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li>许多语言,比如c和python里面的数组和其他sequence,都使用zero-based的方式来处理.
这样做有很多优点:
<ul class="org-ul">
<li>当只提供stop的时候,可以很容易的知道一个slice的长度,比如my_list[:3]就知道
有三个成员.range(3)也是一样的道理
</li>
<li>当同时提供了stop和start的时候,通过stop-start就知道了成员的个数,比如
my_list[1:3]就是两个成员
</li>
<li>把一个sequence分成两个的时候,不容易overlap
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">l</span> = <span style="color: #2aa198;">[</span>10, 20, 30, 40, 50, 60<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #b58900;">[</span>:2<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #b58900;">[</span>2:<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #b58900;">[</span>:3<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #b58900;">[</span>3:<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[10, 20]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[30, 40, 50, 60]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[10, 20, 30]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[40, 50, 60]</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2">Slice Objects</h4>
<div class="outline-text-4" id="text-2-4-2">
<ul class="org-ul">
<li>slice容易被人忽视的还在于它可以在start,stop之后拥有一个step选项,用来确定skip
的成员的书面,也就是s[start:stop:step]
</li>
<li>step的时候,总是会包含第一个成员,而且step的数目是包括当前的成员的,例子如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">'1234567'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>s<span style="color: #b58900;">[</span>::3<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">147</span>
</pre>
</div>
</li>
<li>step还可以是负数,那么就是总是包含最后一个成员,从后面开始.
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">'1234567'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>s<span style="color: #b58900;">[</span>::-2<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">7531</span>
</pre>
</div>
</li>
<li>step如果是-1的话,会有特殊效果,那就是"翻转"sequence
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">'1234567'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>s<span style="color: #b58900;">[</span>::-1<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">7654321</span>
</pre>
</div>
</li>
<li>[start:stop:step]这种方式只有在[]里面(并且这个[]是index或者subscript作用的
时候),才起作用:这种情况下[start:stop:step]会生成一个slice(start, stop, step)
object.
</li>
<li>而我们的seq[strt:stop:step]在evaluate的时候,会调用special method__getitem__
像是这样
<div class="org-src-container">

<pre class="src src-python">seq.__getitem__<span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">slice</span><span style="color: #b58900;">(</span>start, stop, step<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>这是我们第一次遇到slice object,其实slice object非常的有用,它能够有自己的名
字,就像excel表格里面的行和列一样,下面来介绍一个slice的应用
</li>
<li>假设我们有如下的发票信息,我们只希望优美的打印发票信息中的某两列信息(比如最
重要是产品说明个单价),怎么办呢?
<pre class="example">
0.....6.................................40........52...55........
1909  Pimoroni PiBrella                     $17.50    3    $52.50
1489  6mm Tactile Switch x20                 $4.95    2     $9.90
1510  Panavise Jr. - PV-201                 $28.00    1    $28.00
1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95
</pre>
</li>
<li>办法就是使用slice来命名这些行(也就是string),打印的时候,可以按照我们的需要
打印对应的列就可以了
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">invoice</span> = <span style="color: #2aa198;">"""</span>
<span style="color: #2aa198;">0.....6.................................40........52...55........</span>
<span style="color: #2aa198;">1909  Pimoroni PiBrella                     $17.50    3    $52.50</span>
<span style="color: #2aa198;">1489  6mm Tactile Switch x20                 $4.95    2     $9.90</span>
<span style="color: #2aa198;">1510  Panavise Jr. - PV-201                 $28.00    1    $28.00</span>
<span style="color: #2aa198;">1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95</span>
<span style="color: #2aa198;">"""</span>

<span style="color: #268bd2;">SKU</span>         = <span style="color: #657b83; font-weight: bold;">slice</span><span style="color: #2aa198;">(</span>0,  6<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">DESCRIPTION</span> = <span style="color: #657b83; font-weight: bold;">slice</span><span style="color: #2aa198;">(</span>6,  40<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">UNIT_PRICE</span>  = <span style="color: #657b83; font-weight: bold;">slice</span><span style="color: #2aa198;">(</span>40, 52<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">QUANTITY</span>    = <span style="color: #657b83; font-weight: bold;">slice</span><span style="color: #2aa198;">(</span>52, 55<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">ITEM_TOTAL</span>  = <span style="color: #657b83; font-weight: bold;">slice</span><span style="color: #2aa198;">(</span>55, <span style="color: #268bd2; font-weight: bold;">None</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">for</span> item <span style="color: #859900; font-weight: bold;">in</span> invoice.split<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'\n'</span><span style="color: #2aa198;">)[</span>2:-1<span style="color: #2aa198;">]</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>item<span style="color: #b58900;">[</span>UNIT_PRICE<span style="color: #b58900;">]</span>.strip<span style="color: #b58900;">()</span>, item<span style="color: #b58900;">[</span>DESCRIPTION<span style="color: #b58900;">]</span>.strip<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('$17.50', 'Pimoroni PiBrella')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('$4.95', '6mm Tactile Switch x20')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('$28.00', 'Panavise Jr. - PV-201')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('$34.95', 'PiTFT Mini Kit 320x240')</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3">Multidimensional Slicing and Ellipsis</h4>
<div class="outline-text-4" id="text-2-4-3">
<ul class="org-ul">
<li>在numpy这个package里面,[]operator也是可以接受使用逗号分隔的index的,比如
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> numpy
<span style="color: #268bd2;">a</span> = numpy.arange<span style="color: #2aa198;">(</span>12<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">a.shape</span> = 3, 4
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #b58900;">[</span>2, 1<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[[ 0  1  2  3]</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">[ 4  5  6  7]</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">[ 8  9 10 11]]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">9</span>
</pre>
</div>
</li>
<li>但是built-in的sequence type在python里面确实是只有一维的(one-dimensional)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-4" class="outline-4">
<h4 id="sec-2-4-4">Assigning to Slices</h4>
<div class="outline-text-4" id="text-2-4-4">
<ul class="org-ul">
<li>如果一个sequence是mutable的,那么这个sequence的slice用法可以放在赋值语句的
左边,作为receiver.注意,这个receiver的区间的长度,甚至可能和右边值的长度不一
样.但是右边必须也得是iterable object,即便只有一个item
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">l</span> = <span style="color: #657b83; font-weight: bold;">list</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">range</span><span style="color: #b58900;">(</span>10<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">l</span><span style="color: #2aa198;">[</span>2:5<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">[</span>20, 30<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">##########################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">TypeError: can only assign an iterable #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">l[2:5] = 100                           #</span>
<span style="color: #93a1a1;">##########################################</span>

<span style="color: #268bd2;">l</span><span style="color: #2aa198;">[</span>2:5<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">[</span>100<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, 1, 20, 30, 5, 6, 7, 8, 9]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, 1, 100, 6, 7, 8, 9]</span>
</pre>
</div>
</li>
<li>如果一个sequence是mutable的,那么这个sequence的slice用法也是可以放到del语句
后面的
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">l</span> = <span style="color: #657b83; font-weight: bold;">list</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">range</span><span style="color: #b58900;">(</span>10<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">del</span> l<span style="color: #2aa198;">[</span>2:5<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, 1, 5, 6, 7, 8, 9]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Using + and * with Sequences</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>sequence支持+operator和*operator:
<ul class="org-ul">
<li>对于+operator来说,两个操作数要求是同一个类型,否则相加不成功,结果返回一个
新的sequence,原来的两个操作数都不会被改动
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">l1</span> = <span style="color: #2aa198;">[</span>1, 2, 3<span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">l2</span> = <span style="color: #2aa198;">[</span>4, 5, 6<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l1 + l2<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l1<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l2<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[1, 2, 3, 4, 5, 6]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[1, 2, 3]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[4, 5, 6]</span>
</pre>
</div>
</li>
<li>对于乘法来说,操作数中一个为sequence,另外一个为整形,结果返回一个新的sequence
原来的两个操作数也都不会被改动
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">l1</span> = <span style="color: #2aa198;">[</span>1, 2, 3<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l1 * 2<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>2 * l1<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l1<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[1, 2, 3, 1, 2, 3]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[1, 2, 3, 1, 2, 3]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[1, 2, 3]</span>
</pre>
</div>
</li>
</ul>
</li>
<li>对于a * n这种格式(其中n为整数,a为sequence),如果a的成员里面还有sequence,并且
a不是immutable的话,那么这种做法非常的危险,因为同一个list会有多个reference,
很多问题都会随之出现.
</li>
<li>下面就是一个常见的错误做法,此种做法的问题在于,最外层的list其实是三个reference,
而且这三个reference是指向的同一个list
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">[</span><span style="color: #2aa198;">'_'</span><span style="color: #b58900;">]</span> * 3<span style="color: #2aa198;">]</span> * 3
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
a<span style="color: #2aa198;">[</span>1<span style="color: #2aa198;">][</span>2<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">'0'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '0'], ['_', '_', '0'], ['_', '_', '0']]</span>
</pre>
</div>
</li>
<li>上面的做法其实是相当于如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">row</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'_'</span><span style="color: #2aa198;">]</span> * 3
<span style="color: #268bd2;">board</span> = <span style="color: #2aa198;">[]</span>
<span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>3<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   board.append<span style="color: #2aa198;">(</span>row<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>board<span style="color: #2aa198;">)</span>
board<span style="color: #2aa198;">[</span>1<span style="color: #2aa198;">][</span>2<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">'0'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>board<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '0'], ['_', '_', '0'], ['_', '_', '0']]</span>
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1">Building Lists of Lists</h4>
<div class="outline-text-4" id="text-2-5-1">
<ul class="org-ul">
<li>上面提到的这种创建list of list(nested list)的情况也是很常见的.常见的错误做
法我们也在上面做了举例了,正确的解法应该是使用list comprehension
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">[</span><span style="color: #2aa198;">'_'</span><span style="color: #b58900;">]</span> * 3 <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #b58900;">(</span>3<span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
a<span style="color: #2aa198;">[</span>1<span style="color: #2aa198;">][</span>2<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">'0'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '_'], ['_', '_', '0'], ['_', '_', '_']]</span>
</pre>
</div>
</li>
<li>上面正确的做法其实是相当于
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">board</span> = <span style="color: #2aa198;">[]</span>
<span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>3<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">row</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'_'</span><span style="color: #2aa198;">]</span> * 3
<span style="background-color: #eee8d5;"> </span>   board.append<span style="color: #2aa198;">(</span>row<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>board<span style="color: #2aa198;">)</span>
board<span style="color: #2aa198;">[</span>1<span style="color: #2aa198;">][</span>2<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">'0'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>board<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '_'], ['_', '_', '0'], ['_', '_', '_']]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Augmented Assignment with Sequences</h3>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
