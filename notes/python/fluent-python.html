<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>fluent-python</title>
<!-- 2017-08-09 Wed 13:35 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">fluent-python</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 01: The Python Data Model</a>
<ul>
<li><a href="#sec-1-1">A Pythonic Card Deck</a></li>
<li><a href="#sec-1-2">How Special Methods Are Used</a>
<ul>
<li><a href="#sec-1-2-1">Emulating Numeric Types</a></li>
<li><a href="#sec-1-2-2">String Representation</a></li>
<li><a href="#sec-1-2-3">Arithmetic Operators</a></li>
<li><a href="#sec-1-2-4">Boolean Value of Custom Type</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Overview of Special Methods</a></li>
<li><a href="#sec-1-4">Why Len Is Not a Method</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 02: An Array of Sequences</a>
<ul>
<li><a href="#sec-2-1">Overview of Built-In Sequences</a></li>
<li><a href="#sec-2-2">List Comprehensions and Generator Expressions</a>
<ul>
<li><a href="#sec-2-2-1">List Comprehensions and Readability</a></li>
<li><a href="#sec-2-2-2">Listcomps Versus map and filter</a></li>
<li><a href="#sec-2-2-3">Cartesian Products</a></li>
<li><a href="#sec-2-2-4">Generator Expressions</a></li>
</ul>
</li>
<li><a href="#sec-2-3">Tuples Are Not Just Immutable Lists</a>
<ul>
<li><a href="#sec-2-3-1">Tuples as Records</a></li>
<li><a href="#sec-2-3-2">Tuple Unpacking</a></li>
<li><a href="#sec-2-3-3">Nested Tuple Unpacking</a></li>
<li><a href="#sec-2-3-4">Named Tuples</a></li>
<li><a href="#sec-2-3-5">Tuples as Immutable lists</a></li>
</ul>
</li>
<li><a href="#sec-2-4">Slicing</a>
<ul>
<li><a href="#sec-2-4-1">Why Slices and Range Exclude the Last Item</a></li>
<li><a href="#sec-2-4-2">Slice Objects</a></li>
<li><a href="#sec-2-4-3">Multidimensional Slicing and Ellipsis</a></li>
<li><a href="#sec-2-4-4">Assigning to Slices</a></li>
</ul>
</li>
<li><a href="#sec-2-5">Using + and * with Sequences</a>
<ul>
<li><a href="#sec-2-5-1">Building Lists of Lists</a></li>
</ul>
</li>
<li><a href="#sec-2-6">Augmented Assignment with Sequences</a>
<ul>
<li><a href="#sec-2-6-1">A += Assignment Puzzler</a></li>
</ul>
</li>
<li><a href="#sec-2-7">list.sort and sorted Built-In Function</a></li>
<li><a href="#sec-2-8">Managing Ordered Sequences with bisect</a>
<ul>
<li><a href="#sec-2-8-1">Searching with bisect</a></li>
<li><a href="#sec-2-8-2">Inserting with bisect.insort</a></li>
</ul>
</li>
<li><a href="#sec-2-9">When a List Is Not the Answer</a>
<ul>
<li><a href="#sec-2-9-1">Arrays</a></li>
<li><a href="#sec-2-9-2">Memory Views</a></li>
<li><a href="#sec-2-9-3">NumPy and SciPy</a></li>
<li><a href="#sec-2-9-4">Deques and Other Queues</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">Chapter 03: Dictionaries and Sets</a>
<ul>
<li><a href="#sec-3-1">Generic Mapping Types</a></li>
<li><a href="#sec-3-2">dict Comprehensions</a></li>
<li><a href="#sec-3-3">Overview of Common Mapping Methods</a></li>
<li><a href="#sec-3-4">Mappings with Flexible Key Lookup</a>
<ul>
<li><a href="#sec-3-4-1">Variations of dict</a></li>
<li><a href="#sec-3-4-2">Subclassing UserDict</a></li>
<li><a href="#sec-3-4-3">Immutable Mappings</a></li>
</ul>
</li>
<li><a href="#sec-3-5">Set Theory</a>
<ul>
<li><a href="#sec-3-5-1">set Literals</a></li>
<li><a href="#sec-3-5-2">Set Comprehensions</a></li>
<li><a href="#sec-3-5-3">Set Operations</a></li>
</ul>
</li>
<li><a href="#sec-3-6">dict and set Under the Hood</a></li>
</ul>
</li>
<li><a href="#sec-4">Chapter 04: Text versus Bytes</a>
<ul>
<li><a href="#sec-4-1">Character Issues</a>
<ul>
<li><a href="#sec-4-1-1">Python2 problem</a></li>
</ul>
</li>
<li><a href="#sec-4-2">Character Issues Continue</a></li>
<li><a href="#sec-4-3">Byte Essentials</a>
<ul>
<li><a href="#sec-4-3-1">Structs and Memory Views</a></li>
</ul>
</li>
<li><a href="#sec-4-4">Basic Encoders/Decoders</a></li>
<li><a href="#sec-4-5">Understanding Encode/Decode Problems</a>
<ul>
<li><a href="#sec-4-5-1">Coping with UnicodeEncodeError</a></li>
<li><a href="#sec-4-5-2">Coping with UnicodeDecodeError</a></li>
<li><a href="#sec-4-5-3">SyntxtError When Loading Modules with Unexpected Encoding</a></li>
<li><a href="#sec-4-5-4">How to Discover the Encoding of a Byte Sequence</a></li>
<li><a href="#sec-4-5-5">BOM: A Useful Gremin</a></li>
</ul>
</li>
<li><a href="#sec-4-6">Handling Text Files</a></li>
<li><a href="#sec-4-7">Normalizing Unicode for Saner Comparisons</a></li>
<li><a href="#sec-4-8">Case Folding</a></li>
<li><a href="#sec-4-9">Sorting Unicode Text</a></li>
<li><a href="#sec-4-10">The Unicode Database</a></li>
<li><a href="#sec-4-11">Dual-Mode str and bytes APIs</a></li>
</ul>
</li>
<li><a href="#sec-5">Chapter 05: First-Class Functions</a>
<ul>
<li><a href="#sec-5-1">Treating a Function Like an Object</a></li>
<li><a href="#sec-5-2">Higher-Order Functions</a>
<ul>
<li><a href="#sec-5-2-1">Modern Replacements for map, filter, and reduce</a></li>
</ul>
</li>
<li><a href="#sec-5-3">Anonymous Functions</a></li>
<li><a href="#sec-5-4">The Sevent Flavors of Callable Objects</a></li>
<li><a href="#sec-5-5">User-Defined Callable Types</a>
<ul>
<li><a href="#sec-5-5-1">Function Introspection</a></li>
<li><a href="#sec-5-5-2">From Positional to Keyword-Only Parameters</a></li>
<li><a href="#sec-5-5-3">Retrieving Information About Parameters</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 01: The Python Data Model</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>python的最大特质就是consistency,当你在python上面工作了一段时间以后,你可以通过
"猜测"来完成学习新的feature
</li>
<li>但是,如果你原来学习过其他的oo语言,那么当你开始使用python的时候会有些困惑,比如,
为什么使用len(collection)而不是collection.len()
</li>
<li>而这种看起来很奇怪的东西(其实就是Python data model的一个例子),一旦理解了以后,
可以对我们理解Pythonic起到关键作用.
</li>
<li>所谓的python data model,它描述了一套API,如果你的object也能符合这个API,那么你
的object也可以和python其他的语言特性融合的很好
</li>
<li>无论是web开发还是GUI开发,都会有很多的framework,当你使用一个framework的时候,
你其实是实现了很多的method,让framework来call
</li>
<li>如果你把python看成是一个framework的话,那么data model其实规定了我们经常需要实
现的函数的接口,比如后面要说的__getitem__()
</li>
<li>Python解析器在遇到某些syntax的时候,就去调用某些接口,这些接口往往是以两个下划
线开始和结尾的,比如在遇到obj[key]的时候,解析器就会去调用__getitem__.你想和python
其他object玩得好,你的的object如果是线性存储的,那么也要实现"这些特殊接口"
</li>
<li>"这些特殊接口"能够覆盖的语言特性有:
<ul class="org-ul">
<li>Iteration
</li>
<li>Collections
</li>
<li>Attribute access
</li>
<li>Function and method invocation
</li>
<li>Object creation and destruction
</li>
<li>String representation and formatting
</li>
<li>Managed context(with block)
</li>
</ul>
</li>
<li>"特殊接口"其实真正的名字叫做magic method,但是其真正的完整发音应该是"under-under-getitem-under-under"
显然这个名字太长了,所以业界比较喜欢用的称呼是"dunder-getitem"(double under
get item)的叫法
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">A Pythonic Card Deck</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>下面是一个非常简单的例子,我们可以用来证明实现了special method(__getitem__,
__len__)的威力
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> collections

<span style="color: #268bd2;">Card</span> = collections.namedtuple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Card'</span>, <span style="color: #b58900;">[</span><span style="color: #2aa198;">'rank'</span>, <span style="color: #2aa198;">'suit'</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>


<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">FrenchDeck</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">ranks</span> = <span style="color: #2aa198;">[</span><span style="color: #657b83; font-weight: bold;">str</span><span style="color: #b58900;">(</span>n<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> n <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #b58900;">(</span>2, 11<span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span> + <span style="color: #657b83; font-weight: bold;">list</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'JQKA'</span><span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">suits</span> = <span style="color: #2aa198;">'spades diamonds clubs hearts'</span>.split<span style="color: #2aa198;">()</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">self</span>._cards = <span style="color: #2aa198;">[</span>
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   Card<span style="color: #b58900;">(</span>rank, suit<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> suit <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #859900; font-weight: bold;">self</span>.suits <span style="color: #859900; font-weight: bold;">for</span> rank <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #859900; font-weight: bold;">self</span>.ranks
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #2aa198;">]</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__len__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>._cards<span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__getitem__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, position<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>._cards<span style="color: #2aa198;">[</span>position<span style="color: #2aa198;">]</span>


<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">deck</span> = FrenchDeck<span style="color: #2aa198;">()</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>deck<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>deck<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>deck<span style="color: #b58900;">[</span>-1<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>


<span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">__name__</span> == <span style="color: #2aa198;">'__main__'</span>:
<span style="background-color: #eee8d5;"> </span>   main<span style="color: #2aa198;">()</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">52</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Card(rank='2', suit='spades')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Card(rank='A', suit='hearts')</span>
</pre>
</div>
</li>
<li>当然了,这个例子最主要的一个令初学者费解的地方就是collections.namedtuple啦,
这个是python的特性:namedtuple可以用来创建只有attribute,而没有custom method
的class,最常见的用法就是database record
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> collections

<span style="color: #268bd2;">Card</span> = collections.namedtuple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Card'</span>, <span style="color: #b58900;">[</span><span style="color: #2aa198;">'rank'</span>, <span style="color: #2aa198;">'suit'</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>Card<span style="color: #b58900;">(</span><span style="color: #2aa198;">'7'</span>, <span style="color: #2aa198;">'diamonds'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Card(rank='7', suit='diamonds')</span>
</pre>
</div>
</li>
<li>了解了namedtuple以后,其他的代码比较容易理解:我们通过实现不同的special method
来获得了不同的能力:
<ul class="org-ul">
<li>通过实现__getitem__来获得了[]的能力
</li>
<li>通过实现__len__来获得了len()的能力
</li>
</ul>
</li>
<li>实现了special method不仅仅能够获得"相应"的能力(比如[]),还可以和其他的python
library完美的配合,比如当我们需要"随机"取出一个card的时候,我们不需要自己再造
一次轮子,我们只要使用python library的random.choice就可以了.记住,能够把random.choice
直接使用,是因为我们实现了special method!
<div class="org-src-container">

<pre class="src src-python">In <span style="color: #2aa198;">[</span>20<span style="color: #2aa198;">]</span>: <span style="color: #268bd2;">deck</span> = FrenchDeck<span style="color: #2aa198;">()</span>

In <span style="color: #2aa198;">[</span>21<span style="color: #2aa198;">]</span>: <span style="color: #859900; font-weight: bold;">from</span> random <span style="color: #859900; font-weight: bold;">import</span> choice

In <span style="color: #2aa198;">[</span>22<span style="color: #2aa198;">]</span>: choice<span style="color: #2aa198;">(</span>deck<span style="color: #2aa198;">)</span>
Out<span style="color: #2aa198;">[</span>22<span style="color: #2aa198;">]</span>: Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'4'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #2aa198;">)</span>

In <span style="color: #2aa198;">[</span>23<span style="color: #2aa198;">]</span>: choice<span style="color: #2aa198;">(</span>deck<span style="color: #2aa198;">)</span>
Out<span style="color: #2aa198;">[</span>23<span style="color: #2aa198;">]</span>: Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'3'</span>, suit=<span style="color: #2aa198;">'hearts'</span><span style="color: #2aa198;">)</span>

In <span style="color: #2aa198;">[</span>24<span style="color: #2aa198;">]</span>: choice<span style="color: #2aa198;">(</span>deck<span style="color: #2aa198;">)</span>
Out<span style="color: #2aa198;">[</span>24<span style="color: #2aa198;">]</span>: Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'A'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>不仅仅如此,获得了"相应"的能力(比如[])之后,这个能力的附加能力也会获得,比如我
们通过__getitem__获得了[], 与此同时,我们还获得了slicing.下面就是两个例子:
<ul class="org-ul">
<li>前三个card
<div class="org-src-container">

<pre class="src src-python">In <span style="color: #2aa198;">[</span>25<span style="color: #2aa198;">]</span>: deck<span style="color: #2aa198;">[</span>:3<span style="color: #2aa198;">]</span>
Out<span style="color: #2aa198;">[</span>25<span style="color: #2aa198;">]</span>:
<span style="color: #2aa198;">[</span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'2'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #b58900;">)</span>,
<span style="background-color: #eee8d5;"> </span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'3'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #b58900;">)</span>,
<span style="background-color: #eee8d5;"> </span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'4'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
<li>从第12个开始,每13个取一个deck显示
<div class="org-src-container">

<pre class="src src-python">In <span style="color: #2aa198;">[</span>26<span style="color: #2aa198;">]</span>: deck<span style="color: #2aa198;">[</span>12::13<span style="color: #2aa198;">]</span>
Out<span style="color: #2aa198;">[</span>26<span style="color: #2aa198;">]</span>:
<span style="color: #2aa198;">[</span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'A'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #b58900;">)</span>,
<span style="background-color: #eee8d5;"> </span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'A'</span>, suit=<span style="color: #2aa198;">'diamonds'</span><span style="color: #b58900;">)</span>,
<span style="background-color: #eee8d5;"> </span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'A'</span>, suit=<span style="color: #2aa198;">'clubs'</span><span style="color: #b58900;">)</span>,
<span style="background-color: #eee8d5;"> </span>Card<span style="color: #b58900;">(</span>rank=<span style="color: #2aa198;">'A'</span>, suit=<span style="color: #2aa198;">'hearts'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
</ul>
</li>
<li>实现了__getitem__之后,deck还变得iterable
<div class="org-src-container">

<pre class="src src-python">In <span style="color: #2aa198;">[</span>32<span style="color: #2aa198;">]</span>: <span style="color: #859900; font-weight: bold;">for</span> card <span style="color: #859900; font-weight: bold;">in</span> deck: <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>card<span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'2'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'3'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'4'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'5'</span>, suit=<span style="color: #2aa198;">'spades'</span><span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
</pre>
</div>
</li>
<li>reverse iterable也拥有了
<div class="org-src-container">

<pre class="src src-python">In <span style="color: #2aa198;">[</span>33<span style="color: #2aa198;">]</span>: <span style="color: #859900; font-weight: bold;">for</span> card <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">reversed</span><span style="color: #2aa198;">(</span>deck<span style="color: #2aa198;">)</span>: <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>card<span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'A'</span>, suit=<span style="color: #2aa198;">'hearts'</span><span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'K'</span>, suit=<span style="color: #2aa198;">'hearts'</span><span style="color: #2aa198;">)</span>
Card<span style="color: #2aa198;">(</span>rank=<span style="color: #2aa198;">'Q'</span>, suit=<span style="color: #2aa198;">'hearts'</span><span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
</pre>
</div>
</li>
<li>实现了__getitem__的好处还有:可以自动识别in operator(虽然要遍历一遍,如果有
__contains__的话,就不用遍历了,会快很多)
<div class="org-src-container">

<pre class="src src-python">In <span style="color: #2aa198;">[</span>34<span style="color: #2aa198;">]</span>: Card<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Q'</span>, <span style="color: #2aa198;">'hearts'</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">in</span> deck
Out<span style="color: #2aa198;">[</span>34<span style="color: #2aa198;">]</span>: <span style="color: #268bd2; font-weight: bold;">True</span>

In <span style="color: #2aa198;">[</span>35<span style="color: #2aa198;">]</span>: Card<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'7'</span>, <span style="color: #2aa198;">'beasts'</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">in</span> deck
Out<span style="color: #2aa198;">[</span>35<span style="color: #2aa198;">]</span>: <span style="color: #268bd2; font-weight: bold;">False</span>
</pre>
</div>
</li>
<li>我们还可以实现排序,不过要借助一些函数TODO
</li>
<li>虽然FrenchDeck是继承自object,但是它的功能(functionality)却不是通过继承获得
的而是通过实现special method(类似于composition)来完成的.实现这些special
method让我们自己写的函数和python的library看起来,用起来都很像
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">How Special Methods Are Used</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>首先,我们需要明确的是,special method是设计用来被python interpreter来调用的,
而不是程序员!换句话说,你不可以使用my_object.__len__()这种代码,而是应该使用
len(my_object),如果my_object是user defined的class的instance话python interpreter
会为你调用__len__
</li>
<li>为什么会说"如果my_object是user defined的class的instance话"这句话呢?这是因为
如果不是user defined的class,python可以采用一些优化的手段来避免调用函数,而直
接返回field值,因为函数调用更"昂贵".
</li>
<li>比如内置的类型,比如list, str,我们写了len(some_list)函数的时候,python interpreter
不会去直接调用__len__,而是直接返回ob_szie这个域
</li>
<li>special method也不是每个都是像函数一样被interpreter调用,一个反例就是in operator,
在内部interpreter对于形如i in x的代码,其实是先转换成iter(x),然后再调用x.__iter__()
</li>
<li>对于用户来说,唯一一个可能频繁调用的special method就是__init__
</li>
<li>对于用户来说,也不要去创建类似__foo__的函数名,因为虽然现在看起来滑稽,但是保
不齐以后python真的会实现这样一个函数
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Emulating Numeric Types</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>前面讲了special method会提供类型in operator的功能,其实在python里面,连+ operator
都是使用special method完成的
</li>
<li>下面我们就来实现一个二维vector类,能够满足二维加减法,比如vector(2,4) + vector(2,1)
得到vector(4,5)
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">from</span> math <span style="color: #859900; font-weight: bold;">import</span> hypot


<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Vector</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, x=0, y=0<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">self</span>.x = x
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">self</span>.y = y

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__repr__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">'Vector(%r, %r)'</span> % <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.x, <span style="color: #859900; font-weight: bold;">self</span>.y<span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__abs__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> hypot<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.x, <span style="color: #859900; font-weight: bold;">self</span>.y<span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__bool__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">bool</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">abs</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__add__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, other<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">x</span> = <span style="color: #859900; font-weight: bold;">self</span>.x + other.x
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">y</span> = <span style="color: #859900; font-weight: bold;">self</span>.y + other.y
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> Vector<span style="color: #2aa198;">(</span>x, y<span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__mul__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, scalar<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> Vector<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.x * scalar, <span style="color: #859900; font-weight: bold;">self</span>.y * scalar<span style="color: #2aa198;">)</span>


<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">v1</span> = Vector<span style="color: #2aa198;">(</span>2, 4<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">v2</span> = Vector<span style="color: #2aa198;">(</span>2, 1<span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>v1 + v2<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">v</span> = Vector<span style="color: #2aa198;">(</span>3, 4<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">abs</span><span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>v * 3<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">abs</span><span style="color: #b58900;">(</span>v * 3<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>


<span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">__name__</span> == <span style="color: #2aa198;">'__main__'</span>:
<span style="background-color: #eee8d5;"> </span>   main<span style="color: #2aa198;">()</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Vector(4, 5)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">5.0</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Vector(9, 12)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">15.0</span>
</pre>
</div>
</li>
<li>注意,我们的例子除了__init__以外,实现了四个special method,但是在main()函数
里面,没有主动调用过一次
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">String Representation</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>__repr__这个special method的用法,比较基础,就是内置的repr()函数会调用它,这个
repr()函数是干啥的呢,这个函数是返回某个instance的名字给"解释器"看的,因为是
给解释器看的,所以唯一的要求就是要"独一无二"让解释器不会认错人
</li>
<li>其实你不实现__repr__也没事的,"解释器"会自己生成一个,让repr唯一的办法就是使
用内存地址,所以不实现__repr__的结果就是会出现类似&lt;Vector object ax 0x10e100070&gt;
这种结果
</li>
<li>我们上面对__repr__的实现使用了%r来表现我们的attribute,就是对repr使用的一种
"清醒认识",因为只有使用repr,才能区分出Vector(1, 2)和Vector('1', '2')
</li>
<li>__str__也是存在的,会被str()调用,不同的是str()是给用户看的,而repr()是给机器
看的.
</li>
<li>如果你指向实现__str__和__repr__里面的一个,那么请实现后者.因为在找不到__str__
的情况下,str()会去调用__repr__
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Arithmetic Operators</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>前面我们实现了两个运算符的special method:
<ul class="org-ul">
<li>__add__被+ operator调用
</li>
<li>__mul__被* operator调用
</li>
</ul>
</li>
<li>需要注意的是,我们的运算符special method都是返回了新的instance,而没有改动
"参与计算"的其他instance,比如self和other,这是和运算函数的预期相同的
</li>
<li>还是需要注意的是,我们支持 vector * 3这种运算,但是不支持 3 * vector,这不符合
乘法的交换律,这需要到13章的__rmul__来解决
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">Boolean Value of Custom Type</h4>
<div class="outline-text-4" id="text-1-2-4">
<ul class="org-ul">
<li>虽然Python自己有bool type,但是在需要boolean的情形中,它却允许所有的object,这
点和java不一样,但是和c却是一样的.
</li>
<li>如果我们想知道任何一个object是会被认为是true还是false,我们需要bool(x)
</li>
<li>除非__bool__或者__len__被实现,否则,我们会认为user-defined的class是True:
<ul class="org-ul">
<li>如果__bool__实现了的话bool(x)返回__bool__的值
</li>
<li>如果__len__实现了的话,__len__ 的值为0的话,bool(x)为False
</li>
</ul>
</li>
<li>我们的__bool__实现非常简单,判断绝对值是否为0
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__bool__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">bool</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">abs</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Overview of Special Methods</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>常见的special method一共有83种,其中
<ul class="org-ul">
<li>47种用来实现各种operator
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">category</td>
<td class="left">Method names and related operators</td>
</tr>

<tr>
<td class="left">Unary numeric operators</td>
<td class="left">__neg__-,__pos__+,__abs__abs()</td>
</tr>

<tr>
<td class="left">Rich comparison operators</td>
<td class="left">__lt__&gt;,__le__&lt;=,__eq__==,__ne__!=,__gt__&gt;,__ge__&gt;=</td>
</tr>

<tr>
<td class="left">Arithmetic operators</td>
<td class="left">__add__+,__sub__-,__mul__*,__truediv__/,__floordiv__//,__mod__%,</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">__divmod__divmod(),__pow__**,__round_round()</td>
</tr>

<tr>
<td class="left">Reversed arithmetic operators</td>
<td class="left">__radd__,__rsub__,__rmul__,__rtruediv__,__rfloordiv__,__rmod__,</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">__rdivmod__,__rpow__</td>
</tr>

<tr>
<td class="left">Augmented assignment arithmetic operators</td>
<td class="left">__iadd__,__isub__,__imul__,__itruediv__,__ifloordiv__,__imod__,</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">__ipow__</td>
</tr>

<tr>
<td class="left">Bitwise operators</td>
<td class="left">__invert__~,__lshift__<a id="__rshift__" name="__rshift__"></a>,__and__&amp;amp;,__or__!,__xor__^</td>
</tr>

<tr>
<td class="left">Reversed bitwise operators</td>
<td class="left">__rlshift__, __rrshift__, __rand__, __rxor__, __ror__</td>
</tr>

<tr>
<td class="left">Augmented assignment bitwise operators</td>
<td class="left">__ilshift__, __irshift__, __iand__, __ixor__, __ior__</td>
</tr>
</tbody>
</table>
</li>
<li>36种用来表示非operator
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">category</th>
<th scope="col" class="left">Method names(operators excluded)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">String/bytes representation</td>
<td class="left">__repr__, __str__, __format__, bytes__</td>
</tr>

<tr>
<td class="left">Conversiont to number</td>
<td class="left">__abs__, __bool__, __complex__,__int__,</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">__float__,__hash__,__index__</td>
</tr>

<tr>
<td class="left">Emulating collections</td>
<td class="left">__len__,__getitem__,__setitem__,__delitem__,__contains__</td>
</tr>

<tr>
<td class="left">Iteration</td>
<td class="left">__iter__,__reversed__,__next__</td>
</tr>

<tr>
<td class="left">Emulating callables</td>
<td class="left">__call__</td>
</tr>

<tr>
<td class="left">Context management</td>
<td class="left">__enter__,__exit__</td>
</tr>

<tr>
<td class="left">Instance creation and destruction</td>
<td class="left">__new__,__init__,__del__</td>
</tr>

<tr>
<td class="left">Attribute management</td>
<td class="left">__getattr__,__getattribute__,__setattr__,__delattr__,__dir__</td>
</tr>

<tr>
<td class="left">Attribute descriptors</td>
<td class="left">__get__,__set__,__delete__</td>
</tr>

<tr>
<td class="left">Class services</td>
<td class="left">__prepare__,__instancecheck__,__subclasscheck__</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Why Len Is Not a Method</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>len被实现成了special method,而不是作为一个普通的method,通过object.len来调用
显然object.len的样式更加的"OO",但是python毕竟不是ruby,对于python来说实用性
比纯洁性更重要
<pre class="example">
practicality beats purity
</pre>
</li>
<li>对python来说len(x)的设计更加的"实用",因为len()是被频繁调用的模块,python把它
设计成special method以后,可以使用比method call更加经济的方式来调用它&#x2013;直接
读取struct的length field
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 02: An Array of Sequences</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Overview of Built-In Sequences</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>python std提供了一系列丰富的sequence types,它们都是使用C来实现的
</li>
<li>从container成员的类型来区分可以分成两类:
<ul class="org-ul">
<li>Container sequences:因为存储的是reference,所以可以存储一系列不同类型的成员:
<ol class="org-ol">
<li>list
</li>
<li>tuple
</li>
<li>collections.deque
</li>
</ol>
</li>
<li>Flat sequences:因为是把成员数据value(不是reference),所以存储的成员类型必须
一致
<ol class="org-ol">
<li>str
</li>
<li>bytes
</li>
<li>bytearray
</li>
<li>memoryview
</li>
<li>array.array
</li>
</ol>
</li>
</ul>
</li>
<li>从成员的是否mutable,也可以分成两类:
<ul class="org-ul">
<li>成员可变的:list,bytearray,array.array,collections.deque,memoryview
</li>
<li>成员不可变的:tuple,str,bytes
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">List Comprehensions and Generator Expressions</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>这个题目看起来有点难以理解,因为它说的是两种"快速而优雅"的创建sequence的方法:
<ul class="org-ul">
<li>如果最终的sequence是list的话,我们可以使用list comprehension(简称listcomps)
</li>
<li>如果最终的sequence是出来list以外的sequence的话,我们就使用generator
expression(简称genexps)
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">List Comprehensions and Readability</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>先来看一个不使用listcomps的例子
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'abcde'</span>
<span style="color: #268bd2;">codes</span> = <span style="color: #2aa198;">[]</span>
<span style="color: #859900; font-weight: bold;">for</span> symbol <span style="color: #859900; font-weight: bold;">in</span> symbols:
<span style="background-color: #eee8d5;"> </span>   codes.append<span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #b58900;">(</span>symbol<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>codes<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[97, 98, 99, 100, 101]</span>
</pre>
</div>
</li>
<li>看起来也没有那么麻烦,只不过python可以更简略,可以把codes的声明和赋值在一行
搞定,这就是所谓的list comprehension(listcomps)
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'abcde'</span>
<span style="color: #268bd2;">codes</span> = <span style="color: #2aa198;">[</span><span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #b58900;">(</span>symbol<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> symbol <span style="color: #859900; font-weight: bold;">in</span> symbols<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>codes<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[97, 98, 99, 100, 101]</span>
</pre>
</div>
</li>
<li>listcomps的优点不仅仅在于其短了一行,还在于其语意的唯一性:listcomps就是用来
初始化一个新的list的,而第一种方法里面的for loop却可能有很多种用途,这里只不
过是使用了第一种用途:初始化
</li>
<li>这也给我们提了醒,listcomps应该永远只用在初始化list的时候,而且同时我们要去
listcomps应该不能超过一行,超过一行的话,从可读性的角度,还是使用for循环比较好
</li>
<li>既然说到了跨行,那再多说一句,在python的[], {}, ()里面, line break是被ignore的
<pre class="example">
In Python code, line breaks are ignored inside pairs of [], {}, or ().
So you can build multiline lists, listcomps, genexps, dictionaries and
the like without using the ugly \ line continuation escape.
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">Listcomps Versus map and filter</h4>
<div class="outline-text-4" id="text-2-2-2">
<ul class="org-ul">
<li>在创建新list这个功能上面listcomps肯定是最好的选择,虽然funtional的filter和
map也可以起到同样的作用,但是显然它们太麻烦了:
<ul class="org-ul">
<li>麻烦的filter+map.其中filter函数的原型是filter(function, iterable),对iterable
里面的所有成员调用function,返回true的组成一个新的iterable返回.map的函数原
型就简单了map(function, iterable),对所有的iterable调用function.所以我们
函数式的创建一个list的代码如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'$&#162;&#163;&#165;&#8364;&#164;'</span>
<span style="color: #268bd2;">beyond_ascii</span> = <span style="color: #657b83; font-weight: bold;">list</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">filter</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">lambda</span> c: c &gt; 127, <span style="color: #657b83; font-weight: bold;">map</span><span style="color: #268bd2;">(</span><span style="color: #657b83; font-weight: bold;">ord</span>, symbols<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>beyond_ascii<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[162, 163, 165, 8364, 164]</span>
</pre>
</div>
</li>
<li>而listcomps的代码肯定简单的多啦
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'$&#162;&#163;&#165;&#8364;&#164;'</span>
<span style="color: #268bd2;">beyond_ascii</span> = <span style="color: #2aa198;">[</span><span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> s <span style="color: #859900; font-weight: bold;">in</span> symbols <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span> &gt; 127<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>beyond_ascii<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[162, 163, 165, 8364, 164]</span>
</pre>
</div>
</li>
</ul>
</li>
<li>而且更重要的是listcomps的效率并不比"函数式方法"的差
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">Cartesian Products</h4>
<div class="outline-text-4" id="text-2-2-3">
<ul class="org-ul">
<li>笛卡尔积,这个题目比较吓人,其实就是全排列,我们来看看笛卡尔积的定义
<pre class="example">
假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为
{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}
</pre>
</li>
<li>我们用一个例子来理解下笛卡尔积,比如我们要做T恤,有两种颜色和三种大小的T恤,所
以最常见的使用for循环来初始化的方法如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">colors</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'black'</span>, <span style="color: #2aa198;">'white'</span><span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">sizes</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'S'</span>, <span style="color: #2aa198;">'M'</span>, <span style="color: #2aa198;">'L'</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">for</span> color <span style="color: #859900; font-weight: bold;">in</span> colors:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">for</span> size <span style="color: #859900; font-weight: bold;">in</span> sizes:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>color, size<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('black', 'S')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('black', 'M')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('black', 'L')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'S')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'M')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'L')</span>
</pre>
</div>
</li>
<li>如果使用listcomps,会是一种更加简洁的写法
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">colors</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'black'</span>, <span style="color: #2aa198;">'white'</span><span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">sizes</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'S'</span>, <span style="color: #2aa198;">'M'</span>, <span style="color: #2aa198;">'L'</span><span style="color: #2aa198;">]</span>

<span style="color: #268bd2;">tshirts</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">(</span>color, size<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> color <span style="color: #859900; font-weight: bold;">in</span> colors <span style="color: #859900; font-weight: bold;">for</span> size <span style="color: #859900; font-weight: bold;">in</span> sizes<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tshirts<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[('black', 'S'), ('black', 'M'), ('black', 'L'),</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'S'), ('white', 'M'), ('white', 'L')]</span>
</pre>
</div>
</li>
<li>listcomps的优势还在于可以在[]内部进行换行提高可读性
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">colors</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'black'</span>, <span style="color: #2aa198;">'white'</span><span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">sizes</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'S'</span>, <span style="color: #2aa198;">'M'</span>, <span style="color: #2aa198;">'L'</span><span style="color: #2aa198;">]</span>

<span style="color: #268bd2;">tshirts</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">(</span>color, size<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> size <span style="color: #859900; font-weight: bold;">in</span> sizes
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>  <span style="color: #859900; font-weight: bold;">for</span> color <span style="color: #859900; font-weight: bold;">in</span> colors<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tshirts<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[('black', 'S'), ('white', 'S'), ('black', 'M'),</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">('white', 'M'), ('black', 'L'), ('white', 'L')]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4">Generator Expressions</h4>
<div class="outline-text-4" id="text-2-2-4">
<ul class="org-ul">
<li>如果想初始化tuple, array或者其他类型的sequence,你当然可以先使用listcomps初
始化一个list,然后在作为ctor的参赛来初始化一个sequence,比如tuple
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">t_from_l</span> = <span style="color: #657b83; font-weight: bold;">tuple</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[</span>n <span style="color: #859900; font-weight: bold;">for</span> n <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #268bd2;">(</span>5<span style="color: #268bd2;">)</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>t_from_l<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">(0, 1, 2, 3, 4)</span>
</pre>
</div>
</li>
<li>但这样做代价太大,因为某个"临时的list",其主要作用,就是用来初始化另外一个sequence
</li>
<li>最经济的创建非list sequence的方法就是generator expression(genexp).
</li>
<li>从样子上来看,你肯定可以发现genexp其实就是"去掉中括号"的listcomps:
<ul class="org-ul">
<li>listcomp:
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'abcde'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[</span><span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #268bd2;">(</span>symbol<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">for</span> symbol <span style="color: #859900; font-weight: bold;">in</span> symbols<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[97, 98, 99, 100, 101]</span>
</pre>
</div>
</li>
<li>genexp for tuple:
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'abcde'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">tuple</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #268bd2;">(</span>symbol<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">for</span> symbol <span style="color: #859900; font-weight: bold;">in</span> symbols<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">(97, 98, 99, 100, 101)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>在上面的例子中tuple()这个ctor只有一个参数,所以我们的genexp是"去掉中括号"的
listcomps,如果某个sequence的ctor有两个参数,那么我们的genexp就是"去掉中括号
换上小括号"的listcomps
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> array
<span style="color: #268bd2;">symbols</span> = <span style="color: #2aa198;">'abcde'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>array.array<span style="color: #b58900;">(</span><span style="color: #2aa198;">'I'</span>, <span style="color: #268bd2;">(</span><span style="color: #657b83; font-weight: bold;">ord</span><span style="color: #6c71c4;">(</span>symbol<span style="color: #6c71c4;">)</span> <span style="color: #859900; font-weight: bold;">for</span> symbol <span style="color: #859900; font-weight: bold;">in</span> symbols<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">array('I', [97, 98, 99, 100, 101])</span>
</pre>
</div>
</li>
<li>genexp相比于传统的for循环也有优势,比如前面我们使用两层for循环来打印T恤代码
如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">colors</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'black'</span>, <span style="color: #2aa198;">'white'</span><span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">sizes</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'S'</span>, <span style="color: #2aa198;">'M'</span>, <span style="color: #2aa198;">'L'</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">for</span> color <span style="color: #859900; font-weight: bold;">in</span> colors:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">for</span> size <span style="color: #859900; font-weight: bold;">in</span> sizes:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>color, size<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('black', 'S')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('black', 'M')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('black', 'L')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'S')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'M')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('white', 'L')</span>
</pre>
</div>
</li>
<li>上述做法没有什么不对,但是所有的成员都是先存储在内存里面,然后让print读取的,
如果笛卡尔积的个数比较大(比如各有1000个成员),那么讲使用非常大一块内存.genexp
就能够解决这个问题,因为genexp是每次生成一个就传递给print
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">colors</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'black'</span>, <span style="color: #2aa198;">'white'</span><span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">sizes</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'S'</span>, <span style="color: #2aa198;">'M'</span>, <span style="color: #2aa198;">'L'</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">for</span> tshirt <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #2aa198;">(</span><span style="color: #2aa198;">'%s %s'</span> % <span style="color: #b58900;">(</span>c, s<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> c <span style="color: #859900; font-weight: bold;">in</span> colors <span style="color: #859900; font-weight: bold;">for</span> s <span style="color: #859900; font-weight: bold;">in</span> sizes<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tshirt<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">black S</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">black M</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">black L</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">white S</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">white M</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">white L</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Tuples Are Not Just Immutable Lists</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>很多的python入门教材都会把tuple描述成"immutable list",但是这只是tuple两个重
要特性中的一个,另外一个重要的特性是:records with no field names
</li>
</ul>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Tuples as Records</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>tuple的成员可以看成是record,但是要从一个抽象的维度去看:
<ul class="org-ul">
<li>首先tuple的成员每个都是可以看成是这个record的field
</li>
<li>每个tuple的成员还有一个position,这个potion也会给予它特殊的意义,虽然这个意
义不像filed name那么好,但也总算是有个区别
</li>
</ul>
</li>
<li>如果仅仅把tuple看成是immutable list的话,那么其成员的个数,和每个成员的position
是不重要的,但是你要是把tuple看成是record的话,这两者就都非常重要啦
</li>
<li>我们来看看下面的例子,下面例子中的position都有其确定的意义,更改每个tuple里面
成员的位置都会是破坏性的
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">lax_coordinates</span> = <span style="color: #2aa198;">(</span>33.9425, -118.408056<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">city</span>, <span style="color: #268bd2;">year</span>, <span style="color: #268bd2;">pop</span>, <span style="color: #268bd2;">chg</span>, <span style="color: #268bd2;">area</span> = <span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Tokyo'</span>, 2003, 32450, 0.66, 8014<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">traveler_ids</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">'USA'</span>, <span style="color: #2aa198;">'31195855'</span><span style="color: #b58900;">)</span>,
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #b58900;">(</span><span style="color: #2aa198;">'BAR'</span>, <span style="color: #2aa198;">'CE342567'</span><span style="color: #b58900;">)</span>, <span style="color: #b58900;">(</span><span style="color: #2aa198;">'ESP'</span>, <span style="color: #2aa198;">'XDA205856'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">for</span> passport <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">sorted</span><span style="color: #2aa198;">(</span>traveler_ids<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'%s/%s'</span> % passport<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">for</span> country, _ <span style="color: #859900; font-weight: bold;">in</span> traveler_ids:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>country<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">BAR/CE342567</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">ESP/XDA205856</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">USA/31195855</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">USA</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">BAR</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">ESP</span>
</pre>
</div>
</li>
<li>我们在这个例子里面可以看到,python和tuple相处的特别好:
<ul class="org-ul">
<li>% 可以理解tuple,并且知道把tuple"展开"来使用
</li>
<li>for也知道每一次循环的时候,把tuple"展开"返回
</li>
</ul>
</li>
<li>python能够理解tuple的原因,在于tuple unpacking mechanism
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Tuple Unpacking</h4>
<div class="outline-text-4" id="text-2-3-2">
<ul class="org-ul">
<li>tuple unpacking最常见的地方是parallel assignment:也就是把一个iterable的值
赋给a tuple of variable:
<ul class="org-ul">
<li>把iterable赋给tuple of variable,那么等号右边肯定是iterable(这里是list),
左边肯定是tuple of varialb
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span>1, 2<span style="color: #2aa198;">]</span>
<span style="color: #2aa198;">(</span>b, c<span style="color: #2aa198;">)</span> = a
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
</pre>
</div>
</li>
<li>只要是iterable就可以,那么其实等号的右边也肯定是tuple,只不过是tuple付给tuple
啦
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">(</span>1, 2<span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">(</span>b, c<span style="color: #2aa198;">)</span> = a
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
</pre>
</div>
</li>
<li>左边的tuple可以其实不用加括号,那就转化成了我们最常见的tuple unpacking:一
个陌生的iterable变量返回给N个值给一个"去掉括号的tuple"
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">(</span>1, 2<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">b</span>, <span style="color: #268bd2;">c</span> = a
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
</pre>
</div>
</li>
<li>如果右边是"纯"的tuple的话,那么右边其实也不用括号,这就转换成了我们常见的
swapping the values of variables without using a temporary variable
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = 1
<span style="color: #268bd2;">b</span> = 2

<span style="color: #268bd2;">b</span>, <span style="color: #268bd2;">a</span> = a, b
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
</pre>
</div>
</li>
<li>当tuple作为函数的参数的时候,你必须在传参的时候,明确的告诉function,tuple
的成员要"展开"使用,否则函数是不知道你要怎样使用的.明确"展开"tuple的方法是
在tuple前面加一个*
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">foo</span><span style="color: #2aa198;">(</span>a, b=<span style="color: #2aa198;">'not set'</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>


foo<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>1, 2<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
foo<span style="color: #2aa198;">(</span>*<span style="color: #b58900;">(</span>1, 2<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">(1, 2)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">not set</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
</pre>
</div>
</li>
<li>函数的返回值其实也就是一个变量,如果函数的返回值是一个iterable的话,那么肯
定可以是可以利用tuple unpacking把结果传递给多个参数的
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">foo</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">[</span>1, 2<span style="color: #2aa198;">]</span>


<span style="color: #268bd2;">a</span>, <span style="color: #268bd2;">b</span> = foo<span style="color: #2aa198;">()</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
</pre>
</div>
</li>
<li>函数返回值有时候返回了很多的信息,但是我们不是对所有信息都有兴趣,那么我可
以使用variable `_`(注意`_`也是一个变量,这和golang里面是不一样的)来作为
placeholder
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">foo</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">[</span>1, 2, 3<span style="color: #2aa198;">]</span>


<span style="color: #268bd2;">_</span>, <span style="color: #268bd2;">a</span>, <span style="color: #268bd2;">_</span> = foo<span style="color: #2aa198;">()</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>_<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">3</span>
</pre>
</div>
</li>
<li>有时候我们不确定有多少的返回值，或者说我们希望把某些“连续”的返回值存储在
同一个list里面.这个时候,还是用*来提醒python解释器,把"剩下的"都以list的形
式都装到某个变量里面
<div class="org-src-container">

<pre class="src src-python">a, b, *<span style="color: #268bd2;">rest</span> = <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>5<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a, b, rest<span style="color: #2aa198;">)</span>
a, b, *<span style="color: #268bd2;">rest</span> = <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>3<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a, b, rest<span style="color: #2aa198;">)</span>
a, b, *<span style="color: #268bd2;">rest</span> = <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a, b, rest<span style="color: #2aa198;">)</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">0 1 [2, 3, 4]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">0 1 [2]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">0 1 []</span>
</pre>
</div>
</li>
<li>*prefix出现且只能出现一次,但是并不一定是在最后,还是可以在其他位置的
<div class="org-src-container">

<pre class="src src-python">a, *<span style="color: #268bd2;">body</span>, <span style="color: #268bd2;">c</span>, <span style="color: #268bd2;">d</span> = <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>5<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a, body, c, d<span style="color: #2aa198;">)</span>
*<span style="color: #268bd2;">head</span>, <span style="color: #268bd2;">b</span>, <span style="color: #268bd2;">c</span>, <span style="color: #268bd2;">d</span> = <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>5<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>head, b, c, d<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">0 [1, 2] 3 4</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, 1] 2 3 4</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3">Nested Tuple Unpacking</h4>
<div class="outline-text-4" id="text-2-3-3">
<ul class="org-ul">
<li>tuple unpacking更智能一步的可以让我们的receiver tuple nested(当然也就意味着
提供tuple的iterable也是nested的)
<div class="org-src-container">

<pre class="src src-python">a, <span style="color: #2aa198;">(</span>b1, b2<span style="color: #2aa198;">)</span>, <span style="color: #268bd2;">c</span> = <span style="color: #2aa198;">[</span>1, <span style="color: #b58900;">[</span>2, 3<span style="color: #b58900;">]</span>, 4<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b1<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b2<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">3</span>
</pre>
</div>
</li>
<li>值得注意的是,在python2里面,函数的参数在定义的时候,是允许使用nested tuple的
换句话说,如下的函数定义在python2里面是合法的
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">fn</span><span style="color: #2aa198;">(</span>a, <span style="color: #b58900;">(</span>b, c<span style="color: #b58900;">)</span>, d<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">pass</span>
</pre>
</div>
</li>
<li>但是从python3开始,这种定义方法变得非法了PEP3113详细说明了原因
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-4" class="outline-4">
<h4 id="sec-2-3-4">Named Tuples</h4>
<div class="outline-text-4" id="text-2-3-4">
<ul class="org-ul">
<li>tuple的position(0, 1, 2, 3等)为tuple成员value提供了一个比较"模糊"的name,但
是在调试的时候,这个name往往不容易辨识,所以python后来又提供了collections.namedtuple
你可以认为这是一个带name的tuple
</li>
<li>collections.namedtuple的实现方法比较独特(主要是为了节省内存):namedtuple返回
一个tuple的subclass(通过工厂模式),但是带有名字,名字存在了class里面,所以一
个namedtuple instance和一个普通的tuple instance的内存大小是一样的
</li>
<li>一个namedtuple的例子如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">from</span> collections <span style="color: #859900; font-weight: bold;">import</span> namedtuple

<span style="color: #268bd2;">City</span> = namedtuple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'City'</span>, <span style="color: #2aa198;">'name country population coordinates'</span><span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">tokyo</span> = City<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Tokyo'</span>, <span style="color: #2aa198;">'JP'</span>, 36.933, <span style="color: #b58900;">(</span>35.689722, 139.691667<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tokyo<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tokyo.population<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tokyo.coordinates<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>tokyo<span style="color: #b58900;">[</span>1<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667))</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">36.933</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">(35.689722, 139.691667)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">JP</span>
</pre>
</div>
</li>
<li>可以看到,我们的namedtuple的返回值是一个新的class,namedtuple的参数有两个:
<ul class="org-ul">
<li>第一个是class的名字
</li>
<li>第二个是一个"空格分割"的字符串,来描述每个域.当然了从前面的例子中我们可以
看到,第二个参数还可以是一个字符串数组
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">Card</span> = collections.namedtuple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Card'</span>, <span style="color: #b58900;">[</span><span style="color: #2aa198;">'rank'</span>, <span style="color: #2aa198;">'suit'</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>另外所有的namedtuple class,都会有如下三个属性:
<ul class="org-ul">
<li>_fields: 就是named tuple所有的name
</li>
<li>_make(): 使用iterable来初始化某个named tuple
</li>
<li>_asdict(): 主要返回利于打印的数据格式
</li>
</ul>
</li>
<li>三个属性的例子如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">from</span> collections <span style="color: #859900; font-weight: bold;">import</span> namedtuple

<span style="color: #268bd2;">City</span> = namedtuple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'City'</span>, <span style="color: #2aa198;">'name country population coordinates'</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>City._fields<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">LatLong</span> = namedtuple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'LatLong'</span>, <span style="color: #2aa198;">'lat long'</span><span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">delhi_data</span> = <span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Delhi NCR'</span>, <span style="color: #2aa198;">'IN'</span>, 21.935, LatLong<span style="color: #b58900;">(</span>28.613889, 77.208889<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">delhi</span> = City._make<span style="color: #2aa198;">(</span>delhi_data<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>delhi<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">for</span> key, value <span style="color: #859900; font-weight: bold;">in</span> delhi._asdict<span style="color: #2aa198;">()</span>.items<span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>key + <span style="color: #2aa198;">":"</span>, value<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('name', 'country', 'population', 'coordinates')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">City(name='Delhi NCR', country='IN', population=21.935, coordinates=LatLong(lat=28.613889, long=77.208889))</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">name: Delhi NCR</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">country: IN</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">population: 21.935</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">coordinates: LatLong(lat=28.613889, long=77.208889)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-5" class="outline-4">
<h4 id="sec-2-3-5">Tuples as Immutable lists</h4>
<div class="outline-text-4" id="text-2-3-5">
<ul class="org-ul">
<li>另外,tuple实现了所有的list的函数,除了能更改成员数目的函数,比如add, remove等
</li>
<li>tuple没有实现__reverse__,但是这也只是由于为了提高性能,我们可以使用reverse(tuple)
来替代
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span>1, 2, 3<span style="color: #2aa198;">]</span>
a.reverse<span style="color: #2aa198;">()</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>

<span style="color: #268bd2;">b</span> = <span style="color: #2aa198;">(</span>1, 2, 3<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">b</span> = <span style="color: #657b83; font-weight: bold;">tuple</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">reversed</span><span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[3, 2, 1]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">(3, 2, 1)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Slicing</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>一个list,tuple,str乃至所有的sequence type都有的特性,就是slice操作.这个操作
非常有用,甚至影响了其他语言的设计,比如golang
</li>
</ul>
</div>
<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1">Why Slices and Range Exclude the Last Item</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li>许多语言,比如c和python里面的数组和其他sequence,都使用zero-based的方式来处理.
这样做有很多优点:
<ul class="org-ul">
<li>当只提供stop的时候,可以很容易的知道一个slice的长度,比如my_list[:3]就知道
有三个成员.range(3)也是一样的道理
</li>
<li>当同时提供了stop和start的时候,通过stop-start就知道了成员的个数,比如
my_list[1:3]就是两个成员
</li>
<li>把一个sequence分成两个的时候,不容易overlap
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">l</span> = <span style="color: #2aa198;">[</span>10, 20, 30, 40, 50, 60<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #b58900;">[</span>:2<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #b58900;">[</span>2:<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #b58900;">[</span>:3<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #b58900;">[</span>3:<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[10, 20]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[30, 40, 50, 60]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[10, 20, 30]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[40, 50, 60]</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2">Slice Objects</h4>
<div class="outline-text-4" id="text-2-4-2">
<ul class="org-ul">
<li>slice容易被人忽视的还在于它可以在start,stop之后拥有一个step选项,用来确定skip
的成员的书面,也就是s[start:stop:step]
</li>
<li>step的时候,总是会包含第一个成员,而且step的数目是包括当前的成员的,例子如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">'1234567'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>s<span style="color: #b58900;">[</span>::3<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">147</span>
</pre>
</div>
</li>
<li>step还可以是负数,那么就是总是包含最后一个成员,从后面开始.
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">'1234567'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>s<span style="color: #b58900;">[</span>::-2<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">7531</span>
</pre>
</div>
</li>
<li>step如果是-1的话,会有特殊效果,那就是"翻转"sequence
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">'1234567'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>s<span style="color: #b58900;">[</span>::-1<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">7654321</span>
</pre>
</div>
</li>
<li>[start:stop:step]这种方式只有在[]里面(并且这个[]是index或者subscript作用的
时候),才起作用:这种情况下[start:stop:step]会生成一个slice(start, stop, step)
object.
</li>
<li>而我们的seq[strt:stop:step]在evaluate的时候,会调用special method__getitem__
像是这样
<div class="org-src-container">

<pre class="src src-python">seq.__getitem__<span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">slice</span><span style="color: #b58900;">(</span>start, stop, step<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>这是我们第一次遇到slice object,其实slice object非常的有用,它能够有自己的名
字,就像excel表格里面的行和列一样,下面来介绍一个slice的应用
</li>
<li>假设我们有如下的发票信息,我们只希望优美的打印发票信息中的某两列信息(比如最
重要是产品说明个单价),怎么办呢?
<pre class="example">
0.....6.................................40........52...55........
1909  Pimoroni PiBrella                     $17.50    3    $52.50
1489  6mm Tactile Switch x20                 $4.95    2     $9.90
1510  Panavise Jr. - PV-201                 $28.00    1    $28.00
1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95
</pre>
</li>
<li>办法就是使用slice来命名这些行(也就是string),打印的时候,可以按照我们的需要
打印对应的列就可以了
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">invoice</span> = <span style="color: #2aa198;">"""</span>
<span style="color: #2aa198;">0.....6.................................40........52...55........</span>
<span style="color: #2aa198;">1909  Pimoroni PiBrella                     $17.50    3    $52.50</span>
<span style="color: #2aa198;">1489  6mm Tactile Switch x20                 $4.95    2     $9.90</span>
<span style="color: #2aa198;">1510  Panavise Jr. - PV-201                 $28.00    1    $28.00</span>
<span style="color: #2aa198;">1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95</span>
<span style="color: #2aa198;">"""</span>

<span style="color: #268bd2;">SKU</span>         = <span style="color: #657b83; font-weight: bold;">slice</span><span style="color: #2aa198;">(</span>0,  6<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">DESCRIPTION</span> = <span style="color: #657b83; font-weight: bold;">slice</span><span style="color: #2aa198;">(</span>6,  40<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">UNIT_PRICE</span>  = <span style="color: #657b83; font-weight: bold;">slice</span><span style="color: #2aa198;">(</span>40, 52<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">QUANTITY</span>    = <span style="color: #657b83; font-weight: bold;">slice</span><span style="color: #2aa198;">(</span>52, 55<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">ITEM_TOTAL</span>  = <span style="color: #657b83; font-weight: bold;">slice</span><span style="color: #2aa198;">(</span>55, <span style="color: #268bd2; font-weight: bold;">None</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">for</span> item <span style="color: #859900; font-weight: bold;">in</span> invoice.split<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'\n'</span><span style="color: #2aa198;">)[</span>2:-1<span style="color: #2aa198;">]</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>item<span style="color: #b58900;">[</span>UNIT_PRICE<span style="color: #b58900;">]</span>.strip<span style="color: #b58900;">()</span>, item<span style="color: #b58900;">[</span>DESCRIPTION<span style="color: #b58900;">]</span>.strip<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('$17.50', 'Pimoroni PiBrella')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('$4.95', '6mm Tactile Switch x20')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('$28.00', 'Panavise Jr. - PV-201')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('$34.95', 'PiTFT Mini Kit 320x240')</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3">Multidimensional Slicing and Ellipsis</h4>
<div class="outline-text-4" id="text-2-4-3">
<ul class="org-ul">
<li>在numpy这个package里面,[]operator也是可以接受使用逗号分隔的index的,比如
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> numpy
<span style="color: #268bd2;">a</span> = numpy.arange<span style="color: #2aa198;">(</span>12<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">a.shape</span> = 3, 4
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #b58900;">[</span>2, 1<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[[ 0  1  2  3]</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">[ 4  5  6  7]</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">[ 8  9 10 11]]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">9</span>
</pre>
</div>
</li>
<li>但是built-in的sequence type在python里面确实是只有一维的(one-dimensional)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-4" class="outline-4">
<h4 id="sec-2-4-4">Assigning to Slices</h4>
<div class="outline-text-4" id="text-2-4-4">
<ul class="org-ul">
<li>如果一个sequence是mutable的,那么这个sequence的slice用法可以放在赋值语句的
左边,作为receiver.注意,这个receiver的区间的长度,甚至可能和右边值的长度不一
样.但是右边必须也得是iterable object,即便只有一个item
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">l</span> = <span style="color: #657b83; font-weight: bold;">list</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">range</span><span style="color: #b58900;">(</span>10<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">l</span><span style="color: #2aa198;">[</span>2:5<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">[</span>20, 30<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">##########################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">TypeError: can only assign an iterable #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">l[2:5] = 100                           #</span>
<span style="color: #93a1a1;">##########################################</span>

<span style="color: #268bd2;">l</span><span style="color: #2aa198;">[</span>2:5<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">[</span>100<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, 1, 20, 30, 5, 6, 7, 8, 9]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, 1, 100, 6, 7, 8, 9]</span>
</pre>
</div>
</li>
<li>如果一个sequence是mutable的,那么这个sequence的slice用法也是可以放到del语句
后面的
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">l</span> = <span style="color: #657b83; font-weight: bold;">list</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">range</span><span style="color: #b58900;">(</span>10<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">del</span> l<span style="color: #2aa198;">[</span>2:5<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, 1, 5, 6, 7, 8, 9]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Using + and * with Sequences</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>sequence支持+operator和*operator:
<ul class="org-ul">
<li>对于+operator来说,两个操作数要求是同一个类型,否则相加不成功,结果返回一个
新的sequence,原来的两个操作数都不会被改动
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">l1</span> = <span style="color: #2aa198;">[</span>1, 2, 3<span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">l2</span> = <span style="color: #2aa198;">[</span>4, 5, 6<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l1 + l2<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l1<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l2<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[1, 2, 3, 4, 5, 6]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[1, 2, 3]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[4, 5, 6]</span>
</pre>
</div>
</li>
<li>对于乘法来说,操作数中一个为sequence,另外一个为整形,结果返回一个新的sequence
原来的两个操作数也都不会被改动
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">l1</span> = <span style="color: #2aa198;">[</span>1, 2, 3<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l1 * 2<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>2 * l1<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>l1<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[1, 2, 3, 1, 2, 3]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[1, 2, 3, 1, 2, 3]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[1, 2, 3]</span>
</pre>
</div>
</li>
</ul>
</li>
<li>对于a * n这种格式(其中n为整数,a为sequence),如果a的成员里面还有sequence,并且
a不是immutable的话,那么这种做法非常的危险,因为同一个list会有多个reference,
很多问题都会随之出现.
</li>
<li>下面就是一个常见的错误做法,此种做法的问题在于,最外层的list其实是三个reference,
而且这三个reference是指向的同一个list
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">[</span><span style="color: #2aa198;">'_'</span><span style="color: #b58900;">]</span> * 3<span style="color: #2aa198;">]</span> * 3
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
a<span style="color: #2aa198;">[</span>1<span style="color: #2aa198;">][</span>2<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">'0'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '0'], ['_', '_', '0'], ['_', '_', '0']]</span>
</pre>
</div>
</li>
<li>上面的做法其实是相当于如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">row</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'_'</span><span style="color: #2aa198;">]</span> * 3
<span style="color: #268bd2;">board</span> = <span style="color: #2aa198;">[]</span>
<span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>3<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   board.append<span style="color: #2aa198;">(</span>row<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>board<span style="color: #2aa198;">)</span>
board<span style="color: #2aa198;">[</span>1<span style="color: #2aa198;">][</span>2<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">'0'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>board<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '0'], ['_', '_', '0'], ['_', '_', '0']]</span>
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1">Building Lists of Lists</h4>
<div class="outline-text-4" id="text-2-5-1">
<ul class="org-ul">
<li>上面提到的这种创建list of list(nested list)的情况也是很常见的.常见的错误做
法我们也在上面做了举例了,正确的解法应该是使用list comprehension
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">[</span><span style="color: #2aa198;">'_'</span><span style="color: #b58900;">]</span> * 3 <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #b58900;">(</span>3<span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
a<span style="color: #2aa198;">[</span>1<span style="color: #2aa198;">][</span>2<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">'0'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '_'], ['_', '_', '0'], ['_', '_', '_']]</span>
</pre>
</div>
</li>
<li>上面正确的做法其实是相当于
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">board</span> = <span style="color: #2aa198;">[]</span>
<span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>3<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">row</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'_'</span><span style="color: #2aa198;">]</span> * 3
<span style="background-color: #eee8d5;"> </span>   board.append<span style="color: #2aa198;">(</span>row<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>board<span style="color: #2aa198;">)</span>
board<span style="color: #2aa198;">[</span>1<span style="color: #2aa198;">][</span>2<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">'0'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>board<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[['_', '_', '_'], ['_', '_', '0'], ['_', '_', '_']]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Augmented Assignment with Sequences</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>c里面开始就有的augmented assignment operators(比如+=, *=),其special method是
__iadd__
</li>
<li>但是__iadd__又不是非得要实现的,如果不实现__iadd__,那么会调用__add__先相加
得到一个tmp object,然后把这个tmp object会赋给第一个操作数,这样一来我们会多
一个中间对象.对于immutable sequence来说,这个中间对象是不可避免的,所以我们不
得不去忍受这个
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">t</span> = <span style="color: #2aa198;">(</span>1, 2, 3<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">id</span><span style="color: #b58900;">(</span>t<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">t</span> *= 2
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">id</span><span style="color: #b58900;">(</span>t<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">4319626152</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">4318489384</span>
</pre>
</div>
</li>
<li>但是对于mutable sequence来说,这个中间object是可以避免的,所以内置的list显然是
自己实现了__imul__
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">t</span> = <span style="color: #2aa198;">[</span>1, 2, 3<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">id</span><span style="color: #b58900;">(</span>t<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">t</span> *= 2
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">id</span><span style="color: #b58900;">(</span>t<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">4304217736</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">4304217736</span>
</pre>
</div>
</li>
<li>所以,如果你的类是mutable sequence,那么你肯定要自己实现一下__iadd__和__imul__
</li>
</ul>
</div>
<div id="outline-container-sec-2-6-1" class="outline-4">
<h4 id="sec-2-6-1">A += Assignment Puzzler</h4>
<div class="outline-text-4" id="text-2-6-1">
<ul class="org-ul">
<li>有一个关于+=非常著名的问题,下面的结果输出是什么
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">t</span> = <span style="color: #2aa198;">(</span>1, 2, <span style="color: #b58900;">[</span>30, 40<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #268bd2;">t</span><span style="color: #2aa198;">[</span>2<span style="color: #2aa198;">]</span> += <span style="color: #2aa198;">[</span>50, 60<span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
<li>选择题,四个选项是:
<ol class="org-ol">
<li>t becomes(1, 2, [30, 40, 50, 60])
</li>
<li>TypeError: 'tuple' object does not support item assignment
</li>
<li>Neither
</li>
<li>Both a and b
</li>
</ol>
</li>
<li>如果我们对python有点了解,就可以知道tuple是immutable的,所以,即便tuple的成员
自己本身是mutable的,但是我们不可以使用t[n]作为赋值的对象.所以了解到这点的
人都会选择b作为答案
</li>
<li>但真实的情况是a也是正确的,t获得了想要的新值,原因是什么呢?探求python机制的一
个方法是查看python的bytecode
<div class="org-src-container">

<pre class="src src-python">Python 3.6.1 <span style="color: #2aa198;">(</span>default, Mar 23 2017, 16:49:06<span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">[</span>GCC 4.2.1 Compatible Apple LLVM 8.0.0 <span style="color: #b58900;">(</span>clang-800.0.42.1<span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span> on darwin
Type <span style="color: #2aa198;">"help"</span>, <span style="color: #2aa198;">"copyright"</span>, <span style="color: #2aa198;">"credits"</span> <span style="color: #859900; font-weight: bold;">or</span> <span style="color: #2aa198;">"license"</span> <span style="color: #859900; font-weight: bold;">for</span> more information.
&gt;&gt;&gt; python.el: native completion setup loaded
&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">import</span> dis
&gt;&gt;&gt; dis.dis<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'s[a] += b'</span><span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span> 1           0 LOAD_NAME                0 <span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span> 2 LOAD_NAME                1 <span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span> 4 DUP_TOP_TWO
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span> 6 BINARY_SUBSCR
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span> 8 LOAD_NAME                2 <span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>10 INPLACE_ADD
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>12 ROT_THREE
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>14 STORE_SUBSCR
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>16 LOAD_CONST               0 <span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">None</span><span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>18 RETURN_VALUE
</pre>
</div>
</li>
<li>BINARY_SUBSCR这一步的意思,是把s[a]的值(这里是一个referenc)放到TOS(top of stack)
</li>
<li>INPLACE_ADD这一步的是做如下处理:TOS += b,TOS里面是我们[30, 40]的ref,这个是
一个mutable的object,所以TOS += b成功[30, 40]变成了[30, 40, 50, 60]
</li>
<li>STORE_SUBSCR这一步的意思就是s[a] = TOS,因为s是immutable的,所以TypeError
</li>
<li>从上面的例子中,我们也可以得到三条教训:
<ul class="org-ul">
<li>在tuple里面存储mutable item不是一个好的注意
</li>
<li>agumented assignment不是一个原子操作
</li>
<li>使用byte code是非常好的分析python错误的办法
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">list.sort and sorted Built-In Function</h3>
<div class="outline-text-3" id="text-2-7">
<ul class="org-ul">
<li>list.sort这个函数是in place的来排序list的,也就是说,没有使用额外的copy
</li>
<li>为了不让使用者误解(以为会返回一个新的object), list.sort的返回值是None,这也
成为了python API的一个重要的convention
<pre class="example">
Functions or methods that change an object in place should return
None to make it clear to the caller that the object itself was changed,
and no new object was created.
</pre>
</li>
<li>当然了,使用上面的convention也有缺点:那就是无法将method chain起来.
</li>
<li>和list.sort刚好相对的,就是built-in的sorted函数,这个函数不是in place的,所以
它返回一个新的object.因为有新的object返回,所以这个sorted可以使用immutable
sequence或者是generator来作为参数.
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">sorted</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>1, 3, 2, 4, 5<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">[</span>1, 2, 3, 4, 5<span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
<li>list.sort和sorted都可以接受两个额外的optional的参数:
<ul class="org-ul">
<li>reverse用来降序排列,默认值是False
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">l</span> = <span style="color: #2aa198;">[</span>1, 3, 2, 4, 5<span style="color: #2aa198;">]</span>
&gt;&gt;&gt; l.sort<span style="color: #2aa198;">(</span>reverse=<span style="color: #268bd2; font-weight: bold;">True</span><span style="color: #2aa198;">)</span>        <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">return None</span>
&gt;&gt;&gt; l
<span style="color: #2aa198;">[</span>5, 4, 3, 2, 1<span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
<li>key用来对每个成员调用函数后再排列
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">sorted</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"abc"</span>, <span style="color: #2aa198;">"defg"</span>, <span style="color: #2aa198;">"hi"</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">[</span><span style="color: #2aa198;">'abc'</span>, <span style="color: #2aa198;">'defg'</span>, <span style="color: #2aa198;">'hi'</span><span style="color: #2aa198;">]</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">sorted</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"abc"</span>, <span style="color: #2aa198;">"defg"</span>, <span style="color: #2aa198;">"hi"</span><span style="color: #b58900;">)</span>, key=<span style="color: #657b83; font-weight: bold;">len</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">[</span><span style="color: #2aa198;">'hi'</span>, <span style="color: #2aa198;">'abc'</span>, <span style="color: #2aa198;">'defg'</span><span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
</ul>
</li>
<li>一旦sequence变成sorted的,那么搜索起来就会快很多.python也为我们内置了二分搜索
的模块bisect
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">Managing Ordered Sequences with bisect</h3>
<div class="outline-text-3" id="text-2-8">
</div><div id="outline-container-sec-2-8-1" class="outline-4">
<h4 id="sec-2-8-1">Searching with bisect</h4>
<div class="outline-text-4" id="text-2-8-1">
<ul class="org-ul">
<li>bisect(haystack, needle) 其实就是在排序好的haystack上面使用二分法寻找needle
的position,这个position是什么意思呢?意思就是我们插入的haystack的位置.换句
话说我们bisect的返回值肯定是一个位置,而不会是-1
</li>
<li>返回值为-1的二分搜索法只存在于算法题中,现实生活中找不到某个element是没有意
义的,如果找到这个element,我们至少希望知道它如果插入到这个排序好的sequence里
面的话,位置是什么.换句话说这个返回值可以直接用到haystack.insert里面作为index
然后haystack还是sorted的
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span>1, 2, 3, 4<span style="color: #2aa198;">]</span>
&gt;&gt;&gt; bisect.bisect<span style="color: #2aa198;">(</span>a, 2.5<span style="color: #2aa198;">)</span>
2
&gt;&gt;&gt; a.insert<span style="color: #2aa198;">(</span>bisect.bisect<span style="color: #b58900;">(</span>a, 2.5<span style="color: #b58900;">)</span>, 2.5<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; a
<span style="color: #2aa198;">[</span>1, 2, 2.5, 3, 4<span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
<li>bisect还自带两个optional参数lo和hi,是指定的需要排序的个数lo默认是0,hi默认是
sequence的长度
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span>1, 2, 3, 4, 5<span style="color: #2aa198;">]</span>
&gt;&gt;&gt; bisect.bisect<span style="color: #2aa198;">(</span>a, 6, lo=0, hi=3<span style="color: #2aa198;">)</span>
3
&gt;&gt;&gt; bisect.bisect<span style="color: #2aa198;">(</span>a, 6<span style="color: #2aa198;">)</span>
5
</pre>
</div>
</li>
<li>实际上bisect.bisect的真名叫做bisect.bisect_right,它还有一个妹妹叫做bisect_left
两者的区别,只有在needle的数据和haystack里面的数据相同的情况下才能看出,区别
是pos,也就是插入的位置不同:
<ul class="org-ul">
<li>bisect_right,会返回一个pos,needle插入的话会排在所有"相同值"的最右边.这个
是和bisect.bisect等价的
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span>1, 2, 3, 4<span style="color: #2aa198;">]</span>
&gt;&gt;&gt; bisect.bisect<span style="color: #2aa198;">(</span>a, 2.0<span style="color: #2aa198;">)</span>
2
&gt;&gt;&gt; bisect.bisect_right<span style="color: #2aa198;">(</span>a, 2.0<span style="color: #2aa198;">)</span>
2
&gt;&gt;&gt; a.insert<span style="color: #2aa198;">(</span>bisect.bisect_right<span style="color: #b58900;">(</span>a, 2.0<span style="color: #b58900;">)</span>, 2.0<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; a
<span style="color: #2aa198;">[</span>1, 2, 2.0, 3, 4<span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
<li>bisect_left:顾名思义,就是把needle插入到所有"相同值"的最左边
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span>1, 2, 3, 4<span style="color: #2aa198;">]</span>
&gt;&gt;&gt; bisect.bisect<span style="color: #2aa198;">(</span>a, 2.0<span style="color: #2aa198;">)</span>
2
&gt;&gt;&gt; bisect.bisect_left<span style="color: #2aa198;">(</span>a, 2.0<span style="color: #2aa198;">)</span>
1
&gt;&gt;&gt; a.insert<span style="color: #2aa198;">(</span>bisect.bisect_left<span style="color: #b58900;">(</span>a, 2.0<span style="color: #b58900;">)</span>, 2.0<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; a
<span style="color: #2aa198;">[</span>1, 2.0, 2, 3, 4<span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8-2" class="outline-4">
<h4 id="sec-2-8-2">Inserting with bisect.insort</h4>
<div class="outline-text-4" id="text-2-8-2">
<ul class="org-ul">
<li>我们前面说了bisect主要是找到needle插入haystack的位置,那么好了,我们能不能把
两者结合到一块呢?那就是bisect.insort了,兼顾查找后插入,并且速度更快
</li>
<li>下面是一个使用bisect来获取一个随机的数组,但是一直要保证数组顺序是升序
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> bisect
<span style="color: #859900; font-weight: bold;">import</span> random

<span style="color: #268bd2;">SIZE</span> = 7
random.seed<span style="color: #2aa198;">(</span>1729<span style="color: #2aa198;">)</span>

<span style="color: #268bd2;">my_list</span> = <span style="color: #2aa198;">[]</span>
<span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>SIZE<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">new_item</span> = random.randrange<span style="color: #2aa198;">(</span>SIZE*2<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   bisect.insort<span style="color: #2aa198;">(</span>my_list, new_item<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'%2d -&gt;'</span> % new_item, my_list<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">10 -&gt; [10]</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">0 -&gt; [0, 10]</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">6 -&gt; [0, 6, 10]</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">8 -&gt; [0, 6, 8, 10]</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">7 -&gt; [0, 6, 7, 8, 10]</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">2 -&gt; [0, 2, 6, 7, 8, 10]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">10 -&gt; [0, 2, 6, 7, 8, 10, 10]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">When a List Is Not the Answer</h3>
<div class="outline-text-3" id="text-2-9">
<ul class="org-ul">
<li>list由于其非常便捷的特点,在python大有被滥用的趋势,我们需要知道的是,根据情形
的不同其实可以选择其他sequence来替代list
</li>
</ul>
</div>
<div id="outline-container-sec-2-9-1" class="outline-4">
<h4 id="sec-2-9-1">Arrays</h4>
<div class="outline-text-4" id="text-2-9-1">
<ul class="org-ul">
<li>如果list里面全部都是number的话,最好使用array来代替list.因为这种情况下array
效率更高
</li>
<li>array效率高的代价是需要要求内部所有成员的类型一致(和c语言一样).这样一来所有
成员的内存大小都一致,也更容易的进行优化:
<ul class="org-ul">
<li>比如对于signed char,传入array的第一个参数是'b',这个是typecode用来限定内
存的大小
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">a</span> = array.array<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'b'</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; a
array<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'b'</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; a.append<span style="color: #2aa198;">(</span>12<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; a
array<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'b'</span>, <span style="color: #b58900;">[</span>12<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; a.append<span style="color: #2aa198;">(</span>1234<span style="color: #2aa198;">)</span>
Traceback <span style="color: #2aa198;">(</span>most recent call last<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span> File <span style="color: #2aa198;">"&lt;stdin&gt;"</span>, line 1, <span style="color: #859900; font-weight: bold;">in</span> &lt;module&gt;
<span style="color: #b58900;">OverflowError</span>: signed char <span style="color: #859900; font-weight: bold;">is</span> greater than maximum
</pre>
</div>
</li>
<li>对于float number,typecode是'd'
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-9-2" class="outline-4">
<h4 id="sec-2-9-2">Memory Views</h4>
<div class="outline-text-4" id="text-2-9-2">
<ul class="org-ul">
<li>可以让你在不需要拷贝数据的时候,在不同的sequence之间共享数据,这对于超大数据是非常重要的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-9-3" class="outline-4">
<h4 id="sec-2-9-3">NumPy and SciPy</h4>
<div class="outline-text-4" id="text-2-9-3">
<ul class="org-ul">
<li>NumPy主要是数据方面的package
</li>
<li>SciPy在NumPy基础上开发,又使用了久经考验的C和Fortran库
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-9-4" class="outline-4">
<h4 id="sec-2-9-4">Deques and Other Queues</h4>
<div class="outline-text-4" id="text-2-9-4">
<ul class="org-ul">
<li>虽然list也可以用来做队列,但是其实效率不高,特别是要在list最左侧进行添加删除的时候
</li>
<li>collections.deque是一个thread-safe的double-ended的queue.
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 03: Dictionaries and Sets</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>dict type不仅仅在我们的代码里面广泛使用,它还是Python内部实现的重要组成部分
</li>
<li>也正是因为如此,python的dict类型是python虚拟机优化的重点部分
</li>
</ul>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Generic Mapping Types</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>在python2.6和python3.2以前,存在着一个叫做collections.abc的module,用来作为所
有的dict的子类
</li>
<li>dict类型有一个局限性,就是它的key必须是hashable的,value不要求.什么是hashable
呢?
<pre class="example">
An object is hasable if it has a hash value which never changes during its
lifetime(it needs a __hash__() method), and can be compared to other objects
(it need an  __eq__() method).Hasable objects which compare equal must have
the same hash value
</pre>
</li>
<li>所有的atomic immutable类型都是hashable的,比如str, bytes, numeric
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">hash</span><span style="color: #2aa198;">(</span>1<span style="color: #2aa198;">)</span>
1
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">hash</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"abc"</span><span style="color: #2aa198;">)</span>
-4275028297401921076
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">hash</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'d'</span><span style="color: #2aa198;">)</span>
-6398895540996775586
</pre>
</div>
</li>
<li>frozen set永远是hashable的,这是由其定义决定的
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">hash</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">frozenset</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[</span>30, 40<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
-3232971350518600656
</pre>
</div>
</li>
<li>tuple比较复杂,如果其所有的成员都是hashable的,那么它是hashable的,比如下面的tt
但是如果它含所有mutable的数据,比如tl,那它就不是hashable的
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">tt</span> = <span style="color: #2aa198;">(</span>1, 2, <span style="color: #b58900;">(</span>30, 40<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">hash</span><span style="color: #2aa198;">(</span>tt<span style="color: #2aa198;">)</span>
8027212646858338501
&gt;&gt;&gt; <span style="color: #268bd2;">tl</span> = <span style="color: #2aa198;">(</span>1, 2, <span style="color: #b58900;">[</span>30, 40<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">hash</span><span style="color: #2aa198;">(</span>tl<span style="color: #2aa198;">)</span>
Traceback <span style="color: #2aa198;">(</span>most recent call last<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span> File <span style="color: #2aa198;">"&lt;stdin&gt;"</span>, line 1, <span style="color: #859900; font-weight: bold;">in</span> &lt;module&gt;
<span style="color: #b58900;">TypeError</span>: unhashable <span style="color: #657b83; font-weight: bold;">type</span>: <span style="color: #2aa198;">'list'</span>
</pre>
</div>
</li>
<li>Python Glossary里面有一句是说"All Python's immutable built-in objects are
hashable",这是不准确的,因为并不是所有的tuple都是hashable的,比如上面的tl
</li>
<li>对于所有User-defined type来说:
<ul class="org-ul">
<li>如果它们没有创建__eq__,那么它是hashable的,因为hash(user_define_instance)
的结果总会是id()的结果
</li>
<li>如果它们实现了__eq__,那么就要求这个类型的所有的attribute都是immutable的
</li>
</ul>
</li>
<li>我们可以使用多种方法来创建一个dict,如下例,这几种方法的效果是等价的
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">a</span> = <span style="color: #657b83; font-weight: bold;">dict</span><span style="color: #2aa198;">(</span>one=1, two=2, three=3<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #268bd2;">b</span> = <span style="color: #2aa198;">{</span><span style="color: #2aa198;">'one'</span>: 1, <span style="color: #2aa198;">'two'</span>: 2, <span style="color: #2aa198;">'three'</span>: 3<span style="color: #2aa198;">}</span>
&gt;&gt;&gt; <span style="color: #268bd2;">c</span> = <span style="color: #657b83; font-weight: bold;">dict</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">zip</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[</span><span style="color: #2aa198;">'one'</span>, <span style="color: #2aa198;">'two'</span>, <span style="color: #2aa198;">'three'</span><span style="color: #268bd2;">]</span>, <span style="color: #268bd2;">[</span>1, 2, 3<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #268bd2;">d</span> = <span style="color: #657b83; font-weight: bold;">dict</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">'two'</span>, 2<span style="color: #268bd2;">)</span>, <span style="color: #268bd2;">(</span><span style="color: #2aa198;">'one'</span>, 1<span style="color: #268bd2;">)</span>, <span style="color: #268bd2;">(</span><span style="color: #2aa198;">'three'</span>, 3<span style="color: #268bd2;">)</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #268bd2;">e</span> = <span style="color: #657b83; font-weight: bold;">dict</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span><span style="color: #2aa198;">'three'</span>: 3, <span style="color: #2aa198;">'one'</span>: 1, <span style="color: #2aa198;">'two'</span>: 2<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; a == b == c == d == e
<span style="color: #268bd2; font-weight: bold;">True</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">dict Comprehensions</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>从python2.7开始,listcomp的变体distcomp开始作用于dict. 下面是一个distcomp的
例子
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">DIAL_CODES</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">(</span>86, <span style="color: #2aa198;">'China'</span><span style="color: #b58900;">)</span>, <span style="color: #b58900;">(</span>91, <span style="color: #2aa198;">'India'</span><span style="color: #b58900;">)</span>, <span style="color: #b58900;">(</span>1, <span style="color: #2aa198;">'United States'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
&gt;&gt;&gt; <span style="color: #268bd2;">country_code</span> = <span style="color: #2aa198;">{</span> country: code <span style="color: #859900; font-weight: bold;">for</span> code, country <span style="color: #859900; font-weight: bold;">in</span> DIAL_CODES <span style="color: #2aa198;">}</span>  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">here is the revere of key and value</span>
&gt;&gt;&gt; country_code
<span style="color: #2aa198;">{</span><span style="color: #2aa198;">'China'</span>: 86, <span style="color: #2aa198;">'India'</span>: 91, <span style="color: #2aa198;">'United States'</span>: 1<span style="color: #2aa198;">}</span>
&gt;&gt;&gt; <span style="color: #2aa198;">{</span>code: country.upper<span style="color: #b58900;">()</span> <span style="color: #859900; font-weight: bold;">for</span> country, code <span style="color: #859900; font-weight: bold;">in</span> country_code.items<span style="color: #b58900;">()</span> <span style="color: #859900; font-weight: bold;">if</span> code &gt; 66<span style="color: #2aa198;">}</span>
<span style="color: #2aa198;">{</span>86: <span style="color: #2aa198;">'CHINA'</span>, 91: <span style="color: #2aa198;">'INDIA'</span><span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Overview of Common Mapping Methods</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>dict和其另外的两个主要变体defaultdict,OrderedDict有着很多的API,我们统一叫做
mapping API
</li>
<li>这里有个特殊的api,叫做upate(),其用法如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">d</span> = <span style="color: #2aa198;">{</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #2aa198;">"one"</span>: 1,
<span style="background-color: #eee8d5;"> </span>   <span style="color: #2aa198;">"two"</span>: 2
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>d<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">d2</span> = <span style="color: #2aa198;">{</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #2aa198;">"one"</span>: 11,
<span style="background-color: #eee8d5;"> </span>   <span style="color: #2aa198;">"two"</span>: 22,
<span style="background-color: #eee8d5;"> </span>   <span style="color: #2aa198;">"three"</span>: 33
<span style="color: #2aa198;">}</span>

d2.update<span style="color: #2aa198;">(</span>d<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>d2<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{'one': 1, 'two': 2}</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{'one': 1, 'two': 2, 'three': 33}</span>
</pre>
</div>
</li>
<li>update(m)调用的过程是典型的duck typing的例子:update会首先测试参数m是不是有
method keys():
<ul class="org-ul">
<li>如果有,就认为这是一个mapping类型.
</li>
<li>如果没有,就假设它是一个(key, value)的pair
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">d</span> = <span style="color: #2aa198;">{</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #2aa198;">"one"</span>: 11,
<span style="background-color: #eee8d5;"> </span>   <span style="color: #2aa198;">"two"</span>: 22,
<span style="background-color: #eee8d5;"> </span>   <span style="color: #2aa198;">"three"</span>: 33
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>d<span style="color: #2aa198;">)</span>
d.update<span style="color: #2aa198;">(</span>one=111, two=222, three=333<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>d<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{'one': 11, 'two': 22, 'three': 33}</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{'one': 111, 'two': 222, 'three': 333}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>还有个特殊的api叫做setdefault(),它会极大的提高我们的效率,如下
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">index</span> = <span style="color: #2aa198;">{</span>
<span style="background-color: #eee8d5;"> </span>   1: <span style="color: #2aa198;">"one"</span>,
<span style="background-color: #eee8d5;"> </span>   2: <span style="color: #2aa198;">"two"</span>,
<span style="background-color: #eee8d5;"> </span>   3: <span style="color: #2aa198;">"three"</span>
<span style="color: #2aa198;">}</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">use three line to set a value</span>
<span style="color: #268bd2;">occur</span> = index.get<span style="color: #2aa198;">(</span>4, <span style="color: #2aa198;">""</span><span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">occur</span> += <span style="color: #2aa198;">"four"</span>
<span style="color: #268bd2;">index</span><span style="color: #2aa198;">[</span>4<span style="color: #2aa198;">]</span> = occur
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>index<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">use only one line to set the value</span>
<span style="color: #268bd2;">ff</span> = index.setdefault<span style="color: #2aa198;">(</span>5, <span style="color: #2aa198;">"five"</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>ff<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>index<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{1: 'one', 2: 'two', 3: 'three', 4: 'four'}</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">five</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}</span>
</pre>
</div>
</li>
<li>相比较于setdefault(), d[k]会在找不到key的时候抛出异常,而d.get(k, default)会
是更好的选择,至少不用处理异常.当然了如果同时要update的话,setdefault()是首选
</li>
<li>setdefault()的返回值就是我们新的value在dict里面的变量,如果变量是ref类型,比如
list的话,我们还可以把初始化和赋值chain起来,更加的简洁
<div class="org-src-container">

<pre class="src src-python"><span style="color: #268bd2;">index</span> = <span style="color: #2aa198;">{</span>
<span style="background-color: #eee8d5;"> </span>   1: <span style="color: #b58900;">[</span><span style="color: #2aa198;">"one"</span><span style="color: #b58900;">]</span>,
<span style="background-color: #eee8d5;"> </span>   2: <span style="color: #b58900;">[</span><span style="color: #2aa198;">"two"</span><span style="color: #b58900;">]</span>,
<span style="background-color: #eee8d5;"> </span>   3: <span style="color: #b58900;">[</span><span style="color: #2aa198;">"three"</span><span style="color: #b58900;">]</span>
<span style="color: #2aa198;">}</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">use three line to set a value</span>
<span style="color: #268bd2;">occur</span> = index.get<span style="color: #2aa198;">(</span>4, <span style="color: #2aa198;">""</span><span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">occur</span> += <span style="color: #2aa198;">"four"</span>
<span style="color: #268bd2;">index</span><span style="color: #2aa198;">[</span>4<span style="color: #2aa198;">]</span> = occur
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>index<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">use only one line to set the value</span>
index.setdefault<span style="color: #2aa198;">(</span>5, <span style="color: #b58900;">[</span><span style="color: #2aa198;">"five"</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>.append<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"plus"</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>index<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{1: ['one'], 2: ['two'], 3: ['three'], 4: 'four'}</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{1: ['one'], 2: ['two'], 3: ['three'], 4: 'four', 5: ['five', 'plus']}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Mappings with Flexible Key Lookup</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>由于dict里面某个元素不存在这种情况，特别的常见情况就是,某个key不存在的时候,
有个默认值, 前面是通过setdefault来设置一个默认值,而defaultdict的做法是设置
一个默认的"调用方法"
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> collections
<span style="color: #268bd2;">index</span> = collections.defaultdict<span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">list</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>index<span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">do not include "one" before, initialize with the index["one"] = list()</span>
index<span style="color: #2aa198;">[</span><span style="color: #2aa198;">"one"</span><span style="color: #2aa198;">]</span>.append<span style="color: #2aa198;">(</span>1<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>index<span style="color: #b58900;">[</span><span style="color: #2aa198;">"one"</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">defaultdict(&lt;class 'list'&gt;, {})</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[1]</span>
</pre>
</div>
</li>
<li>missing key之所以能够起作用,其背后起作用是special method: __missing__,这个
special method只会被__getitem__所调用
</li>
</ul>
</div>
<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1">Variations of dict</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>在collections包里面,有很多dict的变形:
<ul class="org-ul">
<li>collections.OrderedDict:特点是保持key插入的顺序
</li>
<li>collections.ChainMap
</li>
<li>collections.Counter:存储着key的数目
</li>
<li>collections.UserDict
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2">Subclassing UserDict</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>一般来说,如果我们想自己实现一个dict的话,需要去extend UserDict而不是去extend
dict
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4-3" class="outline-4">
<h4 id="sec-3-4-3">Immutable Mappings</h4>
<div class="outline-text-4" id="text-3-4-3">
<ul class="org-ul">
<li>dict默认情况下肯定是mutable的,但是有些时候,你不希望用户去更改你的dict,这个
时候immutable的dict就显得很重要了
</li>
<li>python3提供了这种dict
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">from</span> types <span style="color: #859900; font-weight: bold;">import</span> MappingProxyType
<span style="color: #268bd2;">d</span> = <span style="color: #2aa198;">{</span>1: <span style="color: #2aa198;">'A'</span><span style="color: #2aa198;">}</span>
<span style="color: #268bd2;">d_proxy</span> = MappingProxyType<span style="color: #2aa198;">(</span>d<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>d_proxy<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">#####################################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Traceback (most recent call last):                                #</span>
<span style="color: #93a1a1;">#   </span><span style="color: #93a1a1;">File "c:/Users/hfeng/tmp/one.py", line 5, in &lt;module&gt;           #</span>
<span style="color: #93a1a1;">#     </span><span style="color: #93a1a1;">d_proxy[1] = 'x'                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">TypeError: 'mappingproxy' object does not support item assignment #</span>
<span style="color: #93a1a1;">#####################################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">d_proxy[1] = 'x'</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{1: 'A'}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Set Theory</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>set这个概念是计算机中很常见的概念,但是比较晚才出现在python里面(2.3),其中有
两种set:
<ul class="org-ul">
<li>mutable版本:就是set
</li>
<li>immutable版本:就是frozenset
</li>
</ul>
</li>
<li>set不能有两个相同的元素,所以它的元素必须是hashable的
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">l</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'spam'</span>, <span style="color: #2aa198;">'spam'</span>, <span style="color: #2aa198;">'eggs'</span>, <span style="color: #2aa198;">'spam'</span><span style="color: #2aa198;">]</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">set</span><span style="color: #2aa198;">(</span>l<span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">set</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[</span><span style="color: #2aa198;">'eggs'</span>, <span style="color: #2aa198;">'spam'</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>set自己不是hashable的,因为其中的元素可能改变,但是frozenset是hashable
</li>
</ul>
</div>
<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1">set Literals</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>set的literal模式很简单,就是{1}, {2}这种模式
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">{</span>1<span style="color: #2aa198;">}</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">type</span><span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>
&lt;<span style="color: #657b83; font-weight: bold;">type</span> <span style="color: #2aa198;">'set'</span>&gt;
</pre>
</div>
</li>
<li>但是注意set没有empty set的literal,比如{}就默认是一个空的dict.空的set需要使
用set()才可以. 在python3里面,为了让set也有一个空的literal,特别引进了{&#x2026;}
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">{</span>...<span style="color: #2aa198;">}</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">type</span><span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>
&lt;<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #2aa198;">'set'</span>&gt;
</pre>
</div>
</li>
<li>{1,2,3}这种literal的方式不仅仅是更加易读,而且其速度要超过set([1, 2, 3]),因
为python为了让后者能够成功创建,还要去分析它的ctor的参数:一个list
</li>
<li>frozenset就没有literal的格式啦,需要使用ctor来完成
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">frozenset</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">range</span><span style="color: #b58900;">(</span>10<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">frozenset</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-2" class="outline-4">
<h4 id="sec-3-5-2">Set Comprehensions</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>listcomp的巨大成功让python在2.7的时候同时为dict和set都加入了comprehension
其中set comprehension用法如下
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #2aa198;">{</span> i <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #b58900;">(</span>10, 20<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
<span style="color: #2aa198;">{</span>10, 11, 12, 13, 14, 15, 16, 17, 18, 19<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-3" class="outline-4">
<h4 id="sec-3-5-3">Set Operations</h4>
<div class="outline-text-4" id="text-3-5-3">
<ul class="org-ul">
<li>set支持基本上所有的数学操作
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">dict and set Under the Hood</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>知道dict和set在内部都是使用hash table来实现的,有助于我们理解它们的优点和缺点
</li>
<li>在python2里面,keys()返回一个list,这也是我们能想到的最简单的实现
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; m
<span style="color: #2aa198;">{</span>1: 11, 2: 22<span style="color: #2aa198;">}</span>
&gt;&gt;&gt; m.keys<span style="color: #2aa198;">()</span>
<span style="color: #2aa198;">[</span>1, 2<span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
<li>但是在python3里面,keys()返回了一个叫做dict_keys的类型,其行为更像是set,而不
再是list
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; m
<span style="color: #2aa198;">{</span>1: 11, 2: 22<span style="color: #2aa198;">}</span>
&gt;&gt;&gt; m.keys<span style="color: #2aa198;">()</span>
dict_keys<span style="color: #2aa198;">(</span><span style="color: #b58900;">[</span>1, 2<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 04: Text versus Bytes</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Character Issues</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>string的定义,是非常简单的,就是一系列的character
<pre class="example">
A string is a sequence of characters.
</pre>
</li>
<li>但是问题就出在这个character上面:
<ul class="org-ul">
<li>在python2里面,这个character被定义成ascii character
</li>
<li>在python3里面,这个character被定义成unicode character
</li>
</ul>
</li>
<li>本书主要介绍python3,但是python2还活生生的占据更多的代码,所以我们还是要拿出
非常大的篇幅来介绍python2,但是首先要明确的是,python3的设计肯定教python2要更
合理
</li>
</ul>
</div>
<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">Python2 problem</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>python2里面默认的字符串都是str()类型的, 它的str的每个成员都是ascii编码的
character.正因为如此,str就可以看做是byte数组,所以没有bytes(注意是bytes,而
不是byte,因为说的是一个串的概念,不是单独一个.python2.6也引入了bytes,但是是
str的alias,完全不是python3里面的bytes的概念)这个类型
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>sys.version_info<span style="color: #2aa198;">)</span>
sys.version_info<span style="color: #2aa198;">(</span>major=2, minor=7, micro=13, releaselevel=<span style="color: #2aa198;">'final'</span>, serial=0<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">print</span> <span style="color: #657b83; font-weight: bold;">type</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">'byte type does not exist, it is str in python2'</span><span style="color: #2aa198;">)</span>
&lt;<span style="color: #657b83; font-weight: bold;">type</span> <span style="color: #2aa198;">'str'</span>&gt;
</pre>
</div>
</li>
<li>相比之下,python3里面字符串的类型还叫str(),但是含义变了,每个成员都是unicode
的character.而bytes数组就必须存在了,因为bytes数组和str不是一个东西
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>sys.version_info<span style="color: #2aa198;">)</span>
sys.version_info<span style="color: #2aa198;">(</span>major=3, minor=6, micro=1, releaselevel=<span style="color: #2aa198;">'final'</span>, serial=0<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'strings are now utf-8 \u03BCnico\u0394&#233;!'</span><span style="color: #2aa198;">)</span>
strings are now utf-8 &#956;nico&#916;&#233;!
&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">type</span><span style="color: #b58900;">(</span>b<span style="color: #2aa198;">'python3 has bytes type'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
&lt;<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #2aa198;">'bytes'</span>&gt;
</pre>
</div>
</li>
<li>python2的str因为是bytes的集合,所以它会有一个单独的unicode()类型
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>sys.version_info<span style="color: #2aa198;">)</span>
sys.version_info<span style="color: #2aa198;">(</span>major=2, minor=7, micro=13, releaselevel=<span style="color: #2aa198;">'final'</span>, serial=0<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">print</span> <span style="color: #657b83; font-weight: bold;">type</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">unicode</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">'this is like a python3 str type'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
&lt;<span style="color: #657b83; font-weight: bold;">type</span> <span style="color: #2aa198;">'unicode'</span>&gt;
</pre>
</div>
</li>
<li>"str默认是ascii编码,拥有unicode类型"都不是python2的错误,python2的错误是允许
unicode类型和str类型进行相加!不同类型的对象相加需要implicit的转换:
<ul class="org-ul">
<li>在unicode类型的对象里面都是str的情况下,都转换成unicode后相加是没有问题的
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>sys.version_info<span style="color: #2aa198;">)</span>
sys.version_info<span style="color: #2aa198;">(</span>major=2, minor=7, micro=13, releaselevel=<span style="color: #2aa198;">'final'</span>, serial=0<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">"world"</span>
&gt;&gt;&gt; u<span style="color: #2aa198;">"Hello"</span> + s
u<span style="color: #2aa198;">'Helloworld'</span>
</pre>
</div>
</li>
<li>但是有一天,我们的unicode类型不小心加入了非str的字符串,那么当对方转换成unicode
和我们unicode相加的时候,错误就出现了!
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>sys.version_info<span style="color: #2aa198;">)</span>
sys.version_info<span style="color: #2aa198;">(</span>major=2, minor=7, micro=13, releaselevel=<span style="color: #2aa198;">'final'</span>, serial=0<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">"&#19990;&#30028;"</span>
&gt;&gt;&gt; u<span style="color: #2aa198;">"Hello"</span> + s
Traceback <span style="color: #2aa198;">(</span>most recent call last<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span> File <span style="color: #2aa198;">"&lt;stdin&gt;"</span>, line 1, <span style="color: #859900; font-weight: bold;">in</span> &lt;module&gt;
<span style="color: #b58900;">UnicodeDecodeError</span>: <span style="color: #2aa198;">'ascii'</span> codec can<span style="color: #2aa198;">'t decode byte 0xe4 in position 0: ordinal not in range(128)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>错误的根源就是这种,"遇到不合适的类型才报错"的机制,在s的内容不再是ascii编码
的情况下才暴露问题的机制!
</li>
<li>python3则从根本上杜绝了这个问题,因为它不允许implicit的相加,相加两个字符串
的类型必须一致
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>sys.version_info<span style="color: #2aa198;">)</span>
sys.version_info<span style="color: #2aa198;">(</span>major=3, minor=6, micro=1, releaselevel=<span style="color: #2aa198;">'final'</span>, serial=0<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">type</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"hello"</span><span style="color: #2aa198;">)</span>
&lt;<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #2aa198;">'str'</span>&gt;
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">type</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">"world"</span><span style="color: #2aa198;">)</span>
&lt;<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #2aa198;">'bytes'</span>&gt;
&gt;&gt;&gt; <span style="color: #2aa198;">"hello"</span> + b<span style="color: #2aa198;">"world"</span>
Traceback <span style="color: #2aa198;">(</span>most recent call last<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span> File <span style="color: #2aa198;">"&lt;stdin&gt;"</span>, line 1, <span style="color: #859900; font-weight: bold;">in</span> &lt;module&gt;
<span style="color: #b58900;">TypeError</span>: must be <span style="color: #657b83; font-weight: bold;">str</span>, <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #657b83; font-weight: bold;">bytes</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Character Issues Continue</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>Unicode 规范非常明确的区分了character和byte representation两个概念:
<ul class="org-ul">
<li>在Unicode的语境下面character被叫做code pint,它的range是从0到1,114,111这是
非常大的一个数字,迄今只用了十分之一.比如A的Unicode表示方法就是"U+0041"
</li>
<li>而在计算机中,只存在byte,所有的Unicode最终只能encode成byte,才能在计算机里面
存储,转发.encode就是把code point转换成byte sequence的过程, 而byte sequence
有不同的存储方式,所以我们encode的时候都会有一个格式,比如UTF-8 encoding我们
前面说的"U+0041"就得到\x41, 再比如UTF-16LE encoding "U+0041"就得到\x41\x00
</li>
</ul>
</li>
<li>这里为了帮助记忆来区分下encoding和decoding,Unicode是人类可以看懂的样式,而byte
representation是机器可以看懂的格式,所以
<ul class="org-ul">
<li>从byte representation转换成人类可读的unicode就是decoding!(解码,不解,人类怎么读)
</li>
<li>从unicode(code piont)转换成byte representation(无论是UTF-8也好,UTF-16也好)
就叫做encoding(decoding的反义词)
</li>
</ul>
</li>
<li>下面是一个unicode转换成utf-8 byte representation的例子
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">'cafe&#769;'</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>
5
&gt;&gt;&gt; <span style="color: #268bd2;">b</span> = s.encode<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'utf8'</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; b
b<span style="color: #2aa198;">'cafe\xcc\x81'</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>
6
&gt;&gt;&gt; b.decode<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'utf8'</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">'cafe&#769;'</span>
</pre>
</div>
</li>
<li>需要注意的是,我们bytes类型的b是不可以encode的.而unicode类型的s也是不可以decode
的,这就更加不会让我们容易弄错
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; b.encode<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'utf8'</span><span style="color: #2aa198;">)</span>
Traceback <span style="color: #2aa198;">(</span>most recent call last<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span> File <span style="color: #2aa198;">"&lt;stdin&gt;"</span>, line 1, <span style="color: #859900; font-weight: bold;">in</span> &lt;module&gt;
<span style="color: #b58900;">AttributeError</span>: <span style="color: #2aa198;">'bytes'</span> <span style="color: #657b83; font-weight: bold;">object</span> has no attribute <span style="color: #2aa198;">'encode'</span>
&gt;&gt;&gt; s.decode<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'utf8'</span><span style="color: #2aa198;">)</span>
Traceback <span style="color: #2aa198;">(</span>most recent call last<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span> File <span style="color: #2aa198;">"&lt;stdin&gt;"</span>, line 1, <span style="color: #859900; font-weight: bold;">in</span> &lt;module&gt;
<span style="color: #b58900;">AttributeError</span>: <span style="color: #2aa198;">'str'</span> <span style="color: #657b83; font-weight: bold;">object</span> has no attribute <span style="color: #2aa198;">'decode'</span>
</pre>
</div>
</li>
<li>之所以有上面一条,就是因为在python2里面,byte格式和unicode都是可以调用encode和
decode的,结果就非常的混乱
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">type</span><span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>
&lt;<span style="color: #657b83; font-weight: bold;">type</span> <span style="color: #2aa198;">'str'</span>&gt;
&gt;&gt;&gt; s.encode<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'utf8'</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">'world'</span>
&gt;&gt;&gt; s.decode<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'utf8'</span><span style="color: #2aa198;">)</span>
u<span style="color: #2aa198;">'world'</span>
&gt;&gt;&gt; <span style="color: #268bd2;">h</span> = u<span style="color: #2aa198;">'world'</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">type</span><span style="color: #2aa198;">(</span>h<span style="color: #2aa198;">)</span>
&lt;<span style="color: #657b83; font-weight: bold;">type</span> <span style="color: #2aa198;">'unicode'</span>&gt;
&gt;&gt;&gt; h.encode<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'utf8'</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">'world'</span>
&gt;&gt;&gt; h.decode<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'utf8'</span><span style="color: #2aa198;">)</span>
u<span style="color: #2aa198;">'world'</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Byte Essentials</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>前面介绍到了bytes类型,我们说:bytes是一种内置的binary sequences.但是,内置的
binary sequence并不是只有这一种,还有一种叫做bytearray.不同的地方在于:
<ul class="org-ul">
<li>bytes是immutable的, 只在python3里面有(python2里面的bytes是str的alias,完全
不同于python3里面的bytes)
</li>
<li>bytearray是mutable的, 在python3和python2里面都有
</li>
</ul>
</li>
<li>好了,我们下面来重点说说我们的binary sequence(也就是bytes和bytearray).每一个
bytes or bytearray的成员(item)都是一个从0到255的integer!
</li>
<li>而str不行,每个str的成员(item)都还是一个string
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>sys.version_info<span style="color: #2aa198;">)</span>
sys.version_info<span style="color: #2aa198;">(</span>major=3, minor=6, micro=1, releaselevel=<span style="color: #2aa198;">'final'</span>, serial=0<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #268bd2;">a</span> = <span style="color: #657b83; font-weight: bold;">bytes</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"abc"</span>, encoding=<span style="color: #2aa198;">"utf_8"</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">type</span><span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span>
&lt;<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #2aa198;">'bytes'</span>&gt;
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">type</span><span style="color: #2aa198;">(</span>a<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
&lt;<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #2aa198;">'int'</span>&gt;
&gt;&gt;&gt; <span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">"abc"</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">type</span><span style="color: #2aa198;">(</span>s<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
&lt;<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #2aa198;">'str'</span>&gt;
</pre>
</div>
</li>
<li>这里还要特别的指出,str类型是唯一一个s== s[:1]的类型,这是为了实用性的考虑
随便一个其他类型都不满足这个要求
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #268bd2;">n</span> = <span style="color: #2aa198;">[</span>1, 1, 1<span style="color: #2aa198;">]</span>
&gt;&gt;&gt; n<span style="color: #2aa198;">[</span>0<span style="color: #2aa198;">]</span>
1
&gt;&gt;&gt; n<span style="color: #2aa198;">[</span>:1<span style="color: #2aa198;">]</span>
<span style="color: #2aa198;">[</span>1<span style="color: #2aa198;">]</span>
&gt;&gt;&gt; n<span style="color: #2aa198;">[</span>0<span style="color: #2aa198;">]</span> == n<span style="color: #2aa198;">[</span>:1<span style="color: #2aa198;">]</span>
<span style="color: #268bd2; font-weight: bold;">False</span>
&gt;&gt;&gt; <span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">"111"</span>
&gt;&gt;&gt; s<span style="color: #2aa198;">[</span>0<span style="color: #2aa198;">]</span>
<span style="color: #2aa198;">'1'</span>
&gt;&gt;&gt; s<span style="color: #2aa198;">[</span>:1<span style="color: #2aa198;">]</span>
<span style="color: #2aa198;">'1'</span>
&gt;&gt;&gt; s<span style="color: #2aa198;">[</span>0<span style="color: #2aa198;">]</span> == s<span style="color: #2aa198;">[</span>:1<span style="color: #2aa198;">]</span>
<span style="color: #268bd2; font-weight: bold;">True</span>
</pre>
</div>
</li>
<li>说了这么多关于bytes和str,其实很没条理.如果用golang里面的类型来解释下python3
里面的类型会非常的清晰:
<ul class="org-ul">
<li>golang里面的string类型,对应python3里面的str
</li>
<li>golang里面的rune类型,对应python3里面的str(长度为1的str)
</li>
<li>golang里面的[]byte类型,对应python3里面的bytes
</li>
</ul>
</li>
<li>在golang里面,一个str可以使用强制类型转换,来看看其rune和byte的长度:
<ul class="org-ul">
<li>如果str里面都是ascii,则两者长度相同
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        str := <span style="color: #2aa198;">"cafe"</span>
        b := <span style="color: #b58900;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #b58900;">(</span>str<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
        r := <span style="color: #b58900;">[]</span><span style="color: #268bd2;">rune</span><span style="color: #b58900;">(</span>str<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>r<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[99 97 102 101]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[99 97 102 101]</span>
</pre>
</div>
</li>
<li>如果str里面含有unicode(UTF-8编码)长度最少为16bit的字符,那么长度不同
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        str := <span style="color: #2aa198;">"cafe&#769;"</span>
        b := <span style="color: #b58900;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #b58900;">(</span>str<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
        r := <span style="color: #b58900;">[]</span><span style="color: #268bd2;">rune</span><span style="color: #b58900;">(</span>str<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>r<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[99 97 102 101 204 129]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[99 97 102 101 769]</span>
</pre>
</div>
</li>
</ul>
</li>
<li>因为有更好的类型系统,golang能够清晰的显示如下两种类型的不同:
<ul class="org-ul">
<li>byte这种二进制本质上是为了计算机准备的(所以会有utf-8这种编码格式,因为计算机想省空间)
</li>
<li>rune这种unicode,本质上的为了给人看懂的(所以都是32bit存储的,能存储所有的unicode,
爷不在乎空间,就安装最大的空间为每个字符准备)
</li>
</ul>
</li>
<li>bytes是python3里面给计算机准备的,计算机就会要求你告诉它是怎样的存储方式,计
算机当然更喜欢比较节省空间的存储方式,这也是为什么UTF-8比较流行的原因,但其实
你真的可以选择使用UTF-32,只是占的byte数目较多而已
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">import</span> sys;<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>sys.version_info<span style="color: #2aa198;">)</span>
sys.version_info<span style="color: #2aa198;">(</span>major=3, minor=6, micro=1, releaselevel=<span style="color: #2aa198;">'final'</span>, serial=0<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #268bd2;">u8</span> = <span style="color: #657b83; font-weight: bold;">bytes</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'cafe&#769;'</span>, encoding=<span style="color: #2aa198;">'utf_8'</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #268bd2;">u32</span> = <span style="color: #657b83; font-weight: bold;">bytes</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'cafe&#769;'</span>, encoding=<span style="color: #2aa198;">'utf_32'</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>u8<span style="color: #2aa198;">)</span>
6
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>u32<span style="color: #2aa198;">)</span>
24
&gt;&gt;&gt; u8
b<span style="color: #2aa198;">'cafe\xcc\x81'</span>
&gt;&gt;&gt; u32
b<span style="color: #2aa198;">'\xff\xfe\x00\x00c\x00\x00\x00a\x00\x00\x00f\x00\x00\x00e\x00\x00\x00\x01\x03\x00\x00'</span>
</pre>
</div>
</li>
<li>无论使用什么编码方式,区别是使用的byte数目,每个byte里面绝对不可能超过256
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">for</span> c <span style="color: #859900; font-weight: bold;">in</span> u8: <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>
...
99
97
102
101
204
129
&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">for</span> c <span style="color: #859900; font-weight: bold;">in</span> u32: <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>
...
255
254
0
0
99
0
0
0
97
0
0
0
102
0
0
0
101
0
0
0
1
3
0
0
</pre>
</div>
</li>
<li>bytearray是byte的一个mutable扩展,不是常用类型,所以没有为它设计literal syntax
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">import</span> sys;<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>sys.version_info<span style="color: #2aa198;">)</span>
sys.version_info<span style="color: #2aa198;">(</span>major=3, minor=6, micro=1, releaselevel=<span style="color: #2aa198;">'final'</span>, serial=0<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #268bd2;">cafe</span> = <span style="color: #657b83; font-weight: bold;">bytes</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'cafe&#769;'</span>, encoding=<span style="color: #2aa198;">'utf_8'</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; cafe
b<span style="color: #2aa198;">'cafe\xcc\x81'</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">bytearray</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">'cafe\xcc\x81'</span><span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">bytearray</span><span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">'cafe\xcc\x81'</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>binary sequence虽然本质上都是integer,但是如果真的按照integer显示出来,不太便
于阅读,所以为了人类,python在byte sequence的显示上面,做了让步:
<ul class="org-ul">
<li>对于ASCII,我们就显示ASCII character
</li>
<li>对于tab,newline, carriage return,\,分别使用escape sequence:\t,\n,\r,<br  />
</li>
<li>对于所有其他的byte value,统一使用hexadecimal escape sequence比如null byte
就显示成\x00
</li>
</ul>
</li>
<li>binary sequence大部分的API和str一样,除了:
<ul class="org-ul">
<li>bytes没有两部分API:formatting方面的(为了给人看的,bytes不需要给人看),以及
Unicode方面的,比如isdecimal, isnumeric等等
</li>
<li>bytes自己有一个str没有的class method:从hex digit创建bytes(显然人类看不懂
hex digit,所以也就不可能使用这个作为ctor的参赛)
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">import</span> sys;<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>sys.version_info<span style="color: #2aa198;">)</span>
sys.version_info<span style="color: #2aa198;">(</span>major=3, minor=6, micro=1, releaselevel=<span style="color: #2aa198;">'final'</span>, serial=0<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">bytes</span>.fromhex<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'31 4B CE A9'</span><span style="color: #2aa198;">)</span>
b<span style="color: #2aa198;">'1K\xce\xa9'</span>
</pre>
</div>
</li>
</ul>
</li>
<li>除了上面说的fromhex以外,我们还有更加普通的一些创建bytes或是bytearray的方法:
<ul class="org-ul">
<li>str和encoding作为参数
</li>
<li>使用iterable来提供0到255的数字做参数
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #657b83; font-weight: bold;">bytes</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">range</span><span style="color: #b58900;">(</span>2<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
b<span style="color: #2aa198;">'\x00\x01'</span>
</pre>
</div>
</li>
<li>使用实现了buffer protocol协议的object做参数,这种从bufer-like的object来创建
byte的方法,有点像low-level的操作
<div class="org-src-container">

<pre class="src src-python">&gt;&gt;&gt; <span style="color: #859900; font-weight: bold;">import</span> array
&gt;&gt;&gt; <span style="color: #268bd2;">numbers</span> = array.array<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'h'</span>, <span style="color: #b58900;">[</span>-2, -1, 0, 1, 2<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #268bd2;">octets</span> = <span style="color: #657b83; font-weight: bold;">bytes</span><span style="color: #2aa198;">(</span>numbers<span style="color: #2aa198;">)</span>
&gt;&gt;&gt; octets
b<span style="color: #2aa198;">'\xfe\xff\xff\xff\x00\x00\x01\x00\x02\x00'</span>
</pre>
</div>
</li>
</ul>
</li>
<li>使用所有buffer-like的source来创建bytes或者bytearray的情形下,都会copy这些bytes
相对的是memoryview,它会让你在binary data structure之间来分享内存!
</li>
<li>和内存相关的还有一个struct mode,下面来详细介绍
</li>
</ul>
</div>
<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1">Structs and Memory Views</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>struct module 提供了如下两个对象的相互转化:
<ul class="org-ul">
<li>packed bytes
</li>
<li>a tuple of fields of different types
</li>
</ul>
</li>
<li>TODO
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Basic Encoders/Decoders</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>在python里面,有超过100钟的编码格式,每一种都有自己的名字,同时还会有alias,换句
话说,如下的字符串都表示utf8编码:
<ul class="org-ul">
<li>'utf_8'
</li>
<li>'utf8'
</li>
<li>'utf-8'
</li>
<li>'U8'
</li>
</ul>
</li>
<li>这些编码字符串都可以作为函数的参赛,比如:
<ul class="org-ul">
<li>open()
</li>
<li>str.encode()
</li>
<li>bytes.decode()
</li>
</ul>
</li>
<li>常见的encoding有:
<ul class="org-ul">
<li>latin1
</li>
<li>cp1252
</li>
<li>cp437
</li>
<li>gb2312
</li>
<li>utf-8
</li>
<li>utf-16le
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Understanding Encode/Decode Problems</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>虽然编码错误最常见的形式就是UnicodeError exception,但是其实这个错误肯定是可
以分成两类的:
<ul class="org-ul">
<li>UnicodeEncodeError(从str变成binary sequence)
</li>
<li>UnicodeDecodeError(从binary sequence变成str)
</li>
</ul>
</li>
<li>而且在读取python文件的时候,遇到编码问题一般也会报错
</li>
</ul>
</div>
<div id="outline-container-sec-4-5-1" class="outline-4">
<h4 id="sec-4-5-1">Coping with UnicodeEncodeError</h4>
<div class="outline-text-4" id="text-4-5-1">
<ul class="org-ul">
<li>对于大部分的非UTF编码格式(binary)来说,它们其实只是处理了"一部分"的Unicode,
所以text转换成binary的时候,有些text找不到合适的binary表达方式就会报UnicodeEncodeError
的错误(encode是给计算机看)
</li>
<li>默认情况下"encode函数+某个编码格式"遇到无法正确的从text到binary的转换的时
候,会抛出Error
<pre class="example">
&gt;&gt;&gt; import sys;print(sys.version_info)
sys.version_info(major=3, minor=6, micro=1, releaselevel='final', serial=0)
&gt;&gt;&gt; city = 'São Paulo'
&gt;&gt;&gt; city.encode('utf_8')
b'Sa\xcc\x83o Paulo'
&gt;&gt;&gt; city.encode('cp437')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/local/Cellar/python3/3.6.1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/encodings/cp437.py", line 12, in encode
    return codecs.charmap_encode(input,errors,encoding_map)
UnicodeEncodeError: 'charmap' codec can't encode character '\u0303' in position 2: character maps to &lt;undefined&gt;
</pre>
</li>
<li>如果不想出现exception,那么我没有三个选择:
<ul class="org-ul">
<li>传入errors='ignore',忽略这个字符,这一般是非常差的选择
<pre class="example">
&gt;&gt;&gt; import sys;print(sys.version_info)
sys.version_info(major=3, minor=6, micro=1, releaselevel='final', serial=0)
&gt;&gt;&gt; city.encode('cp437', errors='ignore')
b'Sao Paulo'
</pre>
</li>
<li>传入errors='replace',使用`?`来替代不知道如何转换的text
<pre class="example">
&gt;&gt;&gt; import sys;print(sys.version_info)
sys.version_info(major=3, minor=6, micro=1, releaselevel='final', serial=0)
&gt;&gt;&gt; city.encode('cp437', errors='replace')
b'Sa?o Paulo'
</pre>
</li>
<li>传入errors='xmlcharrefreplace',使用XML entity来替代
<pre class="example">
&gt;&gt;&gt; import sys;print(sys.version_info)
sys.version_info(major=3, minor=6, micro=1, releaselevel='final', serial=0)
&gt;&gt;&gt; city.encode('cp437', errors='xmlcharrefreplace')
b'Sa&amp;#771;o Paulo'
</pre>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5-2" class="outline-4">
<h4 id="sec-4-5-2">Coping with UnicodeDecodeError</h4>
<div class="outline-text-4" id="text-4-5-2">
<ul class="org-ul">
<li>就像不是所有的byte都是vaild的ascii一样,也不是所有的byte sequence都是valid
的UTF-8或者UTF-16.遇到binary到text转换失败的时候,就会碰到UnicodeDecodeError
<pre class="example">
&gt;&gt;&gt; import sys;print(sys.version_info)
sys.version_info(major=3, minor=6, micro=1, releaselevel='final', serial=0)
&gt;&gt;&gt; octets = b'Montr\xe9al'
&gt;&gt;&gt; octets.decode('utf_8')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe9 in position 5: invalid continuation byte
</pre>
</li>
<li>decode的问题在于,不是所有的编码都和UTF-8一样有节操,很多legacy的8-bit编码格
式,比如'koi8_r', 'iso8859_1',是可以接受任意的byte sequence的,所以如果一个
本来具有text意义的byte sequence使用类似'koi8_r'这种编码格式进行解码,就会出
现我们原来在玩日本游戏的时候经常会出现的"乱码"(mojibake)
<pre class="example">
&gt;&gt;&gt; import sys;print(sys.version_info)
sys.version_info(major=3, minor=6, micro=1, releaselevel='final', serial=0)
&gt;&gt;&gt; octets = b'Montr\xe9al'
&gt;&gt;&gt; octets.decode('cp1252')
'Montréal'
&gt;&gt;&gt; octets.decode('koi8_r')
'MontrИal'
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5-3" class="outline-4">
<h4 id="sec-4-5-3">SyntxtError When Loading Modules with Unexpected Encoding</h4>
<div class="outline-text-4" id="text-4-5-3">
<ul class="org-ul">
<li>对于python2来说,其默认的source encoding是ASCII
</li>
<li>对于python3来说,其默认的source encoding是UTF-8
</li>
<li>无论是ASCII还是UTF-8,都不是那种所有的binary sequence都认的,所以如果有一个
python module里面的byte sequence无法被UTF-8编码所认识(同时你又没有指定编码
格式)的时候,你就会得到如下的message
<pre class="example">
SyntaxError: Non-UTF-8 code starting with '\xe1' in file ola.py on line
     1, but no encoding declared; see http://python.org/dev/peps/pep-0263/
     for details
</pre>
</li>
<li>鉴于unix下面编辑器都是以UTF-8格式编码,一个可能出现上述问题的原因是你在windows
上面使用cp1252来对自己的源代码进行了encode,而但我们使用decode的时候,默认使
用了UTF-8,当然会出错.对此,一个可行的解决方案是在代码最上面写上
<div class="org-src-container">

<pre class="src src-python"><span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">coding: cp1252</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5-4" class="outline-4">
<h4 id="sec-4-5-4">How to Discover the Encoding of a Byte Sequence</h4>
<div class="outline-text-4" id="text-4-5-4">
<ul class="org-ul">
<li>如何能够得知某个byte sequence(binary)的编码格式呢?答案是你不能!一个byte sequence
有可能就只是二进制执行的机器代码,如果是某种text编码而来,你获知的方法只能是被告知
</li>
<li>如果在没有被告知的情况下,我们可以根据binary里面字符的分布状况来猜编码格式
当然了,有程序猜的比我们更准确,那就是chardet(Universal Character Encoding
Detector)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5-5" class="outline-4">
<h4 id="sec-4-5-5">BOM: A Useful Gremin</h4>
<div class="outline-text-4" id="text-4-5-5">
<ul class="org-ul">
<li>由于UTF-16和UTF-32都使用了超过一个Byte的组合(两个或者四个)来表示一个char,
这种情况下就会涉及到计算机有两种体系:
<ul class="org-ul">
<li>little endian
</li>
<li>big endian
</li>
</ul>
</li>
<li>为了区分这两种endian,utf-16和utf-32都不得不在自己编码的最前面加上BOM来表示
自己的endian:
<ul class="org-ul">
<li>对于little endian来说就是'\xff\xfe'
</li>
<li>对于big endian来说就是'\xff\xff'
</li>
</ul>
</li>
<li>UTF-8的一个巨大的优势就是无论endian怎样(endian只是对binary来说有意义),从某
种text产生的byte sequence都是一样的
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">Handling Text Files</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li>处理text的最佳实践是Unicode sandwich,包含三个要求(都是在python3的语境里面讨
论的):
<ul class="org-ul">
<li>input的时候,bytes要尽早的转换成str
</li>
<li>三明治的meat部分,就是你的business logic,而你的business logic要完全的使用
str object来完成.在你的business logic里面你不应该做任何的encode和decode操
作
</li>
<li>output的时候,str要尽可能晚的转换成bytes
</li>
</ul>
</li>
<li>所有的python web framework都执行了这个最佳实践,所以你在Django里面只需要处理
str就可以了
</li>
<li>你需要注意的一个问题是,在你存储的时候,会强制你设置encoding,在你读取的时候,
虽然不强制你设置encoding,但是你最好设置,因为你不设置的话,会使用当前系统默认
的encoding,比如在Windows上面就是cp1252,会出现如下的bug(在系统默认encoding是
utf-8的情况下不会发生)
<pre class="example">
&gt;&gt;&gt; open('cafe.txt', 'w', encoding='utf_8').write('café') 4
&gt;&gt;&gt; open('cafe.txt').read()
'cafÃ©'
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7">Normalizing Unicode for Saner Comparisons</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8">Case Folding</h3>
<div class="outline-text-3" id="text-4-8">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-9" class="outline-3">
<h3 id="sec-4-9">Sorting Unicode Text</h3>
<div class="outline-text-3" id="text-4-9">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-10" class="outline-3">
<h3 id="sec-4-10">The Unicode Database</h3>
<div class="outline-text-3" id="text-4-10">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-11" class="outline-3">
<h3 id="sec-4-11">Dual-Mode str and bytes APIs</h3>
<div class="outline-text-3" id="text-4-11">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 05: First-Class Functions</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>在python里面,function是first-class object,所谓first-class object具有如下特质:
<ul class="org-ul">
<li>可以在runtime创建
</li>
<li>可以赋值给一个variable,或者是data structure里面的variable
</li>
<li>可以作为一个argument传递给function
</li>
<li>可以作为一个result从function返回
</li>
</ul>
</li>
<li>作为参照,我们可以列出除了function以外,python里面其他的first-class object:
<ul class="org-ul">
<li>integer
</li>
<li>string
</li>
<li>dictionary
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Treating a Function Like an Object</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>首先看一个简单的例子,从这个例子中,我们可以看到,python的function其实就是object
它是class function的一个object,还可以有自己的attribute,比如__doc__
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">factorial</span><span style="color: #2aa198;">(</span>n<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #2aa198;">'''return n!'''</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> 1 <span style="color: #859900; font-weight: bold;">if</span> n &lt; 2 <span style="color: #859900; font-weight: bold;">else</span> n * factorial<span style="color: #2aa198;">(</span>n-1<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>factorial<span style="color: #b58900;">(</span>42<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>factorial.<span style="color: #657b83; font-weight: bold;">__doc__</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">type</span><span style="color: #b58900;">(</span>factorial<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1405006117752879898543142606244511569936384000000000</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">return n!</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;class 'function'&gt;</span>
</pre>
</div>
</li>
<li>下面的例子,证明了function object的"first class"特性
<pre class="example">
&gt;&gt;&gt; fact = factorial
&gt;&gt;&gt; fact(5)
120
&gt;&gt;&gt; map(factorial, range(11))
&lt;map object at 0x10ea31c50&gt;
&gt;&gt;&gt; list(map(factorial, range(11)))
[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]
</pre>
</li>
<li>前面说过的"first class"特性都一一满足:
<ul class="org-ul">
<li>因为function是在console session里面创建的,所以是在runtime创建的
</li>
<li>成功赋值给变量fact
</li>
<li>函数fact作为map的参赛
</li>
<li>可以赋值给变量,就一定能作为返回值返回
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Higher-Order Functions</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>如果一个函数把一个function作为参数,或者是返回一个function作为返回值,那么这个
函数就叫做higher-order function.
</li>
<li>上面例子中的map就是一个higher-oder函数,它总是会要求一个参数为function
</li>
<li>另外一个例子就是sorted,它有一个optional的参赛key,如果传入的话,就必须是一个
function
<pre class="example">
&gt;&gt;&gt; fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana']
&gt;&gt;&gt; sorted(fruits, key=len)
['fig', 'apple', 'cherry', 'banana', 'raspberry', 'strawberry']
</pre>
</li>
<li>这里我们使用的是len()作为key,其实所有的one-argument函数都可以作为key,比如我
们下面定义一个函数reverse,只有一个参数(当然参数就是sorted的list里面的内容啦)
<pre class="example">
&gt;&gt;&gt; def reverse(word):
...     return word[::-1]
...
&gt;&gt;&gt; reverse('testing')
'gnitset'
&gt;&gt;&gt; sorted(fruits, key=reverse)
['banana', 'apple', 'fig', 'raspberry', 'strawberry', 'cherry']
</pre>
</li>
<li>原来在python里面常见的"符合函数式编程要求"的higher-order function有:
<ul class="org-ul">
<li>map
</li>
<li>filter
</li>
<li>reduce
</li>
<li>apply(在python3里面已经被移除)
</li>
</ul>
</li>
<li>这些函数虽然看起来很"函数式"但是并不是python3的追求(可能过于的函数式),对python
来说,更好的替代品listcomp和genexp
</li>
</ul>
</div>
<div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1">Modern Replacements for map, filter, and reduce</h4>
<div class="outline-text-4" id="text-5-2-1">
<ul class="org-ul">
<li>map, reduce, filter是函数式编程比较核心的几个函数,python在原来也提供了名字
完全一致的内置函数,但是后来发现这种方法不是很pythonic:因为需要函数式编程的
知识,代码理解起来才不那么费劲
</li>
<li>从python3开始,我们使用liscomp和genexp来替代map和reduce,它们是python的常见
语法,而且更加的readable:
<ul class="org-ul">
<li>listcomp就可以完全的替代map
<pre class="example">
&gt;&gt;&gt; list(map(fact, range(6)))
[1, 1, 2, 6, 24, 120]
&gt;&gt;&gt; [fact(n) for n in range(6)]
[1, 1, 2, 6, 24, 120]
</pre>
</li>
<li>原来需要filter并且外加lambda的情况,我们还是通过一个简单的if加listcomp就解决了
<pre class="example">
&gt;&gt;&gt; list(map(factorial, filter(lambda n: n % 2, range(6))))
[1, 6, 120]
&gt;&gt;&gt; [factorial(n) for n in range(6) if n % 2]
[1, 6, 120]
</pre>
</li>
</ul>
</li>
<li>这里需要注意的是我们是python3,所以我们map,filter的返回值是一个generator
<pre class="example">
&gt;&gt;&gt; import sys; print('=====Current Python Version: %s.%s=====' % (sys.version_info.major, sys.version_info.minor))
=====Current Python Version: 3.6=====
&gt;&gt;&gt; map(fact, range(6))
&lt;map object at 0x10ea35160&gt;
</pre>
</li>
<li>而在python2时代,map, filter的返回值都是一个list
<pre class="example">
&gt;&gt;&gt; import sys; print('=====Current Python Version: %s.%s=====' % (sys.version_info.major, sys.version_info.minor))
=====Current Python Version: 2.7=====
&gt;&gt;&gt; map(fact, range(6))
[1, 1, 2, 6, 24, 120]
</pre>
</li>
<li>reduce在python2里面曾经也是一个built-in的函数,和map的地位一样
<pre class="example">
&gt;&gt;&gt; import sys; print('=====Current Python Version: %s.%s=====' % (sys.version_info.major, sys.version_info.minor))
=====Current Python Version: 2.7=====
&gt;&gt;&gt; from operator import add
&gt;&gt;&gt; reduce(add, range(101))
5050
</pre>
</li>
<li>在python3里面,reduce的地位下降了,不再是built-in的函数,而是一个functools
module里面的成员函数,需要import才能使用.原因还是因为python不想太functional
本来sum()就能完成的工作,不要再麻烦reduce啦
<pre class="example">
&gt;&gt;&gt; import sys; print('=====Current Python Version: %s.%s=====' % (sys.version_info.major, sys.version_info.minor))
=====Current Python Version: 3.6=====
&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; from operator import add
&gt;&gt;&gt; reduce(add, range(101))
5050
&gt;&gt;&gt; sum(range(101))
5050
</pre>
</li>
<li>其实reduce的核心思想就是把sequence of values变成一个value,除了sum以外,python
中还有两个built-in的函数有类似的功能:
<ul class="org-ul">
<li>all(iterable):如果iterable里面的每个参数都是true,那么就返回true,注意all([])
也返回True
<pre class="example">
&gt;&gt;&gt; all([1, 2, 3, 4])
True
&gt;&gt;&gt; all([True, 0])
False
&gt;&gt;&gt; all([0,0])
False
&gt;&gt;&gt; all([])
True
</pre>
</li>
<li>any(iterable):如果iterable里面有一个参数是true,那么就返回true,注意any([])
返回False
<pre class="example">
&gt;&gt;&gt; any([1, 0, 0, 0])
True
&gt;&gt;&gt; any([0, False])
False
&gt;&gt;&gt; any([])
False
</pre>
</li>
</ul>
</li>
<li>对于higher-order函数来说,创建一些小的,只用一次的函数的需求非常常见,这也就是
anonymous function存在的理由,后面我们会详细讲述匿名函数
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Anonymous Functions</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>匿名函数在java等语言里面也有出现,其就是所谓"只用一次"的函数,在python里面,
"一次性"函数的创建方法是加一个lambda关键字
</li>
<li>python的lambda创建出来的"一次性函数"和普通的函数是有区别的,区别在于
<pre class="example">
lambda function的函数体必须是pure expressions的,换句话说在这个函数
体里面,不能有赋值,也不能使用其他的python statement,比如while, try
</pre>
</li>
<li>鉴于lambda的这种局限性,一般只有在做higher-order函数的参数的时候,才会使用这
种形式
<pre class="example">
&gt;&gt;&gt; fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana']
&gt;&gt;&gt; sorted(fruits, key=lambda word: word[::-1])
['banana', 'apple', 'fig', 'raspberry', 'strawberry', 'cherry']
</pre>
</li>
<li>lambda syntax其实只是一种语法糖,完全可以使用def来替代.lambda准确的说是一种
callable object,在python中还有很多这样的object,我们下面来介绍
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">The Sevent Flavors of Callable Objects</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>前面说了,lambda其实只是一种callable object,python专门有个built-in的function
来判断"一个object是不是一个callable object"
<pre class="example">
&gt;&gt;&gt; i = 23
&gt;&gt;&gt; callable(i)
False
&gt;&gt;&gt; callable(lambda word: word)
True
</pre>
</li>
<li>python的data model文档里面,一共列出了存在于python的总共七种的callable type列
举如下,需要注意下面的function和method的区别(function是不属于任何class的,而
method是属于某个class的):
<ul class="org-ul">
<li>User-defined function:在非class的区域使用def或者lambda定义的function
</li>
<li>Built-in method: 全局的function,使用c语言实现,比如len()
</li>
<li>Built-in method: 定义在内置class里面的method,使用c语言实现,比如dict.get
</li>
<li>Method: 定义在普通class里面的的method,使用python实现的,而不是那些c实现的
</li>
<li>Class: python里面class创建一个instance的过程,其实是一个"被调用"的过程,这个
过程会首先调用__new__method来创建一个instance,然后调用__init__来填充内存
里面的各个域.因为没有new operator,所以在python里面实例化就是通过calling
class
<pre class="example">
&lt;class 'str'&gt;
&gt;&gt;&gt; callable(str)
True
</pre>
</li>
<li>Class instance: 如果一个class定义了__call__ method,那么这个class创建出来
的instance也是可以像function一样被调用的
</li>
<li>Generator functions: 如果一个function或者method使用了yield关键字,那么它的
返回值就必然是一个generator object,这种情况下,这个function叫做generator
function. 其实说generator function可以callable,倒不如说是generator function
的返回值generator object callable.而generator object之所以能够callable,其
奥秘在于yield: yield是类似return的东西,但是它并不是返回,而是进行下一次循
环,更重要的是yield是在调用的时候才去执行!这点非常重要,后面我们会讲到,先列
一个简单的例子
<div class="org-src-container">

<pre class="src src-python"><span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">a generator function that yeilds items instead of returning a list</span>
<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">firstn</span><span style="color: #2aa198;">(</span>n<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">num</span> = 0
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">while</span> num &lt; n:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">yield</span> num
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">num</span> += 1


<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">sum</span><span style="color: #b58900;">(</span>firstn<span style="color: #268bd2;">(</span>1000000<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>     <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">too big to put the list in the memory</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">499999500000</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">User-Defined Callable Types</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li>并不是只有Python function才可以被调用,任何其他的python object在设置一下以后
都可以被调用,这个设置就是实现__call__ instance method
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">import</span> random

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">BingoCage</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, items<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">self</span>._items = <span style="color: #657b83; font-weight: bold;">list</span><span style="color: #2aa198;">(</span>items<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   random.shuffle<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>._items<span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">pick</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">try</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>._items.pop<span style="color: #2aa198;">()</span>
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">except</span> <span style="color: #b58900;">IndexError</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">raise</span> <span style="color: #b58900;">LookupError</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'pick from empty BingoCage'</span><span style="color: #2aa198;">)</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__call__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.pick<span style="color: #2aa198;">()</span>

<span style="color: #268bd2;">bingo</span> = BingoCage<span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">range</span><span style="color: #b58900;">(</span>3<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>bingo.pick<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>bingo<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">callable</span><span style="color: #b58900;">(</span>bingo<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">True</span>
</pre>
</div>
</li>
<li>上面的这个例子略显生硬,因为一个object干啥要把自己变得callable啊,要有原因,要
有动力.在python里面,最有动力把自己(一个object)变成callable的原因是:在不同的
调用(被call)之间能够保存某些state
<pre class="example">
A class implementing __call__ is an easy way to create function-like
objects that have some internal state that must be kept across invocations
</pre>
</li>
<li>python当中,一个这样的例子就是class decorator(不是普通的decorator)
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">counted</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #2aa198;">""" counts ho often a function is called """</span>

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, func<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">self</span>.func = func
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">self</span>.counter = 0

<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__call__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, *args, **kwargs<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">self</span>.counter += 1
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.func<span style="color: #2aa198;">(</span>*args, **kwargs<span style="color: #2aa198;">)</span>


<span style="color: #b58900;">@counted</span>
<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">something</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">pass</span>


<span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>10<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   something<span style="color: #2aa198;">()</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>something.counter<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">10</span>
</pre>
</div>
</li>
<li>我们知道,普通的函数就可以作为decorator,为什么要有class decorator呢?就是我们
前面说的,我们希望能够保持一点inernal state(比如,调用次数),那么函数是做不到的,
class 的class member可以做到(在不同的instance之间记录调用次数).下一步就是让
我们的class生成的instance callable,使用的就是实现__call__ special method
</li>
<li>closure也可以做到function with internal state,我们后面会介绍
</li>
</ul>
</div>
<div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1">Function Introspection</h4>
<div class="outline-text-4" id="text-5-5-1">
<ul class="org-ul">
<li>除了__doc__以外,function object还有很多其他的属性(attribute)
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">factorial</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">pass</span>

<span style="color: #859900; font-weight: bold;">for</span> one <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #657b83; font-weight: bold;">dir</span><span style="color: #2aa198;">(</span>factorial<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>one<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__annotations__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__call__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__class__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__closure__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__code__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__defaults__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__delattr__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__dict__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__dir__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__doc__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__eq__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__format__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__ge__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__get__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__getattribute__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__globals__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__gt__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__hash__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__init__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__init_subclass__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__kwdefaults__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__le__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__lt__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__module__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__name__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__ne__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__new__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__qualname__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__reduce__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__reduce_ex__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__repr__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__setattr__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__sizeof__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__str__</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">__subclasshook__</span>
</pre>
</div>
</li>
<li>我们挑几个重点的来看一下,比如,让function更像个object的属性__dict__.这个属性
其实就是一个真的字典,初始值是空{},每个instance都有,我们先看个简单的,非function
的instance
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">User</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, name<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">self</span>.name = name
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">display</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.name<span style="color: #2aa198;">)</span>

<span style="color: #268bd2;">u</span> = User<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Alice'</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>u.__dict__<span style="color: #2aa198;">)</span>
u.display<span style="color: #2aa198;">()</span>
<span style="color: #268bd2;">u.name</span> = <span style="color: #2aa198;">'Bill'</span>
u.display<span style="color: #2aa198;">()</span>

<span style="color: #268bd2;">u.age</span> = 23
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>u.name, u.age<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>u.__dict__<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">print(u.__dict__)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Alice</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Bill</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Bill 23</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{'name': 'Bill', 'age': 23}</span>
</pre>
</div>
</li>
<li>function也是一种instance(class function的instance),所以,也能有自己的__dic__,
所以也可以使用这个字典,虽然看起来有点奇怪
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">upper_case_name</span><span style="color: #2aa198;">(</span>obj<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">return</span> obj.upper<span style="color: #2aa198;">()</span>

<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>upper_case_name.__dict__<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">upper_case_name.short_description</span> = <span style="color: #2aa198;">'Customer name'</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>upper_case_name.__dict__<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>upper_case_name.short_description<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{}</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{'short_description': 'Customer name'}</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Customer name</span>
</pre>
</div>
</li>
<li>好了,我们再来看看function拥有,而普通的user-defined instance没有的属性
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">C</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">pass</span>
<span style="color: #268bd2;">obj</span> = C<span style="color: #2aa198;">()</span>
<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">func</span><span style="color: #2aa198;">()</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">pass</span>

<span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">sorted</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">set</span><span style="color: #268bd2;">(</span><span style="color: #657b83; font-weight: bold;">dir</span><span style="color: #6c71c4;">(</span>func<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> - <span style="color: #657b83; font-weight: bold;">set</span><span style="color: #268bd2;">(</span><span style="color: #657b83; font-weight: bold;">dir</span><span style="color: #6c71c4;">(</span>obj<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">['__annotations__', '__call__', '__closure__', '__code__',</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">'__defaults__', '__get__', '__globals__', '__kwdefaults__',</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">'__name__', '__qualname__']</span>
</pre>
</div>
</li>
<li>我们来总结下这些个属性
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Name</th>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">__annotations__</td>
<td class="left">dict</td>
<td class="left">Parameter and return annotations</td>
</tr>

<tr>
<td class="left">__call__</td>
<td class="left">method-wrapper</td>
<td class="left">Implementation of the () operator</td>
</tr>

<tr>
<td class="left">__closure__</td>
<td class="left">tuple</td>
<td class="left">function closure, bindings for free variables</td>
</tr>

<tr>
<td class="left">__code__</td>
<td class="left">code</td>
<td class="left">function metadata and function body compiled into bytecode</td>
</tr>

<tr>
<td class="left">__defaults__</td>
<td class="left">tuple</td>
<td class="left">default values for the formal parameters</td>
</tr>

<tr>
<td class="left">__get__</td>
<td class="left">method-wrapper</td>
<td class="left">implementation of the read-only descriptor protocol</td>
</tr>

<tr>
<td class="left">__globals__</td>
<td class="left">dict</td>
<td class="left">Global variables of the module where the function is defined</td>
</tr>

<tr>
<td class="left">__kwdefaults__</td>
<td class="left">dict</td>
<td class="left">Default values for the keyword-only formal paramters</td>
</tr>

<tr>
<td class="left">__name__</td>
<td class="left">str</td>
<td class="left">the function name</td>
</tr>

<tr>
<td class="left">__qualname__</td>
<td class="left">str</td>
<td class="left">the qualified function name, e.g. Random.choice</td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-5-2" class="outline-4">
<h4 id="sec-5-5-2">From Positional to Keyword-Only Parameters</h4>
<div class="outline-text-4" id="text-5-5-2">
<ul class="org-ul">
<li>python的一大特点就是函数参数的处理非常的方便:
<ul class="org-ul">
<li>比如一个'*'的可变参数,会把参数以tuple的形式存储在'*'后面的变量里面
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">argfunc</span><span style="color: #2aa198;">(</span>*my_args<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">type</span><span style="color: #b58900;">(</span>my_args<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>my_args<span style="color: #2aa198;">)</span>

argfunc<span style="color: #2aa198;">(</span>1, 2, 3, 4, 5<span style="color: #2aa198;">)</span>
argfunc<span style="color: #2aa198;">()</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;class 'tuple'&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">(1, 2, 3, 4, 5)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;class 'tuple'&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">()</span>
</pre>
</div>
</li>
<li>还有两个'*'的可变参数,会把参数以dict的形式存储在'**'后面的变量里面
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">argDict</span><span style="color: #2aa198;">(</span>**my_args<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">type</span><span style="color: #b58900;">(</span>my_args<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>my_args<span style="color: #2aa198;">)</span>

argDict<span style="color: #2aa198;">(</span>a = <span style="color: #2aa198;">'one'</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;class 'dict'&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{'a': 'one'}</span>
</pre>
</div>
</li>
<li>当然了,更多的源代码会把两者结合起来使用,也就是源代码里面随处可见的*args, **kwargs
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">test</span><span style="color: #2aa198;">(</span>*args, **kwargs<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>args<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>kwargs<span style="color: #2aa198;">)</span>

test<span style="color: #2aa198;">(</span>1, 2, a= 23<span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">(1, 2)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{'a': 23}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>在python3里面,这种便利性得到了进一步的提高,因为python3引入了keyword-only
argument
</li>
<li>keyword-only argument在python3里面才出现,其出现是为了弥补单'*'和双'*'参数
的一个缺陷:无法处理python的关键字作为dict的参数,看例子
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">html_tag</span><span style="color: #2aa198;">(</span>*args, **kwargs<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>args<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>kwargs<span style="color: #2aa198;">)</span>


html_tag<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'div'</span>, <span style="color: #2aa198;">'hello'</span>, name=<span style="color: #2aa198;">"img"</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">###############################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">SyntaxError: invalid syntax #</span>
<span style="color: #93a1a1;">###############################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">html_tag('div', 'hello', name="img", class='sidebar')</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('div', 'hello')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{'name': 'img'}</span>
</pre>
</div>
</li>
<li>上面的例子中,如果我们想传入一个key是python关键字的情况(class),会失败,因为
python不会理解你的意思,它认为你格式错了
</li>
<li>这就是为什么我们引入了keyword-only argument,它有如下要求:
<ul class="org-ul">
<li>在单'*'后面,这个必须满足,而且单'*'必须存在
</li>
<li>在双'*'前面,这个也必须满足,但是双'*'可以不存在
</li>
</ul>
</li>
<li>针对上面的例子,单双'*'都必须有,我们的keyword-only parameter就必须在单双'*'
之间
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">html_tag</span><span style="color: #2aa198;">(</span>*args, cls=<span style="color: #268bd2; font-weight: bold;">None</span>, **kwargs<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">if</span> cls <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #268bd2; font-weight: bold;">None</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="background-color: #eee8d5;"> </span>   <span style="color: #268bd2;">kwargs</span><span style="color: #2aa198;">[</span><span style="color: #2aa198;">'class'</span><span style="color: #2aa198;">]</span> = cls
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>args<span style="color: #2aa198;">)</span>
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>kwargs<span style="color: #2aa198;">)</span>


html_tag<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'div'</span>, <span style="color: #2aa198;">'hello'</span>, name=<span style="color: #2aa198;">"img"</span><span style="color: #2aa198;">)</span>
html_tag<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'div'</span>, <span style="color: #2aa198;">'hello'</span>, cls=<span style="color: #2aa198;">'sidebar'</span>, name=<span style="color: #2aa198;">"img"</span><span style="color: #2aa198;">)</span>


<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('div', 'hello')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{'name': 'img'}</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">('div', 'hello')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{'name': 'img', 'class': 'sidebar'}</span>
</pre>
</div>
</li>
<li>其实我们的keyword-only参数并不需要如下两个条件:
<ul class="org-ul">
<li>并不一定需要双'*',如果我们只有一个dict参数的情况
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">(</span>a, *, b=2<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a, b<span style="color: #2aa198;">)</span>

f<span style="color: #2aa198;">(</span>1, b=3<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1 3</span>
</pre>
</div>
</li>
<li>我们的keyword-only参数也并不一定需要default value,只是设置了default value
会好一点,让用户知道这个是一个keyword-only参数,而不至于用错
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">(</span>a, *, b<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>a, b<span style="color: #2aa198;">)</span>

f<span style="color: #2aa198;">(</span>1, b=2<span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;">###############################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">TypeError: f() takes 1 positional argument but 2 were given #</span>
<span style="color: #93a1a1;">###############################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">f(1, 2)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">1 2</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-5-3" class="outline-4">
<h4 id="sec-5-5-3">Retrieving Information About Parameters</h4>
<div class="outline-text-4" id="text-5-5-3">
<ul class="org-ul">
<li></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
