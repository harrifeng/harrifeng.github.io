<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>gopl</title>
<!-- 2017-05-10 Wed 15:35 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">gopl</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 01: Tutorial</a>
<ul>
<li><a href="#sec-1-1">Hello, World</a></li>
<li><a href="#sec-1-2">Command-Line Arguments</a></li>
<li><a href="#sec-1-3">Finding Duplicate Lines</a></li>
<li><a href="#sec-1-4">Animated GIFs</a></li>
<li><a href="#sec-1-5">Fetching a URL</a></li>
<li><a href="#sec-1-6">Fetching URLs Concurrently</a></li>
<li><a href="#sec-1-7">A Web Server</a></li>
<li><a href="#sec-1-8">Losse Ends</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 02: Program Structure</a>
<ul>
<li><a href="#sec-2-1">Names</a></li>
<li><a href="#sec-2-2">Declarations</a></li>
<li><a href="#sec-2-3">Variables</a>
<ul>
<li><a href="#sec-2-3-1">Short Variable Declarations</a></li>
<li><a href="#sec-2-3-2">Pointers</a></li>
<li><a href="#sec-2-3-3">The new Function</a></li>
<li><a href="#sec-2-3-4">Lifetime of Variables</a></li>
</ul>
</li>
<li><a href="#sec-2-4">Assignments</a>
<ul>
<li><a href="#sec-2-4-1">Tuple Assignment</a></li>
<li><a href="#sec-2-4-2">Assignability</a></li>
</ul>
</li>
<li><a href="#sec-2-5">Type Declarations</a></li>
<li><a href="#sec-2-6">Packages and Files</a>
<ul>
<li><a href="#sec-2-6-1">Imports</a></li>
<li><a href="#sec-2-6-2">Package Initialization</a></li>
</ul>
</li>
<li><a href="#sec-2-7">Scope</a></li>
</ul>
</li>
<li><a href="#sec-3">Chapter 03: Basic Data Types</a>
<ul>
<li><a href="#sec-3-1">Integers</a></li>
<li><a href="#sec-3-2">Floating-Point Numbers</a></li>
<li><a href="#sec-3-3">Complex Numbers</a></li>
<li><a href="#sec-3-4">Booleans</a></li>
<li><a href="#sec-3-5">Strings</a>
<ul>
<li><a href="#sec-3-5-1">String Literals</a></li>
<li><a href="#sec-3-5-2">Unicode</a></li>
<li><a href="#sec-3-5-3">UTF-8</a></li>
<li><a href="#sec-3-5-4">Strings and Byte Slices</a></li>
<li><a href="#sec-3-5-5">Conversions between Strings and Numbers</a></li>
</ul>
</li>
<li><a href="#sec-3-6">Constants</a>
<ul>
<li><a href="#sec-3-6-1">The Constant Generator iota</a></li>
<li><a href="#sec-3-6-2">Untyped Constants</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">Chapter 04: Composite Types</a>
<ul>
<li><a href="#sec-4-1">Arrays</a></li>
<li><a href="#sec-4-2">Slices</a>
<ul>
<li><a href="#sec-4-2-1">The append Function</a></li>
<li><a href="#sec-4-2-2">In-Place Slice Techniques</a></li>
</ul>
</li>
<li><a href="#sec-4-3">Maps</a></li>
<li><a href="#sec-4-4">Structs</a>
<ul>
<li><a href="#sec-4-4-1">Struct Literals</a></li>
<li><a href="#sec-4-4-2">Comparing Structs</a></li>
<li><a href="#sec-4-4-3">Struct Embedding and Anonymous Fields</a></li>
</ul>
</li>
<li><a href="#sec-4-5">Json</a></li>
<li><a href="#sec-4-6">Text and HTML Templates</a></li>
</ul>
</li>
<li><a href="#sec-5">Chapter 05: Functions</a>
<ul>
<li><a href="#sec-5-1">Function Declarations</a></li>
<li><a href="#sec-5-2">Recursion</a></li>
<li><a href="#sec-5-3">Multiple Return Values</a></li>
<li><a href="#sec-5-4">Errors</a>
<ul>
<li><a href="#sec-5-4-1">Error Handling Stratgies</a>
<ul>
<li><a href="#sec-5-4-1-1">Propagate the error</a></li>
<li><a href="#sec-5-4-1-2">Transient or unpredictable problem</a></li>
<li><a href="#sec-5-4-1-3">Print the error and stop the program gracefully</a></li>
<li><a href="#sec-5-4-1-4">Just to log and then continue</a></li>
<li><a href="#sec-5-4-1-5">Sefely ignore entirely</a></li>
<li><a href="#sec-5-4-1-6">Summary</a></li>
</ul>
</li>
<li><a href="#sec-5-4-2">End of File (EOF)</a></li>
</ul>
</li>
<li><a href="#sec-5-5">Function Values</a></li>
<li><a href="#sec-5-6">Anonymous Functions</a>
<ul>
<li><a href="#sec-5-6-1">Caveat: Capturing Iteration Variables</a></li>
</ul>
</li>
<li><a href="#sec-5-7">Variadic Functions</a></li>
<li><a href="#sec-5-8">Deferred Function Calls</a></li>
<li><a href="#sec-5-9">Panic</a></li>
<li><a href="#sec-5-10">Recover</a></li>
</ul>
</li>
<li><a href="#sec-6">Chapter 06: Methods</a>
<ul>
<li><a href="#sec-6-1">Method Declarations</a></li>
<li><a href="#sec-6-2">Methods with a Pointer Receiver</a>
<ul>
<li><a href="#sec-6-2-1">Nil Is a Valid Receiver Value</a></li>
</ul>
</li>
<li><a href="#sec-6-3">Composing Types by Struct Embedding</a></li>
<li><a href="#sec-6-4">Method Values and Expressions</a></li>
<li><a href="#sec-6-5">Example: Bit Vector Type</a></li>
<li><a href="#sec-6-6">Encapsulation</a></li>
</ul>
</li>
<li><a href="#sec-7">Chapter 07: Interfaces</a>
<ul>
<li><a href="#sec-7-1">Interfaces as Contracts</a></li>
<li><a href="#sec-7-2">Interface Types</a></li>
<li><a href="#sec-7-3">Interface Satisfaction</a></li>
<li><a href="#sec-7-4">Parsing Flags with flag.Value</a></li>
<li><a href="#sec-7-5">Interface Values</a>
<ul>
<li><a href="#sec-7-5-1">Caveat: An Interface Containing a Nil Pointer Is Non-Nil</a></li>
</ul>
</li>
<li><a href="#sec-7-6">Sorting with sort.Interface</a></li>
<li><a href="#sec-7-7">The http.Handler Interface</a></li>
<li><a href="#sec-7-8">The error Interface</a></li>
<li><a href="#sec-7-9">Example: Expression Evaluator</a></li>
<li><a href="#sec-7-10">Type Assertions</a></li>
<li><a href="#sec-7-11">Discriminating Errors with Type Assertions</a></li>
<li><a href="#sec-7-12">Querying Behaviors with Interface Type Assertions</a></li>
<li><a href="#sec-7-13">Type Switches</a></li>
<li><a href="#sec-7-14">Example: Token-Based XML Decoding</a></li>
<li><a href="#sec-7-15">A Few Words of Advice</a></li>
</ul>
</li>
<li><a href="#sec-8">Chapter 08: Goroutines and Channels</a>
<ul>
<li><a href="#sec-8-1">Goroutines</a></li>
<li><a href="#sec-8-2">Example: Concurrent Clock Server</a></li>
<li><a href="#sec-8-3">Example: Concurrent Echo Server</a></li>
<li><a href="#sec-8-4">Channels</a>
<ul>
<li><a href="#sec-8-4-1">Unbuffered Channels</a></li>
<li><a href="#sec-8-4-2">Pipelines</a></li>
<li><a href="#sec-8-4-3">Unidirectional Channel Types</a></li>
<li><a href="#sec-8-4-4">Buffered Channels</a></li>
</ul>
</li>
<li><a href="#sec-8-5">Looping in Parallel</a></li>
<li><a href="#sec-8-6">Example: Concurrent Web Crawler</a></li>
<li><a href="#sec-8-7">Multiplexing with select</a></li>
<li><a href="#sec-8-8">Example: Concurrent Directory Traversal</a></li>
<li><a href="#sec-8-9">Cancellation</a></li>
<li><a href="#sec-8-10">Example: Chat Server</a></li>
</ul>
</li>
<li><a href="#sec-9">Chapter 09: Concurrency with Shared Variables</a>
<ul>
<li><a href="#sec-9-1">Race Conditions</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 01: Tutorial</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Hello, World</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>下面就是go的helloworld代码
<a href="https://play.golang.org/p/pEydfiFPIs">https://play.golang.org/p/pEydfiFPIs</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Hello, &#19990;&#30028;"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hello, &#19990;&#30028;</span>
</pre>
</div>
</li>
<li>go是编译语言, go toolchain会把源代码以及源代码依赖的库转换成native machine
language.
</li>
<li>编译的方法是使用命令go 加上一些subcommand,最简单的subcommand就是run, 比如上
面的代码就是使用go run获得的OUTPUT
<div class="org-src-container">

<pre class="src src-sh">$ go run main.go
Hello, &#19990;&#30028;
</pre>
</div>
</li>
<li>go内部支持Unicode,所以他可以处理世界上的所有语言
</li>
<li>另外一个常见的sucommand就是build, go build可以把源代码编译成一个executable
binary file
</li>
<li>go的代码是以package的形式进行组织的.一个package包含一个或者多个.go文件,并且
被定义在同一个文件夹下面
</li>
<li>每一个文件都要以package开头,上面的例子是以package main开头,指的是main package
</li>
<li>go的standard libray有超过100个package,比如fmt,这个package就包含input,output
等的函数
</li>
<li>package main是一个test的package,只有它是表示了自己是standalone executable文
件其他所有的package都是代表library
</li>
<li>在package main内部, 函数main也是特别的,它是表示了executable文件开始的地方
</li>
<li>你必须同时告诉编译器,你需要哪些package,告诉编译器的方式就是import. 我们的
hello-world程序只使用了一个其他package的function,但是一般来说都会import多个
package
</li>
<li>go要求你只能import"刚刚好的"package,import没有被用到的package会导致编译失败
</li>
<li>function declaration包括了如下的几个部分:
<ul class="org-ul">
<li>func关键字
</li>
<li>函数的名字(这里是main)
</li>
<li>函数的参赛list(这里是空)
</li>
<li>函数的返回值list(这里也是空)
</li>
</ul>
</li>
<li>Go不要求statement结尾的分好,除非多个语句出现在同一行.在内部,其实编译器是如
下处理的:
<pre class="example">
If the newline comes after a token that could end a statement, insert a semicolon
</pre>
</li>
<li>这也就解释了为什么为什么'{'不能单独一行,因为, 如果'{'单独一行的话,'{'之前的
语句之后就会被加上一个分号,如下f()后面会有一个分号
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">if</span> i &lt; <span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span>                      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">wrong</span>
<span style="color: #2aa198;">{</span>                               <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">wrong</span>
        <span style="color: #268bd2;">g</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>Go语言对格式的要求非常严格,你需要对自己的代码运行gofmt来保证其格式.这也是一
个在工程上来讲特别有效的做法.你可以设置每次save的时候都gofmt一遍以便保证自己
格式的正确性
</li>
<li>一个不在standard distribution里面的命令是goimports,goimports可以同时起到如
下两个作用:
<ul class="org-ul">
<li>gofmt
</li>
<li>import 必要的package
</li>
</ul>
</li>
<li>我们可以使用如下的命令来安装goimports
<div class="org-src-container">

<pre class="src src-sh">$ go get golang.org/x/tools/cmd/goimports
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Command-Line Arguments</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>和c语言类似,我们的go exe文件需要在运行之初获得一些参数,这些参数在go里面是存
放在变量Args里面的,而这个变量是package os暴露出来的,所以这个变量叫做os.Args
</li>
<li>os.Args的类型是string slice. 而你现在可以把它理解为一个string"变长数组".这样
一来os.Args就和Java里面的args差不多了:
<ul class="org-ul">
<li>os.Args表示exe自己
</li>
<li>os.Args[1:len(os.Args)]表示剩下的参数. Go使用类似python的数组表达方式,所
以可以不加':'后面的数字,默认就是剩下所有.所以os.Args[1:len(os.Args)]和
Args[1:]完全等价
</li>
</ul>
</li>
<li>下面是一个使用go来重写unix的echo函数的例子
<a href="https://play.golang.org/p/0CjFBMUrTG">https://play.golang.org/p/0CjFBMUrTG</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Echo1 prints its command-line arguments.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> s, sep string
        <span style="color: #859900; font-weight: bold;">for</span> i := 1; i &lt; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>os.Args<span style="color: #b58900;">)</span>; i++ <span style="color: #b58900;">{</span>
                s += sep + os.Args<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>
                sep = <span style="color: #2aa198;">" "</span>
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ go run main.go a b c d   E   f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">a b c d E f</span>
</pre>
</div>
</li>
<li>上面是比较c的方式来实现我们的逻辑,其实还有更加go的方式,那就是使用range函数:
range函数是非常特殊的一种函数,它返回两个值(所以必须使用`:`), 第一个值是index
而第二个值是value,我们只需要value,所以第一个值可以使用`_`占位符,例子如下
<a href="https://play.golang.org/p/vhKc6nYNNT">https://play.golang.org/p/vhKc6nYNNT</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Echo2 prints its command-line arguments.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        s, sep := <span style="color: #2aa198;">""</span>, <span style="color: #2aa198;">""</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, arg := <span style="color: #859900; font-weight: bold;">range</span> os.Args<span style="color: #b58900;">[</span>1:<span style="color: #b58900;">]</span> <span style="color: #b58900;">{</span>
                s += sep + arg
                sep = <span style="color: #2aa198;">" "</span>
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个版本的代码中,使用了short variable declaration来"声明并且初始化了"s和sep
这种方法使用了':',初始化一个变量有很多种方法,如下的四种方法都是等价的.
<div class="org-src-container">

<pre class="src src-go">s := <span style="color: #2aa198;">""</span>
<span style="color: #859900; font-weight: bold;">var</span> s string
<span style="color: #859900; font-weight: bold;">var</span> s = <span style="color: #2aa198;">""</span>
<span style="color: #859900; font-weight: bold;">var</span> s string = <span style="color: #2aa198;">""</span>
</pre>
</div>
</li>
<li>第一种也就是short variable declaration是最简洁的,但是它"只能用在function里面"
不能用于package-level的变量
</li>
<li>第二种方法之所以和其他等价,在于go的string的默认初始化值就是"",没有这个前提
是无法推导出等价的
</li>
<li>第三种格式用的时候不多
</li>
<li>第四种的用法把string也列出来带来,显得有些多余,但是在某些时候是必须的
</li>
<li>总结起来就是,前两种方法分别用在function里面和function外面.
</li>
<li>和java语言类似,string在go里面也是immutable的,所以上面两个例子接连在循环中append
字符给s可能会造成性能方面的缺失.解决的办法是下面的例子:使用strings package里
面的Join函数(大写函数为public函数)
<a href="https://play.golang.org/p/XylG_RKQ7Z">https://play.golang.org/p/XylG_RKQ7Z</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Echo3 prints its command-line arguments.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"strings"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>strings.<span style="color: #268bd2;">Join</span><span style="color: #268bd2;">(</span>os.Args<span style="color: #6c71c4;">[</span>1:<span style="color: #6c71c4;">]</span>, <span style="color: #2aa198;">" "</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Finding Duplicate Lines</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>Unix有个命令叫做uniq,就是把"相邻"的重复行给找出来.注意只是能找"相邻"重复的行
所以在使用的时候要使用sort命令,把重复的行都排在一块.如下是sort和uniq配合使用
的例子
<div class="org-src-container">

<pre class="src src-sh">i309511@ tmp <span style="color: #2aa198;">(</span>master<span style="color: #2aa198;">)</span> $ cat test.txt
A good idea
Below everage
Below everage
Below everage
Custom Issue
Below everage
Below everage
Custom Issue
Custom Issue
Custom Issue
A good idea
i309511@ tmp <span style="color: #2aa198;">(</span>master<span style="color: #2aa198;">)</span> $ sort test.txt
A good idea
A good idea
Below everage
Below everage
Below everage
Below everage
Below everage
Custom Issue
Custom Issue
Custom Issue
Custom Issue
i309511@ tmp <span style="color: #2aa198;">(</span>master<span style="color: #2aa198;">)</span> $ uniq test.txt
A good idea
Below everage
Custom Issue
Below everage
Custom Issue
A good idea
i309511@ tmp <span style="color: #2aa198;">(</span>master<span style="color: #2aa198;">)</span> $ sort test.txt | uniq
A good idea
Below everage
Custom Issue
i309511@ tmp <span style="color: #2aa198;">(</span>master<span style="color: #2aa198;">)</span> $ sort test.txt | uniq -c
   2 A good idea
   5 Below everage
   4 Custom Issue
</pre>
</div>
</li>
<li>下面就是模仿uniq -c的演示程序dup,我们先来看看第一个版本dup1
<a href="https://play.golang.org/p/sas2jcgPuH">https://play.golang.org/p/sas2jcgPuH</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Dup1 prints the text of each line that appears more than</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">once in the standard input, preceded by its count.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"bufio"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        counts := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        input := bufio.<span style="color: #268bd2;">NewScanner</span><span style="color: #b58900;">(</span>os.Stdin<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> input.<span style="color: #268bd2;">Scan</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                counts<span style="color: #268bd2;">[</span>input.<span style="color: #268bd2;">Text</span><span style="color: #6c71c4;">()</span><span style="color: #268bd2;">]</span>++
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: ignoring potential errors from input.Err()</span>
        <span style="color: #859900; font-weight: bold;">for</span> line, n := <span style="color: #859900; font-weight: bold;">range</span> counts <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> n &gt; 1 <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"%d\t%s\n"</span>, n, line<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">go run main.go</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">hello</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">hello</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">world</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">world</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">world</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">we</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2       hello</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3       world</span>
</pre>
</div>
</li>
<li>借助内置的map,实现uniq变得如此的容易!我们来看看几个细节:
<ul class="org-ul">
<li>内置数据结构map,使用函数make来创建(make只能用来创建map, slice, chan三种类
型)一个empty的map. map的存，储，测三个操作的复杂度都是线性时间的
</li>
<li>map key的类型可以是所有可以使用"=="进行比较的类型,string是最常见的key,这
里的key就是string, value是int
</li>
<li>bufio.NewScanner创建了一个Scanner,所谓Scanner你理解成token array就可以了.
</li>
<li>我们这里又见到了"short variable declaratin"
<div class="org-src-container">

<pre class="src src-go">input := bufio.<span style="color: #268bd2;">NewScanner</span><span style="color: #2aa198;">(</span>os.Stdin<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>for input.Scan():这一句要注意了.这里的for,其实是起到了while (true)的作用,
因为input.Scan()会"探测"下面还有没有.如果下面还有新的一行,token.Scan
function会返回true, 否则会返回false
</li>
<li>input.Text()其实就是取出当前的token(也就是一个string)
</li>
<li>下面的for &#x2026; range是go特殊的用法了. range函数会返回两个值(key, value)的
循环. map iteration是顺序是随机的.(为了更有效的设计map结构)
</li>
<li>Printf就是跟c语言学的啦,会产生formatted output: 常见的%代表如下. 比较"新颖"
的是%v的设计:
<ul class="org-ul">
<li>如果打印的数据为字符串,那么%v就相当于%s
</li>
<li>如果打印的数据为bool,那么%v就相当于%t
</li>
<li>等等&#x2026;
</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">format</th>
<th scope="col" class="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">%d</td>
<td class="left">decimal integer</td>
</tr>

<tr>
<td class="left">%x, %o, %b</td>
<td class="left">integer in hexadecimal, octal, binary</td>
</tr>

<tr>
<td class="left">%f, %g, %e</td>
<td class="left">float-pint number</td>
</tr>

<tr>
<td class="left">%t</td>
<td class="left">boolean: true or false</td>
</tr>

<tr>
<td class="left">%c</td>
<td class="left">rune(Unicode code point)</td>
</tr>

<tr>
<td class="left">%s</td>
<td class="left">string</td>
</tr>

<tr>
<td class="left">%q</td>
<td class="left">quoted string "abc" or rune 'c'</td>
</tr>

<tr>
<td class="left">%v</td>
<td class="left">any value in a natural format</td>
</tr>

<tr>
<td class="left">%T</td>
<td class="left">type of any value</td>
</tr>

<tr>
<td class="left">%%</td>
<td class="left">literal percent sign</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>下面我们来看版本二dup2, 这个版本,可以通过有没有参数(os.Args)来决定是从文件
读入,还是从standard input读入
<a href="https://play.golang.org/p/YESysDK9_F">https://play.golang.org/p/YESysDK9_F</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Dup2 prints the count and text of lines that appear more than once</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">in the input. It reads from stdin or from a list of named files</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span><span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"bufio"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        counts := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        files := os.Args<span style="color: #b58900;">[</span>1:<span style="color: #b58900;">]</span>

        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>files<span style="color: #b58900;">)</span> == 0 <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">countLines</span><span style="color: #268bd2;">(</span>os.Stdin, counts<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, arg := <span style="color: #859900; font-weight: bold;">range</span> files <span style="color: #268bd2;">{</span>
                        f, err := os.<span style="color: #268bd2;">Open</span><span style="color: #6c71c4;">(</span>arg<span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #6c71c4;">{</span>
                                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #859900;">(</span>os.Stderr, <span style="color: #2aa198;">"dup2: %v\n"</span>, err<span style="color: #859900;">)</span>
                                <span style="color: #859900; font-weight: bold;">continue</span>
                        <span style="color: #6c71c4;">}</span>
                        <span style="color: #268bd2;">countLines</span><span style="color: #6c71c4;">(</span>f, counts<span style="color: #6c71c4;">)</span>
                        f.<span style="color: #268bd2;">Close</span><span style="color: #6c71c4;">()</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> line, n := <span style="color: #859900; font-weight: bold;">range</span> counts <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> n &gt; 1 <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"%d\t%s\n"</span>, n, line<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">countLines</span><span style="color: #2aa198;">(</span>f *<span style="color: #b58900;">os.File</span>, counts <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        input := bufio.<span style="color: #268bd2;">NewScanner</span><span style="color: #b58900;">(</span>f<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> input.<span style="color: #268bd2;">Scan</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                counts<span style="color: #268bd2;">[</span>input.<span style="color: #268bd2;">Text</span><span style="color: #6c71c4;">()</span><span style="color: #268bd2;">]</span>++
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: ignoring potential errors from input.Err()</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>函数os.Open返回两个值,第一个是我们真正想要的file的descriptor的对象(*os.File),
第二个就是一个error type用来表示这次打开文件是否成功:
<ul class="org-ul">
<li>如果err为nil,就说明成功
</li>
<li>如果err不为为nil,为某个error类型的值,那么就是打开失败了,打印错误,使用%v
然后继续这里的处理是继续,打开下一个文件
</li>
</ul>
</li>
<li>这里我们把一个map传递给了以子函数.这里我们需要对map做点解释.在go里面,有些类
型是reference的, 比较典型的就是map. 当我们使用make来创建一个map的时候,返回值
是这个map的ref(也就是指针)!当我们把ref传递给子函数的时候,即便是值传递,也不
有太多的拷贝出现!
</li>
<li>Tips:go里面的reference type有 map,slice, channel.而array则是一个value
</li>
<li>dup2是依赖了Scanner的特性,把文件都"按行"给处理成'input数组'了.这个可能是go
里面的比较方便的一个类,别的语言并不一定有.更加通用的方法是把字符串全部读入
内存,然后使用split('\n')的方法把大字符串切成'真的数组'.dup3就是这么做的
<a href="https://play.golang.org/p/7S7Q6o0Z0M">https://play.golang.org/p/7S7Q6o0Z0M</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Dup3 prints the count and text of lines that appear more than once</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">in the named input files.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"io/ioutil"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"strings"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        counts := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, filename := <span style="color: #859900; font-weight: bold;">range</span> os.Args<span style="color: #b58900;">[</span>1:<span style="color: #b58900;">]</span> <span style="color: #b58900;">{</span>
                data, err := ioutil.<span style="color: #268bd2;">ReadFile</span><span style="color: #268bd2;">(</span>filename<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #6c71c4;">(</span>os.Stderr, <span style="color: #2aa198;">"dup3: %v\n"</span>, err<span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">continue</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, line := <span style="color: #859900; font-weight: bold;">range</span> strings.<span style="color: #268bd2;">Split</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">string</span><span style="color: #6c71c4;">(</span>data<span style="color: #6c71c4;">)</span>, <span style="color: #2aa198;">"\n"</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        counts<span style="color: #6c71c4;">[</span>line<span style="color: #6c71c4;">]</span>++
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> line, n := <span style="color: #859900; font-weight: bold;">range</span> counts <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> n &gt; 1 <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"%d\t%s\n"</span>, n, line<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Animated GIFs</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>下面是一个创建"动态gif"文件的程序,其实并不需要你完全的理解创建gif的过程,只
是通过这个例子来快速了解一些golang的特性
<a href="https://play.golang.org/p/o2o2lDR3Eg">https://play.golang.org/p/o2o2lDR3Eg</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Lissajous generates GIF animations of random Lissajous figures.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"image"</span>
        <span style="color: #2aa198;">"image/color"</span>
        <span style="color: #2aa198;">"image/gif"</span>
        <span style="color: #2aa198;">"io"</span>
        <span style="color: #2aa198;">"math"</span>
        <span style="color: #2aa198;">"math/rand"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-main</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Packages not needed by version in book.</span>
<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"net/http"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+main</span>

<span style="color: #859900; font-weight: bold;">var</span> palette = <span style="color: #2aa198;">[]</span><span style="color: #b58900;">color.Color</span><span style="color: #2aa198;">{</span>color.White, color.Black<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #2aa198;">(</span>
        whiteIndex = 0 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">first color in palette</span>
        blackIndex = 1 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">next color in palette</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-main</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The sequence of images is deterministic unless we seed</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">the pseudo-random number generator using the current time.</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Thanks to Randall McPherson for pointing out the omission.</span>
        rand.<span style="color: #268bd2;">Seed</span><span style="color: #b58900;">(</span>time.<span style="color: #268bd2;">Now</span><span style="color: #268bd2;">()</span>.<span style="color: #268bd2;">UTC</span><span style="color: #268bd2;">()</span>.<span style="color: #268bd2;">UnixNano</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>os.Args<span style="color: #b58900;">)</span> &gt; 1 &amp;&amp; os.Args<span style="color: #b58900;">[</span>1<span style="color: #b58900;">]</span> == <span style="color: #2aa198;">"web"</span> <span style="color: #b58900;">{</span>
                <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+http</span>
                handler := <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">(</span>w <span style="color: #b58900;">http.ResponseWriter</span>, r *<span style="color: #b58900;">http.Request</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #268bd2;">lissajous</span><span style="color: #6c71c4;">(</span>w<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                http.<span style="color: #268bd2;">HandleFunc</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"/"</span>, handler<span style="color: #268bd2;">)</span>
                <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-http</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>http.<span style="color: #268bd2;">ListenAndServe</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"localhost:8000"</span>, <span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+main</span>
        <span style="color: #268bd2;">lissajous</span><span style="color: #b58900;">(</span>os.Stdout<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">lissajous</span><span style="color: #2aa198;">(</span>out <span style="color: #b58900;">io.Writer</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">(</span>
                cycles  = 5     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">number of complete x oscillator revolutions</span>
                res     = 0.001 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">angular resolution</span>
                size    = 100   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">image canvas covers [-size..+size]</span>
                nframes = 64    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">number of animation frames</span>
                delay   = 8     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">delay between frames in 10ms units</span>
        <span style="color: #b58900;">)</span>
        freq := rand.<span style="color: #268bd2;">Float64</span><span style="color: #b58900;">()</span> * 3.0 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">relative frequency of y oscillator</span>
        anim := gif.<span style="color: #b58900;">GIF</span><span style="color: #b58900;">{</span>LoopCount: nframes<span style="color: #b58900;">}</span>
        phase := 0.0 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">phase difference</span>
        <span style="color: #859900; font-weight: bold;">for</span> i := 0; i &lt; nframes; i++ <span style="color: #b58900;">{</span>
                rect := image.<span style="color: #268bd2;">Rect</span><span style="color: #268bd2;">(</span>0, 0, 2*size+1, 2*size+1<span style="color: #268bd2;">)</span>
                img := image.<span style="color: #268bd2;">NewPaletted</span><span style="color: #268bd2;">(</span>rect, palette<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">for</span> t := 0.0; t &lt; cycles*2*math.Pi; t += res <span style="color: #268bd2;">{</span>
                        x := math.<span style="color: #268bd2;">Sin</span><span style="color: #6c71c4;">(</span>t<span style="color: #6c71c4;">)</span>
                        y := math.<span style="color: #268bd2;">Sin</span><span style="color: #6c71c4;">(</span>t*freq + phase<span style="color: #6c71c4;">)</span>
                        img.<span style="color: #268bd2;">SetColorIndex</span><span style="color: #6c71c4;">(</span>size+<span style="color: #268bd2;">int</span><span style="color: #859900;">(</span>x*size+0.5<span style="color: #859900;">)</span>, size+<span style="color: #268bd2;">int</span><span style="color: #859900;">(</span>y*size+0.5<span style="color: #859900;">)</span>,
                                blackIndex<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                phase += 0.1
                anim.Delay = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #268bd2;">(</span>anim.Delay, delay<span style="color: #268bd2;">)</span>
                anim.Image = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #268bd2;">(</span>anim.Image, img<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        gif.<span style="color: #268bd2;">EncodeAll</span><span style="color: #b58900;">(</span>out, &amp;anim<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: ignoring encoding errors</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-main</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">go run main.go &gt; lissajous.gif                 //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>上面的程序蕴含了许多的信息,我们重点来看看这些信息:
<ul class="org-ul">
<li>我们import的很多package,虽然有时候名字是image/color两个部分组成的,但是使
用的时候,还是会使用后面的部分,比如color.White就是color package里面的, 而
gif.GIF则是image/gif package里面的
</li>
<li>const关键字是给予'常量'一个有意义的名字的.const的定义可以出现在两个地方:
<ol class="org-ol">
<li>package level(在main packge就是全局变量啦), 整个package可见
</li>
<li>function level, 只在function内部可见
</li>
</ol>
</li>
<li>const的值只可能是三种值:number, string或者boolean.这一点非常重要!
</li>
<li>类似于[]color.Color{&#x2026;}的这种表达式叫做composite literal. 我们一下子有两
个composite literal的例子:
<ol class="org-ol">
<li>[]color.Color是一个slice(长度不固定数组)!所以{}里面是数组的初始化变量,
也就是两个颜色color.Black和color.White. 这里这两个值是采用one by one的
方式列出来的
</li>
<li>gif.GIF是一个struct,所以{}里面就是类似json的一种初始化方式,也可以使用one
by one的方式,但是明显的json的方式更加友好
</li>
</ol>
</li>
<li>gif.GIF是一个struct类型,我们在c语言里面已经了解过这个类型了,这个类型的特
点是:它包括了其他的类型,把他们"包裹"起来,形成一个新的类型.换句话说就是用户
自创类型.在cpp里面struct关键字等于是public的class,由此我们也可以看出go使用
这个关键字的一点点端倪:所有的struct field都可以直接访问!
</li>
<li>前面说过了,我们使用composite literal的方式,提供了一个json格式的初始化列表
{LoopCount:nframes}给gif.GIF.但是gif.GIF明显不会只有这个一个域名,其他所有
没有被赋值的域名都要使用"零值". 后面我们会看到struct的普通field都直接使用
dot notation来访问,比如
<div class="org-src-container">

<pre class="src src-go">anim.Delay = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #2aa198;">(</span>anim.Delay, delay<span style="color: #2aa198;">)</span>
anim.Image = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #2aa198;">(</span>anim.Image, image<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>这个例子的lissajous 函数的形参是io.Writer,实参是os.Stdout,我们后来会看到我
们也可以把结果写入到网页上.这就涉及到go的interface, 如下两个对象都符合io.Writer:
<ul class="org-ul">
<li>http.ResponseWriter
</li>
<li>os.Stdout
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Fetching a URL</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>我们来看如下一个使用go来模仿bash里面的curl的例子
<a href="https://play.golang.org/p/PDpqAKi_gO">https://play.golang.org/p/PDpqAKi_gO</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Fetch prints the content found at a URL.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"io/ioutil"</span>
        <span style="color: #2aa198;">"net/http"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, url := <span style="color: #859900; font-weight: bold;">range</span> os.Args<span style="color: #b58900;">[</span>1:<span style="color: #b58900;">]</span> <span style="color: #b58900;">{</span>
                resp, err := http.<span style="color: #268bd2;">Get</span><span style="color: #268bd2;">(</span>url<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #6c71c4;">(</span>os.Stderr, <span style="color: #2aa198;">"fetch: %v\n"</span>, err<span style="color: #6c71c4;">)</span>
                        os.<span style="color: #268bd2;">Exit</span><span style="color: #6c71c4;">(</span>1<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                b, err := ioutil.<span style="color: #268bd2;">ReadAll</span><span style="color: #268bd2;">(</span>resp.Body<span style="color: #268bd2;">)</span>
                resp.Body.<span style="color: #268bd2;">Close</span><span style="color: #268bd2;">()</span>
                <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #6c71c4;">(</span>os.Stderr, <span style="color: #2aa198;">"fetch: reading %s: %v\n"</span>, url, err<span style="color: #6c71c4;">)</span>
                        os.<span style="color: #268bd2;">Exit</span><span style="color: #6c71c4;">(</span>1<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%s"</span>, b<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-</span>

<span style="color: #93a1a1;">///////////////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ ./fetch http://baidu.com                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;html&gt;                                                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;meta http-equiv="refresh" content="0;url=http://www.baidu.com/"&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;/html&gt;                                                           //</span>
<span style="color: #93a1a1;">///////////////////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>这个例子有如下的要点要学习:
<ul class="org-ul">
<li>http.Get函数是会使用GET method来访问某个url,如果没有错误的话,resp里面就会
含有Response类型的变量,包含有所有的HTTP response的信息
</li>
<li>iotil.ReadAll负责把Body里面的信息读取出来返回给b, 然后我们caller需要负责
Close() resp.Body
</li>
<li>其实更让我们需要学习的是go组织代码的方式:
<ol class="org-ol">
<li>Response本身就是一个struct
</li>
<li>Body是Response内部的一个interface,两者的关系用代码表示如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Response</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
    Status     string <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">e.g. "200 OK"</span>

    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">....</span>
    Body io.ReadCloser
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">....</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们的Body作为io.ReadCloser类型的数据,想从中读取数据,就要借助一些library
这里借助的是ioutil.ReadAll,我们看到ioutil.ReadAll的函数声明如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">ReadAll</span><span style="color: #2aa198;">(</span>r <span style="color: #b58900;">io.Reader</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">[]</span><span style="color: #b58900;">byte</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>这就引出了一个问题:我们如何知道io.Reader是io.ReadCloser的父类的?这就又
要看ReadCloser的定义了
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ReadCloser is the interface that groups the basic Read and Close methods.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">ReadCloser</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        Reader
        Closer
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这里又引出了go里面对"怎样算实现了interface"的定义:
<pre class="example">
            实现了interface里面所有的函数,就算实现了这个interface,不需要显式的写出implement
</pre>
</li>
<li>我们的ReadCloser interface里面包括了Reader interface,所以实现了ReadCloser
interface的instance肯定实现了N个函数,这个N歌函数里面肯定有Reader需要的M
个函数(N &gt; M)
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Fetching URLs Concurrently</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>下面我们来简单的使用以下go的killer feature, goroutine, 下面是goroutine的一
个例子:多线程的来fetch url数据.这个例子设计的比较巧妙,goroutine之间没有依赖
关系,没有访问shared memory所以也不需要用锁.所以,最终的抓取时间取决于最慢的那一个
<a href="https://play.golang.org/p/l3t-FanD3X">https://play.golang.org/p/l3t-FanD3X</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Fetchall fetches URLs in parallel and reports their times and sizes.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"io"</span>
        <span style="color: #2aa198;">"io/ioutil"</span>
        <span style="color: #2aa198;">"net/http"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        start := time.<span style="color: #268bd2;">Now</span><span style="color: #b58900;">()</span>
        ch := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">string</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, url := <span style="color: #859900; font-weight: bold;">range</span> os.Args<span style="color: #b58900;">[</span>1:<span style="color: #b58900;">]</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">fetch</span><span style="color: #268bd2;">(</span>url, ch<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">start a goroutine</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #859900; font-weight: bold;">range</span> os.Args<span style="color: #b58900;">[</span>1:<span style="color: #b58900;">]</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>&lt;-ch<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">receive from channel ch</span>
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%.2fs elapsed\n"</span>, time.<span style="color: #268bd2;">Since</span><span style="color: #268bd2;">(</span>start<span style="color: #268bd2;">)</span>.<span style="color: #268bd2;">Seconds</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">fetch</span><span style="color: #2aa198;">(</span>url <span style="color: #b58900;">string</span>, ch <span style="color: #859900; font-weight: bold;">chan</span>&lt;- <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        start := time.<span style="color: #268bd2;">Now</span><span style="color: #b58900;">()</span>
        resp, err := http.<span style="color: #268bd2;">Get</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                ch &lt;- fmt.<span style="color: #268bd2;">Sprint</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">send to channel ch</span>
                <span style="color: #859900; font-weight: bold;">return</span>
        <span style="color: #b58900;">}</span>

        nbytes, err := io.<span style="color: #268bd2;">Copy</span><span style="color: #b58900;">(</span>ioutil.Discard, resp.Body<span style="color: #b58900;">)</span>
        resp.Body.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">don't leak resources</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                ch &lt;- fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"while reading %s: %v"</span>, url, err<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span>
        <span style="color: #b58900;">}</span>
        secs := time.<span style="color: #268bd2;">Since</span><span style="color: #b58900;">(</span>start<span style="color: #b58900;">)</span>.<span style="color: #268bd2;">Seconds</span><span style="color: #b58900;">()</span>
        ch &lt;- fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%.2fs  %7d  %s"</span>, secs, nbytes, url<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-</span>

<span style="color: #93a1a1;">/////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt; go run main.go http://www.baidu.com http://www.bing.com http://www.360.cn //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0.21s    61705  http://www.bing.com                                         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0.31s    98409  http://www.baidu.com                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0.41s   105174  http://www.360.cn                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0.41s elapsed                                                               //</span>
<span style="color: #93a1a1;">/////////////////////////////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>为了理解这个例子,首先介绍两个概念:
<ul class="org-ul">
<li>goroutine: 是一个并发的function execution.我们可以把它看做是轻量级thread
</li>
<li>channel: 是一个允许goroutine间传递"某种一种类型"数据的"通道". channel是有
类型的,比如上面例子的channel就是string类型的,那么string类型的channel就只
可以在goroutine之间传递string
</li>
</ul>
</li>
<li>我们来看看整个代码:
<ul class="org-ul">
<li>创建channel使用的是make, make只可以为slice, map, chan三种类型服务, 而且make
的返回值是引用而不是指针.
</li>
<li>对于每一个Arg参数, 我们都会使用go关键字来创建一个goroutine来'单独地异步地'
运行fetch函数
</li>
<li>fetch函数的原理就和上一节的main函数很像啦:就是GET打开一个url, 只不过这次
我们不关心具体数据是啥(所以Discard掉),只是把字节数写入nbytes而已.discard
还很文艺,使用了ioutil.Discard
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Discard is an io.Writer on which all Write calls succeed</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">without doing anything.</span>
<span style="color: #859900; font-weight: bold;">var</span> Discard io.Writer = <span style="color: #268bd2;">devNull</span><span style="color: #2aa198;">(</span>0<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>第二个循环就是把channel里面的内容打印出来.
</li>
</ul>
</li>
<li>关于channel:
<ul class="org-ul">
<li>channel有两个操作,注意箭头总是向左的,进入ch就是输入,从ch出来就是输出:
<ol class="org-ol">
<li>写入:
<div class="org-src-container">

<pre class="src src-go">ch &lt;- fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"while reading %s: %v"</span>, url, err<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>读取:
<div class="org-src-container">

<pre class="src src-go">fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>&lt;-ch<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">receive from channel ch</span>
</pre>
</div>
</li>
</ol>
</li>
<li>当goroutine 试图去写入channel的时候是会block住的,直到有另外一个goroutine来
'读取'. 在上面的例子中main goroutine 中"读取"ch的操作会一直block,直到ch被
某个其他的goroutine写入.反之亦然
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">A Web Server</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>刚才写的fetch是client端的操作,go也很容易写出server的服务器,比如下面就是一个
简单的echo server服务器
<a href="https://play.golang.org/p/5My0dnzqIs">https://play.golang.org/p/5My0dnzqIs</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Server1 is a minimal "echo" server.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"net/http"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        http.<span style="color: #268bd2;">HandleFunc</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"/"</span>, handler<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">each request calls handler</span>
        log.<span style="color: #268bd2;">Fatal</span><span style="color: #b58900;">(</span>http.<span style="color: #268bd2;">ListenAndServe</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"localhost:8000"</span>, <span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">handler echoes the Path component of the request URL r.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">handler</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">http.ResponseWriter</span>, r *<span style="color: #b58900;">http.Request</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>w, <span style="color: #2aa198;">"URL.Path = %q\n"</span>, r.URL.Path<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>此程序的要点:
<ul class="org-ul">
<li>HandleFunc设置了一个函数handler来处理"所有以/开头的request"
</li>
<li>函数handler就是接受类型为http.Request的input,然后把结果写入到ResponseWriter
里面.
</li>
</ul>
</li>
<li>一个最简单的更改就是增加一个HandleFunc和一个handler
<a href="https://play.golang.org/p/wAnKCZwlem">https://play.golang.org/p/wAnKCZwlem</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Server2 is a minimal "echo" and counter server.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"net/http"</span>
        <span style="color: #2aa198;">"sync"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">var</span> mu sync.Mutex
<span style="color: #859900; font-weight: bold;">var</span> count int

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        http.<span style="color: #268bd2;">HandleFunc</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"/"</span>, handler<span style="color: #b58900;">)</span>
        http.<span style="color: #268bd2;">HandleFunc</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"/count"</span>, counter<span style="color: #b58900;">)</span>
        log.<span style="color: #268bd2;">Fatal</span><span style="color: #b58900;">(</span>http.<span style="color: #268bd2;">ListenAndServe</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"localhost:8000"</span>, <span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">handler echoes the Path component of the requested URL.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">handler</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">http.ResponseWriter</span>, r *<span style="color: #b58900;">http.Request</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        mu.<span style="color: #268bd2;">Lock</span><span style="color: #b58900;">()</span>
        count++
        mu.<span style="color: #268bd2;">Unlock</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>w, <span style="color: #2aa198;">"URL.Path = %q\n"</span>, r.URL.Path<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">counter echoes the number of calls so far.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">counter</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">http.ResponseWriter</span>, r *<span style="color: #b58900;">http.Request</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        mu.<span style="color: #268bd2;">Lock</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>w, <span style="color: #2aa198;">"Count %d\n"</span>, count<span style="color: #b58900;">)</span>
        mu.<span style="color: #268bd2;">Unlock</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这里的新handler是用来记录从多个不同的client来的不同访问总过有多少.
</li>
<li>因为是多个不同的client访问同一块内存count,所以要保证我们的count只能"同时被
一个client更新",所以我们这个例子还需要mutex的支持.所以这里使用了sync.Mutex
</li>
<li>对server的进一步扩展就是增加了header信息
<a href="https://play.golang.org/p/YsH3jIqzMv">https://play.golang.org/p/YsH3jIqzMv</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Server3 is a minimal "echo" and counter server.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"net/http"</span>
        <span style="color: #2aa198;">"sync"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">var</span> mu sync.Mutex
<span style="color: #859900; font-weight: bold;">var</span> count int

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        http.<span style="color: #268bd2;">HandleFunc</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"/"</span>, handler<span style="color: #b58900;">)</span>
        http.<span style="color: #268bd2;">HandleFunc</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"/count"</span>, counter<span style="color: #b58900;">)</span>
        log.<span style="color: #268bd2;">Fatal</span><span style="color: #b58900;">(</span>http.<span style="color: #268bd2;">ListenAndServe</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"localhost:8000"</span>, <span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+handler</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">handler echoes the HTTP request.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">handler</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">http.ResponseWriter</span>, r *<span style="color: #b58900;">http.Request</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>w, <span style="color: #2aa198;">"%s %s %s\n"</span>, r.Method, r.URL, r.Proto<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> k, v := <span style="color: #859900; font-weight: bold;">range</span> r.Header <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>w, <span style="color: #2aa198;">"Header[%q] = %q\n"</span>, k, v<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>w, <span style="color: #2aa198;">"Host = %q\n"</span>, r.Host<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>w, <span style="color: #2aa198;">"RemoteAddr = %q\n"</span>, r.RemoteAddr<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err := r.<span style="color: #268bd2;">ParseForm</span><span style="color: #b58900;">()</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Print</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> k, v := <span style="color: #859900; font-weight: bold;">range</span> r.Form <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>w, <span style="color: #2aa198;">"Form[%q] = %q\n"</span>, k, v<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-handler</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">counter echoes the number of calls so far.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">counter</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">http.ResponseWriter</span>, r *<span style="color: #b58900;">http.Request</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        mu.<span style="color: #268bd2;">Lock</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>w, <span style="color: #2aa198;">"Count %d"</span>, count<span style="color: #b58900;">)</span>
        mu.<span style="color: #268bd2;">Unlock</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个例子里面提供了一个check err的新思路"nested err in if statement"
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">if</span> err := r.<span style="color: #268bd2;">ParseForm</span><span style="color: #2aa198;">()</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span>
        log.<span style="color: #268bd2;">Print</span><span style="color: #b58900;">(</span>err<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们还可以使用function literal的方法来设置匿名函数处理不同的url
<div class="org-src-container">

<pre class="src src-go">http.<span style="color: #268bd2;">HandleFunc</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"/"</span>, <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">(</span>w <span style="color: #b58900;">http.ResonseWriter</span>, r *<span style="color: #b58900;">http.Request</span><span style="color: #b58900;">){</span><span style="color: #268bd2;">lissajous</span><span style="color: #268bd2;">(</span>w<span style="color: #268bd2;">)</span><span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>下面就是前面讲到的,因为都实现了io.Writer,我们可以把原本写入到io.Stdout的内
容,写入到http.ResponseWriter里面
<a href="https://play.golang.org/p/shcJUg8b8E">https://play.golang.org/p/shcJUg8b8E</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Lissajous generates GIF animations of random Lissajous figures.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"image"</span>
        <span style="color: #2aa198;">"image/color"</span>
        <span style="color: #2aa198;">"image/gif"</span>
        <span style="color: #2aa198;">"io"</span>
        <span style="color: #2aa198;">"math"</span>
        <span style="color: #2aa198;">"math/rand"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-main</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Packages not needed by version in book.</span>
<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"net/http"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+main</span>

<span style="color: #859900; font-weight: bold;">var</span> palette = <span style="color: #2aa198;">[]</span><span style="color: #b58900;">color.Color</span><span style="color: #2aa198;">{</span>color.White, color.Black<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #2aa198;">(</span>
        whiteIndex = 0 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">first color in palette</span>
        blackIndex = 1 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">next color in palette</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-main</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The sequence of images is deterministic unless we seed</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">the pseudo-random number generator using the current time.</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Thanks to Randall McPherson for pointing out the omission.</span>
        rand.<span style="color: #268bd2;">Seed</span><span style="color: #b58900;">(</span>time.<span style="color: #268bd2;">Now</span><span style="color: #268bd2;">()</span>.<span style="color: #268bd2;">UTC</span><span style="color: #268bd2;">()</span>.<span style="color: #268bd2;">UnixNano</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>os.Args<span style="color: #b58900;">)</span> &gt; 1 &amp;&amp; os.Args<span style="color: #b58900;">[</span>1<span style="color: #b58900;">]</span> == <span style="color: #2aa198;">"web"</span> <span style="color: #b58900;">{</span>
                <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+http</span>
                handler := <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">(</span>w <span style="color: #b58900;">http.ResponseWriter</span>, r *<span style="color: #b58900;">http.Request</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #268bd2;">lissajous</span><span style="color: #6c71c4;">(</span>w<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                http.<span style="color: #268bd2;">HandleFunc</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"/"</span>, handler<span style="color: #268bd2;">)</span>
                <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-http</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>http.<span style="color: #268bd2;">ListenAndServe</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"localhost:8000"</span>, <span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+main</span>
        <span style="color: #268bd2;">lissajous</span><span style="color: #b58900;">(</span>os.Stdout<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">lissajous</span><span style="color: #2aa198;">(</span>out <span style="color: #b58900;">io.Writer</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">(</span>
                cycles  = 5     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">number of complete x oscillator revolutions</span>
                res     = 0.001 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">angular resolution</span>
                size    = 100   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">image canvas covers [-size..+size]</span>
                nframes = 64    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">number of animation frames</span>
                delay   = 8     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">delay between frames in 10ms units</span>
        <span style="color: #b58900;">)</span>
        freq := rand.<span style="color: #268bd2;">Float64</span><span style="color: #b58900;">()</span> * 3.0 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">relative frequency of y oscillator</span>
        anim := gif.<span style="color: #b58900;">GIF</span><span style="color: #b58900;">{</span>LoopCount: nframes<span style="color: #b58900;">}</span>
        phase := 0.0 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">phase difference</span>
        <span style="color: #859900; font-weight: bold;">for</span> i := 0; i &lt; nframes; i++ <span style="color: #b58900;">{</span>
                rect := image.<span style="color: #268bd2;">Rect</span><span style="color: #268bd2;">(</span>0, 0, 2*size+1, 2*size+1<span style="color: #268bd2;">)</span>
                img := image.<span style="color: #268bd2;">NewPaletted</span><span style="color: #268bd2;">(</span>rect, palette<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">for</span> t := 0.0; t &lt; cycles*2*math.Pi; t += res <span style="color: #268bd2;">{</span>
                        x := math.<span style="color: #268bd2;">Sin</span><span style="color: #6c71c4;">(</span>t<span style="color: #6c71c4;">)</span>
                        y := math.<span style="color: #268bd2;">Sin</span><span style="color: #6c71c4;">(</span>t*freq + phase<span style="color: #6c71c4;">)</span>
                        img.<span style="color: #268bd2;">SetColorIndex</span><span style="color: #6c71c4;">(</span>size+<span style="color: #268bd2;">int</span><span style="color: #859900;">(</span>x*size+0.5<span style="color: #859900;">)</span>, size+<span style="color: #268bd2;">int</span><span style="color: #859900;">(</span>y*size+0.5<span style="color: #859900;">)</span>,
                                blackIndex<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                phase += 0.1
                anim.Delay = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #268bd2;">(</span>anim.Delay, delay<span style="color: #268bd2;">)</span>
                anim.Image = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #268bd2;">(</span>anim.Image, img<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        gif.<span style="color: #268bd2;">EncodeAll</span><span style="color: #b58900;">(</span>out, &amp;anim<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: ignoring encoding errors</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">Losse Ends</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>go里面的switch是自动break的,不需要额外的break
</li>
<li>而且switch是可以没有operand的, 如下.这种其实就是switch true的意思
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Siignum</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">switch</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> x &gt; 0:
                <span style="color: #859900; font-weight: bold;">return</span> +1
        <span style="color: #859900; font-weight: bold;">default</span>:
                <span style="color: #859900; font-weight: bold;">return</span> 0
        <span style="color: #859900; font-weight: bold;">case</span> x &lt; 0:
                <span style="color: #859900; font-weight: bold;">return</span> -1
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>go里面也是有break和continue的
</li>
<li>type是一个c语言里面typedef的继承者,能够给struct一个更加"容易记住的名字",当
然了,我们后面会看到interface也会使用type来起名字的
</li>
<li>Go语言还是提供了pointer.对pointer的态度一般有两种:
<ul class="org-ul">
<li>比如c语言里面pionter几乎是不受限制的
</li>
<li>比如java语言里面,没有pointer这个概念,使用reference来取代pointer.reference
除了被传递来传递去,也没有其他的作用
</li>
<li>Go对pointer采取了"折中"的态度:
<ol class="org-ol">
<li>和c一样有pionter,而且&amp;同样是'取地址', *是'解地址'
</li>
<li>但是pointer不能像c里面一样进行算术运算
</li>
</ol>
</li>
</ul>
</li>
<li>function是一个常见的概念,c语言开始就有.method则是一个OO语言里面的概念:某个类
型所拥有的function就叫做method
</li>
<li>interface则是Go的特点了,它以你"是否实现了interface规定的function"来决定你是否
implements了这个interface.而不是显示的写出implements
</li>
<li>go比c语言先进的地方是它有了package系统
</li>
<li>go的注释也是和c语言一样,/*&#x2026;*/ 或者//都可以
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 02: Program Structure</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>和其他的语言一样,go里面的:
<ul class="org-ul">
<li>变量存储数据
</li>
<li>简单的expression会通过操作符合成一个大的expression
</li>
<li>不同的'稍微简单的类型'通过组合成为struct,相同的简单类型通过组合形成了array
</li>
<li>expression会进一步成为statment,expression自己本身就是statement, 但是statement
还包括更多,比如condition control
</li>
<li>statement会把一段单独的逻辑独立出来,形成可以复用的function
</li>
<li>function组合起来就形成了package
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Names</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>go的命名规则和c一致,大小写也是区分的.
</li>
<li>keyword有25个,keyword的特点是不能用作name
<pre class="example">
break    default     func   interface select
case     defer       go     map       struct
chan     else        goto   package   switch
const    fallthrough if     range     type
continue for         import return    var
</pre>
</li>
<li>除了keyword以外,还有,如下三类的predeclared names. predeclared names不是保留
字,所以你可以在declaration里面使用它们,当然我们不推荐这样做
<pre class="example">
Constants:                true    false   iota       nil
_________________________________________________________________________________________
Types:                    int     int8    int16      int32     int64
                          uint    uint8   uint16     uint32    uint64 uintptr
                          float32 float64 complex128 complex64
                          bool    byte    rune       string    error
_________________________________________________________________________________________
Functions:                make    len     cap        new       append copy    close delete
                          complex real    imag
                          panic   recover
</pre>
</li>
<li>如果一个entity在function内部定义,那么这个entity是local于这个function的
</li>
<li>如果定义在function之外,那么这个entity是在整个package内可见的.
</li>
<li>如果定义在function之外,那么变量的第一个字母决定了这个变量是不是在"不同package之间可见":
<ul class="org-ul">
<li>如果变量第一个字母大写,那么再package之间可见,比如fmt的Printf
</li>
<li>第一字母小写则package之间不可见.为了表示区分,一般package自己的名字都是全
小写的.
</li>
</ul>
</li>
<li>变量的长度是没有要求的,但是go倾向于你在作用域比较小的变量上面:作用域越小的
变量名字应该越简单.
</li>
<li>同样的Go的变量命名格式一般是"camel case"的,比如parseRequestLine,但是绝对不会
是parse_request_line
</li>
<li>需要特别注意的是,如果HTML或者WTO这种首字母大写的拼写,一定会是"共进退":
<ul class="org-ul">
<li>要么全大写: HTMLEscape, escapeHTML
</li>
<li>要么全小写: htmlEscape
</li>
<li>单绝不可能不一致: escapeHtml
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Declarations</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>声明(declaration)命名了一个program entity,并且确定了它"全部或者部分"的properties
</li>
<li>主要的声明方式有四种:
<ul class="org-ul">
<li>var
</li>
<li>const
</li>
<li>type
</li>
<li>func
</li>
</ul>
</li>
<li>Go语言程序是存储在一个或者多个.go文件里面的,每个问题件都是以package为开头,来
表明当前的文件属于哪个package
</li>
<li>package文件后面是一系列的import
</li>
<li>import之后是package level的type, variable, const,或者function
</li>
<li>下面是一个.go文件的例子
<a href="https://play.golang.org/p/bt033asf7f">https://play.golang.org/p/bt033asf7f</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Boiling prints the boiling point of water.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">const</span> boilingF = 212.0

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> f = boilingF
        <span style="color: #859900; font-weight: bold;">var</span> c = <span style="color: #b58900;">(</span>f - 32<span style="color: #b58900;">)</span> * 5 / 9
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"boiling point = %g&#176;F or %g&#176;C\n"</span>, f, c<span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Output:</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">boiling point = 212&#176;F or 100&#176;C</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">boiling point = 212&#176;F or 100&#176;C                 //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>这个例子的要点有:
<ul class="org-ul">
<li>常量boilingF是一个package-level的声明(和main是一个层次),所有package-level
的entity是可以在所有的相同package文件里面可见的
</li>
<li>变量f和c都是main函数的local变量,local变量的可见域就只有自己的function(或者
仅仅是被定义的一个for)内部了
</li>
</ul>
</li>
<li>函数声明有如下部分组成:
<ul class="org-ul">
<li>name
</li>
<li>a list of parameters
</li>
<li>optional list of results
</li>
<li>function body
</li>
</ul>
</li>
<li>下面就是一个例子,我们把温度转换的逻辑转移到一个function里面,然后多次调用这
个函数,就可以做到"定义一次,使用多次"
<a href="https://play.golang.org/p/uQsRDXGTN8">https://play.golang.org/p/uQsRDXGTN8</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Ftoc prints two Fahrenheit-to-Celsius conversions.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> freezingF, boilingF = 32.0, 212.0
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%g&#176;F = %g&#176;C\n"</span>, freezingF, <span style="color: #268bd2;">fToC</span><span style="color: #268bd2;">(</span>freezingF<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"32&#176;F = 0&#176;C"</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%g&#176;F = %g&#176;C\n"</span>, boilingF, <span style="color: #268bd2;">fToC</span><span style="color: #268bd2;">(</span>boilingF<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"212&#176;F = 100&#176;C"</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">fToC</span><span style="color: #2aa198;">(</span>f <span style="color: #b58900;">float64</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>f - 32<span style="color: #b58900;">)</span> * 5 / 9
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">32&#176;F = 0&#176;C</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">212&#176;F = 100&#176;C</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Variables</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>下面我们来看第一种声明的方法var. var是声明变量的最基本方法,其常规格式如下
<pre class="example">
var name type = expression
</pre>
</li>
<li>其中,'type'和'= expression'都是可以省略的.但不能同时省略!因为:
<ul class="org-ul">
<li>如果type省略了, type可以依靠expression来确定自己的类型
</li>
<li>如果expression省略了.那么name的initial value就都是zero value(也就是如果是
数字就为0,如果是布尔就为false,string就为"", interface和reference type就为
nil, 如果是数组那么就是成员个数为0的数组)
</li>
</ul>
</li>
<li>这里多说一句zero-value机制保证了变量"总是"拥有well-defined value of its type
这也就避免了c语言里面的"uninitialized variable"
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> s string
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>                  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">""</span>
</pre>
</div>
</li>
<li>上面的例子打印出了空字符串(""),而不是错误或者是内存里面的随机值,这是一个非
常好的特性,所以在自己创建的type里面能够保证有一个"有意义的zero value"也是非
常好的习惯
</li>
<li>一个声明表达式声明多个变量是可行的.甚至一个表达式里面可以赋值不同类型的变量,
当然,这种情况需要通过expression来判断
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> i, j, k int                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">int, int, int</span>
<span style="color: #859900; font-weight: bold;">var</span> b, f, s = <span style="color: #268bd2; font-weight: bold;">true</span>, 2.3, <span style="color: #2aa198;">"four"</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">bool, float64, string</span>
</pre>
</div>
</li>
<li>声明所使用的Initializer可以是literal value或者是任意的expression
</li>
<li>需要注意的是:Package-level变量在main函数之前进行初始化,而local variable则是
程序运行遇到了才进行初始化
<pre class="example">
Package-level variables are initialized before main begins,
and local variables are initialized as their declarations are
encountered during function execution.
</pre>
</li>
<li>也可以使用函数的返回值来初始化变量,比如
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> f, err = os.<span style="color: #268bd2;">Open</span><span style="color: #2aa198;">(</span>name<span style="color: #2aa198;">)</span>      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">os.Open returns a file and an error</span>
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Short Variable Declarations</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>var是最基本的声明方式,而且哪里都可以用.另外go还在"function level"提供了一个
声明变量的方式,叫做short variable declaration. 用来声明local variable,其格
式如下
<pre class="example">
name := expression
</pre>
</li>
<li>注意这种方式要求必须提供expression来初始化变量,所以type就不需要了.前面用到
过的short variable declaration的例子有
<div class="org-src-container">

<pre class="src src-go">anim := gif.<span style="color: #b58900;">GIF</span><span style="color: #2aa198;">{</span>loopCount: nframes<span style="color: #2aa198;">}</span>
freq := rand.<span style="color: #268bd2;">Float64</span><span style="color: #2aa198;">()</span> * 3.0
t := 0.0
</pre>
</div>
</li>
<li>因为这种声明的方式简洁而灵活,所以local variable就大多使用这种方式来声明啦
</li>
<li>当然了var在local variable里面也有其多种的用途:
<ul class="org-ul">
<li>声明一个变量其初始值无法有效推导出类型
<div class="org-src-container">

<pre class="src src-go">i := 100                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">an int</span>
<span style="color: #859900; font-weight: bold;">var</span> boiling float64 = 100       <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">a float64</span>
</pre>
</div>
</li>
<li>声明一个一开始没有值的变量,过一会才会有"有意义的值"
</li>
</ul>
</li>
<li>和var能够声明多个变量一样, short variable declaration也可以声明多个变量比
如:
<div class="org-src-container">

<pre class="src src-go">i, j := 0, 1
</pre>
</div>
</li>
<li>需要注意的是,使用short variable declaration一次声明多个变量只有在"能够提高
readability的时候"才使用.比如for loop里面
</li>
<li>需要注意的是:=是声明,而=是赋值. multi-variable 声明不能和tuple assignment
相混淆,如下是tuple assignment
<div class="org-src-container">

<pre class="src src-go">i, j = j, i                     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">swap values of i and j</span>
</pre>
</div>
</li>
<li>short variable declaration 一个重要的却容易被忽视的特性:它并不要求":="左边
的多个变量,全部都是没声明过的.
<pre class="example">
A short variable declaration does NOT necessarily declare all
the variable on its left-hand side
</pre>
</li>
<li>也就是说如果short variable declaration的左边的"其中一部分变量"已经声明过了,
那么shaort variable declaration自动转成对其进行"赋值":
<ul class="org-ul">
<li>注意一定是"一部分变量",比如下面例子中err在第二次的short variable声明中其
实已经被第一次short variable声明中"声明"过了.所以第二次其实是赋值.而short
variable的这种"赋值"只会对"定义在同一层次"的变量有效.如果是声明在outer block
的,那么外面的声明就直接被忽略掉了
<div class="org-src-container">

<pre class="src src-go">in, err := os.<span style="color: #268bd2;">Open</span><span style="color: #2aa198;">(</span>infile<span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
out, err := os.<span style="color: #268bd2;">Create</span><span style="color: #2aa198;">(</span>outfile<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>注意,如果全部都声明过了,是会报错的
<div class="org-src-container">

<pre class="src src-go">f, err := os.<span style="color: #268bd2;">Open</span><span style="color: #2aa198;">(</span>infile<span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
f, err := os.<span style="color: #268bd2;">Create</span><span style="color: #2aa198;">(</span>outfile<span style="color: #2aa198;">)</span>    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: no new variables</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Pointers</h4>
<div class="outline-text-4" id="text-2-3-2">
<ul class="org-ul">
<li>在计算机看来:变量就是一片存储着value的storage
</li>
<li>大部分的variable是通过一个name比如'x'来identified的,但是也有通过expression
来识别的,比如x[i]或者是x.f
</li>
<li>无论是name还是expression,它们都会自动读取value的值,除非它出现在赋值符号的
左边,这种情况下,这个vairable会有一个新的值!
</li>
<li>所谓的pointer value(注意有value),其实就是variable的地址.也就是说是"存储一
个value的storage的地址"
</li>
<li>不是每个value都有地址(比如0值),但是每个variable都肯定有地址
<pre class="example">
Not every value has an address, but every variable does.
</pre>
</li>
<li>使用pointer的一大意义在于:我们可以读取甚至更新varaible的值,但是同时甚至不
需要知道这varaible的name(如果它有name的话)!
</li>
<li>如果使用var x int来定义一个variable的话,那么:
<ul class="org-ul">
<li>&amp;就是"c++中的取地址符", &amp;x这个操作会产生一个类型为*int的value,而这个value如果有
name的话,比如p.那么我们就说"p contains the address of x"
</li>
<li>*就是"c++中的解引用(我们这里就没有引用的概念了,所以不能这么叫)", *p这个
操作就会产生类型为int的variable!注意,这里*p产生的不是一个值,而是一个variable!
所以它可以出现在赋值符号的左边
</li>
</ul>
</li>
<li>下面是一个pointer的例子, 表达了pointer在go里面的能力.
<div class="org-src-container">

<pre class="src src-go">x := 1
p := &amp;x                         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">p, of type *int, points to x</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>*p<span style="color: #2aa198;">)</span>                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"1"</span>
*p = 2                          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">equivalent to x = 2 left side of assignment</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>x<span style="color: #2aa198;">)</span>                  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"2"</span>
</pre>
</div>
</li>
<li>pointer的zero value是nil, 使用p != nil来确定p是否指向一个variable.两个
pointer相等的情况只有两种:都等于零,或者都指向同一个变量
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> x, y in
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == <span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"true false false"</span>
</pre>
</div>
</li>
<li>和c语言不同的地方是, 在go里面"函数返回一个指向local variable的地址"是非常
安全的(因为go是GC的语言),比如下面的例子. 注意,我们每次返回的地址都不一样.
<a href="https://play.golang.org/p/IMesLxqyWk">https://play.golang.org/p/IMesLxqyWk</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">var</span> p = <span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span> *<span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        v := 1
        <span style="color: #859900; font-weight: bold;">return</span> &amp;v
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>p<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">f</span><span style="color: #268bd2;">()</span> == <span style="color: #268bd2;">f</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0x82024e220                                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>"返回function的local variable的地址"这种方法极大的提高了生存率,我们知道在
c语言里面,如果想返回稍微复杂的数据(int类型可以放在寄存器里面返回),那么就需
要声明一个static的存储结构,然后返回这个存储结构的地址.这又引入了另外一个问题:
由于使用了static存储,程序就无法做成reentrant的了
</li>
<li>由于pointer包含了variable的地址,所以把pointer传递给函数就可以更新pointer指
向的变量的值.这和c语言里面的用法是一样的:
<pre class="example">
        函数值传递的情况下,使用指针作为参数来更改"指针指向的变量"
</pre>
</li>
<li>每次我们对一个变量做"取地址"操作,或者我们copy一个pointer(也就有了一个新的
name),我们都会对某个variable创建一个新的alias,比如*p就是v的一个alias
<div class="org-src-container">

<pre class="src src-go">v := 1
p := &amp;v <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">p, of type *int, points to x</span>
</pre>
</div>
</li>
<li>alias允许我们在不使用variable name的情况下进行对variable的使用,但是代价就
是GC的时候,我们可能要找到所有的alias,而copy一个pionter会出现在非常多的地方:
一个极端的例子就是copy reference type(slice, map, channel等)的时候,reference
type内部所有的成员都是pointer,都会创建一个alias!
</li>
<li>"返回function的local variable的地址,这种c语言里面无法使用,但是go里面却可以
的feature"被std里面的flag库应用,轻松实现了分析一个command line参数,然后返
回指向参数值的"pointer".源代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Bool defines a bool flag with specified name, default value, and usage string.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The return value is the address of a bool variable that stores the value of the flag.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>f *<span style="color: #b58900;">FlagSet</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Bool</span><span style="color: #2aa198;">(</span>name <span style="color: #b58900;">string</span>, value <span style="color: #b58900;">bool</span>, usage <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> *<span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
    p := <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #b58900;">(</span><span style="color: #b58900;">bool</span><span style="color: #b58900;">)</span>              <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">equals to var x bool first, then &amp;x</span>
    f.<span style="color: #268bd2;">BoolVar</span><span style="color: #b58900;">(</span>p, name, value, usage<span style="color: #b58900;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> p
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Bool defines a bool flag with specified name, default value, and usage string.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The return value is the address of a bool variable that stores the value of the flag.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Bool</span><span style="color: #2aa198;">(</span>name <span style="color: #b58900;">string</span>, value <span style="color: #b58900;">bool</span>, usage <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> *<span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> CommandLine.<span style="color: #268bd2;">Bool</span><span style="color: #b58900;">(</span>name, value, usage<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>使用flag的一个例子如下
<a href="https://play.golang.org/p/TGDginIe_B">https://play.golang.org/p/TGDginIe_B</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Copyright &#169; 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">License: https://creativecommons.org/licenses/by-nc-sa/4.0/</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">See page 33.</span>
<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Echo4 prints its command-line arguments.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
    <span style="color: #2aa198;">"flag"</span>
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"strings"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">var</span> n = flag.<span style="color: #268bd2;">Bool</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"n"</span>, <span style="color: #268bd2; font-weight: bold;">false</span>, <span style="color: #2aa198;">"omit trailing newline"</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">var</span> sep = flag.<span style="color: #268bd2;">String</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"s"</span>, <span style="color: #2aa198;">" "</span>, <span style="color: #2aa198;">"separator"</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    flag.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">()</span>
    fmt.<span style="color: #268bd2;">Print</span><span style="color: #b58900;">(</span>strings.<span style="color: #268bd2;">Join</span><span style="color: #268bd2;">(</span>flag.<span style="color: #268bd2;">Args</span><span style="color: #6c71c4;">()</span>, *sep<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
    <span style="color: #859900; font-weight: bold;">if</span> !*n <span style="color: #b58900;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">()</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;                 //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">i309511@ echo4 (master) $ go run main.go -s="," Hello World    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hello,World                                                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">i309511@ echo4 (master) $ go run main.go -n -s="," Hello World //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hello,Worldi309511@ echo4 (master) $                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3">The new Function</h4>
<div class="outline-text-4" id="text-2-3-3">
<ul class="org-ul">
<li>另外一种创建variable的方法是使用内置的new function.因为expression new(T)会
创建一个unnamed variable of type T, 初始化为zero值,并且返回其地址*T,所以这
种创建方法是和指针密切联系的!
<pre class="example">
The expression new(T) creates an unnamed variable of type T,
initializes it to the zero value of T, and returns its address,
which is a value of type *T
</pre>
</li>
<li>例子如下
<a href="https://play.golang.org/p/LX-aOM5T9s">https://play.golang.org/p/LX-aOM5T9s</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        p := <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>p<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>*p<span style="color: #b58900;">)</span>
        *p = 2
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>p<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>*p<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0x82024e220                                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0x82024e220                                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>new创建变量和我们使用var等方法创建的变量没有本质的不同,只不过现在我们不需
要给变量取名字了!所以,下面的两个例子其实是等价的.只不过第二个例子写起来就
有点复杂:
<ul class="org-ul">
<li>use new function:
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">newInt</span><span style="color: #2aa198;">()</span> *<span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>use dummy variable
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">newInt</span><span style="color: #2aa198;">()</span> *<span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> dummy int
        <span style="color: #859900; font-weight: bold;">return</span> &amp;dummy
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>每次new"大多数情况下"都会返回一个unique的address
<div class="org-src-container">

<pre class="src src-go">p := <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>
q := <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>p == q<span style="color: #2aa198;">)</span>             <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"false"</span>
</pre>
</div>
</li>
<li>但是"根据具体implementation", 有些时候也会返回相同的地址,这些情况,通常是一
个类型没有任何的信息,其size为0. 比如struct{}, int
<a href="https://play.golang.org/p/pD6Vr98zdt">https://play.golang.org/p/pD6Vr98zdt</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d\n"</span>, <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">int</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d\n"</span>, <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">int</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d\n"</span>, <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #268bd2;">(</span><span style="color: #6c71c4;">[</span>0<span style="color: #6c71c4;">]</span><span style="color: #b58900;">int</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d\n"</span>, <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #268bd2;">(</span><span style="color: #6c71c4;">[</span>0<span style="color: #6c71c4;">]</span><span style="color: #b58900;">int</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">34898576208                                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">34898576240                                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&amp;[]                                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&amp;[]                                            //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>new function虽然存在,但是在实际情况下却很少使用!因为unnamed variable大多数
情况下都是struct type的,而struct type的unnamed variable使用struct literal
syntax是最简单的方法吧
</li>
<li>因为new只是predeclared function,而不是keyword,所以我们是可以redefine new使
用的.当然,这不推荐.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-4" class="outline-4">
<h4 id="sec-2-3-4">Lifetime of Variables</h4>
<div class="outline-text-4" id="text-2-3-4">
<ul class="org-ul">
<li>所谓变量的作用域,是值的程序运行的过程中,某个变量存在的"时间段"(interval of time)
</li>
<li>一个variable根据其类型的不同,有不同的作用域:
<ul class="org-ul">
<li>对于package level variable来说,在程序运行的全部时刻都一直有效
</li>
<li>对于local variable来说,每当local variable的declaration运行的时候,这个variable
就开始有效,直到其变得unreachable.也就是在这个时候,变量占用的storage可能
会被回收
</li>
<li>function的参赛和返回值都是local variable,每次函数调用都会创建一份(当然调
用完大部分都会被回收)
</li>
</ul>
</li>
<li>GC如何知道一个variable的storage可以被回收?完整的真相肯定不是我们这里可以一
下子说完的.但是总体的思路如下:
<ul class="org-ul">
<li>要判断一个变量x,首先要把它能够接触到的所有的package-level变量和local变量都找到做成数组a
</li>
<li>然后遍历a中所有的元素,看看从这些元素是不是能够找到一条道路(道路通过pointer或者reference到达变量x)
</li>
<li>如果没有任何元素能够到达x,说明x是unreachable了
</li>
</ul>
</li>
<li>所以,go和c最大的不同就在于local variable,go中local variable并不是在
离开作用域后就不可用,而是直到unreachable才不可用.也就是说,我们可以在其作用
域消失后依然存在.
</li>
<li>是编译器在编译的时候来决定某个变量存放在heap或者stack,从而拥有不同的生命期
的.但是编译器是通过分析程序,而不是通过这个变量使用了var或者new来决定其放置
在heap或者stack的.比如下面两个例子:
<ul class="org-ul">
<li>虽然x看起来是个局部变量,但是因为它一被global所"reach",即便func f退出,这个
x还是要reachable,所以编译器要把它分配在heap上面.而这种情况下,我们称x"esacpe
from f"
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> global *int

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> x int
        x = 1
        global = &amp;x
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>下面这个例子,虽然y是一new上面分配的一个地址,但是因为它并没有escape from g,
所以把g分配在stack上面也是很安全的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">g</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        y := <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        *y = 1
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>总之,虽然变量是否"escape"其function不需要我们关系,但是了解原理是非常重要的,
这会让我们写出更高效的代码,比如了解了上面的机制,我们就知道:最好不要使用"存
在于long-lived(比如全局变量) object(比如slice)里面的pointer"来指向short-lived
对象(比如函数里面的对象),因为这会阻止GC来回收这些short-lived 对象
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Assignments</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>了解了variable和value的关系以后,我们来看看variable是怎样来更新其内部的value的
</li>
<li>更新有如下常用几种方式: go中的assignment和c中的assignment没有什么区别:
<ul class="org-ul">
<li>使用"="赋值
<div class="org-src-container">

<pre class="src src-go">x = 1                           <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">named variable</span>
*p = <span style="color: #268bd2; font-weight: bold;">true</span>                       <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">indirect variable</span>
person.name = <span style="color: #2aa198;">"bob"</span>             <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">struct field</span>
count<span style="color: #2aa198;">[</span>x<span style="color: #2aa198;">]</span> = count<span style="color: #2aa198;">[</span>x<span style="color: #2aa198;">]</span> * scale     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">array or slice or map element</span>
</pre>
</div>
</li>
<li>每一种binary operator 都有对应的assignment operator,比如上面最后一个例子
使用assignment operator改写就是如下效果
<div class="org-src-container">

<pre class="src src-go">count<span style="color: #2aa198;">[</span>x<span style="color: #2aa198;">]</span> *= scale
</pre>
</div>
</li>
<li>支持自增,自减
<div class="org-src-container">

<pre class="src src-go">v := 1
v++                             <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">v becomes 2</span>
v--                             <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">v becomes 1 again</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1">Tuple Assignment</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li>go中新引入的一种assignment叫做tuple assignment,其核心是多个变量"同时"赋值:
right-hand的expression先做evaluation,然后才assign给左边的值.由于evaluation
和assignment分开了,所以特别适合变量同时出现在assignment 操作符左右两边的情
况,简言之就是swap
<ul class="org-ul">
<li>赋值数为两个的时候,可以用来swap两个变量的值
<a href="https://play.golang.org/p/hq0aoRwZLK">https://play.golang.org/p/hq0aoRwZLK</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        x := 1
        y := 2
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x, y<span style="color: #b58900;">)</span>
        x, y = y, x
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x, y<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1 2                                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2 1                                            //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>赋值数多于三个的时候,也是可以使用的,如下,但是为了让程序更加易懂,尽量少使
用为妙
<div class="org-src-container">

<pre class="src src-go">i, j, k = 2, 3, 5
</pre>
</div>
</li>
</ul>
</li>
<li>赋值为两个的时候,还有如下几种常见的用法,一共有四种:
<ul class="org-ul">
<li>我们前面说过变量"声明"的时候讲过short variable declaration可以允许用函数
返回值来"声明一个或者两个未声明的变量", 但如果两个变量都已经声明过了的情
况下,我们就只能使用tuple assignment了
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        f, err := os.<span style="color: #268bd2;">Open</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"foo.txt"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>f<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>err<span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">! ERROR no new variables on left side of :=</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">f, err := os.Open("foo.txt")</span>
        f, err = os.<span style="color: #268bd2;">Open</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"foo.txt"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>map是两个值么,key和value,所以map lookup是会用到tuple assignment
<a href="https://play.golang.org/p/Y11HZi_GFU">https://play.golang.org/p/Y11HZi_GFU</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        m := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">int</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">)</span>
        m<span style="color: #b58900;">[</span>1<span style="color: #b58900;">]</span> = <span style="color: #2aa198;">"One"</span>
        m<span style="color: #b58900;">[</span>2<span style="color: #b58900;">]</span> = <span style="color: #2aa198;">"Two"</span>

        <span style="color: #859900; font-weight: bold;">var</span> v string
        <span style="color: #859900; font-weight: bold;">var</span> ok bool
        v, ok = m<span style="color: #b58900;">[</span>2<span style="color: #b58900;">]</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>v, ok<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>type assertion: go特有的,对inteface的assertion
<a href="https://play.golang.org/p/EFkIAHjIwh">https://play.golang.org/p/EFkIAHjIwh</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> x <span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span>
        x = <span style="color: #2aa198;">"abc"</span>
        <span style="color: #859900; font-weight: bold;">var</span> v string
        <span style="color: #859900; font-weight: bold;">var</span> k bool
        v, k = x.<span style="color: #b58900;">(</span><span style="color: #b58900;">string</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> k <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>v, k<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"first x is Not a String"</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        x = 12
        v, k = x.<span style="color: #b58900;">(</span><span style="color: #b58900;">string</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> k <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>v, k<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"second x is Not a String"</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">abc true                                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">second x is Not a String                       //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>channel receive
<div class="org-src-container">

<pre class="src src-go">v, ok = &lt;-ch                    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">channel receive</span>
</pre>
</div>
</li>
</ul>
</li>
<li>当然了,如果我们赋的值并不是都有receiver的话,我们可以把我们不想要的reciver
写作blank identifier(_),这个和声明是一样的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2">Assignability</h4>
<div class="outline-text-4" id="text-2-4-2">
<ul class="org-ul">
<li>有"="的情况下是explicit assignment, 但是还有很多情况下发生了assignment,但
是因为没有"=",所以是implicit assignment,比如:
<ul class="org-ul">
<li>function call的时候,实参是都是通过assignment来传递给形参的
</li>
<li>function call的 return value也是assignment给接收function结果的变量
</li>
<li>go特有的literal expression(也就是我们前面说的unnamed variable最舒服的创
建方式),这里的例子是slice,但是其实map和channel也是一样的
<div class="org-src-container">

<pre class="src src-go">medals := <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">{</span><span style="color: #2aa198;">"gold"</span>, <span style="color: #2aa198;">"sliver"</span>, <span style="color: #2aa198;">"bronze"</span><span style="color: #2aa198;">}</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">equals to</span>
medals<span style="color: #2aa198;">[</span>0<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">"gold"</span>
medals<span style="color: #2aa198;">[</span>1<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">"sliver"</span>
medals<span style="color: #2aa198;">[</span>2<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">"bronze"</span>
</pre>
</div>
</li>
</ul>
</li>
<li>无论赋值是explicit还是implicit,必须遵守赋值的最基本要求:variable(left side)
和value (right side)拥有一样的type.
</li>
<li>这里"一样的type"是一个宽泛的概念,并不是要求type完全一样,而是说value(right side)
is assignable to the variable(left side)的type
</li>
<li>我们后面会详细解释assignable
</li>
<li>我们的"=="和"!="和我们的assignablitiy有关:只有first operand和second operand
可以相互assignable的时候,才能使用"=="和"!="
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Type Declarations</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>变量(或者exporession)的type定义了其在语言里面的非常多的特性,比如:
<ul class="org-ul">
<li>他们的size(bit数目)
</li>
<li>程序语言内部表达方式
</li>
<li>哪些语言intrinsic operation可以操作它们
</li>
<li>它们"自带"了哪些method
</li>
</ul>
</li>
<li>在程序里面,会经常会出现两个事物"表现形式"完全一样(完全可以使用同一种type表
示),但是concept却并不完全一样.比如float64即可以代表, 速度(几点几秒),也可以
代表温度(几点几度)
</li>
<li>Go给这种情况一个解决方案就是type declaration,它可以把一个underlying-type定
义成一种新的named的类型
<pre class="example">
type new-named-type underlying-type
</pre>
</li>
<li>我们来看看下面这个例子,华氏温度和摄氏温度是"温度"的两种不同的表达方式,其实
都可以使用float64表示但是我们定义成不同的type
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Package tempconv performs Celsius and Fahrenheit conversions.</span>
<span style="color: #859900; font-weight: bold;">package</span> tempconv

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Celsius</span> <span style="color: #b58900;">float64</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Fahrenheit</span> <span style="color: #b58900;">float64</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #2aa198;">(</span>
        AbsoluteZeroC Celsius = -273.15
        FreezingC     Celsius = 0
        BoilingC      Celsius = 100
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>c <span style="color: #b58900;">Celsius</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">String</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span>    <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%g&#176;C"</span>, c<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>f <span style="color: #b58900;">Fahrenheit</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">String</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%g&#176;F"</span>, f<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>定义成不同type的好处,是当两者进行运算的时候,因为类型不同,我们必须先"convert",
这会减少很多错误.这种错误在underlying type为float64的时候不是很明显,但是如果
underlying type是复杂的struct的话,我们会减少非常多的错误.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> tempconv

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">CToF converts a Celsius temperature to Fahrenheit.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">CToF</span><span style="color: #2aa198;">(</span>c <span style="color: #b58900;">Celsius</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">Fahrenheit</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">Fahrenheit</span><span style="color: #b58900;">(</span>c*9/5 + 32<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">FToC converts a Fahrenheit temperature to Celsius.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">FToC</span><span style="color: #2aa198;">(</span>f <span style="color: #b58900;">Fahrenheit</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">Celsius</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">Celsius</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">(</span>f - 32<span style="color: #268bd2;">)</span> * 5 / 9<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>上面使用T(x)的方法作用是:
<pre class="example">
convert value x to type T.
</pre>
</li>
<li>这种转换在c-like语言里面也存在,但是在go里面,这种转换的要求非常的严格,允许转
换的情况不多:
<ul class="org-ul">
<li>如果x当前的类型和类型T拥有相同的underlying type(也就是我们这个例子里面的
情况,华氏和摄氏问题都是float64类型)
</li>
<li>如果两种类型都是unnamed pointer,并且指向的变量类型相同
</li>
<li>高精度的数值转换成低精度的数值(会损失精度, 比如float转换成int就会损失所有
的小数部分)
</li>
<li>string转换成[]byte
<a href="https://play.golang.org/p/cGitbsVI6d">https://play.golang.org/p/cGitbsVI6d</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        s := <span style="color: #2aa198;">"ABCDE"</span>
        arr := <span style="color: #b58900;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%v\n"</span>, arr<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">string</span><span style="color: #268bd2;">(</span>arr<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ABCDE</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[65 66 67 68 69]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ABCDE</span>
</pre>
</div>
</li>
</ul>
</li>
<li>最最重要的是无论怎样的情况下,在运行期,转换绝对不会失败.注意是"运行期"不会失
败,也就是说你必须首先满足go conversion的要求.
<pre class="example">
In any case, a conversion never fails at run time.
</pre>
</li>
<li>named type的underlying type决定了它能接受哪些intrinsic operation,比如摄氏和
华氏本质上是float64.所以所有对float64起作用的intrinsic operation都可以对摄氏
华氏起作用
<a href="https://play.golang.org/p/ZjSJcqEEJC">https://play.golang.org/p/ZjSJcqEEJC</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Cel</span> <span style="color: #b58900;">float64</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Fah</span> <span style="color: #b58900;">float64</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #859900; font-weight: bold;">var</span> c Cel = 99.5
        <span style="color: #859900; font-weight: bold;">var</span> f Fah = 500.7

        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%v\n"</span>, c<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%g\n"</span>, f<span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">//////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">//invalid operation: c - f (mismatched types Cel and Fah)        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Printf("%g\n", c-f)                                          //</span>
        <span style="color: #93a1a1;">//////////////////////////////////////////////////////////////////////</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">99.5</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">500.7</span>
</pre>
</div>
</li>
<li>相同的named type之间,或者named type和自己的underlying type之间是可以使用
comparision operator的(比如==, &lt;),不同的named type之间连加减都不可以,更不要
说比较了.
<a href="https://play.golang.org/p/Yte0wz8VLm">https://play.golang.org/p/Yte0wz8VLm</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Cel</span> <span style="color: #b58900;">float64</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Fah</span> <span style="color: #b58900;">float64</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #859900; font-weight: bold;">var</span> c Cel
        <span style="color: #859900; font-weight: bold;">var</span> f Fah

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>c == 0<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>f &gt;= 0<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>c == <span style="color: #268bd2;">Cel</span><span style="color: #268bd2;">(</span>f<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">/////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">invalid operation: c == f (mismatched types Cel and Fah)        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Println(c == f)                                             //</span>
        <span style="color: #93a1a1;">/////////////////////////////////////////////////////////////////////</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
</pre>
</div>
</li>
<li>而 named type的method就不是underlying type能够决定的了.换句话说,method是定
义在named type上的,而不是定义在underlying type的
<ol class="org-ol">
<li>比如,我们可以定义String(), 会被打印函数调用.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>c <span style="color: #b58900;">Celsius</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">String</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%g&#176;C"</span>, c<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>调用结果如下,但是其他的underlying type为float的类型并不会享受到这个method
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>
<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"github.com/harrifeng/gopl.io/ch2/tempconv0"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> c tempconv.Celsius
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>c<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0&#176;C                                            //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ol>
</li>
<li>使用named type当然有一个最明显的优势,就是可以把复杂的类型,使用type改成简单
的名字,会减少书写复杂度.当然了,原来的名字越复杂就能获得更大的简化
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Packages and Files</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>和其他语言一样,package在go里面起到了模块化,封装,分离编译还有重用等功能
</li>
<li>队友某个package的代码来说,它们会存在于一个或者多个.go文件里面,而且这一个或
者多个文件一般会放在文件x/y/z/{package-name}下面,其中最后一层一般是package的
名字,比如我们最常用的package fmt存放在src/fmt文件夹下
</li>
<li>每个package其实都提供了一个namespace,比如image package和unicode/utf16两个package
里面都有identifier Decode,如果要区分,我们就要分别写成:
<ul class="org-ul">
<li>image.Decode
</li>
<li>utf16.Decode
</li>
</ul>
</li>
<li>package还可以来控制哪些name是可以在package外面被看到的(在外面被看到叫做exported)
在Go里面,export的原则很简单.首字母大写的会被exported
</li>
<li>下面我们来看一个package例子,比如我们想把我们的华氏摄氏问题开源:
<ul class="org-ul">
<li>首先我们定义我们的package名字为tempconv,所以我们创建如下的文件夹
<div class="org-src-container">

<pre class="src src-sh">mkdir -p src/gopl.io/ch2/tempconv
</pre>
</div>
</li>
<li>我们建立第一个文件,主要放了我们的type, constant,还有为这个type创建的method
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">file path: src/gopl.io/ch2/tempconv/tempconv.go</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Package tempconv performs Celsius and Fahrenheit conversions.</span>
<span style="color: #859900; font-weight: bold;">package</span> tempconv

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Celsius</span> <span style="color: #b58900;">float64</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Fahrenheit</span> <span style="color: #b58900;">float64</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #2aa198;">(</span>
        AbsoluteZeroC Celsius = -273.15
        FreezingC     Celsius = 0
        BoilingC      Celsius = 100
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>c <span style="color: #b58900;">Celsius</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">String</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span>    <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%g&#176;C"</span>, c<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>f <span style="color: #b58900;">Fahrenheit</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">String</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%g&#176;F"</span>, f<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>然后我们把另一块逻辑:两种type 转换的例子放到package文件夹下面的另外一个文
件
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">file path: src/gopl.io/ch2/tempconv/conv.go</span>
<span style="color: #859900; font-weight: bold;">package</span> tempconv

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">CToF converts a Celsius temperature to Fahrenheit.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">CToF</span><span style="color: #2aa198;">(</span>c <span style="color: #b58900;">Celsius</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">Fahrenheit</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">Fahrenheit</span><span style="color: #b58900;">(</span>c*9/5 + 32<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">FToC converts a Fahrenheit temperature to Celsius.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">FToC</span><span style="color: #2aa198;">(</span>f <span style="color: #b58900;">Fahrenheit</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">Celsius</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">Celsius</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">(</span>f - 32<span style="color: #268bd2;">)</span> * 5 / 9<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>在package上面会有一段comment(这个叫doc comment),比如这个package的doc就如下.
一般只有一个package 文件里面会有这个doc comment
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Package tempconv performs Celsius and Fahrenheit conversions.</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-2-6-1" class="outline-4">
<h4 id="sec-2-6-1">Imports</h4>
<div class="outline-text-4" id="text-2-6-1">
<ul class="org-ul">
<li>有了package,那么就得有导入package的方法.go里面,导入package的方法是使用import
</li>
<li>import后面跟的是我们"确定了导入工具后(一般是git)", 使用这个工具下载的代码,
比如gopl.io/ch2/tempcov
</li>
<li>我们当然不会使用"gopl.io/ch2/tempcov"这么长的名字,一般来说就是最后一节名字
这里是tempcov
</li>
<li>下面就是import我们tempcov的例子
<a href="https://play.golang.org/p/z6rRJlVlBL">https://play.golang.org/p/z6rRJlVlBL</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Cf converts its numeric argument to Celsius and Fahrenheit.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"strconv"</span>

        <span style="color: #2aa198;">"gopl.io/ch2/tempconv"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        arr := <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">{</span><span style="color: #2aa198;">"32"</span>, <span style="color: #2aa198;">"212"</span><span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, arg := <span style="color: #859900; font-weight: bold;">range</span> arr <span style="color: #b58900;">{</span>
                t, err := strconv.<span style="color: #268bd2;">ParseFloat</span><span style="color: #268bd2;">(</span>arg, 64<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #6c71c4;">(</span>os.Stderr, <span style="color: #2aa198;">"cf: %v\n"</span>, err<span style="color: #6c71c4;">)</span>
                        os.<span style="color: #268bd2;">Exit</span><span style="color: #6c71c4;">(</span>1<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                f := tempconv.<span style="color: #268bd2;">Fahrenheit</span><span style="color: #268bd2;">(</span>t<span style="color: #268bd2;">)</span>
                c := tempconv.<span style="color: #268bd2;">Celsius</span><span style="color: #268bd2;">(</span>t<span style="color: #268bd2;">)</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%s = %s, %s = %s\n"</span>,
                        f, tempconv.<span style="color: #268bd2;">FToC</span><span style="color: #6c71c4;">(</span>f<span style="color: #6c71c4;">)</span>, c, tempconv.<span style="color: #268bd2;">CToF</span><span style="color: #6c71c4;">(</span>c<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">32&#176;F = 0&#176;C, 32&#176;C = 89.6&#176;F</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">212&#176;F = 100&#176;C, 212&#176;C = 413.6&#176;F</span>
</pre>
</div>
</li>
<li>import了但没有使用的话,会被认为是error type(error就是一个type, err才是变量
名字!),这是为了减少不必要的依赖,当然这也会引入问题,因为有时候你comment了一
行代码,因为只有一处用到这个package,这个package就被删除了.我们推荐的方法是使
用goimports来自动加入import
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6-2" class="outline-4">
<h4 id="sec-2-6-2">Package Initialization</h4>
<div class="outline-text-4" id="text-2-6-2">
<ul class="org-ul">
<li>package 的initializtion的第一步是initialize package-level的variable,其顺序一
般是按照variable的定义的顺序,除非先定义的variable依赖了后定义的variable,比
如下面的a依赖b,c, 而b依赖c(在函数里面), 所以package-level的variable只有让c
先初始化
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> a = b + c                   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">a initialized third, to 3</span>
<span style="color: #859900; font-weight: bold;">var</span> b = <span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span>                     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">b initialized second, to 2, by calling f</span>
<span style="color: #859900; font-weight: bold;">var</span> c = 1                       <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">c initialized first, to 1,</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> c + 1 <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>如果一个package有多个文件的话,是安装字母顺序的先后进行初始化的(go tool会发
送文件给编译器前,进行这个排序)
</li>
<li>package level的变量其初始化值就是其初始化expression里面赋予的.但是有些时候
initializer expression不是最好的初始化方式,这种情况下init function就被引入
了.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">init</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>  <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>init function和其他function一样,唯二的区别就是一不能被call,二不能被refer
</li>
<li>每个文件里面都可以含有多个init()函数
</li>
<li>每个文件里面的init()函数都会在程序运行的之后,自动运行.顺序和声明的顺序相同
</li>
<li>前面讲述的是单个package初始化的顺序.如果我们import了多个package,那么就安装
import的顺序来初始化.当然了,如果这些package之间有dependency关系,那么要先初
始化被依赖的.这样才能保证某个package开始初始化的时候,前提条件都已经具备了
</li>
<li>main package是最后初始化的.换句话说,当main function开始的时候,所有的import
的package都已经初始化好了
</li>
<li>下面就是一个使用init()函数的例子:计算某个64bit无符号书里面bit的个数,我们这
里使用了一个技巧:
<ul class="org-ul">
<li>64bit个数字就是2**64个数,我们把它分成8个2**8个部分,
</li>
<li>我们在init()函数里面把第一个2**8数组里面每个序列含有的bit个数计算出来,我
们可以把这个pc数组想成是一个简单的map
</li>
<li>输入一个数,我们就把它依次向右移动8位,然后是有byte()强制转换成8bit的数字,
然后就可以去map pc里面找到对应的数字
</li>
</ul>
</li>
<li>代码如下:注意for i, _ := range pc可以简单写作for i := range pc(例子里面的
写法)
<a href="https://play.golang.org/p/0md9KLYnVy">https://play.golang.org/p/0md9KLYnVy</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">var</span> pc <span style="color: #2aa198;">[</span>256<span style="color: #2aa198;">]</span><span style="color: #b58900;">byte</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2**8 elements</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">init</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> i := <span style="color: #859900; font-weight: bold;">range</span> pc <span style="color: #b58900;">{</span>
                pc<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span> = pc<span style="color: #268bd2;">[</span>i/2<span style="color: #268bd2;">]</span> + <span style="color: #268bd2;">byte</span><span style="color: #268bd2;">(</span>i&amp;1<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">PopCount</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">uint64</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">int</span><span style="color: #b58900;">(</span>pc<span style="color: #268bd2;">[</span><span style="color: #268bd2;">byte</span><span style="color: #6c71c4;">(</span>x&gt;&gt;<span style="color: #859900;">(</span>0*8<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">]</span> +
                pc<span style="color: #268bd2;">[</span><span style="color: #268bd2;">byte</span><span style="color: #6c71c4;">(</span>x&gt;&gt;<span style="color: #859900;">(</span>1*8<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">]</span> +
                pc<span style="color: #268bd2;">[</span><span style="color: #268bd2;">byte</span><span style="color: #6c71c4;">(</span>x&gt;&gt;<span style="color: #859900;">(</span>2*8<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">]</span> +
                pc<span style="color: #268bd2;">[</span><span style="color: #268bd2;">byte</span><span style="color: #6c71c4;">(</span>x&gt;&gt;<span style="color: #859900;">(</span>3*8<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">]</span> +
                pc<span style="color: #268bd2;">[</span><span style="color: #268bd2;">byte</span><span style="color: #6c71c4;">(</span>x&gt;&gt;<span style="color: #859900;">(</span>4*8<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">]</span> +
                pc<span style="color: #268bd2;">[</span><span style="color: #268bd2;">byte</span><span style="color: #6c71c4;">(</span>x&gt;&gt;<span style="color: #859900;">(</span>5*8<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">]</span> +
                pc<span style="color: #268bd2;">[</span><span style="color: #268bd2;">byte</span><span style="color: #6c71c4;">(</span>x&gt;&gt;<span style="color: #859900;">(</span>6*8<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">]</span> +
                pc<span style="color: #268bd2;">[</span><span style="color: #268bd2;">byte</span><span style="color: #6c71c4;">(</span>x&gt;&gt;<span style="color: #859900;">(</span>7*8<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">PopCount</span><span style="color: #268bd2;">(</span>0xFFFF<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">PopCount</span><span style="color: #268bd2;">(</span>0xFFF0<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">PopCount</span><span style="color: #268bd2;">(</span>0xFF00<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">PopCount</span><span style="color: #268bd2;">(</span>0xF000<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">16</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">12</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">8</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Scope</h3>
<div class="outline-text-3" id="text-2-7">
<ul class="org-ul">
<li>scope是一种通过program text就可以分析到的,也就是是一种compile-time 属性
</li>
<li>而lifetime和scope是不同的概念.lifetime是一个run-time的属性,必须在运行时进行
判断
</li>
<li>syntactic block是一个{}, 在syntactic block里面定义的变量在外面是看不到的.
</li>
<li>如果declaration没有在一个明显的{}里面的话,有几种情况:
<ul class="org-ul">
<li>declaration定义在了universe block (block for entire source code)
</li>
<li>declaration定义在了package
</li>
<li>declaration定义在了for
</li>
<li>declaration定义在了if
</li>
<li>declaration定义在了switch statement
</li>
</ul>
</li>
<li>一个程序可以多次declare一个name,只要每次declare都在一个不同的lexical block,
比如你可以定义一个local variable和package-level拥有同样的名字
</li>
<li>当编译器遇到一个名字的时候,它会从最近的block(innermost enclosing lexical
block)里面开始寻找,知道universe block
</li>
<li>如果编译器在这个过程中没有找到哪怕一个declaration,它会报告"undeclared name" error
</li>
<li>如果编译器在这个过程中遇到了第一个declaration,它就不会继续寻找了.换句话说,
如果一个name同时声明在inner block和outer block,那么inner declaration会shadow
(hide) outer declaration
<a href="https://play.golang.org/p/U3fWcnuXCE">https://play.golang.org/p/U3fWcnuXCE</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>

<span style="color: #859900; font-weight: bold;">var</span> g = <span style="color: #2aa198;">"g"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        f := <span style="color: #2aa198;">"f"</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>f<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>g<span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// undefined: h        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Println(h)         //</span>
        <span style="color: #93a1a1;">////////////////////////////</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">g</span>
</pre>
</div>
</li>
<li>在一个function里面,lexical block会嵌套任意多层,所以两个local declartion也会
shadow另外的local declaration
</li>
<li>大多数的function内部的block都是通过if和for 创建的!下面是一个反面例子,x这个
name被declare了三次
<a href="https://play.golang.org/p/1qyLFZzXho">https://play.golang.org/p/1qyLFZzXho</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        x := <span style="color: #2aa198;">"hello!"</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">one</span>

        <span style="color: #859900; font-weight: bold;">for</span> i := 0; i &lt; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span>; i++ <span style="color: #b58900;">{</span>
                x := x<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">two</span>
                <span style="color: #859900; font-weight: bold;">if</span> x != <span style="color: #2aa198;">'!'</span> <span style="color: #268bd2;">{</span>
                        x := x + <span style="color: #2aa198;">'A'</span> - <span style="color: #2aa198;">'a'</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">three</span>
                        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"%c"</span>, x<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">HELLO</span>
</pre>
</div>
</li>
<li>block和其scope并不一定完全一致,比如,for loop会创建两个lexical block:
<ul class="org-ul">
<li>explicit block: block全体loop body, 这个block的scope也是loop body
</li>
<li>implicit block: block全体就是for开始,到'第一个分号'结束的这个语句. 但是这
个block的scope却比block大,包括了:
<ol class="org-ol">
<li>condition阶段: i &lt; len(x)
</li>
<li>post-state阶段: i++
</li>
<li>for body全体
</li>
</ol>
</li>
</ul>
</li>
<li>和for一样,if statement也会创建implicit block.如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">if</span> x := <span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span>; x == 0 <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">if</span> y := <span style="color: #268bd2;">g</span><span style="color: #2aa198;">(</span>x<span style="color: #2aa198;">)</span>; x == y <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x, y<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x, y<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: x and y are not visible here</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>x, y<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>第二个个if和第一个if是相互nested的,所以第一个if里面定义的vairable也会在第二
个if里面被看到.switch statement也遵循这个准则
</li>
<li>在package level, 声明出现的顺序不重要(因为依赖关系编译器会去处理的),所以一
个声明可以引用它后面出现的声明,或者引用它自己,所以我们是可以在package level
声明recursive的function的.但是变量和const是不能recursive的,所以如果变量或
常量的声明指向了自己,编译器会报错的
</li>
<li>下面的例子中, f的scope只有if statement,所以if后面的语句再调用f就会报错f没有
定义.当然了编译器还会报错就是f没有使用
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">if</span> f, err := os.<span style="color: #268bd2;">Open</span><span style="color: #2aa198;">(</span>fname<span style="color: #2aa198;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: unused: f</span>
        <span style="color: #859900; font-weight: bold;">return</span> err
<span style="color: #2aa198;">}</span>

f.<span style="color: #268bd2;">ReadByte</span><span style="color: #2aa198;">()</span>                    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: undefined f</span>
f.<span style="color: #268bd2;">Close</span><span style="color: #2aa198;">()</span>                       <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: undefined f</span>
</pre>
</div>
</li>
<li>所以一般改动的方法是在condition之前就声明f
<div class="org-src-container">

<pre class="src src-go">f, err := os.<span style="color: #268bd2;">Open</span><span style="color: #2aa198;">(</span>fname<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> err
<span style="color: #2aa198;">}</span>
f.<span style="color: #268bd2;">ReadByte</span><span style="color: #2aa198;">()</span>
f.<span style="color: #268bd2;">Close</span><span style="color: #2aa198;">()</span>
</pre>
</div>
</li>
<li>short variable declaration需要格外的注意scope的问题,因为short variable
declaration有如下两个特点:
<ul class="org-ul">
<li>没有var关键字,看起来是赋值,其实是声明,只有其中某一个变量在"当前scope"声明
过才会转换为赋值
</li>
<li>声明的是局部变量
</li>
</ul>
</li>
<li>下面的这个例子本来的意愿是"把当前的路径存储到cwd里面",但是因为":="其实是声明
所以其实在init()函数里面又创建了一个cwd的局部变量,shadow了全局变量cwd
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> cwd string

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">init</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        cwd, err := os.Getwd*<span style="color: #b58900;">()</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: unused: cwd</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatalf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"os.Getwd failed: %v"</span>, err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>所以上面程序的结果是编译器报错,cwd没有被使用
</li>
<li>一个最错误的修改方法就是简单的"使用一下"局部变量cwd,这样虽然能够运行了,在编
译上没有错误了,但是在逻辑上是错误的!
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> cwd string

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">init</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        cwd, err := os.Getwd*<span style="color: #b58900;">()</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: unused: cwd</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatalf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"os.Getwd failed: %v"</span>, err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        log.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Working directory = %s"</span>, cwd<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>正确的改法则是放弃使用":=",而使用真正的assignment "=",当然了要先使用var来声
明err(error是类型,err是变量),因为赋值符号要求左边的操作数都是已经声明过的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> cwd string

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">init</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> err error
        cwd, err = os.<span style="color: #268bd2;">Getwd</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fataf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"os.Getwd failed: %v"</span>, err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 03: Basic Data Types</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>Go的type主要分成四个大的类别:
<ul class="org-ul">
<li>Basic type: 包括number, string, boolean
</li>
<li>Aggregate type: 包括array,struct, 他们共同的特点是把多个不同的value结合在
一起
</li>
<li>Refference type: 包括pointer, slice, map, function, channel.他们的特点是间
接的"包含"variable
</li>
<li>Interface type
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Integers</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>Go的number是按照其长度(bit数)和是否有符号,分成了,如下的多个类型
<pre class="example">
int8, 1int16, int32, int64, uint8, uint16, uint32, uint64
</pre>
</li>
<li>而最最常用的类型是int和unit,他们对应int32"或者"int64, 这是根据平台不同而不同
的,所以不要assume int的size
</li>
<li>rune也是一种int32的同义词,但是使用rune了以后,就标示了这个variable其实就是一
个Unicode.
</li>
<li>同样的, byte也是uint8的同义词,但是使用了byte以后,就说明这个变量是raw data而
不是small numeric quantity
</li>
<li>uintptr是一个width没有定义的类型,但是可以用来存储"全部类型的pointer", uintptr
类型主要是为了low-level编程,比如和C library相关的操作
</li>
<li>即便是size一样, int和int32也不能相互直接转换,而是需要explicit conversion.我
们可以把int和int32(或者64!)想象成underlying type一致,但是type不一样的两个类
型相互之间肯定是需要显式的转换的.
</li>
<li>Go里面的有符号数是通过two's complement form(二补数)的方法来存储:high-order bit
要存储符号,所以n-bit number的取值区间是(-2)**(n-1)到(2)**(n-1)-1.比如int8的
取值区间就是-128到127.二补数的方法负数采取"首位为1表示负数,除此之外取反加一
获得真正数值"的办法来表达负数,我们来看一个例子
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">Hex</th>
<th scope="col" class="right">highest sign + number</th>
<th scope="col" class="left">one's complement</th>
<th scope="col" class="left">two's complement</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">+7</td>
<td class="right">0111</td>
<td class="left">Same with left</td>
<td class="left">Same with left</td>
</tr>

<tr>
<td class="right">+6</td>
<td class="right">0110</td>
<td class="left">Same with left</td>
<td class="left">Same with left</td>
</tr>

<tr>
<td class="right">+5</td>
<td class="right">0101</td>
<td class="left">Same with left</td>
<td class="left">Same with left</td>
</tr>

<tr>
<td class="right">+4</td>
<td class="right">0100</td>
<td class="left">Same with left</td>
<td class="left">Same with left</td>
</tr>

<tr>
<td class="right">+3</td>
<td class="right">0011</td>
<td class="left">Same with left</td>
<td class="left">Same with left</td>
</tr>

<tr>
<td class="right">+2</td>
<td class="right">0010</td>
<td class="left">Same with left</td>
<td class="left">Same with left</td>
</tr>

<tr>
<td class="right">+1</td>
<td class="right">0001</td>
<td class="left">Same with left</td>
<td class="left">Same with left</td>
</tr>

<tr>
<td class="right">+0</td>
<td class="right">0000</td>
<td class="left">Same with left</td>
<td class="left">Same with left</td>
</tr>

<tr>
<td class="right">-0</td>
<td class="right">0000</td>
<td class="left">1111</td>
<td class="left">0000 for both -0 and +0</td>
</tr>

<tr>
<td class="right">-1</td>
<td class="right">1001</td>
<td class="left">1110</td>
<td class="left">1111</td>
</tr>

<tr>
<td class="right">-2</td>
<td class="right">1010</td>
<td class="left">1101</td>
<td class="left">1110</td>
</tr>

<tr>
<td class="right">-3</td>
<td class="right">1011</td>
<td class="left">1100</td>
<td class="left">1101</td>
</tr>

<tr>
<td class="right">-4</td>
<td class="right">1100</td>
<td class="left">1011</td>
<td class="left">1100</td>
</tr>

<tr>
<td class="right">-5</td>
<td class="right">1101</td>
<td class="left">1010</td>
<td class="left">1011</td>
</tr>

<tr>
<td class="right">-6</td>
<td class="right">110</td>
<td class="left">1001</td>
<td class="left">1010</td>
</tr>

<tr>
<td class="right">-7</td>
<td class="right">1111</td>
<td class="left">1000</td>
<td class="left">1001</td>
</tr>

<tr>
<td class="right">-8</td>
<td class="right">overflow for 4bit</td>
<td class="left">overflow for 4bit</td>
<td class="left">1000</td>
</tr>
</tbody>
</table>
</li>
<li>由于two's complement复杂的表达方式,我们写个例子来进行理解
<a href="https://play.golang.org/p/TBSF8sxEkZ">https://play.golang.org/p/TBSF8sxEkZ</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">GetTwoComplement</span><span style="color: #2aa198;">(</span>num <span style="color: #b58900;">int8</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> ret = <span style="color: #b58900;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"00000000"</span><span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">for</span> i := <span style="color: #859900; font-weight: bold;">range</span> ret <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span><span style="color: #6c71c4;">(</span>1 &lt;&lt; <span style="color: #268bd2;">uint</span><span style="color: #859900;">(</span>i<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span> &amp; <span style="color: #268bd2;">uint</span><span style="color: #6c71c4;">(</span>num<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> &gt; 0 <span style="color: #268bd2;">{</span>
                        ret<span style="color: #6c71c4;">[</span>i<span style="color: #6c71c4;">]</span> = <span style="color: #2aa198;">'1'</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        beg := 0
        end := <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>ret<span style="color: #b58900;">)</span> - 1
        <span style="color: #859900; font-weight: bold;">for</span> beg &lt;= end <span style="color: #b58900;">{</span>
                ret<span style="color: #268bd2;">[</span>beg<span style="color: #268bd2;">]</span>, ret<span style="color: #268bd2;">[</span>end<span style="color: #268bd2;">]</span> = ret<span style="color: #268bd2;">[</span>end<span style="color: #268bd2;">]</span>, ret<span style="color: #268bd2;">[</span>beg<span style="color: #268bd2;">]</span>
                beg++
                end--
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">string</span><span style="color: #b58900;">(</span>ret<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> i := 0; i &lt; 8; i++ <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Hex: %d \t\tTwo's complement %s\n"</span>, i,
                        <span style="color: #268bd2;">GetTwoComplement</span><span style="color: #6c71c4;">(</span><span style="color: #268bd2;">int8</span><span style="color: #859900;">(</span>i<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">for</span> i := -121; i &gt;= -128; i-- <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Hex: %d \t\tTwo's complement %s\n"</span>, i,
                        <span style="color: #268bd2;">GetTwoComplement</span><span style="color: #6c71c4;">(</span><span style="color: #268bd2;">int8</span><span style="color: #859900;">(</span>i<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: 0               Two's complement 00000000</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: 1               Two's complement 00000001</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: 2               Two's complement 00000010</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: 3               Two's complement 00000011</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: 4               Two's complement 00000100</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: 5               Two's complement 00000101</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: 6               Two's complement 00000110</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: 7               Two's complement 00000111</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: -121            Two's complement 10000111</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: -122            Two's complement 10000110</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: -123            Two's complement 10000101</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: -124            Two's complement 10000100</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: -125            Two's complement 10000011</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: -126            Two's complement 10000010</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: -127            Two's complement 10000001</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hex: -128            Two's complement 10000000</span>
</pre>
</div>
</li>
<li>无符号数就不需要存储符号了,所以range全是正数,比如uint8的range就是0到255
</li>
<li>所有basic type内部,都是可以使用==或者!=来进行比较大小
</li>
<li>Go的二元操作符的有如下五个level的优先级顺序(同一级别的,左边的操作符优先级高),
这五个级别如下
<pre class="example">
*  /  % &lt;&lt;  &gt;&gt; &amp;  &amp;^
___________________
+  -  | ^
___________________
== != &lt; &lt;== &gt;  &gt;=
___________________
&amp;&amp;
___________________
||
</pre>
</li>
<li>这五行里面的前面两行都可以有对应的assignment operator:比如'+'其对应的assignment
operator是'+='
</li>
<li>常见的+,-,*,/可以对所有的number(包括integer, float, complex number)进行操作
</li>
<li>但是%符号只能用到integer上面
</li>
<li>而且%符号的"负数操作"是众所周知的麻烦,因为每个语言的处理都不太一样,在Go语言
里面,%操作的结果的符号"永远和被除数(dividend)的符号相同"
<a href="https://play.golang.org/p/cQcxbAI09p">https://play.golang.org/p/cQcxbAI09p</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>-5 % 3<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>-5 % 3<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-2</span>
</pre>
</div>
</li>
<li>/操作符的行为是和其操作数(operand)相关的,只有'/操作符'的两个操作数全部是整数
其操作结果才会是整数(去掉小数部分)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>5 / 4<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>5.0 / 4<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>5 / 4.0<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>5.0 / 4.0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1.25</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1.25</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1.25</span>
</pre>
</div>
</li>
<li>如果算术运算的结果所拥有的bit数"大于"它type所能拥有的bit数值,我们就说出现了
overflow.overflow的结果就是把最high-order的bit给丢弃掉了,所以"带符号数"由于
最high-order的一个bit是表示符号的,所以其结果可能是负数(即便两个正数操作的情
况下)
<a href="https://play.golang.org/p/_LScrRQ1oI">https://play.golang.org/p/_LScrRQ1oI</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> u uint8 = 255
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>u, u+1, u*u<span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">var</span> i int8 = 127
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>i, i+1, i*1<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">255 0 1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">127 -128 127</span>
</pre>
</div>
</li>
<li>Go里面的二元比较符(binary comparison operator)有下面几种
<pre class="example">
==      equal to
!=      not equal to
&lt;       less than
&lt;=      less than or equal to
&gt;       greater than
&gt;=      greater than or equal to
</pre>
</li>
<li>一个类型是否可以使用比较符号可以推断出这个type的两个特性:
<ol class="org-ol">
<li>comparable:就是可以比较性,并不是所有的类型都可以比较,先阶段我们知道的可
比较的类型有所有的基本类型,也就是boolean, number, string.后面我们介绍每
个类型的时候,会介绍这个类型是否可以比较
</li>
<li>ordered:就是可以排序性,这个也是通过比较符号来实现的.在Go语言里面,可以order
的类型是固定的,只有三个:integer, float-point number和string
</li>
</ol>
</li>
<li>然后还有一元的操作符:
<ul class="org-ul">
<li>一元的加法操作符: + 一般没什么意义, +x就是0+x的缩写
</li>
<li>一元的减法操作符: - 一般表示负数, -x就是0-x的缩写
</li>
</ul>
</li>
<li>接下来是二元二进制操作符(bitwise binary operator).
<pre class="example">
&amp;       bitwise AND
|       bitwise OR
^       bitwise XOR
&amp;^      bit clear (AND NOT)
___________________________
&lt;&lt;      left shift
&gt;&gt;      right shift
</pre>
</li>
<li>前四种是"真的底层"操作,会把它们的操作数(operand)作为bit pattern来对待并不会
认为他们有算术特征:比如进位(carry)和符号(highest order 作为符号).换句话说前
四种操作(我们利用自己写的libray bitutil来写个实验):
<ul class="org-ul">
<li>只是当前bit的操作,结果只会是1或者0,不会对其他bit有影响(没有进位)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"github.com/harrifeng/bitutil"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>127 &amp; 127<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">no carry</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">01111111</span>
</pre>
</div>
</li>
<li>把两个操作数当做raw data,不会考虑补码是使用的one's 还是two'是的complement
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"github.com/harrifeng/bitutil"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-1 's two's complement binary is 11111111</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>64 | -1<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">11111111</span>
</pre>
</div>
</li>
<li>两个操作数是low-bit对齐,没有对应bit的位,无论进行什么操作,都保持原有数字
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"github.com/harrifeng/bitutil"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-1 's two's complement binary is 11111111</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>-1 &amp;^ 7<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">11111000</span>
</pre>
</div>
</li>
</ul>
</li>
<li>而shift operation(<a id="" name=""></a>)就是有算术相关性了:
<ul class="org-ul">
<li>'x&lt;&lt;n'表示x乘以 2 ** n
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"github.com/harrifeng/bitutil"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>5<span style="color: #268bd2;">)</span>, 5<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>5&lt;&lt;2<span style="color: #268bd2;">)</span>, 5&lt;&lt;2<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">00000101 -&gt; 5</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">00010100 -&gt; 20</span>
</pre>
</div>
</li>
<li>'x&gt;&gt;n'表示x除以 2 ** n
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"github.com/harrifeng/bitutil"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>5<span style="color: #268bd2;">)</span>, 5<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>5&gt;&gt;2<span style="color: #268bd2;">)</span>, 5&gt;&gt;2<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">00000101 -&gt; 5</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">00000001 -&gt; 1</span>
</pre>
</div>
</li>
<li>'<a id="" name=""></a>'的算术相关性还体现在:向右移动的时候,如果是负数,则会填充1.其他所有
的情况(包括无符号数的右移,所有数的左移,都是填充零)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"github.com/harrifeng/bitutil"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">minus number '&gt;&gt;' will pad with 1</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>-128<span style="color: #268bd2;">)</span>, -128<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>-128&gt;&gt;6<span style="color: #268bd2;">)</span>, -128&gt;&gt;6<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"----------------------"</span><span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">All other cases pad with 0</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>127&gt;&gt;6<span style="color: #268bd2;">)</span>, 127&gt;&gt;6<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"----------------------"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>1&lt;&lt;6<span style="color: #268bd2;">)</span>, 1&lt;&lt;6<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"----------------------"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>-1<span style="color: #268bd2;">)</span>, -1<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>-1&lt;&lt;6<span style="color: #268bd2;">)</span>, -1&lt;&lt;6<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">00000101 -&gt; 5</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">00000001 -&gt; 1</span>
</pre>
</div>
</li>
<li>当然了还有特殊的情况,有符号数最高一位是符号,假设最高位是1(是0则相反),我们
有没有可能把左边的一个0(或者1)"左移&lt;&lt;"到最高位上呢?答案是否定的,因为这就
溢出了啊!左移就没有这个问题,最后都会到0的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"github.com/harrifeng/bitutil"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>127&gt;&gt;6<span style="color: #268bd2;">)</span>, 127&gt;&gt;6<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>127&gt;&gt;7<span style="color: #268bd2;">)</span>, 127&gt;&gt;7<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>-1&lt;&lt;6<span style="color: #268bd2;">)</span>, -1&lt;&lt;6<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s -&gt; %d\n"</span>, bitutil.<span style="color: #268bd2;">TwoComplementInt8ToRaw</span><span style="color: #268bd2;">(</span>-1&lt;&lt;7<span style="color: #268bd2;">)</span>, -1&lt;&lt;7<span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">///////////////////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">//constant -256 overflows int8                                                //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Printf("%s -&gt; %d\n", bitutil.TwoComplementInt8ToRaw(-1&lt;&lt;8), -1&lt;&lt;8)        //</span>
        <span style="color: #93a1a1;">///////////////////////////////////////////////////////////////////////////////////</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">00000001 -&gt; 1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">00000000 -&gt; 0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">11000000 -&gt; -64</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10000000 -&gt; -128</span>
</pre>
</div>
</li>
</ul>
</li>
<li>在很多算法当中，要使用int作为bit pattern，为了确保行为的可预测性最好使用unsigned
数(因为负数使用的是two's complement表示法)
</li>
<li>从c语言时代开始,语言就提供了signed和unsigned两种格式的int格式,按理说对于某
些不可能为负数的情况,比如数组的长度,我们可以使用unsigned int.但是我们所有的
例子中还是使用了signed int,甚至内置函数len也返回了signed int.这绝不是巧合,
真正的原因在于
<pre class="example">
       计算机采用了从0开始的计数方式!使用unsigned int会导致i &gt;= 0 一直为true
</pre>
</li>
<li>比如下面的例子,本来三次循环就可以结束的,但是却报错数组越界
<a href="https://play.golang.org/p/AOf53Gzgox">https://play.golang.org/p/AOf53Gzgox</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        medals := <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">{</span><span style="color: #2aa198;">"gold"</span>, <span style="color: #2aa198;">"silver"</span>, <span style="color: #2aa198;">"bronze"</span><span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">var</span> i uint
        <span style="color: #859900; font-weight: bold;">for</span> i = <span style="color: #268bd2;">uint</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>medals<span style="color: #268bd2;">)</span> - 1<span style="color: #b58900;">)</span>; i &gt;= 0; i-- <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>medals<span style="color: #6c71c4;">[</span>i<span style="color: #6c71c4;">]</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">bronze</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">silver</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">gold</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panic: runtime error: index out of range</span>
</pre>
</div>
</li>
<li>因为对于uint32来说0-1并不是-1,而是unit32里面最大的数2**32-1,所以数组访问就
越界了<a href="https://play.golang.org/p/HvX4bg8oxl">https://play.golang.org/p/HvX4bg8oxl</a>
</li>
<li>所以,并不是说只要是"不可能为负值"的数就使用unsinged,而是只有个别领域可以使用
unsigned:
<ul class="org-ul">
<li>bit相关操作
</li>
<li>hash的key
</li>
<li>密码学(cryptography)
</li>
</ul>
</li>
<li>Go里面的算术运算(加减乘除)和逻辑运算(与或非,不包括shift)里面的所有的binary
operation肯定是需要两个操作数(operand)啦,go里面要求这两个操作数的type必须完
全一致!implicit conversion是不存在的
<a href="https://play.golang.org/p/I1DFXrTshN">https://play.golang.org/p/I1DFXrTshN</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #859900; font-weight: bold;">var</span> i int
        <span style="color: #859900; font-weight: bold;">var</span> u uint
        <span style="color: #93a1a1;">////////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// invalid operation: i &amp; u (mismatched types int and uint)        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Println(i &amp; u)                                                 //</span>
        <span style="color: #93a1a1;">////////////////////////////////////////////////////////////////////////</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">uint</span><span style="color: #268bd2;">(</span>i<span style="color: #268bd2;">)</span> &amp; u<span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">var</span> apples int32 = 1
        <span style="color: #859900; font-weight: bold;">var</span> oranges int16 = 2
        <span style="color: #93a1a1;">//////////////////////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// invalid operation: apples + oranges (mismatched types int32 and int16)        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Println(apples + oranges)                                                    //</span>
        <span style="color: #93a1a1;">//////////////////////////////////////////////////////////////////////////////////////</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span><span style="color: #268bd2;">(</span>apples<span style="color: #268bd2;">)</span> + <span style="color: #268bd2;">int</span><span style="color: #268bd2;">(</span>oranges<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3</span>
</pre>
</div>
</li>
<li>前面已经说过了conversion operation T(x)有可能会损失精度,比如float 和int之间
两个方向的转换
<a href="https://play.golang.org/p/JvNzPMsV9l">https://play.golang.org/p/JvNzPMsV9l</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        f := 3.14
        i := <span style="color: #268bd2;">int</span><span style="color: #b58900;">(</span>f<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>f, i<span style="color: #b58900;">)</span>

        f = 1.99
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span><span style="color: #268bd2;">(</span>f<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3.14 3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
</pre>
</div>
</li>
<li>这种丢失精度的方式还是有迹可循的(就是丢失小数部分),还有一种丢失精度的方式完
全无法预判(implementation-dependent),那就是原始的操作数的值已经"大于了目标
操作数的取值范围"
<a href="https://play.golang.org/p/mEcvjMfYGQ">https://play.golang.org/p/mEcvjMfYGQ</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        f := 1e100
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>f<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">int</span><span style="color: #268bd2;">(</span>f<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">result is implementation-dependent</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1e+100</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-9223372036854775808</span>
</pre>
</div>
</li>
<li>所有的integer都可以表示成:
<ul class="org-ul">
<li>八进制:以0开头.用处不大,现在主要是POSIX系统的file system
</li>
<li>十六进制:以0x或者0X开头.如今还是广泛的应用在各个领域
</li>
</ul>
</li>
<li>八进制和十六进制的format 打印的字母分别是%o,和%x(%X),如果需要带上前缀(0,0x,0X)
的话,就需要分别使用%#o, %#x(%#X). 下面例子还介绍了一个技巧就是告诉fmt.Printf
反复使用第一个操作数(operand)来打印
<a href="https://play.golang.org/p/sBNthgqZPD">https://play.golang.org/p/sBNthgqZPD</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        o := 0666
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d %[1]o %#[1]o\n"</span>, o<span style="color: #b58900;">)</span>

        x := <span style="color: #268bd2;">int64</span><span style="color: #b58900;">(</span>0xdeadbeef<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d %[1]x %#[1]x %#[1]X\n"</span>, x<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">438 666 0666</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3735928559 deadbeef 0xdeadbeef 0XDEADBEEF</span>
</pre>
</div>
</li>
<li>Rune是能够容纳所有Unicode的字符集,所有被single quote(')包围的单个字符就是rune
类型.format打印字母是%c,如果需要quote就是%q
<a href="https://play.golang.org/p/_yTgOmMLKc">https://play.golang.org/p/_yTgOmMLKc</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        ascii := <span style="color: #2aa198;">'a'</span>
        unicode := <span style="color: #2aa198;">'&#22269;'</span>
        newline := <span style="color: #2aa198;">'\n'</span>

        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d %[1]c %[1]q\n"</span>, ascii<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d %[1]c %[1]q\n"</span>, unicode<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d %[1]q\n"</span>, newline<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">97 a 'a'</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">22269 &#22269; '&#22269;'</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10 '\n'</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Floating-Point Numbers</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>Go提供了两种floating-point number:
<ul class="org-ul">
<li>float32:提供了6个decimal digit: 最大值保存在math.MaxFloat32大约是3.4e38
</li>
<li>float64:提供了15个decimal digit: 最大值保存在math.MaxFloat64大约是1.8e308
</li>
</ul>
</li>
<li>float32是非常容易出错的,因为float32的最大表示值不是很大. 所以在绝大多数情况
下,我们应该使用float64
<a href="https://play.golang.org/p/HuTXck5Pmn">https://play.golang.org/p/HuTXck5Pmn</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> f float32 = <span style="color: #b58900;">(</span>1 &lt;&lt; 24<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>f<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>f + 1<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>f == f+1<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1.6777216e+07                                  //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1.6777216e+07                                  //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>floating-point number可以使用十进制的初始化方法,比如
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">const</span> e = 2.171828
</pre>
</div>
</li>
<li>非常大的数字可以使用scientific notation,也就是e(或者E)来代表以10为底的指数
注意,我们使用%e来故意打印scientific notation
<a href="https://play.golang.org/p/lO0452rSAG">https://play.golang.org/p/lO0452rSAG</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%e\n"</span>, 1200.00<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">const</span> Avogadro = 6.02214129e23
        <span style="color: #859900; font-weight: bold;">const</span> Planck = 6.6206957e-34
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>Avogadro<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>Planck<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1.200000e+03</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">6.02214129e+23</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">6.6206957e-34</span>
</pre>
</div>
</li>
<li>float数字如果整数部分或者小数部分为0,那么可以省略,当然了小数点不能省略.如下
两种都是合格的float数:
<ul class="org-ul">
<li>.707
</li>
<li>1.
</li>
</ul>
</li>
<li>float有三种format打印格式:
<ul class="org-ul">
<li>%f:最传统的方式,无论数字有多大都不使用exponent的方式打印
</li>
<li>%e:无论数字大小,都使用exponent的方式打印
</li>
<li>%g:根据数据的大小来动态决定是使用%f,还是%e
</li>
</ul>
</li>
<li>我们可以使用% +"总数.小数部分"+f的方式来right align(或者left align)的打印float
数字
<a href="https://play.golang.org/p/9I5GixyVu6">https://play.golang.org/p/9I5GixyVu6</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"math"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"-------Right Align--------------"</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> x := 0; x &lt; 8; x++ <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"x = %d ex = %8.3f\n"</span>, x, math.<span style="color: #268bd2;">Exp</span><span style="color: #6c71c4;">(</span><span style="color: #268bd2;">float64</span><span style="color: #859900;">(</span>x<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"-------Left Align---------------"</span><span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">for</span> x := 0; x &lt; 8; x++ <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"x = %d ex = %-8.3f\n"</span>, x, math.<span style="color: #268bd2;">Exp</span><span style="color: #6c71c4;">(</span><span style="color: #268bd2;">float64</span><span style="color: #859900;">(</span>x<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-------Right Align--------------</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 0 ex =    1.000</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 1 ex =    2.718</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 2 ex =    7.389</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 3 ex =   20.086</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 4 ex =   54.598</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 5 ex =  148.413</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 6 ex =  403.429</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 7 ex = 1096.633</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-------Left Align---------------</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 0 ex = 1.000</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 1 ex = 2.718</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 2 ex = 7.389</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 3 ex = 20.086</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 4 ex = 54.598</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 5 ex = 148.413</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 6 ex = 403.429</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 7 ex = 1096.633</span>
</pre>
</div>
</li>
<li>除了这些正常的操作,IEEE 754还定义了一些异常的操作, Go也是支持的:
<ul class="org-ul">
<li>positive infinity: 正数除以0
</li>
<li>negative infinity: 负数除以0
</li>
<li>NaN(not a Number): 一些不合理的数学操作,比如0/0,还有Sqrt(-1)
</li>
</ul>
</li>
<li>这三个特殊值的列表如下,值得注意的是竟然还有正零,一个是负零
<a href="https://play.golang.org/p/xBUyq6Ib1b">https://play.golang.org/p/xBUyq6Ib1b</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> z float64
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>z, -z, 1/z, -1/z, z/z<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0 -0 +Inf -Inf NaN</span>
</pre>
</div>
</li>
<li>这里的NaN值得再说一说,这个值除了0/0可以创建出来,我们还可以使用math.NaN创建
出来,这个值的特性是,它和谁compare的结果都是false(包括它自己!).所以我们要使用
math.IsNaN来测试某个值是不是NaN
<a href="https://play.golang.org/p/L6REIhkxco">https://play.golang.org/p/L6REIhkxco</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"math"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        nan := math.<span style="color: #268bd2;">NaN</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>nan<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>math.<span style="color: #268bd2;">IsNaN</span><span style="color: #268bd2;">(</span>nan<span style="color: #268bd2;">)</span>, math.<span style="color: #268bd2;">IsNaN</span><span style="color: #268bd2;">(</span>0<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>nan == nan, nan &lt; nan, nan &gt; nan<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NaN</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true false</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false false false</span>
</pre>
</div>
</li>
<li>如果一个返回float的函数可能失败,那么最好使用另外的err(error是类型,err是变量)
来报告这个错误
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">compute</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">(</span>value <span style="color: #b58900;">float64</span>, ok <span style="color: #b58900;">bool</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
        <span style="color: #859900; font-weight: bold;">if</span> failed <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> 0, <span style="color: #268bd2; font-weight: bold;">false</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> result, <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Complex Numbers</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>Go提供了两种complex number:
<ul class="org-ul">
<li>complex64 (由两个float32组成)
</li>
<li>complex128(由两个float64组成)
</li>
</ul>
</li>
<li>Go提供了一个build-in函数complex()来创建一个complex number, build-in函数real()
用来取得实数部分,imag()取得虚数部分
<a href="https://play.golang.org/p/aEoe_ZDOo9">https://play.golang.org/p/aEoe_ZDOo9</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> x complex128 = <span style="color: #657b83; font-weight: bold;">complex</span><span style="color: #b58900;">(</span>1, 2<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1+2i</span>
        <span style="color: #859900; font-weight: bold;">var</span> y complex128 = <span style="color: #657b83; font-weight: bold;">complex</span><span style="color: #b58900;">(</span>3, 4<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3+4i</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x * y<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">real</span><span style="color: #268bd2;">(</span>x * y<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">imag</span><span style="color: #268bd2;">(</span>x * y<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">(-5+10i)                                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-5                                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10                                             //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>如果不需要实数部分,可以直接一个integer或float加上一个i就是一个实数部分为零的
imaginary literal
<a href="https://play.golang.org/p/7Je3FikIh2">https://play.golang.org/p/7Je3FikIh2</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>1i * 1i<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">(-1+0i)</span>
</pre>
</div>
</li>
<li>complex const可以是如下三种
<ul class="org-ul">
<li>只有real部分
</li>
<li>只有imag的部分
</li>
<li>两者皆有的complex
</li>
</ul>
</li>
<li>两个complex const可以任意相加,所以我们可以使用如下的加法来方便的初始化complex
number
<div class="org-src-container">

<pre class="src src-go">x := 1 + 2i
y := 3 + 4i
</pre>
</div>
</li>
<li>complex number当然可以使用==和=!比较是否相同:只有real部分和imag部分都相同的
两个complex number才是真的相同的
</li>
<li>go有math/cmplx package来提供complex number的帮助函数,比如对-1开分号在普通数
字里面是没有意义的.但是对于complex number就是有意义的
<a href="https://play.golang.org/p/odeuDdDTnG">https://play.golang.org/p/odeuDdDTnG</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"math/cmplx"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>cmplx.<span style="color: #268bd2;">Sqrt</span><span style="color: #268bd2;">(</span>-1<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">(0+1i)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Booleans</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>Go里面的bool值有两个可能的值true或false(都是小写)
</li>
<li>if和for里面的condition都是boolean值,这和Java是一样的,int值做condition是不可以的
<a href="https://play.golang.org/p/uq1zgwB7Kn">https://play.golang.org/p/uq1zgwB7Kn</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"os"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">//non-bool 1 (type untyped number) used as if condition        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">if 1 {                                                         //</span>
        <span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">fmt.Println()                                             //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">}                                                              //</span>
        <span style="color: #93a1a1;">////////////////////////////////////////////////////////////////////</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>!是逻辑否,也就是说(!true==false)==true
</li>
<li>如果x类型为boolean,我们通常不写x==true,而是直接写作x
</li>
<li>boolean值之间可以使用&amp;&amp;(AND)和||(OR)操作,他们都有着短路(short-circuit)的特
性:如果结果已经可以通过第一个操作数(operanad)判断出来了,那么第二个操作数就
不用再去判断了,这种短路特性让我们可以放心的写下如下的表达式
<div class="org-src-container">

<pre class="src src-go">s != <span style="color: #2aa198;">""</span> &amp;&amp; s<span style="color: #2aa198;">[</span>0<span style="color: #2aa198;">]</span> == <span style="color: #2aa198;">'x'</span>
</pre>
</div>
</li>
<li>因为&amp;&amp;有比||高的优先级(可以通过一些窍门来记忆,比如&amp;&amp;叫做布尔乘法,而||叫做布
尔加法),所以如下的代码其实是可以不需要括号的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">'a'</span> &lt;= c &amp;&amp; c &lt;= <span style="color: #2aa198;">'z'</span> ||
        <span style="color: #2aa198;">'A'</span> &lt;= c &amp;&amp; c &lt;= <span style="color: #2aa198;">'Z'</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>在Go里面是没有boolean和int的implicit conversion的,同样的连T(x)的转换也不行,
所以我们要自己手动写代码来转换
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        i := 0
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">bool</span><span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">true</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// cannot convert i (type int) to type bool        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Println(bool(i))                               //</span>
        <span style="color: #93a1a1;">////////////////////////////////////////////////////////</span>

        t := <span style="color: #268bd2; font-weight: bold;">true</span>
        <span style="color: #93a1a1;">////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// cannot convert t (type bool) to type int        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Println(int(t))                                //</span>
        <span style="color: #93a1a1;">////////////////////////////////////////////////////////</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Strings</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>string是一系列"immutable" byte序列的集合
</li>
<li>一般来说byte就是uint8, 所以string里面也可以存储0等数字,但是一般来说都是存储
有意义的字符
</li>
<li>string还可以被解释成rune(UTF-8字符)的组合,这是用来存储Unicode的组织方式.后面
我们会看到,Go的这种组织方式非常有效率
</li>
<li>内置的len()函数用来返回string里面的byte(注意!不是rune)的数目,而s[i]则返回ith
byte.还有类似python的s[i:j]功能. 当然了如果字符串不全是ascii的话
<a href="https://play.golang.org/p/pKnjl1YFSG">https://play.golang.org/p/pKnjl1YFSG</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        s := <span style="color: #2aa198;">"hello, world"</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>s<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>s<span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span>, s<span style="color: #268bd2;">[</span>7<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>s<span style="color: #268bd2;">[</span>0:5<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">12                                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">104 119                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">hello                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>Go也是有类似Java的数组边界检查,所以如下代码会直接报错
<div class="org-src-container">

<pre class="src src-go">c := s<span style="color: #2aa198;">[</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>                  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panic: index out of range</span>
</pre>
</div>
</li>
<li>s[i:j]操作会产生一个新的string!范围是前面inclusive,后面exclusive的[i,j)
</li>
<li>类似于python,前后的index都可以省略
<div class="org-src-container">

<pre class="src src-go">fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>s<span style="color: #b58900;">[</span>:5<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>              <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">hello</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>s<span style="color: #b58900;">[</span>7:<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>              <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">world</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>s<span style="color: #b58900;">[</span>:<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>               <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">hello, world</span>
</pre>
</div>
</li>
<li>"+"可以作用于两个string的连接,也同样和s[i:j]一样,会产生一个新的字符串!
</li>
<li>string可以使用==和&lt;进行比较,而比较是byte by byte进行的,直到分出胜负(不存在
的byte被看做是无穷小)
<a href="https://play.golang.org/p/X9pBasATPL">https://play.golang.org/p/X9pBasATPL</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"abcd"</span> == <span style="color: #2aa198;">"abcd"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"abce"</span> &gt; <span style="color: #2aa198;">"abcd"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"abc"</span> &gt; <span style="color: #2aa198;">"abcd"</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false</span>
</pre>
</div>
</li>
<li>string的重大特点是string是immutable的.如下操作是不允许的
<div class="org-src-container">

<pre class="src src-go">s<span style="color: #2aa198;">[</span>0<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">'L'</span>                      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: cannot assign to s[0]</span>
</pre>
</div>
</li>
<li>而我们类型+=的操作,其实是分配了一块新的string,老的string一直都在
<a href="https://play.golang.org/p/X9pBasATPL">https://play.golang.org/p/X9pBasATPL</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"abcd"</span> == <span style="color: #2aa198;">"abcd"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"abce"</span> &gt; <span style="color: #2aa198;">"abcd"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"abc"</span> &gt; <span style="color: #2aa198;">"abcd"</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false</span>
</pre>
</div>
</li>
<li>immutability有很多的好处:
<ul class="org-ul">
<li>内容相同的string copy可以安全的共享一份内存
</li>
<li>substring的操作也是在一个固定的内存里面的操作,所以substring操作也很cheap,
因为不需要分配新的内存
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1">String Literals</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>string value最常见的引入方式就是双引号""啦,因为Go对source code默认的encode
方法就是UTF-8,所以我们完全可以在string literal里面就引入UTF-8字符串
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> s = <span style="color: #2aa198;">"Hello, &#19990;&#30028;"</span>
</pre>
</div>
</li>
<li>双引号里面的string value对待backslash + 字符(\c)是要转义的和c语言一样,常见
的转义符如下

<pre class="example">
\a      "alert" or bell
\b      backspace
\f      form feed
\n      new line
\r      carriage return
\t      tab
\v      vertical tab
\\      backslash
</pre>
</li>
<li>string的每个成员都是一个byte,而byte我们说了,它是通过type byte uint8得来的,
但是其concept不再是无符号8bit的整数,而是"raw data in 8bit"
</li>
<li>我们的byte含义是"字符", 但是其实还是可以使用整数的表示方式,而且既然我们的byte
不超过8bit,那么我们就可以使用两个十六位数来表示,为了和普通的整数加以区分
我们在前面加一个'\x',叫做hexadecimal escape. 它的范围是
<pre class="example">
\x00 =&gt; \xff (\xFF)
</pre>
</li>
<li>同样的,我们我们还可以使用三个八进制数(当然了要浪费一个bit:3*3 - 8 = 1),来
表示叫做octal escape.这个escape有特权,其就是\加数字(因为8进制不会出现字母!)
其range是
<pre class="example">
\000 =&gt; \377
</pre>
</li>
<li>任何语言都有不需要escape的raw string literal, Go的表示方法是`&lt;string&gt;`,唯
一不同的是所有在raw string literal里面的'\r'(carriage return)都会被删除
('\n' new line会被保留),以保证在每个平台上面的表现一致
</li>
<li>raw string literal的特点决定了它可以很方便的用在以下几个方面(一般都有很多
的backslash):
<ul class="org-ul">
<li>正则表达式
</li>
<li>HTML template
</li>
<li>JSON literal
</li>
<li>command 参数所使用的message
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">const</span> GoUsage = <span style="color: #2aa198;">`Go is a tool for managing Go source code.</span>

<span style="color: #2aa198;">Usage:</span>
<span style="color: #2aa198;">        go command [arguments]</span>
<span style="color: #2aa198;">`</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-2" class="outline-4">
<h4 id="sec-3-5-2">Unicode</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>最早的时候,计算机字符串就是ASCII的同义词,可以使用7个bit来管理128个"character"
</li>
<li>为了让英语以外的国家也能享受到计算机字符的处理,诞生了包含非常多字符信息的
字符集:Unicode
</li>
<li>Unicode version 8定义了超过120000个character.需要32bit的存储,也就是int32.
在Go里面,设计了int32的一个同义词rune来处理Unicode.从容量上来看int32还有很
大富裕
<a href="https://play.golang.org/p/xsKYTSGnl">https://play.golang.org/p/xsKYTSGnl</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"math"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>math.MaxInt32<span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Unicode version 8 defines code for over 120,000 characters</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>120000<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>math.MaxInt16<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2147483647</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">120000</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">32767</span>
</pre>
</div>
</li>
<li>有了Unicode,如果把所有的字符串里面的每个字符都设计成Unicode(rune类型)的话,
一切问题就都解决了.这种情况下,这个字符串叫做UTF-32(或者UCS-4)
</li>
<li>这种做法简单而粗暴.虽然解决了问题,但是造成了巨大的浪费.因为计算机中最主要
的字符还是ASCII(而ASCII只需要8bit,那么剩下的24bit就白白浪费了)
</li>
<li>解决这个问题的新技术就是UTF-8
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-3" class="outline-4">
<h4 id="sec-3-5-3">UTF-8</h4>
<div class="outline-text-4" id="text-3-5-3">
<ul class="org-ul">
<li>UTF-8就是为了克服Unicode浪费空间而设计的一种新的编码方式. 其核心就是:
<ul class="org-ul">
<li>对于ASCII 字符使用1byte
</li>
<li>对于常用的字符串使用2-3byte
</li>
<li>其他不常用字符串使用4byte
</li>
</ul>
</li>
<li>具体实现的方法是第一个byte的前几个bit来"告知"系统后面有几个byte是和当前byte
是"一体的"(当前byte的小弟):
<ul class="org-ul">
<li>小弟(非第一个byte)的编码是10xxxxxx
</li>
<li>大哥(第一个byte)的编码前几位有几个1就是自己有几个"小弟"(包括自己)
</li>
</ul>
</li>
<li>按照上面的规则,我们可以看出不同的Unicode值对应的UTF-8长度
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Runes number</th>
<th scope="col" class="left">UTF-8 bits</th>
<th scope="col" class="left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">0 - 127</td>
<td class="left">0xxxxxxx</td>
<td class="left">ASCII</td>
</tr>

<tr>
<td class="left">128 - 2047</td>
<td class="left">110xxxxx 10xxxxxx</td>
<td class="left">values &lt; 128 unused</td>
</tr>

<tr>
<td class="left">2048 - 65535</td>
<td class="left">1110xxxx 10xxxxxx 10xxxxxx</td>
<td class="left">values &lt; 2048 unused</td>
</tr>

<tr>
<td class="left">65535 - 0x10ffff</td>
<td class="left">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
<td class="left">other values unused</td>
</tr>
</tbody>
</table>
</li>
<li>Go的代码总是以UTF-8来进行编码.
<ul class="org-ul">
<li>如果是对于某些单个rune(uint32),Go提供了一个叫做unicode的package来处理一
些比如区别字符还是数字,大小写转换(不仅仅是英语了)等功能
</li>
<li>而如果是对于UTF-8字符串来说,我们"能够"处理rune的前提是,我们把UTF-8字符串
转换成rune,使用的package是unicode/utf8
</li>
</ul>
</li>
<li>很多Unicode字符都是无法打印出来的.所以我们需要转义符来打印.这里的转义字符
就叫做Unicode escape,使用\u来转义:
<ul class="org-ul">
<li>对于16-bit value来说就是\uhhhh
</li>
<li>对于32-bit value来说就是\Uhhhhhhhh(注意U大写)
</li>
</ul>
</li>
<li>需要注意的是这里的Unicode escape和前面的Hexdecimal Escape以及Octdecimal不
要混淆,不是一回事,但是有联系:一个16bit Unicode escape可以使用两个Hexdecimal
(或者 Octdecimal)Esacpe来表示, 32bit Unicode escape就可以使用4个
</li>
<li>下面就是我们分别使用三种方式来表达同一个Unicode字符串"世界":
<ul class="org-ul">
<li>直接书写
<div class="org-src-container">

<pre class="src src-go"><span style="color: #2aa198;">"&#19990;&#30028;"</span>
</pre>
</div>
</li>
<li>hexdecimal escape
<div class="org-src-container">

<pre class="src src-go"><span style="color: #2aa198;">"\xe4\xb8\x96\xe7\x95\x8c"</span>
</pre>
</div>
</li>
<li>16-bit Unicode escape
<div class="org-src-container">

<pre class="src src-go"><span style="color: #2aa198;">"\u4e16\u754c"</span>
</pre>
</div>
</li>
<li>32-bit Unicode escape
<div class="org-src-container">

<pre class="src src-go"><span style="color: #2aa198;">"\U00004e16\U0000754c"</span>
</pre>
</div>
</li>
</ul>
</li>
<li>上面的32-bit和16bit的Unicode escape之间的转换是非常容易理解的,我们再来看看
另外两个转换:
<ul class="org-ul">
<li>"世界"是两个汉字,其中"世"的unicode值是(通过<a href="https://unicode-table.com/en/search/?q=%E4%B8%96">https://unicode-table.com/en/search/?q=%E4%B8%96</a>查询)
十进制19990,也就是u4e16, 同样也可以算出'界'的unicode值16位表示是754c
<a href="https://play.golang.org/p/ZvkSYwdI1">https://play.golang.org/p/ZvkSYwdI1</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"strconv"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Unicode value for '&#19990;'</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>strconv.<span style="color: #268bd2;">FormatInt</span><span style="color: #268bd2;">(</span>19990, 16<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Unicode value for '&#30028;'</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>strconv.<span style="color: #268bd2;">FormatInt</span><span style="color: #268bd2;">(</span>30028, 16<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4e16</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">754c</span>
</pre>
</div>
</li>
<li>下面就是Unicode和UTF-8值之间的转换了,首先我们写了一个程序来把我们的unicode
十六进制的值转换成二进制
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"github.com/harrifeng/bitutil"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>bitutil.<span style="color: #268bd2;">HexStringToBinaryString</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"4e16"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0100|1110|0001|0110</span>
</pre>
</div>
</li>
<li>得到了二进制字符串0100|1110|0001|0110,然后我们从后面开始每六个一组,从而
得到
<pre class="example">
0100|1110|0001|0110  =&gt; One:0100  two:|1110|00   three:01|0110
</pre>
</li>
<li>two和three前面都加上10,表示是小弟.one加上1110表是是大哥从而得到
<pre class="example">
   One:0100  two:|1110|00   three:01|0110
+  1110        10              10
=&gt; 11100100    10111000        10010110
=&gt;    E4          B8              96
</pre>
</li>
</ul>
</li>
<li>这就是UTF-8的全部内容,其核心就是依赖尽可能能少的bit(最少8个)来实现Unicode
Unicode, 也就是我们说的Rune, 都是32bit的,但是其中"有意义的内容"有8bit,16bit,
24bit,32bit的四种情况,其中:
<ul class="org-ul">
<li>最多的情况是8bit,这种情况下一个hexdecimal escape就够了,比如'\x41'就
可以表示A. 也就是一个rune literal可以使用一个hexdecimal escape来表示
</li>
<li>16bit,24bit,32bit的情况下就不能使用"一个"hexdecimal escape了,要使用好几个
比如'xe4\xb8\x96'这虽然是一个legal的UTF-8literal,但是取并不是一个legal的
rune literal.因为一个rune literal必须是一个escape,不能是三个.所以这种情
况下一个rune literal必须使用一个Unicode escape!
</li>
</ul>
</li>
<li>由于UTF-8出色的设计,我们的很多string操作完全不需要decoding,比如我们可以通
过如下的代码来测试某个string是不是contains另外的string:
<ul class="org-ul">
<li>作为prefix
<a href="https://play.golang.org/p/RbWRJa7NmE">https://play.golang.org/p/RbWRJa7NmE</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">HasPrefix</span><span style="color: #2aa198;">(</span>s, prefix <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span> &gt;= <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>prefix<span style="color: #b58900;">)</span> &amp;&amp; s<span style="color: #b58900;">[</span>:<span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>prefix<span style="color: #268bd2;">)</span><span style="color: #b58900;">]</span> == prefix
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">HasPrefix</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"&#25105;&#20204;&#30340;&#29233;"</span>, <span style="color: #2aa198;">"&#25105;&#20204;"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">HasPrefix</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"&#25105;&#20204;&#30340;&#29233;"</span>, <span style="color: #2aa198;">"&#20204;"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false</span>
</pre>
</div>
</li>
<li>作为suffix
<a href="https://play.golang.org/p/qXYZ6TYid0">https://play.golang.org/p/qXYZ6TYid0</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">HasSuffix</span><span style="color: #2aa198;">(</span>s, suffix <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span> &gt;= <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>suffix<span style="color: #b58900;">)</span> &amp;&amp; s<span style="color: #b58900;">[</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>s<span style="color: #268bd2;">)</span>-<span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>suffix<span style="color: #268bd2;">)</span>:<span style="color: #b58900;">]</span> == suffix
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">HasSuffix</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"&#25105;&#20204;"</span>, <span style="color: #2aa198;">"&#20204;"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">HasSuffix</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"&#25105;&#20204;"</span>, <span style="color: #2aa198;">"&#25105;&#20204;&#30340;"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false</span>
</pre>
</div>
</li>
</ul>
</li>
<li>实际上,所有使用UTF-8编码的字符串都可以使用同样的逻辑,这种简洁性来自于UTF-8的编码
</li>
<li>我们前面讲过,包含了超过8bitUnicode的字符串,其len()的结果,和rune的个数不会一样
<a href="https://play.golang.org/p/b6XoblT29f">https://play.golang.org/p/b6XoblT29f</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"unicode/utf8"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        s := <span style="color: #2aa198;">"hello, &#19990;&#30028;"</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>s<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>utf8.<span style="color: #268bd2;">RuneCountInString</span><span style="color: #268bd2;">(</span>s<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================output===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">13</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9</span>
</pre>
</div>
</li>
<li>如果我们不想一个一个byte(8bit)的处理,而是一个一个rune(32-bit)的处理,,那么
我们就要使用unicode/utf8 package
<a href="https://play.golang.org/p/aZsVr2my_b">https://play.golang.org/p/aZsVr2my_b</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"unicode/utf8"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        s := <span style="color: #2aa198;">"hello, &#19990;&#30028;"</span>

        <span style="color: #859900; font-weight: bold;">for</span> i := 0; i &lt; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>; <span style="color: #b58900;">{</span>
                r, size := utf8.<span style="color: #268bd2;">DecodeRuneInString</span><span style="color: #268bd2;">(</span>s<span style="color: #6c71c4;">[</span>i:<span style="color: #6c71c4;">]</span><span style="color: #268bd2;">)</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%d\t%c\n"</span>, i, r<span style="color: #268bd2;">)</span>
                i += size
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0    h</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1    e</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2    l</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3    l</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4    o</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5    ,</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">6</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">7    &#19990;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10   &#30028;</span>
</pre>
</div>
</li>
<li>当然了,自己算index的方法很麻烦,可喜的是,虽然len()是以byte为中心的,但是内置
的range确是以rune为核心的
<ul class="org-ul">
<li>代码如下
<a href="https://play.golang.org/p/pn4voeyqrM">https://play.golang.org/p/pn4voeyqrM</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #859900; font-weight: bold;">for</span> i, r := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #2aa198;">"hello, &#19990;&#30028;"</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%d\t%q\t%d\n"</span>, i, r, r<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0    'h'     104</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1    'e'     101</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2    'l'     108</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3    'l'     108</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4    'o'     111</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5    ','     44</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">6    ' '     32</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">7    '&#19990;'    19990</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10   '&#30028;'    30028</span>
</pre>
</div>
</li>
<li>其示意图如下
<pre class="example">
              +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
              |...| h | e | l | l | o | , |   | e4| b8| 96| e7| 95| 8c|...|   |   |   |   |   |
              +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
                    ^                          _____世____+_____界_____
                    |
                    |
+----------+        |
| data    -+--------+
+----------+
| len: 13  |
+----------+
</pre>
</li>
</ul>
</li>
<li>换句话说就是range implicit地调用了utf8.DecodeRuneInString.那么问题来了,我们
调用utf8.DecodeRuneInString,无论是explicit还是implicit的情况下,有时候会遇到
所decode的字符串里含有unexpected的input byte.这种情况下,go会自动将unexpected
的字符替换成'\uFFFD'(�),这会是一个菱形的问号.如果遇到这个字符,说明上游的字
符串出了问题(不是一个legal的UTF-8字符串)
</li>
<li>UTF-8很方便,又节省空间.但是有时候,我们更重视效率(rune大小一致,效率更高),直
接使用rune类型是一个好主意.
</li>
<li>rune类型是为Unicode设计的,即便是ASCII类型的字符也是使用32个bit.换句话说,rune
类型数组的len不在是以8bit为单位记录的了,而是以32bit为单位记录.这样虽然不高
效,但是容易理解.
</li>
<li>byte对应的是rune,那么string对应的就是[]rune了(%x会在hex digit之间加空格)
<a href="https://play.golang.org/p/CQcZyiOarS">https://play.golang.org/p/CQcZyiOarS</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        s := <span style="color: #2aa198;">"a&#19990;&#30028;"</span>

        r := <span style="color: #b58900;">[]</span><span style="color: #268bd2;">rune</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>r<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%x\n"</span>, r<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[61 4e16 754c]</span>
</pre>
</div>
</li>
<li>[]rune(slice of rune)可以直接通过T(x)类型转换成string,自动变成"连续的UTF-8"
字符串
</li>
<li>string(x)的参数x如果是整数类型的话,会被理解成rune的integer值,然后转换成
string类型!这一点非常重要,不要理解为会转成"相应字符串",那是itoa做的事情,invalid
的Unicode字符串当然就是打印'\uFFFD'(�)了
<a href="https://play.golang.org/p/HwolI0MzKN">https://play.golang.org/p/HwolI0MzKN</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"strconv"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">string</span><span style="color: #268bd2;">(</span>65<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">string</span><span style="color: #268bd2;">(</span>0x4eac<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">convert integer to corresponding string</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>strconv.<span style="color: #268bd2;">Itoa</span><span style="color: #268bd2;">(</span>65<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">invalid rune Unicode value</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">string</span><span style="color: #268bd2;">(</span>0x123456<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#20140;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">65</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#65533;</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-4" class="outline-4">
<h4 id="sec-3-5-4">Strings and Byte Slices</h4>
<div class="outline-text-4" id="text-3-5-4">
<ul class="org-ul">
<li>go处理string主要有如下几个package:
<ul class="org-ul">
<li>bytes: 主要对byte提供search, replace, compara, trim, split join等功能.而
且因为string是immutable的,所有有些情况下需要使用bytes.Buffer类型来提高字
符串处理的效率
</li>
<li>strconv: 负责boolean, integer, floating-point值和string之间的相互转换.
</li>
<li>unicode: 提供了对rune类型的帮助函数,比如IsDigit, IsLetter, IsUpper, IsLower
等,都是对一个rune的处理,处理的结果,还是一个rune类型.
</li>
<li>strings: 主要对string提供对字符串的查找更改等内容.strings里面也有unicode
里面类似的ToUpper,ToLower功能,只不过输入是UTF-8的字符串,输出也是UTF-8的字
符串
</li>
</ul>
</li>
<li>依靠这四个package的帮助,我们能够很轻松的实现一些功能,比如Unix里面求basename
的命令
<div class="org-src-container">

<pre class="src src-sh">$ basename <span style="color: #2aa198;">"a/b/c.go"</span>
c
</pre>
</div>
</li>
<li>实现的方法核心其实就是strings.LastIndex
<a href="https://play.golang.org/p/QxNxhC5Kpl">https://play.golang.org/p/QxNxhC5Kpl</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"strings"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">basename</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        slash := strings.<span style="color: #268bd2;">LastIndex</span><span style="color: #b58900;">(</span>s, <span style="color: #2aa198;">"/"</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-1 if "/" not found</span>
        s = s<span style="color: #b58900;">[</span>slash+1:<span style="color: #b58900;">]</span>
        <span style="color: #859900; font-weight: bold;">if</span> dot := strings.<span style="color: #268bd2;">LastIndex</span><span style="color: #b58900;">(</span>s, <span style="color: #2aa198;">"."</span><span style="color: #b58900;">)</span>; dot &gt;= 0 <span style="color: #b58900;">{</span>
                s = s<span style="color: #268bd2;">[</span>:dot<span style="color: #268bd2;">]</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> s
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">basename</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"a/b/c.g"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">c</span>
</pre>
</div>
</li>
<li>下面一个例子是给integer里面每三个数字之间插入一个逗号,这是一个简洁的递归版本
<a href="https://play.golang.org/p/VHa7APJvA4">https://play.golang.org/p/VHa7APJvA4</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">comma</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        n := <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> n &lt;= 3 <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> s
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">comma</span><span style="color: #b58900;">(</span>s<span style="color: #268bd2;">[</span>:n-3<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span> + <span style="color: #2aa198;">","</span> + s<span style="color: #b58900;">[</span>n-3:<span style="color: #b58900;">]</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">comma</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"12345"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">12,345</span>
</pre>
</div>
</li>
<li>前面我们说过,使用T(x)的类型转换,可以在string和byte slice之间来回转换.当然
这两种转换的过程中,都会申请一个新的空间来存储新的slice(底层数组)或者新的字
符串
<a href="https://play.golang.org/p/zHTvLHvZHC">https://play.golang.org/p/zHTvLHvZHC</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        s := <span style="color: #2aa198;">"abc"</span>
        b := <span style="color: #b58900;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
        s2 := <span style="color: #268bd2;">string</span><span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>s, b, s2<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">abc [97 98 99] abc</span>
</pre>
</div>
</li>
<li>为了减少byte和string之间转换带来的额外空间使用,我们的bytes库很多地方都拷贝
了strings库的样式(这样就可以在byte类型和string类型完成工作,而不需啊哟先转
换成彼此再工作啦):
<ul class="org-ul">
<li>一些strings库的函数
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Contains</span><span style="color: #2aa198;">(</span>s, substr <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Count</span><span style="color: #2aa198;">(</span>s, sep <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Fields</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">HasPrefix</span><span style="color: #2aa198;">(</span>s, prefix <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Index</span><span style="color: #2aa198;">(</span>s, sep <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Join</span><span style="color: #2aa198;">(</span>a <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>, sep <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span>
</pre>
</div>
</li>
<li>相同名字(类型为[]byte的)bytes库的函数
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Contains</span><span style="color: #2aa198;">(</span>b, subslice <span style="color: #b58900;">[]</span><span style="color: #b58900;">byte</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Count</span><span style="color: #2aa198;">(</span>s, sep <span style="color: #b58900;">[]</span><span style="color: #b58900;">byte</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Fields</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">[]</span><span style="color: #b58900;">byte</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[][]</span><span style="color: #b58900;">byte</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">HasPrefix</span><span style="color: #2aa198;">(</span>s, prefix <span style="color: #b58900;">[]</span><span style="color: #b58900;">byte</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Index</span><span style="color: #2aa198;">(</span>s, sep <span style="color: #b58900;">[]</span><span style="color: #b58900;">byte</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Join</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">[][]</span><span style="color: #b58900;">byte</span>, sep <span style="color: #b58900;">[]</span><span style="color: #b58900;">byte</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">byte</span>
</pre>
</div>
</li>
</ul>
</li>
<li>bytes package提供了一个叫做Buffer的东西(bytes.Buffer)来管理byte slice,它的
特点是内部存储是使用的byte数组,但是提供了写入byte,string,rune的三个接口,如下:
<a href="https://play.golang.org/p/h7G26jnShq">https://play.golang.org/p/h7G26jnShq</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"bytes"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">intsToString</span><span style="color: #2aa198;">(</span>values <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> buf bytes.Buffer

        buf.<span style="color: #268bd2;">WriteRune</span><span style="color: #b58900;">(</span>23383<span style="color: #b58900;">)</span>
        buf.<span style="color: #268bd2;">WriteRune</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">'&#31526;'</span><span style="color: #b58900;">)</span>
        buf.<span style="color: #268bd2;">WriteString</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"&#25968;&#32452;:"</span><span style="color: #b58900;">)</span>
        buf.<span style="color: #268bd2;">WriteByte</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">'['</span><span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">for</span> i, v := <span style="color: #859900; font-weight: bold;">range</span> values <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> i &gt; 0 <span style="color: #268bd2;">{</span>
                        buf.<span style="color: #268bd2;">WriteString</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">", "</span><span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>&amp;buf, <span style="color: #2aa198;">"%d"</span>, v<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        buf.<span style="color: #268bd2;">WriteByte</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">']'</span><span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">return</span> buf.<span style="color: #268bd2;">String</span><span style="color: #b58900;">()</span>

<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">intsToString</span><span style="color: #268bd2;">(</span><span style="color: #6c71c4;">[]</span><span style="color: #b58900;">int</span><span style="color: #6c71c4;">{</span>1, 2, 3<span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#23383;&#31526;&#25968;&#32452;:[1, 2, 3]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-5" class="outline-4">
<h4 id="sec-3-5-5">Conversions between Strings and Numbers</h4>
<div class="outline-text-4" id="text-3-5-5">
<ul class="org-ul">
<li>除了在string, rune和byte直接的转换,另外常见的转换就是numeric value和它们字
符表达方式直接的转换了,在c里面有atoi和itoa两个函数
</li>
<li>先看integer转换成string,有两种方法:一个是fmt.Sprintf,另外一个就是strconv package
里面的Itoa(integer to ASCII)
<a href="https://play.golang.org/p/p8F3JnKMFb">https://play.golang.org/p/p8F3JnKMFb</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"strconv"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        x := 123
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>strconv.<span style="color: #268bd2;">Itoa</span><span style="color: #268bd2;">(</span>x<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        y := fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d"</span>, x<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>y<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">123</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">123</span>
</pre>
</div>
</li>
<li>上面integer转换成string的十进制,有时候我们还想转换成二进制,八进制,十进制,十六
进制这个时候fm.Printf的%b, %x, %u是最可以依赖的.
<a href="https://play.golang.org/p/yM3e6n6SQs">https://play.golang.org/p/yM3e6n6SQs</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        x := 15
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"x = %b\n"</span>, x<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">binary</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"x = %o\n"</span>, x<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">octonary</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"x = %d\n"</span>, x<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">decimal</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"x = %x\n"</span>, x<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">hexadecimal</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"x = %X\n"</span>, x<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 1111</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 17</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = 15</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x = F</span>
</pre>
</div>
</li>
<li>strconv package里面也有Format系列函数来达到上面同样的目的,但是不够灵活,比如
无法像前面加上"x="
<a href="https://play.golang.org/p/o7y9biwmKm">https://play.golang.org/p/o7y9biwmKm</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"strconv"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>strconv.<span style="color: #268bd2;">FormatInt</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">int64</span><span style="color: #6c71c4;">(</span>15<span style="color: #6c71c4;">)</span>, 2<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>strconv.<span style="color: #268bd2;">FormatInt</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">int64</span><span style="color: #6c71c4;">(</span>15<span style="color: #6c71c4;">)</span>, 8<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>strconv.<span style="color: #268bd2;">FormatInt</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">int64</span><span style="color: #6c71c4;">(</span>15<span style="color: #6c71c4;">)</span>, 10<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>strconv.<span style="color: #268bd2;">FormatInt</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">int64</span><span style="color: #6c71c4;">(</span>15<span style="color: #6c71c4;">)</span>, 16<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>strconv.<span style="color: #268bd2;">FormatUint</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">uint64</span><span style="color: #6c71c4;">(</span>15<span style="color: #6c71c4;">)</span>, 2<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1111</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">17</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">15</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1111</span>
</pre>
</div>
</li>
<li>第二个大的转换就是"字符串到integer"了,这个时候fmt(其中的Scanf)就不是特别好
使了,因为它只能处理input,并且要求输入在同一行
</li>
<li>那么就只要靠strconv package的两个函数Atoi(主要负责十进制转换),还有就是
ParseInt(负责各个进制的转换)
<a href="https://play.golang.org/p/niPs58jLeb">https://play.golang.org/p/niPs58jLeb</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"strconv"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        x, _ := strconv.<span style="color: #268bd2;">Atoi</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"23"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span>
        y, _ := strconv.<span style="color: #268bd2;">ParseInt</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"F"</span>, 16, 64<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>y<span style="color: #b58900;">)</span>
        y, _ = strconv.<span style="color: #268bd2;">ParseInt</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"10"</span>, 10, 64<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>y<span style="color: #b58900;">)</span>
        y, _ = strconv.<span style="color: #268bd2;">ParseInt</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"10"</span>, 8, 64<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>y<span style="color: #b58900;">)</span>
        y, _ = strconv.<span style="color: #268bd2;">ParseInt</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"10"</span>, 2, 64<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>y<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">23</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">15</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">8</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">Constants</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>所谓Constant,就是在compile time就被编译器所知的,而且不会改变的值.
</li>
<li>只有如下三种类型可以设置为constant:
<ul class="org-ul">
<li>boolean
</li>
<li>string
</li>
<li>number
</li>
</ul>
</li>
<li>const的会声明一个named value,这个named value和很多的variable一样,只不过它的
值不可能改变
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">const</span> pi = 3.14159              <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">approximately: math.Pi is a better approximation</span>
</pre>
</div>
</li>
<li>const value只是mathematical constant的一种更为容易接受的表示方法(对人类更友
好, 对编译器来说,没区别)
</li>
<li>const可以在()里面一次定义多个
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #2aa198;">(</span>
    e = 2.71828
    pi = 3.1415926
<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>const会对错误detect有好处:某些操作,如果使用变量,那么就要在runtime发现问题,
比如"除以零integer division by zero"
</li>
<li>但是如果我们使用常量来替代变量作为operand(操作数),那么问题就会暴露在编译阶段
</li>
<li>对const 操作数的算术操作,逻辑操作,比较操作结果都可以算作是constant
</li>
<li>某些built-in的函数操作结果也是const,比如len, cap, real, imag, complex,
unsafe.Sizeof
</li>
<li>因为constant其值在compile time已知,所以const(或者const expression)可以出现
在type定义的时候,比如定义array 类型的长度
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">const</span> IPv4Len = 4

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">parseIPv4 parses an IPv4 addresss</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">parseIPv4</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">IP</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> p <span style="color: #b58900;">[</span>IPv4Len<span style="color: #b58900;">]</span>byte
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>const 声明和var声明不一样的地方是,const声明必须有值!但是类型可以省略,因为可
以从值里面推出类型
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> noDelay time.Duration = 0
        <span style="color: #859900; font-weight: bold;">const</span> timeout = 5 * time.Minute
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T %[1]v\n"</span>, noDelay<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T %[1]v\n"</span>, timeout<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T %[1]v\n"</span>, time.Minute<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">time.Duration 0s</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">time.Duration 5m0s</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">time.Duration 1m0s</span>
</pre>
</div>
</li>
<li>定义的时候,如果某一项不赋值,其值(和类型)来自于上一项(previous expression
and its type used again)
<a href="https://play.golang.org/p/x-f9UeuqPb">https://play.golang.org/p/x-f9UeuqPb</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">(</span>
                a = 1
                b
                c = 2
                d
        <span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>a, b, c, d<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1 1 2 2</span>
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-3-6-1" class="outline-4">
<h4 id="sec-3-6-1">The Constant Generator iota</h4>
<div class="outline-text-4" id="text-3-6-1">
<ul class="org-ul">
<li>const 的定义还可以更加的"智能",就是iota,能够"智能"的增加.默认从0开始,默认
每次增加1
<a href="https://play.golang.org/p/nKw9Dcb7Xp">https://play.golang.org/p/nKw9Dcb7Xp</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Weekday</span> <span style="color: #b58900;">int</span>

        <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">(</span>
                Sunday Weekday = <span style="color: #268bd2; font-weight: bold;">iota</span>
                Monday
                Tuesday
                Wednesday
                Thursday
                Friday
                Saturday
        <span style="color: #b58900;">)</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0 1 2 3 4 5 6</span>
</pre>
</div>
</li>
<li>还可以使用更加复杂的用法, 复杂在使用了expression给const赋值,iota还是遵循"从
零开始,每次增长1"的规律
<a href="https://play.golang.org/p/4np6pGINTC">https://play.golang.org/p/4np6pGINTC</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">(</span>
                First uint = 1 &lt;&lt; <span style="color: #268bd2; font-weight: bold;">iota</span>
                Second
                Third
                Fourth
                Fifth
        <span style="color: #b58900;">)</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>First, Second, Third, Fourth, Fifth<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Binary:"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%b, %b, %b, %b, %b"</span>, First, Second, Third, Fourth, Fifth<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1 2 4 8 16</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Binary:</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1, 10, 100, 1000, 10000</span>
</pre>
</div>
</li>
<li>一个更加复杂的例子就是使用iota来生成二进制的容量
</li>
<li>从这个例子也能看出iota的局限性:只能使用位移操作的话,只能以二进制为底,无法产
生1000等不是以2为底产生的数(KB其实就是1000M,  KiB是1024B)
<a href="https://play.golang.org/p/GZ7CekDRmf">https://play.golang.org/p/GZ7CekDRmf</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">(</span>
                _ = 1 &lt;&lt; <span style="color: #268bd2;">(</span>10 * <span style="color: #268bd2; font-weight: bold;">iota</span><span style="color: #268bd2;">)</span>
                KiB
                MiB
                GiB
                TiB
        <span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>KiB<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>MiB<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>GiB<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>TiB<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1024</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1048576</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1073741824</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1099511627776</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-6-2" class="outline-4">
<h4 id="sec-3-6-2">Untyped Constants</h4>
<div class="outline-text-4" id="text-3-6-2">
<ul class="org-ul">
<li>虽然constant可以是一种basic data type比如int或者float64,但是很多情况下constant
在编译时间是无法确定其类型的.这种情况下, go编译器会使用一个最大256bit的存储
空间来存储这个constant,这就是所谓的untyped constant
</li>
<li>这种不确定类型的const有六种表现形式:
<ul class="org-ul">
<li>untyped boolean
</li>
<li>untyped integer
</li>
<li>untyped rune
</li>
<li>untyped floating-point
</li>
<li>untyped complex
</li>
<li>untyped string
</li>
</ul>
</li>
<li>256bit是非常大的一个区间,能够表示非常大的数,大于64bit的数你都不能用fmt打印
出来.为了演示,我们扩展一下上面的例子,打印更多的容量表示方法
<a href="https://play.golang.org/p/kmbx438oSa">https://play.golang.org/p/kmbx438oSa</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">(</span>
                _ = 1 &lt;&lt; <span style="color: #268bd2;">(</span>10 * <span style="color: #268bd2; font-weight: bold;">iota</span><span style="color: #268bd2;">)</span>
                KiB
                MiB
                GiB
                TiB
                PiB
                EiB
                ZiB
                YiB
        <span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>KiB<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>MiB<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>GiB<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>TiB<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>PiB<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>EiB<span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Println(ZiB)   //exceeds 1 &lt;&lt; 64 from here</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Println(YiB)</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>YiB / ZiB<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1024</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1048576</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1073741824</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1099511627776</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1125899906842624</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1152921504606846976</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1024</span>
</pre>
</div>
</li>
<li>ZiB, YiB就是这样的使用了256bit(最大)存储的untype integer.这种untype integer
虽然不能打印,却能够正常的使用
<div class="org-src-container">

<pre class="src src-go">fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>YiB/Zib<span style="color: #2aa198;">)</span>            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"1024"</span>
</pre>
</div>
</li>
<li>另外一个常见的untype的const是math.Pi,它可以在任何float32或者float64应该出现
的位置出现,而且不需要加类型信息
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> x float32 = math.Pi
<span style="color: #859900; font-weight: bold;">var</span> y float64 = math.Pi
<span style="color: #859900; font-weight: bold;">var</span> z complex128 = math.Pi
</pre>
</div>
</li>
<li>如果我们的math.Pi是float64类型的,单说精度降低不假,我们还要每次写代码的时候
写上类型信息(因为Go不允许任何形式的implicit conversion)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">const</span> Pi64 float64 = math.Pi

<span style="color: #859900; font-weight: bold;">var</span> x float32 = <span style="color: #268bd2;">float32</span><span style="color: #2aa198;">(</span>Pi64<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">var</span> y float64 = Pi64
<span style="color: #859900; font-weight: bold;">var</span> z complex128 = <span style="color: #268bd2;">complex128</span><span style="color: #2aa198;">(</span>Pi64<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>在Go的编译器设计中,literal其实都被设计成为了untyped const,对应六种untyped
const,我们就有六种zero value:
<ul class="org-ul">
<li>untyped boolean: 两个:true和false
</li>
<li>untyped integer: 0
</li>
<li>untyped rune: '\u0000'
</li>
<li>untyped float: 0.0
</li>
<li>untyped complex: 0i
</li>
<li>untyped string: 任何string literal
</li>
</ul>
</li>
<li>literal的这种const特性在判断算术结果的时候非常重要,换句话说使用不同的syntax
的literal,得出的结果完全不同
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> f float64 = 212

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">(</span>f - 32<span style="color: #268bd2;">)</span> * 5 / 9<span style="color: #b58900;">)</span>     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">(f-32) is a float64</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>5 / 9 * <span style="color: #268bd2;">(</span>f - 32<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5/9 is an untyped integer, 0</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>5.0 / 9.0 * <span style="color: #268bd2;">(</span>f - 32<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5.0/9.0 is an untyped float</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100</span>
</pre>
</div>
</li>
<li>只有const具有untyped的特性,其他的variable是不可能具有untyped特性的.换句话
说,当一个const赋值给某个variable(声明时候的初始化值也算赋值),implicit
conversion发生了!这种我们第一次在Go里面遇到implicit conversion
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> f float64 = 3 + 0i          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">untyped complex -&gt; float64</span>
f = 2                           <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">untyped integer -&gt; float64</span>
f = 1e123                       <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">untyped floating-point -&gt; float64</span>
f = <span style="color: #2aa198;">'a'</span>                         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">untyped rune -&gt; float64</span>
</pre>
</div>
</li>
<li>下面的代码也就等同于如下(的explicit conversion)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> f float64 = <span style="color: #268bd2;">float64</span><span style="color: #2aa198;">(</span>3 + 0i<span style="color: #2aa198;">)</span>
f = <span style="color: #268bd2;">float64</span><span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>
f = <span style="color: #268bd2;">float64</span><span style="color: #2aa198;">(</span>1e123<span style="color: #2aa198;">)</span>
f = <span style="color: #268bd2;">float64</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'a'</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>我们untyped 六种类型,在var without type 或者short variable declaration这两
种不提供type的初始化方法中,会起到作用(能够定义变量的类型).需要注意的是untype
float会变成确定高精度的float64, untype complex会变成确定的高精度的complex128
但是untype int只会变成int. 这是因为Go中并不存在unsized的float和complex类型,
因为对于浮点数来说,不知道具体bit长度实在太麻烦了
<a href="https://play.golang.org/p/YkATM4_20u">https://play.golang.org/p/YkATM4_20u</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        i := 0
        r := <span style="color: #2aa198;">'\000'</span>
        <span style="color: #859900; font-weight: bold;">var</span> f = 0.0
        <span style="color: #859900; font-weight: bold;">var</span> c = 0i
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, i<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">untyped integer; implicit int(0)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, r<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">untyped rune;    implicit rune('\000')</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, f<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">untyped floating-pint; implicit float64(0.0)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, c<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">untyped complex; implicit complex128(0i)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">int</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">int32</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">float64</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">complex128</span>
</pre>
</div>
</li>
<li>如果不想安装预定的类型转换,那么就要明确的进行T(x)转换
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> i = <span style="color: #268bd2;">int8</span><span style="color: #2aa198;">(</span>0<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">var</span> i int8 = 0
</pre>
</div>
</li>
<li>我们这里第一次见到Go的implicit转换,虽然是implicit的转换,但是和explicit一样,
目的的type必须能够装的下我们的数据,否则会overflow
<a href="https://play.golang.org/p/nwNM9H_qME">https://play.golang.org/p/nwNM9H_qME</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #2aa198;">(</span>
        deadbeef = 0xdeadbeef
        a        = <span style="color: #268bd2;">uint32</span><span style="color: #b58900;">(</span>deadbeef<span style="color: #b58900;">)</span>
        b        = <span style="color: #268bd2;">float32</span><span style="color: #b58900;">(</span>deadbeef<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">rounded up</span>
        c        = <span style="color: #268bd2;">float64</span><span style="color: #b58900;">(</span>deadbeef<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>deadbeef<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>a<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>c<span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">///////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// constant 3735928559 overflows int32        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">const d = int32(deadbeef)                     //</span>
        <span style="color: #93a1a1;">///////////////////////////////////////////////////</span>

        <span style="color: #93a1a1;">/////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// constant 1e+309 overflows float64        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">const e = float64(1e309)                    //</span>
        <span style="color: #93a1a1;">/////////////////////////////////////////////////</span>

        <span style="color: #93a1a1;">//////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// constant -1 overflows uint        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">const f = uint(-1)                   //</span>
        <span style="color: #93a1a1;">//////////////////////////////////////////</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3735928559</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3735928559</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3.7359286e+09</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3.735928559e+09</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 04: Composite Types</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>前面一章我们介绍了Go里面的basic type,这些类型是语言的不可再分的基石(atom),这
一章我们将介绍composite type: array, slice, map, struct
</li>
<li>这四个composite type还能根据长度特性分成两组:
<ul class="org-ul">
<li>fix length: array, struct
</li>
<li>dynamic length: slice, map
</li>
</ul>
</li>
<li>而根据内容的性质array和struct又有不同:
<ul class="org-ul">
<li>array的所有成员的类型一定是相同的,所以它是homogeneous
</li>
<li>struct的所有成员类型不一定相同,所以它是heterogeneous
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Arrays</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>Array是一种"固定"长度的某种类型的element的集合.因为其长度固定,所以在"具有动
态特性"的go语言中,很少使用.而更具动态特点的slice则更多的被使用.slice和array
则是相辅相成的一对.不理解array,则无法理解slice
</li>
<li>array使用最传统的中括号进行访问,而且index从0开始,长度不超过len(arr) - 1
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> a <span style="color: #2aa198;">[</span>3<span style="color: #2aa198;">]</span><span style="color: #b58900;">int</span>                    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">array of 3 integers</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>a<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>               <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">print the first element</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>a<span style="color: #b58900;">[</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>a<span style="color: #268bd2;">)</span>-1<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">print the last element, a[2]</span>
</pre>
</div>
</li>
<li>array初始化方法主要以array literal为主(如果不初始化,或者literal没有提到的,就
设置为0), array literal是一个重点,因为很多奇怪的语法都是因为看不懂array literal
<a href="https://play.golang.org/p/EUYz-koBIT">https://play.golang.org/p/EUYz-koBIT</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> q <span style="color: #b58900;">[</span>3<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span> = <span style="color: #b58900;">[</span>3<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2, 3<span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">var</span> r <span style="color: #b58900;">[</span>3<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span> = <span style="color: #b58900;">[</span>3<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>q<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>r<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2 3]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2 0]</span>
</pre>
</div>
</li>
<li>当然了,如果我们想让literal的长度来决定数组的话,就要使用ellipsis(&#x2026;), 值得
注意的是如果不写'&#x2026;',就变成了slice类型的literal初始化方法
<a href="https://play.golang.org/p/Xj5mhBNDmy">https://play.golang.org/p/Xj5mhBNDmy</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        q := <span style="color: #b58900;">[</span>...<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2, 3, 4<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>q<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, q<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2 3 4]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[4]int</span>
</pre>
</div>
</li>
<li>我们看到数组的类型是int,说明了数组的长度也是数组的类型元素之一,所以int
和int就不是一直类型!
<a href="https://play.golang.org/p/QUx_6OO06Y">https://play.golang.org/p/QUx_6OO06Y</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        q := <span style="color: #b58900;">[</span>3<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2, 3<span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">///////////////////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">//cannot use [4]int literal (type [4]int) as type [3]int in assignment        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">q = [4]int{1, 2, 3, 4}                                                        //</span>
        <span style="color: #93a1a1;">///////////////////////////////////////////////////////////////////////////////////</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>q<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2 3]</span>
</pre>
</div>
</li>
<li>数组的长度必须是constant expression,换言之这个数必须在编译阶段已知.使用const
expresion作为数组长度,是非常"强硬"的一个要求,因为所有变量都不是const.如果我
们在一个function里面进行运算的时候,如果function的一个参数(也就是变量)是容器
长度的最好选择,我们却不能使用它来初始化array!当然了,go有替代的方法,那就是slice,
而且是make创建的slice,因为我们要指定长度
<a href="https://play.golang.org/p/nX6Z1WHVMR">https://play.golang.org/p/nX6Z1WHVMR</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">groupDisplay</span><span style="color: #2aa198;">(</span>l <span style="color: #b58900;">int</span>, s <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>

        <span style="color: #93a1a1;">//////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// non-constant array bound l        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">foo := [l]string{}                   //</span>
        <span style="color: #93a1a1;">//////////////////////////////////////////</span>
        ret := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span>, l<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">bytes.Buffer instead of string is better</span>

        <span style="color: #859900; font-weight: bold;">for</span> i, c := <span style="color: #859900; font-weight: bold;">range</span> s <span style="color: #b58900;">{</span>
                ret<span style="color: #268bd2;">[</span>i%l<span style="color: #268bd2;">]</span> += <span style="color: #268bd2;">string</span><span style="color: #268bd2;">(</span>c<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>ret<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #268bd2;">groupDisplay</span><span style="color: #b58900;">(</span>5, <span style="color: #2aa198;">"abcdefghijklmn"</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[afk bgl chm din ej]</span>
</pre>
</div>
</li>
<li>我们前面多次强调过literal是非常重要的,不理解literal会导致很多代码看不到.literal
这种初始化类型的形式其实主要就是为composite type服务的. composite type一般
成员有两个特性:
<ul class="org-ul">
<li>顺序:数组里面的顺序是前后有别的,但是struct里面的顺序一般语言里面是没有别的
但是在Go里面是有别的
</li>
<li>key:如果把index看成是数组的key,那么数组和struct一样也是有key的,所以literal
在数组中也可以设置成有key的形式
<a href="https://play.golang.org/p/FQCVRu4V6h">https://play.golang.org/p/FQCVRu4V6h</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        symbol := <span style="color: #b58900;">[</span>...<span style="color: #b58900;">]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">{</span>0: <span style="color: #2aa198;">"Dollar"</span>, 1: <span style="color: #2aa198;">"RMB"</span>, 2: <span style="color: #2aa198;">"Yen"</span><span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>symbol<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[Dollar RMB Yen]</span>
</pre>
</div>
</li>
</ul>
</li>
<li>正是由于可以指定index,那么没有指定的就是默认的zero值, 比如指定了index 9为-1
之后,前八个值都为0,第九个为-1
<a href="https://play.golang.org/p/Jln0_01ePU">https://play.golang.org/p/Jln0_01ePU</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        symbol := <span style="color: #b58900;">[</span>...<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>9: -1<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>symbol<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[0 0 0 0 0 0 0 0 0 -1]</span>
</pre>
</div>
</li>
<li>如果两个array的element type是"可以比较的", 那么这两个array也是可以比较的,比
较只有"相同"和"不相同",没有大小关系.所以只能使用"==","!="来比较
<a href="https://play.golang.org/p/huOZmdjU6S">https://play.golang.org/p/huOZmdjU6S</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        a := <span style="color: #b58900;">[</span>2<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2<span style="color: #b58900;">}</span>
        b := <span style="color: #b58900;">[</span>...<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2<span style="color: #b58900;">}</span>
        c := <span style="color: #b58900;">[</span>2<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 3<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>a == b, a == c, b == c<span style="color: #b58900;">)</span>
        d := <span style="color: #b58900;">[</span>3<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2<span style="color: #b58900;">}</span>
        _ = d
        <span style="color: #93a1a1;">//////////////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// invalid operation: a == d (mismatched types [2]int and [3]int)        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Println(a == d)                                                      //</span>
        <span style="color: #93a1a1;">//////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true false false</span>
</pre>
</div>
</li>
<li>可以比较数组是非常"实用"的功能.这样让两个"非常长的数"放到两个数组里面,比较
这两个数组就能比较两个"非常长的数".这里的就是长度为256bit,所以放在byte
类型的byte数组里面的两个hash值的比较
<a href="https://play.golang.org/p/J99rOKgZEw">https://play.golang.org/p/J99rOKgZEw</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"crypto/sha256"</span>
        <span style="color: #2aa198;">"fmt"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        c1 := sha256.<span style="color: #268bd2;">Sum256</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"x"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        c2 := sha256.<span style="color: #268bd2;">Sum256</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"X"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%x\n%x\n%t\n%T\n"</span>, c1, c2, c1 == c2, c1<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[32]uint8</span>
</pre>
</div>
</li>
<li>Go的函数调用使用的pass by value,也就说function的每个参数都会有一份拷贝,所以
function收到的是拷贝,而不是original的variable.
</li>
<li>数组在Go里面并不是一种reference type,所以我们传递一个数组给function的话,调
用的时候,Go还是会复制一份数组的(如果数组大的话,这个开销会比较大).优点当然是
不会改变原来的数组啦
</li>
<li>绝大部分的语言对于数组来说,都是pass by reference的,而Go却不是!
</li>
<li>Go中还保留着指针,所以相比于把整个数组传递进去,更好的方式显然是传递数组的指
针(和c语言学的),这种方法对于数组的操作可以被caller看到.比如我们下面的例子,
将一根byte数组的内容都值零
<a href="https://play.golang.org/p/k0oc9NTgSF">https://play.golang.org/p/k0oc9NTgSF</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">zero</span><span style="color: #2aa198;">(</span>ptr *<span style="color: #b58900;">[</span>32<span style="color: #b58900;">]</span><span style="color: #b58900;">byte</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> i := <span style="color: #859900; font-weight: bold;">range</span> ptr <span style="color: #b58900;">{</span>
                ptr<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span> = 0
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> arr = <span style="color: #b58900;">[</span>32<span style="color: #b58900;">]</span><span style="color: #b58900;">byte</span><span style="color: #b58900;">{</span>1, 2, 3, 4<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>arr<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">zero</span><span style="color: #b58900;">(</span>&amp;arr<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>arr<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2 3 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span>
</pre>
</div>
</li>
<li>这段代码是不是看起来很晕?怎么range就range了一个指针了(指向数组的指针),而且
还可以直接使用指针加[]的方法访问成员变量!这是因为spec里面定义了对于pointer
to array 的优待
<a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a>
<pre class="example">
For a of pointer to array type:
+ a[x] is shorthand for (*a)[x]
</pre>
</li>

<li>上面的例子可以改写成如下
<a href="https://play.golang.org/p/OhlSax5KCB">https://play.golang.org/p/OhlSax5KCB</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">zero</span><span style="color: #2aa198;">(</span>ptr *<span style="color: #b58900;">[</span>32<span style="color: #b58900;">]</span><span style="color: #b58900;">byte</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> i := <span style="color: #859900; font-weight: bold;">range</span> *ptr <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">(</span>*ptr<span style="color: #268bd2;">)[</span>i<span style="color: #268bd2;">]</span> = 0
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> arr = <span style="color: #b58900;">[</span>32<span style="color: #b58900;">]</span><span style="color: #b58900;">byte</span><span style="color: #b58900;">{</span>1, 2, 3, 4<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>arr<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">zero</span><span style="color: #b58900;">(</span>&amp;arr<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>arr<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2 3 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span>
</pre>
</div>
</li>
<li>我们还可以利用byte{}整个literal产生的数组本来就是zero value数组这个事实
来简化我们的代码
<a href="https://play.golang.org/p/1kcOrqTV03">https://play.golang.org/p/1kcOrqTV03</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">zero</span><span style="color: #2aa198;">(</span>ptr *<span style="color: #b58900;">[</span>32<span style="color: #b58900;">]</span><span style="color: #b58900;">byte</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        *ptr = <span style="color: #b58900;">[</span>32<span style="color: #b58900;">]</span><span style="color: #b58900;">byte</span><span style="color: #b58900;">{}</span>
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> arr = <span style="color: #b58900;">[</span>32<span style="color: #b58900;">]</span><span style="color: #b58900;">byte</span><span style="color: #b58900;">{</span>1, 2, 3, 4<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>arr<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">zero</span><span style="color: #b58900;">(</span>&amp;arr<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>arr<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2 3 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span>
</pre>
</div>
</li>
<li>尽管这样,把数组作为function的参数仍然不是一个好的主意,因为数组长度也是数组
类型的一部分,所以上面的例子对于byte就不适用.
</li>
<li>所以除非是256bit哈希值那种例子,大部分的Go代码都不会使用数组作为参数,而是使
用slice
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Slices</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>slice是"变长"的相同数据类型的集合.和数组的"固定长度"相对立.数组的类型一般是
[n]T, 数组长度不一样,其类型肯定不一样. 而slice的类型则是[]T, 也就是说slice
的类型,只和其内部数据的类型有关系
</li>
<li>slice其实是依附于array的, 每个slice都有三部分组成:
<ul class="org-ul">
<li>pointer: 指向自己的underlying array的某个一位置(不一定是underlying数组的
第一个)
</li>
<li>length: slice的长度. len函数返回这个值,不能超过capacity
</li>
<li>capacity: slice的长度(pointer指向的underlying array位置开始,到underlying
array 结束时候的长度). cap函数返回这个值
</li>
</ul>
</li>
<li>多个slice可以共享同一个underlying array,比如下面的例子中Q2和summer就共享了June
<a href="https://play.golang.org/p/m1a4fYyoag">https://play.golang.org/p/m1a4fYyoag</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        months := <span style="color: #b58900;">[</span>...<span style="color: #b58900;">]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">{</span>
                <span style="color: #268bd2; font-weight: bold;">1</span>:  <span style="color: #2aa198;">"January"</span>,
                <span style="color: #268bd2; font-weight: bold;">2</span>:  <span style="color: #2aa198;">"Febrary"</span>,
                <span style="color: #268bd2; font-weight: bold;">3</span>:  <span style="color: #2aa198;">"March"</span>,
                <span style="color: #268bd2; font-weight: bold;">4</span>:  <span style="color: #2aa198;">"April"</span>,
                <span style="color: #268bd2; font-weight: bold;">5</span>:  <span style="color: #2aa198;">"May"</span>,
                <span style="color: #268bd2; font-weight: bold;">6</span>:  <span style="color: #2aa198;">"June"</span>,
                <span style="color: #268bd2; font-weight: bold;">7</span>:  <span style="color: #2aa198;">"July"</span>,
                <span style="color: #268bd2; font-weight: bold;">8</span>:  <span style="color: #2aa198;">"August"</span>,
                <span style="color: #268bd2; font-weight: bold;">9</span>:  <span style="color: #2aa198;">"September"</span>,
                <span style="color: #268bd2; font-weight: bold;">10</span>: <span style="color: #2aa198;">"October"</span>,
                <span style="color: #268bd2; font-weight: bold;">11</span>: <span style="color: #2aa198;">"November"</span>,
                <span style="color: #268bd2; font-weight: bold;">12</span>: <span style="color: #2aa198;">"December"</span><span style="color: #b58900;">}</span>

        Q2 := months<span style="color: #b58900;">[</span>4:7<span style="color: #b58900;">]</span>
        summer := months<span style="color: #b58900;">[</span>6:9<span style="color: #b58900;">]</span>

        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"    Q2:  %v len:%d cap:%d\n"</span>, Q2, <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>Q2<span style="color: #268bd2;">)</span>, <span style="color: #657b83; font-weight: bold;">cap</span><span style="color: #268bd2;">(</span>Q2<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"summer:  %v len:%d cap:%d\n"</span>, summer, <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>summer<span style="color: #268bd2;">)</span>, <span style="color: #657b83; font-weight: bold;">cap</span><span style="color: #268bd2;">(</span>summer<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">Q2:  [April May June] len:3 cap:9</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">summer:  [June July August] len:3 cap:7</span>
</pre>
</div>
</li>
<li>我们的slice的cap其实就是从我们的slice开始,到达underlying数组的最后一个数值,
可以通过下面的图直观的看出来
<img src="https://raw.githubusercontent.com/harrifeng/org_dot/master/notes/go/slice-array.png" alt="slice-array.png" />
</li>
<li>slice的创建方法是s[i:j], 其中这里的s类型可能是:
<ul class="org-ul">
<li>array
</li>
<li>指向array的pointer
</li>
<li>另外一个slice
</li>
</ul>
</li>
<li>[i:j]的规则和python相同,所以大家应该不会陌生.但是和python不同的是cap的设计
(也就是underlying数组的设计),我们的j可以超过len,但是不能超过cap
<div class="org-src-container">

<pre class="src src-go">fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>summer<span style="color: #b58900;">[</span>:20<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panic: out of range</span>
endlessSummer := summer<span style="color: #2aa198;">[</span>:5<span style="color: #2aa198;">]</span>     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">extend a slice(within capacity)</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>endlessSummer<span style="color: #2aa198;">)</span>      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"[June July August September October]"</span>
</pre>
</div>
</li>
<li>这里插一句,如果把string看成是underlying数组的话,可以重复使用underlying string
的slice就是[]byte
</li>
<li>所以slice看起来有点像c语言里面的数组指针!只不过是包裹过的,更加安全的指针!因
为是指针,所以两个slice之间也是有可能重叠的.
</li>
<li>还是因为slice内部有一个指针,所以传递一个slice到一个函数里面是常用的做法,因为
这避免了传递数组会发生的拷贝.既然是slice含有指针,那么副作用必然会有,那就是
underlying array的值可能会被改变
<a href="https://play.golang.org/p/hub1AS4Ov4">https://play.golang.org/p/hub1AS4Ov4</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">reverse</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> i, j := 0, <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>-1; i &lt; j; i, j = i+1, j-1 <span style="color: #b58900;">{</span>
                s<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>, s<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span> = s<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span>, s<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        a := <span style="color: #b58900;">[</span>...<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>0, 1, 2, 3, 4, 5<span style="color: #b58900;">}</span>
        <span style="color: #268bd2;">reverse</span><span style="color: #b58900;">(</span>a<span style="color: #268bd2;">[</span>:<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>a<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[5 4 3 2 1 0]</span>
</pre>
</div>
</li>
<li>编程珠玑里面的rotate 一个数组n个位置的经典问题,在slice看来就变得非常简单,下
面就是例子的代码.Note:这里是初始化的slice,所以类型写的是[]int,而不是[&#x2026;]int
当然了,因为后面还是literal string,我们还是可以1:按顺序书写,2:写上index加某号
指定,未指定的位置值为0
<a href="https://play.golang.org/p/udhSGhHyY9">https://play.golang.org/p/udhSGhHyY9</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">reverse</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> i, j := 0, <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>-1; i &lt; j; i, j = i+1, j-1 <span style="color: #b58900;">{</span>
                s<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>, s<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span> = s<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span>, s<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">rotate s by 2</span>
        s := <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>0, 1, 2, 3, 4, 5<span style="color: #b58900;">}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Important! slice is []int type</span>
        <span style="color: #268bd2;">reverse</span><span style="color: #b58900;">(</span>s<span style="color: #268bd2;">[</span>:2<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">reverse</span><span style="color: #b58900;">(</span>s<span style="color: #268bd2;">[</span>2:<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">reverse</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[2 3 4 5 0 1]</span>
</pre>
</div>
</li>
<li>和数组不一样的是,slice是不能使用==进行比较的.唯一一个类外,是[]byte类型的slice
可以使用bytes.Equal来进行比较.除此以外我们必须自己写函数来比较两个slice.比如
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">equal</span><span style="color: #2aa198;">(</span>x, y <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span> != <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>y<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> i := <span style="color: #859900; font-weight: bold;">range</span> x <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> x<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span> != y<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>写出代码后,我们并没有发现这段代码有特别难的地方(基本和比较两个字符串数组没
什么区别,这里比较的是两个字符串slice),那既然支持"=="两个字符串数组,为什么我
们就不支持"=="两个字符串slice呢?原因有两点:
<ul class="org-ul">
<li>slice是indirect的,它不能"包含"自己
</li>
<li>slice所以依赖的underlying数组是可能改变的我们无法控制
</li>
</ul>
</li>
<li>能够支持"=="的重要意义在于,能够使用"=="比较的类型才能作为map的key.所以slice
是不能作为key值的
</li>
<li>slice使用==的情况只有一种,就是和nil比较.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">if</span> summer == <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>之所以可以和nil比较.是因为slice有一种形态叫做zero value. 注意不是成员是zero
个,而是什么都没有的状态. 这种状态下的slice是没有underlying array的.反之,有
zero个的slice是存在的,比如[]int{}, 其明显有类型为[]int.所以
<pre class="example">
If you need to test whether a slice is empty,
use len(s) == 0, not s == nil
</pre>
</li>
<li>除了和nil比较的结果不同,一个nil的slice和一个长度为0的slice是完全一致的,比如
reverse(nil)是完全合理的,这也就要求go的库要始终考虑nil的情况(如果不能兼顾,要
在document里面体现)
</li>
<li>go使用内置的make函数来创建一个slice(其核心就是创建一个unnamed array, 然后在
这个array基础上创建slice),其有三个参数:类型, length, capacity.其中capacity
可以省略,省略的情况下length等于capacity. 其实这个capacity就是unnamed array的
全部长度啦.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[]</span><span style="color: #b58900;">T</span>, len<span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[]</span><span style="color: #b58900;">T</span>, len, cap<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>make创建一个slice的原理是首先创建一个unnamed array,并且返回这个array的slice
因为是unnamed,所以这个数组是只能通过slice访问.
</li>
<li>使用make创建,再次印证了slice是reference type三剑客(另外两个是map, channel)
之一
</li>
</ul>
</div>
<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">The append Function</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>append是go语言内置的函数,用来添加item到slice里面.append添加的数目不受slice
capacity的限制,所以最后很可能返回一个和原来的slice'不相同的'slice(重新分配
了地址). 比如下面的runes slice从0开始,最后的size肯定不是0
<a href="https://play.golang.org/p/XEj_bs_pO0">https://play.golang.org/p/XEj_bs_pO0</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> runes <span style="color: #b58900;">[]</span><span style="color: #b58900;">rune</span>

        <span style="color: #859900; font-weight: bold;">for</span> _, r := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #2aa198;">"Hello, &#19990;&#30028;"</span> <span style="color: #b58900;">{</span>
                runes = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #268bd2;">(</span>runes, r<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%q\n"</span>, runes<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">['H' 'e' 'l' 'l' 'o' ',' ' ' '&#19990;' '&#30028;']</span>
</pre>
</div>
</li>
<li></li>
<li>append对于slice的处理,类似c++中对于vector的处理&#x2013;空间不够的情况下,cap加倍
当然这只是简单的描述,具体的算法可能更加的精密.去除精密的设计以后,append的真
实骨架可能就和下面我们自己实现的appendInt差不多
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">appendInt</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span>, y <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> z <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span>
        zlen := <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span> + 1

        <span style="color: #859900; font-weight: bold;">if</span> zlen &lt;= <span style="color: #657b83; font-weight: bold;">cap</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">There is room to grow. Extend the slice</span>
                z = x<span style="color: #268bd2;">[</span>:zlen<span style="color: #268bd2;">]</span>
        <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">There is insufficient space. Allocate a new array.</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Grow by doubling, for amortized linear complexity.</span>
                zcap := zlen
                <span style="color: #859900; font-weight: bold;">if</span> zcap &lt; 2*<span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>x<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        zcap = 2 * <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #6c71c4;">(</span>x<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                z = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #268bd2;">(</span><span style="color: #6c71c4;">[]</span><span style="color: #b58900;">int</span>, zlen, zcap<span style="color: #268bd2;">)</span>
                <span style="color: #657b83; font-weight: bold;">copy</span><span style="color: #268bd2;">(</span>z, x<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">a built-in function copy(dist, source)</span>
        <span style="color: #b58900;">}</span>
        z<span style="color: #b58900;">[</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>x<span style="color: #268bd2;">)</span><span style="color: #b58900;">]</span> = y
        <span style="color: #859900; font-weight: bold;">return</span> z
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>每次appendIt运行的时候,都要看看我们新的位置zlen是不是在capacity以内:
<ul class="org-ul">
<li>是的话,它会extend原来的slice,使用下面这句.本质上还是在同一个underlying数
组上进行操作
<div class="org-src-container">

<pre class="src src-go">z = x<span style="color: #2aa198;">[</span>:zlen<span style="color: #2aa198;">]</span>                    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">new slice, with 1 bigger larger length</span>
</pre>
</div>
</li>
<li>不是的话要申请新的更大的underlying数组(cap最少是当前length的两倍,这样可以
减少分配次数)来存放,然后把原来的value拷贝过来.这样一来,当前的z指向的是一
个全新的underlying数组
</li>
</ul>
</li>
<li>当然一个一个的拷贝是最显然的做法了,但是更好的办法是使用built-in函数copy(dist, source)
这个函数要求两个参数必须是同一类型的slice!
</li>
<li>我们来通过下面的例子来真正的调用append,看看结果
<a href="https://play.golang.org/p/jqTIfvu2sP">https://play.golang.org/p/jqTIfvu2sP</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> x, y <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span>
        <span style="color: #859900; font-weight: bold;">for</span> i := 0; i &lt; 10; i++ <span style="color: #b58900;">{</span>
                y = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #268bd2;">(</span>x, i<span style="color: #268bd2;">)</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%d cap =%d\t%v\n"</span>, i, <span style="color: #657b83; font-weight: bold;">cap</span><span style="color: #6c71c4;">(</span>y<span style="color: #6c71c4;">)</span>, y<span style="color: #268bd2;">)</span>
                x = y
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">///////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0 cap =1 [0]                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1 cap =2 [0 1]                                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2 cap =4 [0 1 2]                                  //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3 cap =4 [0 1 2 3]                                //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4 cap =8 [0 1 2 3 4]                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5 cap =8 [0 1 2 3 4 5]                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">6 cap =8 [0 1 2 3 4 5 6]                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">7 cap =8 [0 1 2 3 4 5 6 7]                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">8 cap =16    [0 1 2 3 4 5 6 7 8]                  //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9 cap =16    [0 1 2 3 4 5 6 7 8 9]                //</span>
<span style="color: #93a1a1;">///////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>虽然我们看到了built-in的append和我们的appendInt使用的策略是一样的,但可能它
只是在数目比较小的时候一致,built-in的append可以在后面使用更加精密的算法,所
以我们不能"想当然"的去assume这个算法什么时候重新分配underlying数组,所以使
用append最常见的做法,就是把返回值赋给原来的variable
<div class="org-src-container">

<pre class="src src-sh">runes = append<span style="color: #2aa198;">(</span>runes, r<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>slice虽然叫做reference type,但是需要注意的是虽然slice underlying的数组是indirect
的,但是slice的pointer, length, capacity却是真真正正的和slice在一起的:
<ul class="org-ul">
<li>indirect的数组可以不和slice打招呼就更改
</li>
<li>和slice在一起的pointer, length, capacity就需要"显式"的使用赋值等方法来更
改了
</li>
</ul>
</li>
<li>所以我们大可以把slice看成是如下的一个struct
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">IntSlice</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        ptr      *int
        len, cap int
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>append函数更加强大的地方在于其允许每次加多个item, 甚至允许增加一整个slice.
<a href="https://play.golang.org/p/rXiTV9iaMQ">https://play.golang.org/p/rXiTV9iaMQ</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> x <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span>
        x = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #b58900;">(</span>x, 1<span style="color: #b58900;">)</span>
        x = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #b58900;">(</span>x, 2, 3<span style="color: #b58900;">)</span>
        x = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #b58900;">(</span>x, 4, 5, 6<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span>
        x = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #b58900;">(</span>x, x...<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2 3 4 5 6]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2 3 4 5 6 1 2 3 4 5 6]</span>
</pre>
</div>
</li>
<li>加入整个数组作为参数的时候,使用了ellipsis "&#x2026;",这种用法在Go里面叫做variadic
pamater
<pre class="example">
The final parameter in a function signature may have a type
prefixed with .... A function with such a parameter is called
variadic and may be invoked with zero or more arguments for
that parameter
</pre>
</li>
<li>调用的时候样子是append(x, x&#x2026;),而我们的append函数声明如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span>, y ...<span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>根据参数的不同y会被初始化成不同的slice:
<ul class="org-ul">
<li>append(x, 1): y =&gt; []int{1}
</li>
<li>append(x, 4, 5, 6): y =&gt; []int{4, 5, 6}
</li>
<li>append(x, x&#x2026;): y =&gt; []int{1, 2, 3, 4, 5, 6}
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2">In-Place Slice Techniques</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>in-place的更改一个slice的值是非常常用的手段.比如下面的这个nonempty的例子,就
是输入一个slice,去除这个slice里面为empty的string,然后返回.
</li>
<li>nonempty函数"implicit"的更改了input slice(因为使用了相同的underlying array
这样能节省一次array的申请), 使用公共underlying array也可以从下例中看到(所
以返回值要写明strings[:i])
<a href="https://play.golang.org/p/VOjSuhBC4-">https://play.golang.org/p/VOjSuhBC4-</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">nonempty</span><span style="color: #2aa198;">(</span>strings <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        i := 0
        <span style="color: #859900; font-weight: bold;">for</span> _, s := <span style="color: #859900; font-weight: bold;">range</span> strings <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> s != <span style="color: #2aa198;">""</span> <span style="color: #268bd2;">{</span>
                        strings<span style="color: #6c71c4;">[</span>i<span style="color: #6c71c4;">]</span> = s
                        i++
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> strings<span style="color: #b58900;">[</span>:i<span style="color: #b58900;">]</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        data := <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">{</span><span style="color: #2aa198;">"one"</span>, <span style="color: #2aa198;">""</span>, <span style="color: #2aa198;">"three"</span><span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">usually write</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">data = nonempty(data)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%q\n"</span>, <span style="color: #268bd2;">nonempty</span><span style="color: #268bd2;">(</span>data<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%q\n"</span>, data<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">["one" "three"]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">["one" "three" "three"]</span>
</pre>
</div>
</li>
<li>所以上面的例子中的nonempty最常用的手法和append相同
<div class="org-src-container">

<pre class="src src-go">data = <span style="color: #268bd2;">nonempty</span><span style="color: #2aa198;">(</span>data<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>一个slice可以用来实现stack:
<ul class="org-ul">
<li>比如我们一开始有一个empty slice `stack`,我们可以使用append来模仿push
<div class="org-src-container">

<pre class="src src-go">stack = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #2aa198;">(</span>stack, v<span style="color: #2aa198;">)</span>        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">push v</span>
</pre>
</div>
</li>
<li>[len(stack)-1]就可以模仿top
<div class="org-src-container">

<pre class="src src-go">top := stack<span style="color: #2aa198;">[</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>stack<span style="color: #b58900;">)</span>-1<span style="color: #2aa198;">]</span>      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">top of stack</span>
</pre>
</div>
</li>
<li>[:len(stack)-1]就可以模仿pop
<div class="org-src-container">

<pre class="src src-go">stack = stack<span style="color: #2aa198;">[</span>:<span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>stack<span style="color: #b58900;">)</span>-1<span style="color: #2aa198;">]</span>    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">pop</span>
</pre>
</div>
</li>
</ul>
</li>
<li>从slice中间删除数据:
<ul class="org-ul">
<li>如果需要保持原来的顺序,那么就用我们前面讲的dist和slice的类型一致的函数
copy(dist, src)
<a href="https://play.golang.org/p/5UsqG0cmbK">https://play.golang.org/p/5UsqG0cmbK</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">remove</span><span style="color: #2aa198;">(</span>slice <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span>, i <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #657b83; font-weight: bold;">copy</span><span style="color: #b58900;">(</span>slice<span style="color: #268bd2;">[</span>i:<span style="color: #268bd2;">]</span>, slice<span style="color: #268bd2;">[</span>i+1:<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> slice<span style="color: #b58900;">[</span>:<span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>slice<span style="color: #268bd2;">)</span>-1<span style="color: #b58900;">]</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        s := <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>5, 6, 7, 8, 9<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">remove</span><span style="color: #268bd2;">(</span>s, 2<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[5 6 8 9]</span>
</pre>
</div>
</li>
<li>如果不需要保持原来的顺序
<a href="https://play.golang.org/p/XcvL8JgX4F">https://play.golang.org/p/XcvL8JgX4F</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">remove</span><span style="color: #2aa198;">(</span>slice <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span>, i <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        slice<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span> = slice<span style="color: #b58900;">[</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>slice<span style="color: #268bd2;">)</span>-1<span style="color: #b58900;">]</span>
        <span style="color: #859900; font-weight: bold;">return</span> slice<span style="color: #b58900;">[</span>:<span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>slice<span style="color: #268bd2;">)</span>-1<span style="color: #b58900;">]</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        s := <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>5, 6, 7, 8, 9<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">remove</span><span style="color: #268bd2;">(</span>s, 2<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[5 6 9 8]</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Maps</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>哈希表是计算机重要的数据结构,能够做到search,insert,delete三种操作的复杂度在
O(logN)
</li>
<li>在go里面,是使用map关键字来指代hashmap,而且map是一个reference类型,既然是refrene
type,那么就需要使用make来声明,声明的时候,有两个类型需要指定,一个是key的类型,
一个是value的类型(两者类型不一定需要相同)
</li>
<li>key的类型是需要能够使用"=="来比较的类型,所以,虽然float类型可以使用"=="来比较
但是显然比较不准确,所以使用float类型做key是不合理的.
</li>
<li>创建map有两种方式:
<ul class="org-ul">
<li>最基本的当然是使用make
<div class="org-src-container">

<pre class="src src-go">ages := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>也可以使用map literal(literal是Go的重要语法,在所有的reference type,包括数
组中都地位重要)
<div class="org-src-container">

<pre class="src src-go">ages := <span style="color: #859900; font-weight: bold;">map</span><span style="color: #2aa198;">[</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">{</span>
        <span style="color: #2aa198;">"alice"</span>:   31,
        <span style="color: #2aa198;">"charlie"</span>: 34,
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>使用map literal等同于先使用make,然后赋值
<div class="org-src-container">

<pre class="src src-go">ages := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>
ages<span style="color: #2aa198;">[</span><span style="color: #2aa198;">"alice"</span><span style="color: #2aa198;">]</span> = 31
ages<span style="color: #2aa198;">[</span><span style="color: #2aa198;">"charlie"</span><span style="color: #2aa198;">]</span> = 34
</pre>
</div>
</li>
<li>尽然两者相等,我们还可以使用更简单literal, 可以避免使用make来实现一个成员
个数为0的map.下面这种方法非常常用(大多数情况下是希望有个空的map)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">map</span><span style="color: #2aa198;">[</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">{}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>map的访问是使用[]
</li>
<li>map的删除是使用内置的delete函数
<div class="org-src-container">

<pre class="src src-go"><span style="color: #657b83; font-weight: bold;">delete</span><span style="color: #2aa198;">(</span>ages, <span style="color: #2aa198;">"alice"</span><span style="color: #2aa198;">)</span>           <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">remove element ages["alice"]</span>
</pre>
</div>
</li>
<li>go中map的一大特性是:如果key不存在就会返回zero value,所以如下操作即便是在map
中没有bob的时候,依然不会出错. delete一个不存在的当然也不会出错啦
<a href="https://play.golang.org/p/EWVt96-14j">https://play.golang.org/p/EWVt96-14j</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">sum</span><span style="color: #2aa198;">(</span>x, y, z <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> x + y + z
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        ages := <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>ages<span style="color: #b58900;">)</span>
        ages<span style="color: #b58900;">[</span><span style="color: #2aa198;">"bob"</span><span style="color: #b58900;">]</span> = ages<span style="color: #b58900;">[</span><span style="color: #2aa198;">"bob"</span><span style="color: #b58900;">]</span> + 1
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>ages<span style="color: #b58900;">)</span>
        <span style="color: #657b83; font-weight: bold;">delete</span><span style="color: #b58900;">(</span>ages, <span style="color: #2aa198;">"alice"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>ages<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">map[]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">map[bob:1]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">map[bob:1]</span>
</pre>
</div>
</li>
<li>map element还支持+= 和++操作
<div class="org-src-container">

<pre class="src src-go">ages<span style="color: #2aa198;">[</span><span style="color: #2aa198;">"bob"</span><span style="color: #2aa198;">]</span> += 1
ages<span style="color: #2aa198;">[</span><span style="color: #2aa198;">"bob"</span><span style="color: #2aa198;">]</span>++
</pre>
</div>
</li>
<li>但是map element不是一个variable,所以我们无法取得它的地址. 这样做也是有其深
层次原因的. 因为map可能每加入一个element就会重构内部的存储,m[key]的存储位置
可能就会改变.
</li>
<li>对于map来说,和数组一样使用range遍历,只不过range返回的结果,不再是index value,
而是key,value
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">for</span> name, age := <span style="color: #859900; font-weight: bold;">range</span> ages <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s\t%d\n"</span>, name, age<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>需要特别注意的是,map的结果是random的,没有顺序的.这么做当然也是故意的.所以我
们不要依赖range返回的顺序,真的需要顺序访问的话,需要借助slice和sort
<a href="https://play.golang.org/p/tBo_ksV6R6">https://play.golang.org/p/tBo_ksV6R6</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"sort"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        ages := <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>
                <span style="color: #2aa198;">"Jan"</span>: 12,
                <span style="color: #2aa198;">"Bob"</span>: 14,
                <span style="color: #2aa198;">"Zoe"</span>: 18,
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">var</span> names <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>
        <span style="color: #859900; font-weight: bold;">for</span> name := <span style="color: #859900; font-weight: bold;">range</span> ages <span style="color: #b58900;">{</span>
                names = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #268bd2;">(</span>names, name<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        sort.<span style="color: #268bd2;">Strings</span><span style="color: #b58900;">(</span>names<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, name := <span style="color: #859900; font-weight: bold;">range</span> names <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%s\t%d\n"</span>, name, ages<span style="color: #6c71c4;">[</span>name<span style="color: #6c71c4;">]</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Bob  14</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Jan  12</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Zoe  18</span>
</pre>
</div>
</li>
<li>上面的代码中我们分配了一个初始值为空的slice,但是因为我们的长度其实是固定的
所以最好是分配一个数组或固定长度的slice.同时我们要使用append,所以必须是slice
那么,最好的方案是固定长度的slice(当然了以后我们会发现大部分情况下我们都是只
会使用slice)
<div class="org-src-container">

<pre class="src src-go">names := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>, 0, <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>ages<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>

<li>在第一次循环中,我们的range返回的顺序是key, value,在我们只需要key的时候,可以
省略第二个参数value. 但是第二次循环的时候,我们返回顺序是index, value.我们只
需要value的情况下,必须使用blank identifier "_"来忽略第一个参数
</li>
<li>map type的zero value是nil,换句话说就是referenfe to no hash table at all
<a href="https://play.golang.org/p/-_gt47Upx7">https://play.golang.org/p/-_gt47Upx7</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> ages <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #b58900;">int</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>ages == <span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>ages<span style="color: #268bd2;">)</span> == 0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
</pre>
</div>
</li>
<li>delete, len, range这些操作于一个nil的map(而不是empty size map)都是可以的,这
一点我们前面也说过,对于一个nil的容器和zero size的容器结果需要一样.除非另外
说明,这里我们就要另外说明的是m[key] = value操作不可以在一个nil的map上面.你
得分配了空间才能用啊!
<div class="org-src-container">

<pre class="src src-go">ages<span style="color: #2aa198;">[</span><span style="color: #2aa198;">"carol"</span><span style="color: #2aa198;">]</span> = 21              <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panic: assignment to entry in nil map</span>
</pre>
</div>
</li>
<li>m[key]一个值,即便key不存在,也是没有问题的,但是很多情况下,我们希望知道有没有,
然后进行后续的操作,这就出现了如下的两种写法,它们是等价的,注意返回的第二个参
数不是error类型的err而是boolean类型的true或者false:
<ul class="org-ul">
<li>two-line version:
<div class="org-src-container">

<pre class="src src-go">age, ok := ages<span style="color: #2aa198;">[</span><span style="color: #2aa198;">"bob"</span><span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">if</span> !ok <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">bob is not a key in this map age == 0 */</span><span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>one-line version
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">if</span> age, ok := ages<span style="color: #2aa198;">[</span><span style="color: #2aa198;">"bob"</span><span style="color: #2aa198;">]</span>; !ok <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span><span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>从上面的例子中我们再次看到了"返回两个值"的用法:
<ul class="org-ul">
<li>如果只要第一个值,那么第二个值可以忽略
</li>
<li>如果只要第二个值,那么第一个值必须要明确使用blank identifier
</li>
<li>所以error类型(或者bool类型)一般是第二个值,因为像map[key]的情况下,我们可以
忽略第二个值而直接使用zero值.
</li>
<li>存在第二个bool对于map[key]来说还是很重要的,因为有两种情况的返回0:一种是不
存在,一种是value就是0!
</li>
</ul>
</li>
<li>和slice一样,两个map也不可以相互比较(和nil的比较是可以的).如果想比较两个map
的内容是否完全一致需要自己写loop
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">equal</span><span style="color: #2aa198;">(</span>x, y <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span> != <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>y<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> k, xv := <span style="color: #859900; font-weight: bold;">range</span> x <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> yv, ok := y<span style="color: #268bd2;">[</span>k<span style="color: #268bd2;">]</span>; !ok || yv != <span style="color: #b58900;">xv</span><span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这里我们的equal使用ok来分辨"不存在,所以value是zero value0"和"value值就是0"
如果我们没有写ok,而是直接使用xv != y[k]的话,那么下面这两个map就会碰巧一样!
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Incorrect version!</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">navieEqual</span><span style="color: #2aa198;">(</span>x, y <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span> != <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>y<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">for</span> k, xv := <span style="color: #859900; font-weight: bold;">range</span> x <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> xv != y<span style="color: #268bd2;">[</span>k<span style="color: #268bd2;">]</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">navieEqual</span><span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #6c71c4;">[</span><span style="color: #b58900;">string</span><span style="color: #6c71c4;">]</span><span style="color: #b58900;">int</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"A"</span>: 0<span style="color: #6c71c4;">}</span>, <span style="color: #859900; font-weight: bold;">map</span><span style="color: #6c71c4;">[</span><span style="color: #b58900;">string</span><span style="color: #6c71c4;">]</span><span style="color: #b58900;">int</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"B"</span>: 42<span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
</pre>
</div>
</li>
<li>go没有为我们提供set类型,但是因为map的key也是必须distinct的,所以我们可以如下
提供一个string类型的set
<div class="org-src-container">

<pre class="src src-go">set := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #b58900;">bool</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>有时候,我们需要使用slice做为key,但是slice显然无法使用'==',进行比较,那么我们
就需要一些方法来让slice变成string,然后string肯定就可以使用'=='比较啦.
<a href="https://play.golang.org/p/eJc3grat_B">https://play.golang.org/p/eJc3grat_B</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">var</span> m = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">k</span><span style="color: #2aa198;">(</span>list <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%q"</span>, list<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Add</span><span style="color: #2aa198;">(</span>list <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span>       <span style="color: #2aa198;">{</span> m<span style="color: #b58900;">[</span><span style="color: #268bd2;">k</span><span style="color: #268bd2;">(</span>list<span style="color: #268bd2;">)</span><span style="color: #b58900;">]</span>++ <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Count</span><span style="color: #2aa198;">(</span>list <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> m<span style="color: #b58900;">[</span><span style="color: #268bd2;">k</span><span style="color: #268bd2;">(</span>list<span style="color: #268bd2;">)</span><span style="color: #b58900;">]</span> <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #268bd2;">Add</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"1"</span>, <span style="color: #2aa198;">"2"</span>, <span style="color: #2aa198;">"3"</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">Add</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"1"</span>, <span style="color: #2aa198;">"2"</span>, <span style="color: #2aa198;">"3"</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">Add</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"1"</span>, <span style="color: #2aa198;">"2"</span>, <span style="color: #2aa198;">"3"</span>, <span style="color: #2aa198;">"4"</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">Add</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"1"</span>, <span style="color: #2aa198;">"2"</span>, <span style="color: #2aa198;">"3"</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Count</span><span style="color: #268bd2;">(</span><span style="color: #6c71c4;">[]</span><span style="color: #b58900;">string</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"1"</span>, <span style="color: #2aa198;">"2"</span>, <span style="color: #2aa198;">"3"</span><span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">for</span> k, v := <span style="color: #859900; font-weight: bold;">range</span> m <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>k, v<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">["1" "2" "3" "4"] 1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">["1" "2" "3"] 3</span>
</pre>
</div>
</li>
<li>注意,我们上面的函数使用了"q", 这会给字符串数组每个参数加上""
<a href="https://play.golang.org/p/TbNhh_sw3h">https://play.golang.org/p/TbNhh_sw3h</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        arr := <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">{</span><span style="color: #2aa198;">"1"</span>, <span style="color: #2aa198;">"2"</span>, <span style="color: #2aa198;">"3"</span><span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>arr<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%q\n"</span>, arr<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2 3]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">["1" "2" "3"]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Structs</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>struct 是一种aggregate date type. 它的内部可能有0个或者多个"任意类型的"named
value
</li>
<li>struct的每一个named valu都叫做一个field. 下面就是一个有多个field的struct类型
Employee. 而 dilbert则是Employee类型的一个实例
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"time"</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Employee</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        ID        int
        Name      string
        Address   string
        DoB       time.Time
        Position  string
        Salary    int
        ManagerID int
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> dilbert Employee
</pre>
</div>
</li>
<li>struct 实例的每个field都可以使用"&lt;instance&gt;.&lt;field&gt;"来访问, 而且这些个实例
都是真正的variable,都有自己地址的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Employee</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        ID        int
        Name      string
        Address   string
        DoB       time.Time
        Position  string
        Salary    int
        ManagerID int
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> dilbert Employee
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>dilbert.Salary<span style="color: #b58900;">)</span>
        dilbert.Salary += 5000
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>dilbert.Salary<span style="color: #b58900;">)</span>

        dilbert.Position = <span style="color: #2aa198;">"Engineer"</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>dilbert.Position<span style="color: #b58900;">)</span>
        position := &amp;dilbert.Position
        *position = <span style="color: #2aa198;">"Senior "</span> + *position
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>dilbert.Position<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5000</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Engineer</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Senior Engineer</span>
</pre>
</div>
</li>
<li>dot notation 的"奇特"之处在于不能仅仅instance可以使用"pointer to instance"
也可以使用(相对于go, c语言里面指针会使用-&gt;)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> employeeOfTheMonth *Employee = &amp;dilbert
employeeOfTheMonth.Position += <span style="color: #2aa198;">" (proactive team player)"</span>
</pre>
</div>
</li>
<li>上面例子的最后一句相当于在编译的时候,自动给指针加了"解引用"(* ),给指针主动
加解引用这种方法广泛的应用在Go语言里面,比如range一个指向数组的指针的时候,也
会主动的给这个数组解引用
<div class="org-src-container">

<pre class="src src-go"><span style="color: #2aa198;">(</span>*employeeOfTheMonth<span style="color: #2aa198;">)</span>.Position += <span style="color: #2aa198;">" (proactive team player)"</span>
</pre>
</div>
</li>
<li>下面例子中的函数EmployeeByID会返回一个指向Employee struct的指针,虽然返回的
是指针,但是由于Go会"友好的"为我们加上解引用,所以使用dot访问域也是可以的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">EmployeeByID</span><span style="color: #2aa198;">(</span>id <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> *<span style="color: #b58900;">Employee</span> <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span> <span style="color: #2aa198;">}</span>

fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">EmployeeByID</span><span style="color: #b58900;">(</span>dilbert.ManagerID<span style="color: #b58900;">)</span>.Position<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"Pointy-haired boss"</span>

id := dilbert.ID
<span style="color: #268bd2;">EmployeeByID</span><span style="color: #2aa198;">(</span>id<span style="color: #2aa198;">)</span>.Salary = 0     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fired for ... no real reason</span>
</pre>
</div>
</li>
<li>上面最后一条语句"通过返回值"更改了一个域名!而如果我们的函数声明变成下面的样
子,那么是编译不过去的!因为返回值是一个Employee类型的话,这个返回值是一个值类
型的value(在c语言里面就是一个stack里面的auto变量,调用结束后会被回收),而不是
我们这里的指针!
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">EmployeeById</span><span style="color: #2aa198;">(</span>id <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">Employee</span> <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span><span style="color: #2aa198;">}</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">will NOT compile!!</span>
<span style="color: #268bd2;">EmployeeByID</span><span style="color: #2aa198;">(</span>id<span style="color: #2aa198;">)</span>.Salary = 0     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">EmployeeByID(id) is not a variable !!</span>
</pre>
</div>
</li>
<li>struct的类型信息里面是包括filed的位置信息的,所以struct里面field的位置是不能
随便换的.一旦换了,那么就是一个新的struct类型了.
</li>
<li>如果首字母大写的话,那么这个field就是exported的啦.这是Go独特的控制field是否
private的方法
</li>
<li>struct的类型是非常非常的啰嗦,因为它会包含struct自己所有的field
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>,
                <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #268bd2;">{</span>
                        id      int
                        name    string
                        address string
                <span style="color: #268bd2;">}{</span>1, <span style="color: #2aa198;">""</span>, <span style="color: #2aa198;">""</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>


<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">struct { id int; name string; address string }</span>
</pre>
</div>
</li>
<li>我们当然可以每次都写出完整的struct类型,但是这太麻烦了,所以我们可以看到基本
上每次struct出现的时候,都伴随着type的使用:type把整个struct重定义成另外的named
type
</li>
<li>一个struct类型内部不能声明另外一个自己的类型, 但是却可以声明一个自己类型的指
针. 这样的话,才可以实现linkedlist,或者是二叉树等数据结构.下面就是一个利用二
叉树排序的例子
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        input := <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 3, 5, 7, 2, 4, 6<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>input<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">Sort</span><span style="color: #b58900;">(</span>input<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>input<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">tree</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        value       int
        left, right *tree
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Sort</span><span style="color: #2aa198;">(</span>values <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> root *tree
        <span style="color: #859900; font-weight: bold;">for</span> _, v := <span style="color: #859900; font-weight: bold;">range</span> values <span style="color: #b58900;">{</span>
                root = <span style="color: #268bd2;">add</span><span style="color: #268bd2;">(</span>root, v<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #268bd2;">appendValues</span><span style="color: #b58900;">(</span>values<span style="color: #268bd2;">[</span>:0<span style="color: #268bd2;">]</span>, root<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">appendValues appends the elements of t to values in order</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">and returns the resulting slice.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">appendValues</span><span style="color: #2aa198;">(</span>values <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span>, t *<span style="color: #b58900;">tree</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> t != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                values = <span style="color: #268bd2;">appendValues</span><span style="color: #268bd2;">(</span>values, t.left<span style="color: #268bd2;">)</span>
                values = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #268bd2;">(</span>values, t.value<span style="color: #268bd2;">)</span>
                values = <span style="color: #268bd2;">appendValues</span><span style="color: #268bd2;">(</span>values, t.right<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> values
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">add</span><span style="color: #2aa198;">(</span>t *<span style="color: #b58900;">tree</span>, value <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> *<span style="color: #b58900;">tree</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> t == <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Equivalent to return &amp;tree{value: value}</span>
                t = <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">tree</span><span style="color: #268bd2;">)</span>
                t.value = value
                <span style="color: #859900; font-weight: bold;">return</span> t
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">if</span> value &lt; t.value <span style="color: #b58900;">{</span>
                t.left = <span style="color: #268bd2;">add</span><span style="color: #268bd2;">(</span>t.left, value<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
                t.right = <span style="color: #268bd2;">add</span><span style="color: #268bd2;">(</span>t.right, value<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">t is the parameter of the function</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">paramter of one function is also local variable of the function</span>
        <span style="color: #859900; font-weight: bold;">return</span> t
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 3 5 7 2 4 6]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2 3 4 5 6 7]</span>
</pre>
</div>
</li>
<li>对于一个struct来说,它的zero value,就是它的每个成员的zero value的组合.大多数
情况下,zero value都是有意义的,但是有些时候,设计者需要自己的努力来完成这项工
作(让自己struct的zero value有意义)
</li>
<li>如果一个struct什么"其他field都不包含",那么它的样子是这样子的struct{}.它的size
为0并且没有携带任何的信息,但是有时候会有意义,有些用户使用这个来代替Set(map的
value为bool)里面的bool, 但是我们不推荐这样做
<div class="org-src-container">

<pre class="src src-go">seen := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #859900; font-weight: bold;">struct</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">set of strings</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">if</span> _, ok := seen<span style="color: #2aa198;">[</span>s<span style="color: #2aa198;">]</span>; !ok <span style="color: #2aa198;">{</span>
        seen<span style="color: #b58900;">[</span>s<span style="color: #b58900;">]</span> = <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #b58900;">{}{}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...first time seeing s...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-4-4-1" class="outline-4">
<h4 id="sec-4-4-1">Struct Literals</h4>
<div class="outline-text-4" id="text-4-4-1">
<ul class="org-ul">
<li>一般来说，初始化struct有两种literal：
<ul class="org-ul">
<li>无field版本:(需要自己记住struct初始化时候field的顺序,这也是为什么struct
初始化的顺序改变了的话,就是不同的struct了)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Point</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #2aa198;">{</span>X, Y int<span style="color: #2aa198;">}</span>
p := <span style="color: #b58900;">Point</span><span style="color: #2aa198;">{</span>1, 2<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>有field版本,安装filed:value的方式设置,顺序没有关系(没有设置的field自动设
置为zero value)
<div class="org-src-container">

<pre class="src src-go">anim := gif.<span style="color: #b58900;">GIF</span><span style="color: #2aa198;">{</span>LoopCount: nframes<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>上面两种方法不能"混着用"
</li>
<li>另外需要注意的是,初始化列表并不能改变某个field是不是exported的事实,如果这个
struct的field是unexported的(小写),那么只可以在本package内部使用,那你无论用
什么办法,在package外也是没法用literal来初始化的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> p
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">T</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #2aa198;">{</span>a, b int<span style="color: #2aa198;">}</span>         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">a and b are not exported</span>

<span style="color: #859900; font-weight: bold;">package</span> q
<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"p"</span>
<span style="color: #859900; font-weight: bold;">var</span> _ = p.<span style="color: #b58900;">T</span><span style="color: #2aa198;">{</span>a:1, b:2<span style="color: #2aa198;">}</span>           <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: can't reference a, b</span>
<span style="color: #859900; font-weight: bold;">var</span> _ = p.<span style="color: #b58900;">T</span><span style="color: #2aa198;">{</span>1, 2<span style="color: #2aa198;">}</span>               <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: can't reference a, b</span>
</pre>
</div>
</li>
<li>struct 可以传递给函数,也可以从函数中返回
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Scale</span><span style="color: #2aa198;">(</span>p <span style="color: #b58900;">Point</span>, factor <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">Point</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">Point</span><span style="color: #b58900;">(</span>p.X * factor, p.Y * factor<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>如果struct的size过大,我们就最好使用pointer来传递数据, 因为Go语言是如假包换
的pass-by-value.太大的数据结构拷贝一遍不是闹着玩的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Bonus</span><span style="color: #2aa198;">(</span>e *<span style="color: #b58900;">Employee</span>, percent <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> e.Salary * percent / 100
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>如果需要更改参数的值,那么使用pointer传递数据也是必须的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">AwardAnnualRaise</span><span style="color: #2aa198;">(</span>e *<span style="color: #b58900;">Employee</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        e.Salary = e.Salary * 105  / 100
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>由于struct和pointer如此紧密的联系,Go设计了一种shorthand notation来创建一个
struct,并且马上获取它的指针的写法. 这种写法非常简洁有效
<div class="org-src-container">

<pre class="src src-go">pp := &amp;<span style="color: #b58900;">Point</span><span style="color: #2aa198;">{</span>1, 2<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>它等同于如下的语句,但是&amp;Point{1, 2}不仅仅是简短了一半长度这么简单,它可以灵
活的运用在function里面
<div class="org-src-container">

<pre class="src src-go">pp := <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span>
*pp = <span style="color: #b58900;">Point</span><span style="color: #2aa198;">{</span>1, 2<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4-2" class="outline-4">
<h4 id="sec-4-4-2">Comparing Structs</h4>
<div class="outline-text-4" id="text-4-4-2">
<ul class="org-ul">
<li>struct是一个值value,如果struct的每个field都可以比较,而且顺序相同(顺序是类
型的一部分),那么两个struct就可以比较(注意只是比较"相等"或者"不相等",而不是
比较大小)
</li>
<li>可以比较的struct,就可以做为map的key,换句话说,所有能够使用==或者=!比较的类型
都能作为map的key
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4-3" class="outline-4">
<h4 id="sec-4-4-3">Struct Embedding and Anonymous Fields</h4>
<div class="outline-text-4" id="text-4-4-3">
<ul class="org-ul">
<li>下面介绍的是Go语言struct的嵌套,这种嵌套是把一个named的struct放入到另外的一
个struct里面,作为一个anonymous field.这种做法是Go语言特有的.这个特性是Go语
言"单继承"的一种实现方式,能够实现使用x.f代替x.d.e.f
</li>
<li>我们通过一个例子来看看这个特性:
<ul class="org-ul">
<li>2D图像中常用的shape类型有如下两个(一个是圆形,一个是车轮)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Circle</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        X, Y, Radius int
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Wheel</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        X, Y, Radius, Spokes int
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>车轮和Circle都有X,Y,也都有Radius,只是车轮比Circle多了一个Spoke.而X,Y很明
显能转换成一个Point类型的struct.于是在"其他语言中"会有如下的写法
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Point</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        X, Y int
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Circle</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Center Point
        Radius int
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Wheel</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Circle Circle
        Spokes int
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> w Wheel
w.Circle.Center.X = 8
w.Circle.Center.Y = 8
w.Circle.Radius = 5
w.Spokes = 20
</pre>
</div>
</li>
<li>这一切看起来太麻烦了.Go让一个named struct可以直接存在于另外一个struct里面
而且不需要name(所以叫做anonymous field),注意存一个struct可以,或者存struct
的指针也可以.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Circle</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
    Point
    Radius int
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Wheel</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
    Circle
    Spokes int
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>更绝的是,使用以后时候,访问具体的field的时候,不需要再加上anonymous struct
的名字了
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> w Wheel
w.X = 8
w.Y = 8
w.Radius = 5
w.Spokes = 20
</pre>
</div>
</li>
<li>当然了,一旦你选择了anonymous struct,就不能再向下面一样使用literal了
<div class="org-src-container">

<pre class="src src-go">w = <span style="color: #b58900;">Wheel</span><span style="color: #2aa198;">{</span>8, 8, 5, 20<span style="color: #2aa198;">}</span>          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: unknown fields</span>
w = <span style="color: #b58900;">Wheel</span><span style="color: #2aa198;">{</span>X:8, Y:8, Radius: 5, Spokes:20<span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: unknown fields</span>
</pre>
</div>
</li>
<li>使用的方法是要列出anonymous field
<div class="org-src-container">

<pre class="src src-go">w = Wheel <span style="color: #2aa198;">{</span><span style="color: #b58900;">Circle</span><span style="color: #b58900;">{</span><span style="color: #b58900;">Point</span><span style="color: #268bd2;">{</span>8, 8<span style="color: #268bd2;">}</span>,5<span style="color: #b58900;">}</span>, 20<span style="color: #2aa198;">}</span>

w = Wheel <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2; font-weight: bold;">Circle</span>: <span style="color: #b58900;">Circle</span><span style="color: #b58900;">{</span>
                <span style="color: #268bd2; font-weight: bold;">Point</span>: <span style="color: #b58900;">Point</span><span style="color: #268bd2;">{</span>X: 8, Y:8<span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2; font-weight: bold;">Radius</span>: 5,
        <span style="color: #b58900;">}</span>
        <span style="color: #268bd2; font-weight: bold;">Spokes</span>: 20,
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>匿名的部分名字如果想打印出来,要依靠fmt里面的'#'
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Point</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        X, Y int
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Circle</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Point
        Radius int
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Wheel</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Circle
        Spokes int
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        w := <span style="color: #b58900;">Wheel</span><span style="color: #b58900;">{</span><span style="color: #b58900;">Circle</span><span style="color: #268bd2;">{</span><span style="color: #b58900;">Point</span><span style="color: #6c71c4;">{</span>8, 8<span style="color: #6c71c4;">}</span>, 5<span style="color: #268bd2;">}</span>, 20<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>w<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">equal to "%v"</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%#v\n"</span>, w<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{{{8 8} 5} 20}</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.Wheel{Circle:main.Circle{Point:main.Point{X:8, Y:8}, Radius:5}, Spokes:20}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>anonymous field其实还是有名字的,所以你不能拥有两个类型完全一致的匿名field(
注意:两个类型一致的普通field是可以的).因为两个类型一致的匿名field会冲突
</li>
<li>如果你了解到匿名field是Go实现"继承"的方式,那么你可以这么理解一个匿名类型只
允许出现一次:Go只允许"单继承"
</li>
<li>匿名类型作为一个类型,其大小写决定其作用域,我们这里的例子Point, Circle都是大
写的,所以package都是全局可见的.如果我们把他们改成piont, circle,那么package
外部是不可见的.所以下面两种等价的写法在package外只能使用第一种:
<ul class="org-ul">
<li>w.X = 8
</li>
<li>w.circle.point.X = 8
</li>
</ul>
</li>
<li>匿名类型不仅仅可以是struct type, 普通的named type,甚至是pointer to named
type都可以作为匿名类型.但是问题在于使用普通类型(或者说pointer)作为匿名类型
的好处是什么呢?它们又没有field让我们使用!!
</li>
<li>答案是我们embed一个匿名类型,不仅仅会包含它的域,还会包含它的method!而一个pointer
embed起来不仅仅体积小,还能带来很多的method(这也解释了为什么只能包含一次某个
类型,否则会有好多份同名method)
</li>
<li>这种embed其他类型的方法在其他语言中叫做composition, 在Go中composition是最
主要的OO编程方式
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Json</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>在互联网上传送structured information.有很多的协议,比如json, xml, asn.1等,Go
统统都有支持,比如encoding/json, encoding/xml, encoding/asn1. 但是当前显然大
部分人都只使用json,所以我们使用encoding/json来介绍,但是其实三者的API大体相似
</li>
<li>JSON是一种对js value的encoding,JSON类型支持的javascript types只有如下几种:
<ul class="org-ul">
<li>string
</li>
<li>numbers(javascript数值都是float类型的)
</li>
<li>boolean(true or false)
</li>
<li>array
</li>
<li>object
</li>
</ul>
</li>
<li>JSON也是支持Unicode的,但是它使用的UTF-16(所谓UTF-16就是要用一个或者两个16bit
字符来表示Unicode)
</li>
<li>上面五种javascript的类型其中前三种是基本类型,前三种的组合组成第四五种组合类型:
<ul class="org-ul">
<li>javascript中的array,可以使用Go里面的array和slice来encode成js array
</li>
<li>javascript中的object是一种key必须是string,value可以是各种类型的特殊js类型,
可以使用Go里面map(string作为key)或者struct来encode成js object
</li>
</ul>
</li>
<li>下面的例子就是使用Go来表示json,注意``里面的内容叫做field tag,我们稍后介绍
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Movie</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Title  string
        Year   int  <span style="color: #2aa198;">`json:"released"`</span>
        Color  bool <span style="color: #2aa198;">`json:"color,omitempty"`</span>
        Actors <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> movies = <span style="color: #2aa198;">[]</span><span style="color: #b58900;">Movies</span><span style="color: #2aa198;">{</span>
        <span style="color: #b58900;">{</span>Title: <span style="color: #2aa198;">"Casablanca"</span>, Year: 1942, Color: <span style="color: #268bd2; font-weight: bold;">false</span>,
                <span style="color: #268bd2; font-weight: bold;">Actors</span>: <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"Humphrey Bogart"</span>, <span style="color: #2aa198;">"Ingrid Bergman"</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">}</span>,
        <span style="color: #b58900;">{</span>Title: <span style="color: #2aa198;">"Cool Hand Luke"</span>, Year: 1967, Color: <span style="color: #268bd2; font-weight: bold;">true</span>,
                <span style="color: #268bd2; font-weight: bold;">Actors</span>: <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"Paul Newman"</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">}</span>,
        <span style="color: #b58900;">{</span>Title: <span style="color: #2aa198;">"Bullitt"</span>, Year: 1968, Color: <span style="color: #268bd2; font-weight: bold;">true</span>,
                <span style="color: #268bd2; font-weight: bold;">Actors</span>: <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"Steve McQueen"</span>, <span style="color: #2aa198;">"Jacqueline Bisset"</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">}</span>,
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>像上面的这种structure是非常适合和JSON进行"双向的转换"的.从Go data structure
转换成JSON叫做marshaling,使用json.Marshal
<div class="org-src-container">

<pre class="src src-go">data, err := json.<span style="color: #268bd2;">Marshal</span><span style="color: #2aa198;">(</span>movies<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span>
        log.<span style="color: #268bd2;">Fatalf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"JSON marshaling failed: %s"</span>, err<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
fmt.<span style="color: #268bd2;">Printf</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"%s\n"</span>, data<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>Marshal的结果如下(我们加了两个回车,否则实在是太长)
<pre class="example">
  [{"Title":"Casablanca","released":1942,"Actors":["Humphrey Bogart","Ingrid Bergman"]},
{"Title":"Cool Hand Luke","released":1967,"color":true,"Actors":["Paul Newman"]},
{"Title":"Bullitt","released":1968,"color":true,"Actors":["Steve McQueen","Jacqueline Bisset"]}]
</pre>
</li>
<li>看起来返回值好像是一个数组,或者是slice什么的,里面的内容是struct?答案都不对,
返回值是一个byte slice,也就是[]byte,我们使用%T会得到结果(显示为[]uint8,一回事)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"encoding/json"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Movie</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">{</span>
                Title  string
                Year   int  <span style="color: #2aa198;">`json:"released"`</span>
                Color  bool <span style="color: #2aa198;">`json:"color,omitempty"`</span>
                Actors <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">var</span> movies = <span style="color: #b58900;">[]</span><span style="color: #b58900;">Movie</span><span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">{</span>Title: <span style="color: #2aa198;">"Casablanca"</span>, Year: 1942, Color: <span style="color: #268bd2; font-weight: bold;">false</span>,
                        <span style="color: #268bd2; font-weight: bold;">Actors</span>: <span style="color: #6c71c4;">[]</span><span style="color: #b58900;">string</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"Humphrey Bogart"</span>, <span style="color: #2aa198;">"Ingrid Bergman"</span><span style="color: #6c71c4;">}</span><span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span>Title: <span style="color: #2aa198;">"Cool Hand Luke"</span>, Year: 1967, Color: <span style="color: #268bd2; font-weight: bold;">true</span>,
                        <span style="color: #268bd2; font-weight: bold;">Actors</span>: <span style="color: #6c71c4;">[]</span><span style="color: #b58900;">string</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"Paul Newman"</span><span style="color: #6c71c4;">}</span><span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span>Title: <span style="color: #2aa198;">"Bullitt"</span>, Year: 1968, Color: <span style="color: #268bd2; font-weight: bold;">true</span>,
                        <span style="color: #268bd2; font-weight: bold;">Actors</span>: <span style="color: #6c71c4;">[]</span><span style="color: #b58900;">string</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"Steve McQueen"</span>, <span style="color: #2aa198;">"Jacqueline Bisset"</span><span style="color: #6c71c4;">}</span><span style="color: #268bd2;">}</span>,
        <span style="color: #b58900;">}</span>

        data, err := json.<span style="color: #268bd2;">Marshal</span><span style="color: #b58900;">(</span>movies<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatalf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"JSON marshaling failed: %s"</span>, err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, data<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[]uint8</span>
</pre>
</div>
</li>
<li>这个[]byte里面没有多余的空格,看起来非常麻烦.其实也不是为你看的,这是在网络上
传送的版本,当然尽可能的减少空格和回车,以减小体积.如果你想要"给人看"的版本,
那么就需要使用MarshalIndent来替代Marshall,新的函数需要多两个参数:第一个是
不同行之间的seperator,我们设置为空字符串"",第二个参数来设置indent长度,我们
设置为两个空格
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"encoding/json"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Movie</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">{</span>
                Title  string
                Year   int  <span style="color: #2aa198;">`json:"released"`</span>
                Color  bool <span style="color: #2aa198;">`json:"color,omitempty"`</span>
                Actors <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">var</span> movies = <span style="color: #b58900;">[]</span><span style="color: #b58900;">Movie</span><span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">{</span>Title: <span style="color: #2aa198;">"Casablanca"</span>, Year: 1942, Color: <span style="color: #268bd2; font-weight: bold;">false</span>,
                        <span style="color: #268bd2; font-weight: bold;">Actors</span>: <span style="color: #6c71c4;">[]</span><span style="color: #b58900;">string</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"Humphrey Bogart"</span>, <span style="color: #2aa198;">"Ingrid Bergman"</span><span style="color: #6c71c4;">}</span><span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span>Title: <span style="color: #2aa198;">"Cool Hand Luke"</span>, Year: 1967, Color: <span style="color: #268bd2; font-weight: bold;">true</span>,
                        <span style="color: #268bd2; font-weight: bold;">Actors</span>: <span style="color: #6c71c4;">[]</span><span style="color: #b58900;">string</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"Paul Newman"</span><span style="color: #6c71c4;">}</span><span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span>Title: <span style="color: #2aa198;">"Bullitt"</span>, Year: 1968, Color: <span style="color: #268bd2; font-weight: bold;">true</span>,
                        <span style="color: #268bd2; font-weight: bold;">Actors</span>: <span style="color: #6c71c4;">[]</span><span style="color: #b58900;">string</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"Steve McQueen"</span>, <span style="color: #2aa198;">"Jacqueline Bisset"</span><span style="color: #6c71c4;">}</span><span style="color: #268bd2;">}</span>,
        <span style="color: #b58900;">}</span>

        data, err := json.<span style="color: #268bd2;">MarshalIndent</span><span style="color: #b58900;">(</span>movies, <span style="color: #2aa198;">""</span>, <span style="color: #2aa198;">"  "</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatalf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"JSON marshaling failed: %s"</span>, err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s\n"</span>, data<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[</span>
<span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">{</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"Title": "Casablanca",</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"released": 1942,</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"Actors": [</span>
<span style="color: #93a1a1;">//       </span><span style="color: #93a1a1;">"Humphrey Bogart",</span>
<span style="color: #93a1a1;">//       </span><span style="color: #93a1a1;">"Ingrid Bergman"</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">]</span>
<span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">},</span>
<span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">{</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"Title": "Cool Hand Luke",</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"released": 1967,</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"color": true,</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"Actors": [</span>
<span style="color: #93a1a1;">//       </span><span style="color: #93a1a1;">"Paul Newman"</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">]</span>
<span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">},</span>
<span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">{</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"Title": "Bullitt",</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"released": 1968,</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"color": true,</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"Actors": [</span>
<span style="color: #93a1a1;">//       </span><span style="color: #93a1a1;">"Steve McQueen",</span>
<span style="color: #93a1a1;">//       </span><span style="color: #93a1a1;">"Jacqueline Bisset"</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">]</span>
<span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">}</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">]</span>
</pre>
</div>
</li>
<li>你如果细心就会发现,Year在[]byte里面变成了released, Color变成了color,这就是
我们前面说的field tag的作用
</li>
<li>field tag可以是任意的literal string,但是一般来说,都是如下的格式
<pre class="example">
key:"value"[空格] key:"value"...
</pre>
</li>
<li>由于field tag里面的value一定是double quotation(双引号)的格式,所以我们需要使
用raw string literal(``),因为这样能够保证""不被删除
</li>
<li>field tag里面的key往往用来指定encode的格式,比如这里是json
</li>
<li>field tag里面的value用来指定encode后的名字(因为Go里面想要export,这个名字必
须得是大写,我们又不一定能够容忍所有的json名字是大写的,所以这个value很重要)
</li>
<li>value还能有附加参数,比如这里omitempty就是.用来表示,如果结果是false(或者空)的
话,我们就不需要在结果里面显示这一项目:我们的卡萨布兰卡就没有color这一项
</li>
<li>marshaling的"相反的操作":就是把JSON转换成Go的data structure,叫做unmarshaling
使用的接口是json.Unmarshal
</li>
<li>json.Unmarshal的第二个参数是一个struct,只有我们的struct里面设置的field才会
被真正的转换,其他部分都被丢弃掉了
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> titles <span style="color: #2aa198;">[]</span><span style="color: #859900; font-weight: bold;">struct</span><span style="color: #2aa198;">{</span> Title string <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">if</span> err := json.<span style="color: #268bd2;">Unmarshal</span><span style="color: #2aa198;">(</span>data, &amp;titles<span style="color: #2aa198;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span>
        log.<span style="color: #268bd2;">Fatalf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"JSON unmarshaling failed: %s"</span>, err<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>titles<span style="color: #2aa198;">)</span>             <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"[{Casablanca} {Cool Hand Luke} {Bullitt}]"</span>
</pre>
</div>
</li>
<li>很多的web service都是使用的JSON作为传输的格式,比如github.下面就是一个使用github
API的例子,传输的格式就是json:
<ul class="org-ul">
<li>首先定义类型,类型必须是首字母大写,如果api的返回不是首字母大写的,我们需要一个field tag
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> github

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"time"</span>

<span style="color: #859900; font-weight: bold;">const</span> IssuesURL = <span style="color: #2aa198;">"https://api.github.com/search/issues"</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">IssuesSearchResult</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        TotalCount int <span style="color: #2aa198;">`json:"total_count"`</span>
        Items      <span style="color: #b58900;">[]</span>*<span style="color: #b58900;">Issue</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Issue</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Number    int
        HTMLURL   string <span style="color: #2aa198;">`json:"html_url"`</span>
        Title     string
        State     string
        User      *User
        CreatedAt time.Time <span style="color: #2aa198;">`json:"created_at"`</span>
        Body      string    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">in Markdown format</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">User</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Login   string
        HTMLURL string <span style="color: #2aa198;">`json:"html_url"`</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>下面就是对这个API的使用,先调用HTTP request,返回值解析成我们前面定义的类型
这里我们没有使用Unmarshal,而是使用了straming decoer: json.Decoder,它的特
性是能够允许多个JSON 一块进行decode
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> github

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"encoding/json"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"net/http"</span>
        <span style="color: #2aa198;">"net/url"</span>
        <span style="color: #2aa198;">"strings"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">SearchIssues</span><span style="color: #2aa198;">(</span>terms <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>*<span style="color: #b58900;">IssuesSearchResult</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        q := url.<span style="color: #268bd2;">QueryEscape</span><span style="color: #b58900;">(</span>strings.<span style="color: #268bd2;">Join</span><span style="color: #268bd2;">(</span>terms, <span style="color: #2aa198;">" "</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        resp, err := http.<span style="color: #268bd2;">Get</span><span style="color: #b58900;">(</span>IssuesURL + <span style="color: #2aa198;">"?q="</span> + q<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, err
        <span style="color: #b58900;">}</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">We must close resp.Body on all execution paths.</span>
        <span style="color: #859900; font-weight: bold;">if</span> resp.StatusCode != http.StatusOK <span style="color: #b58900;">{</span>
                resp.Body.<span style="color: #268bd2;">Close</span><span style="color: #268bd2;">()</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"search query failed: %s"</span>, resp.Status<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">var</span> result IssuesSearchResult
        <span style="color: #859900; font-weight: bold;">if</span> err := json.<span style="color: #268bd2;">NewDecoder</span><span style="color: #b58900;">(</span>resp.Body<span style="color: #b58900;">)</span>.<span style="color: #268bd2;">Decode</span><span style="color: #b58900;">(</span>&amp;result<span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                resp.Body.<span style="color: #657b83; font-weight: bold;">close</span><span style="color: #268bd2;">()</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, err
        <span style="color: #b58900;">}</span>
        resp.Body.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">return</span> &amp;result, <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>使用方法如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"gopl.io/ch4/github"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        result, err := github.<span style="color: #268bd2;">SearchIssues</span><span style="color: #b58900;">(</span>os.Args<span style="color: #268bd2;">[</span>1:<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d issues:\n"</span>, result.TotalCount<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, item := <span style="color: #859900; font-weight: bold;">range</span> result.Items <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"#%-5d %9.9s %.55s\n"</span>,
                        item.Number, item.User.Login, item.Title<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ go build gopl.io/ch4/issues</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ ./issues repo:golang/go is:open json decoder</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">13 issues:</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#5680    eaigner encoding/json: set key converter on en/decoder</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#6050  gopherbot encoding/json: provide tokenizer</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#8658  gopherbot encoding/json: use bufio</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#8462  kortschak encoding/json: UnmarshalText confuses json.Unmarshal</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#5901        rsc encoding/json: allow override type marshaling</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#9812  klauspost encoding/json: string tag not symmetric</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#7872  extempora encoding/json: Encoder internally buffers full output</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#9650    cespare encoding/json: Decoding gives errPhase when unmarshalin</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#6716  gopherbot encoding/json: include field name in unmarshal error me</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#6901  lukescott encoding/json, encoding/xml: option to treat unknown fi</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#6384    joeshaw encoding/json: encode precise floating point integers u</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#6647    btracey x/tools/cmd/godoc: display type kind of each named type</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#4237  gjemiller encoding/base64: URLEncoding padding is optional</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">Text and HTML Templates</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li>前面的例子我们使用了Printf来打印format,但是有些时候format的格式要求的更高,
不能简单的使用format,这个时候最好是能够把如下两个概念区分开来:
<ul class="org-ul">
<li>format
</li>
<li>code logic
</li>
</ul>
</li>
<li>我们ruby的erb文件其实就是这样一种模板系统,而在Go里面,对应的概念就是template
注意,所谓的template其实就是一个string或者file,只不过内部有{{&#x2026;}}这种格式符
号(叫做actions),用来在其内部存放变量
<pre class="example">
A template is a string or file containing one or more portions
enclosed in double braces, {{...}}, called actions
</pre>
</li>
<li>除了action以外的其他string都会如实打印, action里面因为是代码逻辑,所以会有不
同的变化, 比如:
<ul class="org-ul">
<li>打印value
</li>
<li>选择struct field
</li>
<li>调用function或者method
</li>
<li>使用flow-control的代码,比如if-else,或者range loop
</li>
<li>实例化其他template
</li>
</ul>
</li>
<li>下面是一个template的例子(其实就是一个string,只不过使用了raw string来表示),而
template一般也是不会改变的,所以用了const
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">const</span> templ = <span style="color: #2aa198;">`{{.TotalCount}} issues:</span>
<span style="color: #2aa198;">{{range .Items}}---------------------------------------</span>
<span style="color: #2aa198;">Number: {{.Number}}</span>
<span style="color: #2aa198;">User:   {{.User.Login}}</span>
<span style="color: #2aa198;">Title:  {{.Title | printf "%.64s"}}</span>
<span style="color: #2aa198;">Age:    {{.CreatedAt | daysAgo}} days</span>
<span style="color: #2aa198;">{{end}}`</span>
</pre>
</div>
</li>
<li>这里的template虽然我们不说,但是也能感觉到它是和我们前面的一个struct相互联系
的.这里剧透一句Go里面会以一个template string(或者file)为基础创建出一个对象
(比如下面的tempObj)然后这个对象Execute的时候,会有两个参数,一个是output,另一
个就是一个struct,我们的template里面的内容就是联系的这个struct
<div class="org-src-container">

<pre class="src src-go">tempObj.<span style="color: #268bd2;">Execute</span><span style="color: #2aa198;">(</span>os.Stdout, someStruct<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>我们还注意到上面的action{}里面,有个"| notation",它在这里的作用和在Unix里面
的管道的作用相似,都是把一个操作的结果传递给下一个操作,作为它的参数.我们这里
就有两个例子,一个是printf,另外一个是daysAgo. printf一看就是fmt的函数,那daysAgo
呢?也是一个函数,只不过是我们自己写的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">daysAgo</span><span style="color: #2aa198;">(</span>t <span style="color: #b58900;">time.Time</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">int</span><span style="color: #b58900;">(</span>time.<span style="color: #268bd2;">Since</span><span style="color: #268bd2;">(</span>t<span style="color: #268bd2;">)</span>.<span style="color: #268bd2;">Hours</span><span style="color: #268bd2;">()</span> / 24<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这又有一个问题啦printf是内置的我们可以理解(其实也不是很里面,因为是小写的p),
那程序如何知道daysAgo是我们自己写的呢,答案就是我们需要自己制定自己写的函数到
一个map里面,让template object知道如何使用.这个map里面已经default了一些常用
的函数,比如printf:
<ul class="org-ul">
<li>添加自己制定的函数,通过Funcs来添加,注意这种"链式"写法也来自c语言,要求这个
链上的每个函数返回值都一样,都是*Template
<div class="org-src-container">

<pre class="src src-go">report, err := template.<span style="color: #268bd2;">New</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"report"</span><span style="color: #2aa198;">)</span>.
        <span style="color: #268bd2;">Funcs</span><span style="color: #2aa198;">(</span>template.<span style="color: #b58900;">FuncMap</span><span style="color: #b58900;">{</span><span style="color: #2aa198;">"daysAgo"</span>: daysAgo<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>.
        <span style="color: #268bd2;">Parse</span><span style="color: #2aa198;">(</span>templ<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>FuncMap(其实就是个map)里面已经内置了一些函数了,比如printf就是fmt.Printf
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> template
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">FuncMap</span> <span style="color: #859900; font-weight: bold;">map</span><span style="color: #2aa198;">[</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">]</span><span style="color: #859900; font-weight: bold;">interface</span><span style="color: #2aa198;">{}</span>

<span style="color: #859900; font-weight: bold;">var</span> builtins = <span style="color: #b58900;">FuncMap</span><span style="color: #2aa198;">{</span>
        <span style="color: #2aa198;">"and"</span>:      and,
        <span style="color: #2aa198;">"call"</span>:     call,
        <span style="color: #2aa198;">"html"</span>:     HTMLEscaper,
        <span style="color: #2aa198;">"index"</span>:    index,
        <span style="color: #2aa198;">"js"</span>:       JSEscaper,
        <span style="color: #2aa198;">"len"</span>:      length,
        <span style="color: #2aa198;">"not"</span>:      not,
        <span style="color: #2aa198;">"or"</span>:       or,
        <span style="color: #2aa198;">"print"</span>:    fmt.Sprint,
        <span style="color: #2aa198;">"printf"</span>:   fmt.Sprintf,
        <span style="color: #2aa198;">"println"</span>:  fmt.Sprintln,
        <span style="color: #2aa198;">"urlquery"</span>: URLQueryEscaper,

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Comparisons</span>
        <span style="color: #2aa198;">"eq"</span>: eq, <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">==</span>
        <span style="color: #2aa198;">"ge"</span>: ge, <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt;=</span>
        <span style="color: #2aa198;">"gt"</span>: gt, <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt;</span>
        <span style="color: #2aa198;">"le"</span>: le, <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;=</span>
        <span style="color: #2aa198;">"lt"</span>: lt, <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;</span>
        <span style="color: #2aa198;">"ne"</span>: ne, <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">!=</span>
<span style="color: #2aa198;">}</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
</pre>
</div>
</li>
</ul>
</li>
<li>把template输出需要两个步骤:
<ul class="org-ul">
<li>首先转换template string(file)成一个内部的object:Template struct,步骤前面
在"链式"函数中写过了,Parse的返回值就是*Template
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Template</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        name string
        *parse.Tree
        *common
        leftDelim  string
        rightDelim string
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>第二步就是使用这个*Template来"联系"上output和我们想要解析的struct
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> report = template.<span style="color: #268bd2;">Must</span><span style="color: #2aa198;">(</span>template.<span style="color: #268bd2;">New</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"issuelist"</span><span style="color: #b58900;">)</span>.
        <span style="color: #268bd2;">Funcs</span><span style="color: #b58900;">(</span>template.<span style="color: #b58900;">FuncMap</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"daysAgo"</span>: daysAgo<span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>.
        <span style="color: #268bd2;">Parse</span><span style="color: #b58900;">(</span>templ<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

result, err := github.<span style="color: #268bd2;">SearchIssues</span><span style="color: #2aa198;">(</span>os.Args<span style="color: #b58900;">[</span>1:<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
report.<span style="color: #268bd2;">Execute</span><span style="color: #2aa198;">(</span>os.Stdout, result<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>我们可以看到代码中有个Must函数,这其实是一种判断返回值是否为nil的简单写法
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Must</span><span style="color: #2aa198;">(</span>t *<span style="color: #b58900;">Template</span>, err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> *<span style="color: #b58900;">Template</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> t
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们再来看看html/template package,其基本的用法和text/template一致,只不过增
加了对html来说防止注入攻击(injection attack)的feature:自动escape HTML(JS,
css, URL等)里面的特殊字符串,比如'&gt;' , '&amp;'等
</li>
<li>html/template会对template string(file) 的action里面的所有的特殊string进行
escape(比如'&gt;' , '&amp;'等),如果你不想让这些字符串被escape.你要赋予字符串一个新
的type(我们前面讲过,两种实质上相同的类型,可能有不同的类型名字),实际上html/template
也是这么做的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Strings of content from a trusted source.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #2aa198;">(</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">CSS encapsulates known safe content that matches any of:</span>
        <span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">1. The CSS3 stylesheet production, such as `p { color: purple }`.</span>
        <span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">2. The CSS3 rule production, such as `a[href=~"https:"].foo#bar`.</span>
        <span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">3. CSS3 declaration productions, such as `color: red; margin: 2px`.</span>
        <span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">4. The CSS3 value production, such as `rgba(0, 0, 255, 127)`.</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">See http://www.w3.org/TR/css3-syntax/#parsing and</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style</span>
        <span style="color: #93a1a1;">//</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Use of this type presents a security risk:</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">the encapsulated content should come from a trusted source,</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">as it will be included verbatim in the template output.</span>
        CSS string

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">HTML encapsulates a known safe HTML document fragment.</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">It should not be used for HTML from a third-party, or HTML with</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">unclosed tags or comments. The outputs of a sound HTML sanitizer</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">and a template escaped by this package are fine for use with HTML.</span>
        <span style="color: #93a1a1;">//</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Use of this type presents a security risk:</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">the encapsulated content should come from a trusted source,</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">as it will be included verbatim in the template output.</span>
        HTML string
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">.....</span>
<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>换句话说,我们自己写一个type也可以,只要不是string类型,template就不会去escape
它的特殊字符.所以下面两种方法的结果一样:
<ul class="org-ul">
<li>使用templte.HTML
<a href="https://play.golang.org/p/TdtDcx8gOx">https://play.golang.org/p/TdtDcx8gOx</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"html/template"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #859900; font-weight: bold;">const</span> templ = <span style="color: #2aa198;">`&lt;p&gt;A: {{.A}}&lt;/p&gt;&lt;p&gt;B: {{.B}}&lt;/p&gt;`</span>
        t := template.<span style="color: #268bd2;">Must</span><span style="color: #b58900;">(</span>template.<span style="color: #268bd2;">New</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"escape"</span><span style="color: #268bd2;">)</span>.<span style="color: #268bd2;">Parse</span><span style="color: #268bd2;">(</span>templ<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">var</span> data <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">{</span>
                A string        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">untrusted plain text</span>
                B template.HTML <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">trusted HTML</span>
        <span style="color: #b58900;">}</span>
        data.A = <span style="color: #2aa198;">"&lt;b&gt;Hello!&lt;/b&gt;"</span>
        data.B = <span style="color: #2aa198;">"&lt;b&gt;Hello!&lt;/b&gt;"</span>
        <span style="color: #859900; font-weight: bold;">if</span> err := t.<span style="color: #268bd2;">Execute</span><span style="color: #b58900;">(</span>os.Stdout, data<span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;p&gt;A: &amp;lt;b&amp;gt;Hello!&amp;lt;/b&amp;gt;&lt;/p&gt;&lt;p&gt;B: &lt;b&gt;Hello!&lt;/b&gt;&lt;/p&gt;</span>
</pre>
</div>
</li>
<li>自己创建一个type,underlying type还是string
<a href="https://play.golang.org/p/BUE_lKngwP">https://play.golang.org/p/BUE_lKngwP</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"html/template"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">HTML</span> <span style="color: #b58900;">string</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #859900; font-weight: bold;">const</span> templ = <span style="color: #2aa198;">`&lt;p&gt;A: {{.A}}&lt;/p&gt;&lt;p&gt;B: {{.B}}&lt;/p&gt;`</span>
        t := template.<span style="color: #268bd2;">Must</span><span style="color: #b58900;">(</span>template.<span style="color: #268bd2;">New</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"escape"</span><span style="color: #268bd2;">)</span>.<span style="color: #268bd2;">Parse</span><span style="color: #268bd2;">(</span>templ<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">var</span> data <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">{</span>
                A string <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">untrusted plain text</span>
                B HTML   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">trusted HTML</span>
        <span style="color: #b58900;">}</span>
        data.A = <span style="color: #2aa198;">"&lt;b&gt;Hello!&lt;/b&gt;"</span>
        data.B = <span style="color: #2aa198;">"&lt;b&gt;Hello!&lt;/b&gt;"</span>
        <span style="color: #859900; font-weight: bold;">if</span> err := t.<span style="color: #268bd2;">Execute</span><span style="color: #b58900;">(</span>os.Stdout, data<span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;p&gt;A: &amp;lt;b&amp;gt;Hello!&amp;lt;/b&amp;gt;&lt;/p&gt;&lt;p&gt;B: &lt;b&gt;Hello!&lt;/b&gt;&lt;/p&gt;</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 05: Functions</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>function让我们把一系列的statement包裹在一起,然后可以到处,多次调用.并且对用户
掩藏了实现的细节.对于任何语言来说function都是必不可少的部分
</li>
</ul>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Function Declarations</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>Go中的函数定义方法如下
<pre class="example">
func name(parameter-list) (result-list) {
     body
}
</pre>
</li>
<li>parameter-list就是函数的参赛(包括name和type),函数的参赛也是函数的local variable,
它们的实际值是由使用者提供的
</li>
<li>result-list是指的返回值的类型.如果函数返回一个unnamed result,或者干脆没有返
回值,那么result-list往往省略.函数也就没有返回值,只是在调用的时候起作用.
</li>
<li>既然说到了unnamed result,那也就是说,Go里面的返回值也是可以被named的,而named
result的初始化值为zero value. 这种情况下return后面什么都没有,但是不能省略
<a href="https://play.golang.org/p/fygES6ah_a">https://play.golang.org/p/fygES6ah_a</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">split</span><span style="color: #2aa198;">(</span>sum <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>x, y <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x, y<span style="color: #b58900;">)</span>
        x = sum * 4 / 9
        y = sum - x
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">can not omit</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">split</span><span style="color: #268bd2;">(</span>17<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0 0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">7 10</span>
</pre>
</div>
</li>
<li>类型相同的可以定义在一起,以下两个声明的作用一致
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">(</span>i, j, k <span style="color: #b58900;">int</span>, s, t <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span> <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">(</span>i <span style="color: #b58900;">int</span>, j <span style="color: #b58900;">int</span>, k <span style="color: #b58900;">int</span>, s <span style="color: #b58900;">string</span>, t <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>再考虑到可以省略参数的名字,或者使用blank identifier来代替参数,我们有如下四种
等价定义一个"参数为两个int,返回值为一个int的函数",而且我们发现,它们的类型(
function 's type) 是一样的
<a href="https://play.golang.org/p/vC7Q0Xq17Q">https://play.golang.org/p/vC7Q0Xq17Q</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">add</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">int</span>, y <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span>   <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> x + y <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">sub</span><span style="color: #2aa198;">(</span>x, y <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>z <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>   <span style="color: #2aa198;">{</span> z = x - y; <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">first</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">int</span>, _ <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> x <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">zero</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span>, <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span>      <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> 0 <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, add<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, sub<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, first<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, zero<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">func(int, int) int</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">func(int, int) int</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">func(int, int) int</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">func(int, int) int</span>
</pre>
</div>
</li>
<li>函数定义里面还是可以有blank identifier(_),可以用来彰显这个field根本就没用
</li>
<li>每一个function都必须提供所有的paramter,并且以我们定义时候的顺序提供给函数,
这也就说明了两点:
<ul class="org-ul">
<li>Go没有default paramter的概念
</li>
<li>Go也不能使用name的方法来specify argument,这也说明了paramter的名字并不重要
</li>
</ul>
</li>
<li>paramter是function内部的local variable参数,初始化值就是调用函数时候的"实参".
Go中还有named result, named result也是和parameter一样的local变量(在function
的最开始这一层)
</li>
<li>在Go中所有的参赛都是按照value传递的
<pre class="example">
Arguments are passed by value, so the function receives a
copy of each argument; modifications to the copy do not
affect the caller.
</pre>
</li>
<li>如果argument是任意一种reference,那么还是有可能在调用的过程当中,间接的更改变
量里面的值的
<ul class="org-ul">
<li>可以是pointer这种真的reference
</li>
<li>也可以是slice, map, channel这种reference type
</li>
<li>还可以是function(Go里面function是first class object)
</li>
</ul>
</li>
<li>有些情况下你会看到function的声明了,却没有body, 这是因为这个function是使用其
他的语言实现的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> math
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Sin</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">float64</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">float64</span>     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">implemented in assembly language</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Recursion</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>函数可以自己直接或者间接的调用自己,这叫做recursive.这是计算机里面一种解决很
多问题的强大技术
</li>
<li>下面我们来看一个使用recursion的问题,这个问题使用了一个golang.org/x/net/html
的包.行如golang.org/x/net/html的包是Go team来维护的.这些包质量肯定是有保证的
但是因为并不是所有的人都会用到,所以没有放到standrd library(但是也是standard
library的强力候选)
</li>
<li>golang.org/x/net/html会调用html.Parse来读取一系列的bytes, 分析过后,返回HTML
document true(以html.Node的格式). HTML会有很多种node,比如text, comments,等等
这里我们只会使用如下的字符串来打印结果&lt;name key='value'&gt;
</li>
<li>下面是简略版本的html package 代码来显示其内部对于html的解释
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">golang.org/x/net/html</span>
<span style="color: #859900; font-weight: bold;">package</span> html

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Node</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Type                    NodeType
        Data                    string
        Attr                    <span style="color: #b58900;">[]</span><span style="color: #b58900;">Attribute</span>
        FirstChild, NextSibling *Node
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">NodeType</span> <span style="color: #b58900;">int32</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #2aa198;">(</span>
        ErrorNode NodeType = <span style="color: #268bd2; font-weight: bold;">iota</span>
        TextNode
        DocumentNode
        ElementNode
        CommentNode
        DoctypeNode
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Attribute</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Key, Val string
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Parse</span><span style="color: #2aa198;">(</span>r <span style="color: #b58900;">io.Reader</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>*<span style="color: #b58900;">Node</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>使用的方法是curl获取一个网页的string,然后我们分析这个string得到结果
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Findlinks1 prints the links in an HTML document read from standard input.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"golang.org/x/net/html"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        doc, err := html.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">(</span>os.Stdin<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>os.Stderr, <span style="color: #2aa198;">"findlinks1: %v\n"</span>, err<span style="color: #268bd2;">)</span>
                os.<span style="color: #268bd2;">Exit</span><span style="color: #268bd2;">(</span>1<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, link := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #268bd2;">visit</span><span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">nil</span>, doc<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>link<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">visit appends to links each link found in n and returns the result.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">visit</span><span style="color: #2aa198;">(</span>links <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>, n *<span style="color: #b58900;">html.Node</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span style="color: #2aa198;">"a"</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, a := <span style="color: #859900; font-weight: bold;">range</span> n.Attr <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">if</span> a.Key == <span style="color: #2aa198;">"href"</span> <span style="color: #6c71c4;">{</span>
                                links = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #859900;">(</span>links, a.Val<span style="color: #859900;">)</span>
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> c := n.FirstChild; c != <span style="color: #268bd2; font-weight: bold;">nil</span>; c = c.NextSibling <span style="color: #b58900;">{</span>
                links = <span style="color: #268bd2;">visit</span><span style="color: #268bd2;">(</span>links, c<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> links
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ curl https://golang.org | go run main.go</span>
<span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span>
<span style="color: #93a1a1;">//                                  </span><span style="color: #93a1a1;">Dload  Upload   Total   Spent    Left  Speed</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100  7902  100  7902    0     0  11896      0 --:--:-- --:--:-- --:--:-- 11900</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">/doc/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">/pkg/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">/project/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">/help/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">/blog/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">http://play.golang.org/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">#</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">//tour.golang.org/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/dl/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">//blog.golang.org/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://developers.google.com/site-policies#restrictions</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">/LICENSE</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">/doc/tos.html</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">http://www.google.com/intl/en/policies/privacy/</span>
</pre>
</div>
</li>
<li>这里的visit函数就是一个典型的递归函数:
<ul class="org-ul">
<li>首先把当前页面里面符合&lt;a href='&#x2026;'&gt;的标签都找出来,放到links里面
</li>
<li>然后以当前页面第一个child开始,到最后一个child为止递归调用visit函数
</li>
</ul>
</li>
<li>我们再来看看另一个例子:打印HTML node tree
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Outline prints the outline of an HTML document tree.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"golang.org/x/net/html"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        doc, err := html.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">(</span>os.Stdin<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>os.Stderr, <span style="color: #2aa198;">"outline: %v\n"</span>, err<span style="color: #268bd2;">)</span>
                os.<span style="color: #268bd2;">Exit</span><span style="color: #268bd2;">(</span>1<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #268bd2;">outline</span><span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">nil</span>, doc<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">outline</span><span style="color: #2aa198;">(</span>stack <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>, n *<span style="color: #b58900;">html.Node</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> n.Type == html.ElementNode <span style="color: #b58900;">{</span>
                stack = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #268bd2;">(</span>stack, n.Data<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">push tag</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>stack<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> c := n.FirstChild; c != <span style="color: #268bd2; font-weight: bold;">nil</span>; c = c.NextSibling <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">outline</span><span style="color: #268bd2;">(</span>stack, c<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ curl https://golang.org | go run main.go</span>
<span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span>
<span style="color: #93a1a1;">//                                  </span><span style="color: #93a1a1;">Dload  Upload   Total   Spent    Left  Speed</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100  7902  100  7902    0     0   9499      0 --:--:-- --:--:-- --:--:--  9497</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html head]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html head meta]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html head meta]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html head meta]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html head title]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html head link]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html head link]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html head link]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html head script]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html head script]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html body]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[html body div]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
</pre>
</div>
</li>
<li>这个例子和前面的fetchlink大体一样,只不过它要打印中间的所有过程,所以我们的stack
每次都会被打印.
</li>
<li>这个slice名字虽然叫stack,但是却是只push,不pop.因为我们函数每次都是"pass by
value",所以传递给下一层的都是新的slice.函数返回的时候,这个新的slice就会被丢
弃.这也同时解释了,我们没什么可以使用nil作为stack(还有前面例子里面的link)的
初始化值
</li>
<li>递归是编程语言最常见的函数使用方法,但是普通的编程语言为了防止stack的增长过快,
设置了fiexed-size的stack.一般是64KB到2MB, 而Go语言则设置了variable-size stack
stack最高可以达到gigabyte. 这让我们在Go里面可以放心的使用递归.
</li>
<li>但是比如斐波那契数那种肯定有更好的复杂度解法的情况下,盲目使用递归会极大的提
高运行时间
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Multiple Return Values</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>Go里面的function可以返回多个返回值,最常见的情况就是返回两个值:
<ul class="org-ul">
<li>一个一般来说,是caller希望的返回值
</li>
<li>另外一个是error类型的错误,或者是一般boolean类型(只可能有一种error错误的情况
下,比如map的获取,那么我们就没必要使用error了,使用一个boolean就可以了)
</li>
</ul>
</li>
<li>下面的例子是findlinks的变体:它变在自己能够发送HTTP request,所以我们不需要自
己来进行fetch了.而由于HTTP获取可能失败,而parsing 也可能失败,所以我们的返回值
自然而然的分成了两部分:
<ul class="org-ul">
<li>list of link
</li>
<li>error类型变量err(不止一种错误,我们就要用error类型了)
</li>
</ul>
</li>
<li>下面就是finklink2的代码
<a href="https://play.golang.org/p/8XjgZvv11l">https://play.golang.org/p/8XjgZvv11l</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Usage:</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">findlinks url ...</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"net/http"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"golang.org/x/net/html"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">visit appends to links each link found in n, and returns the result.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">visit</span><span style="color: #2aa198;">(</span>links <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>, n *<span style="color: #b58900;">html.Node</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span style="color: #2aa198;">"a"</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, a := <span style="color: #859900; font-weight: bold;">range</span> n.Attr <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">if</span> a.Key == <span style="color: #2aa198;">"href"</span> <span style="color: #6c71c4;">{</span>
                                links = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #859900;">(</span>links, a.Val<span style="color: #859900;">)</span>
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> c := n.FirstChild; c != <span style="color: #268bd2; font-weight: bold;">nil</span>; c = c.NextSibling <span style="color: #b58900;">{</span>
                links = <span style="color: #268bd2;">visit</span><span style="color: #268bd2;">(</span>links, c<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> links
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, url := <span style="color: #859900; font-weight: bold;">range</span> os.Args<span style="color: #b58900;">[</span>1:<span style="color: #b58900;">]</span> <span style="color: #b58900;">{</span>
                links, err := <span style="color: #268bd2;">findLinks</span><span style="color: #268bd2;">(</span>url<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #6c71c4;">(</span>os.Stderr, <span style="color: #2aa198;">"findlinks2: %v\n"</span>, err<span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">continue</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, link := <span style="color: #859900; font-weight: bold;">range</span> links <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Println</span><span style="color: #6c71c4;">(</span>link<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">findLinks performs an HTTP GET request for url, parses the</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">response as HTML, and extracts and returns the links.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">findLinks</span><span style="color: #2aa198;">(</span>url <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        resp, err := http.<span style="color: #268bd2;">Get</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, err
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">if</span> resp.StatusCode != http.StatusOK <span style="color: #b58900;">{</span>
                resp.Body.<span style="color: #268bd2;">Close</span><span style="color: #268bd2;">()</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"getting %s: %s"</span>, url, resp.Status<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        doc, err := html.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">(</span>resp.Body<span style="color: #b58900;">)</span>
        resp.Body.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"parsing %s as HTML: %v"</span>, url, err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">visit</span><span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">nil</span>, doc<span style="color: #b58900;">)</span>, <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">go run main.go http://www.baidu.com</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://passport.baidu.com/v2/?login&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2F</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">http://www.nuomi.com/?cid=002540</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">http://news.baidu.com</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">http://www.hao123.com</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">http://map.baidu.com</span>
</pre>
</div>
</li>
<li>这个例子里面有四个地方进行了return,每次都是一对儿返回值,前三次都是返回了http
和html package里面的error "转发"了一下:
<ul class="org-ul">
<li>第一中情况下:err没有被"添加评论",直接进行了转发
</li>
<li>第二钟情况下:err被"包裹"了一些context信息,使用fmt.Errorf
</li>
<li>第二钟情况下:err也是被"包裹"了一些context信息
</li>
</ul>
</li>
<li>我们要自己关闭resp.Body,因为Go的gc是只收集unused内存,而其他的系统资源,还是
要我们自己手动explicitly进行回收.
</li>
<li>我们前面见到过,range或者map的返回值是两个,我们如果不想使用第二个值,可以省略
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        m := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">int</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        m<span style="color: #b58900;">[</span>18<span style="color: #b58900;">]</span> = 18
        v, ok := m<span style="color: #b58900;">[</span>18<span style="color: #b58900;">]</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>v, ok<span style="color: #b58900;">)</span>
        v = m<span style="color: #b58900;">[</span>18<span style="color: #b58900;">]</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span>

        arr := <span style="color: #b58900;">[</span>3<span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2, 3<span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">for</span> i, v := <span style="color: #859900; font-weight: bold;">range</span> arr <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>i, v<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">for</span> i := <span style="color: #859900; font-weight: bold;">range</span> arr <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>i<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">18 true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">18</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0 1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1 2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2 3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2</span>
</pre>
</div>
</li>
<li>但是这只适用于range和map,在函数返回值为两个的情况下,必须两个返回值都设置!
<a href="https://play.golang.org/p/ci0M8R1-dX">https://play.golang.org/p/ci0M8R1-dX</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">getTwo</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span>, <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> 1, 2
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #93a1a1;">//////////////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// ./three.go:14: multiple-value getTwo() in single-value context        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">a := getTwo()                                                            //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Println(a)                                                           //</span>
        <span style="color: #93a1a1;">//////////////////////////////////////////////////////////////////////////////</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>当然了,如果某个函数的返回值和自己一样,我们也可以通过return这个函数来满足返回
值的类型要求
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Note: &#36825;&#37324;&#30340;error&#19981;&#26159;&#21464;&#37327;&#26159;&#31867;&#22411;! Go&#37324;&#38754;&#30340;&#20989;&#25968;&#36820;&#22238;&#20540;&#21487;&#20197;&#21482;&#26377;&#31867;&#22411;,&#27809;&#26377;&#21464;&#37327;&#21517;!</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">findLinksLog</span><span style="color: #2aa198;">(</span>url <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        log.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"findLinks %s"</span>, url<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">findLinks</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>同样的我们也可以把某个函数所有的返回值(是一个tuple)作为另外函数的参数,这是
很容易就能"联想"到的,但是实际情况运用的不多.只有一个地方经常使用,那就是Println
因为Println可以允许不同长度的参数!下面两组代码具有相同的效果:
<div class="org-src-container">

<pre class="src src-go">log.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">findLinks</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

links, err := <span style="color: #268bd2;">findLinks</span><span style="color: #2aa198;">(</span>url<span style="color: #2aa198;">)</span>
log.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>links, err<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>对于多返回值函数来说,每一个返回值的名字都特别重要,因为特别合适的名字能起到
文档的作用
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Split</span><span style="color: #2aa198;">(</span>path <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>dir, file <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>当然了,有些情况下,我们的返回值名字是固定的:
<ul class="org-ul">
<li>对于错误原因多种的情况下,用名字err来返回类型为Error的错误
</li>
<li>对于错误原因肯定只有一种的情况下,用名字bool来返回类型为boolean的错误
</li>
</ul>
</li>
<li>Go中还有所谓的bare return,就是说你的return的value有name的话(也就是分配了变
量内存),我可以不"显式"的返回, 而是function block结束的时候named return value
是啥,就返回啥.
</li>
<li>但是由于bare return很容易会造成理解上的偏差,所以我们完全不鼓励大家使用bare return
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Errors</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>有些function总是完成它们的工作.比如strings.Contains,还有strconv.FormatBool
</li>
<li>还有一些function总是返回成功,只要它们的precondition能够得到满足.而如果"不成功
就成仁"(preconditoin不满足,以time.Date为例, 第二个参数为nil), 函数就会直接panic
</li>
<li>但是还有更多更多的函数,其成功与否依赖太多的factor,都不是程序员可以控制的.比
如IO操作的时候,文件是否存在这种是程序员无法控制的,所以我们必须要为可能存在的
错误负责.
</li>
<li>因为这些错误是可以预期的,那么这些错误其实也是package API里面重要的组成部分,
从另外一个较多讲,我们可以把这些错误当做expected behavior(Java里面把这种估
计到的错误叫做checked exception)
</li>
<li>在Go里面,如果一个function的excepted behavior里面包括某些错误,那么这个function
会返回一个额外的result(一般来说是最后一个)
<ul class="org-ul">
<li>如果"expected error"只有一种的情况下,我们可以只返回一个Boolean类型(一般叫
做ok)
<div class="org-src-container">

<pre class="src src-go">value, ok := cache.<span style="color: #268bd2;">Lookup</span><span style="color: #2aa198;">(</span>key<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">if</span> !ok <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...cache[key] does not exist</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>当然了,大多数情况下expected error不可能只有一种情况,这个时候,就不能再返回
boolean类型了,而要返回error类型(是一个interface type,一般叫做err!).
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">src/builtin/builtin.go</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">error</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Error</span><span style="color: #b58900;">()</span> string
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>

<li>前面看到了error(注意是小写)类型是一种interface类型(绝大多数情况下其变量名是err):
<ul class="org-ul">
<li>如果没有错误,那么err就是nil
</li>
<li>如果有错误, 那么err就是non-nil,可以通过打印'Error()函数的返回值(类型为
string)'来打印错误信息.
</li>
</ul>
</li>
<li>我们注意到,我们总是可以使用fmt.Println(),或者fmt.Printf()来打印error类型的
结果.因为error这个interface只有一个函数Error(),我们很容易想到package fmt肯定
是在内部调用了Error()来打印仅有的那个错误信息,答案是肯定的,源代码如下.我看到
Stringer interface也是在这里处理的(直接调用其String()函数)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">src/fmt/print.go</span>
<span style="color: #859900; font-weight: bold;">if</span> p.fmt.sharpV <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> stringer, ok := p.arg.<span style="color: #b58900;">(</span><span style="color: #b58900;">GoStringer</span><span style="color: #b58900;">)</span>; ok <span style="color: #b58900;">{</span>
                handled = <span style="color: #268bd2; font-weight: bold;">true</span>
                <span style="color: #859900; font-weight: bold;">defer</span> p.<span style="color: #268bd2;">catchPanic</span><span style="color: #268bd2;">(</span>p.arg, verb<span style="color: #268bd2;">)</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Print the result of GoString unadorned.</span>
                p.fmt.<span style="color: #268bd2;">fmt_s</span><span style="color: #268bd2;">(</span>stringer.<span style="color: #268bd2;">GoString</span><span style="color: #6c71c4;">()</span><span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">If a string is acceptable according to the format, see if</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">the value satisfies one of the string-valued interfaces.</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Println etc. set verb to %v, which is "stringable".</span>
        <span style="color: #859900; font-weight: bold;">switch</span> verb <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">'v'</span>, <span style="color: #2aa198;">'s'</span>, <span style="color: #2aa198;">'x'</span>, <span style="color: #2aa198;">'X'</span>, <span style="color: #2aa198;">'q'</span>:
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Is it an error or Stringer?</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The duplication in the bodies is necessary:</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">setting handled and deferring catchPanic</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">must happen before calling the method.</span>
                <span style="color: #859900; font-weight: bold;">switch</span> v := p.arg.<span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">type</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">case</span> error:
                        handled = <span style="color: #268bd2; font-weight: bold;">true</span>
                        <span style="color: #859900; font-weight: bold;">defer</span> p.<span style="color: #268bd2;">catchPanic</span><span style="color: #6c71c4;">(</span>p.arg, verb<span style="color: #6c71c4;">)</span>
                        p.<span style="color: #268bd2;">fmtString</span><span style="color: #6c71c4;">(</span>v.<span style="color: #268bd2;">Error</span><span style="color: #859900;">()</span>, verb<span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">return</span>

                <span style="color: #859900; font-weight: bold;">case</span> Stringer:
                        handled = <span style="color: #268bd2; font-weight: bold;">true</span>
                        <span style="color: #859900; font-weight: bold;">defer</span> p.<span style="color: #268bd2;">catchPanic</span><span style="color: #6c71c4;">(</span>p.arg, verb<span style="color: #6c71c4;">)</span>
                        p.<span style="color: #268bd2;">fmtString</span><span style="color: #6c71c4;">(</span>v.<span style="color: #268bd2;">String</span><span style="color: #859900;">()</span>, verb<span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">return</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们说,我们返回的err只要满足error interface接口就可以了.但是我们终究要有一
个地方来'实例化'我们的返回值的(也就是Error()的返回值string终究是有地方要来放
置的):
<ul class="org-ul">
<li>我们一般的做法是使用内置的error type类型生成器fmt.Errorf.我们发现类型为
*errors.errorString
<a href="https://play.golang.org/p/-50myryX42">https://play.golang.org/p/-50myryX42</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        e := fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s"</span>, <span style="color: #2aa198;">"hello"</span><span style="color: #b58900;">)</span>

        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T, %s\n"</span>, e, e<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">*errors.errorString, hello</span>
</pre>
</div>
</li>
<li>这个*errors.errorString从名字来看,就是一个errors package下面的没有export
的一个struct类型,它实现了Error()这个函数,所以也就implement了error interface
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">file: src/fmt/print.go</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Errorf formats according to a format specifier and returns the string</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">as a value that satisfies error.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Errorf</span><span style="color: #2aa198;">(</span>format <span style="color: #b58900;">string</span>, a ...<span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> errors.<span style="color: #268bd2;">New</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Sprintf</span><span style="color: #268bd2;">(</span>format, a...<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">file: src/errors/erros.go</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Package errors implements functions to manipulate errors.</span>
<span style="color: #859900; font-weight: bold;">package</span> errors

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">New returns an error that formats as the given text.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">New</span><span style="color: #2aa198;">(</span>text <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> &amp;<span style="color: #b58900;">errorString</span><span style="color: #b58900;">{</span>text<span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">errorString is a trivial implementation of error.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">errorString</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        s string
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>e *<span style="color: #b58900;">errorString</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Error</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> e.s
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>所以我们看到了,是errorString的指针类型*errorString满足了error interface,而
不是errorString类型.所以New()函数返回的也是带取地址符'&amp;'的结果
</li>
<li>我们可以自己写一个error返回,毫无违和感,我们这里没有用指针,也可以.具体什么
时候用指针,什么时候不用,请看后面的章节
<a href="https://play.golang.org/p/uckj_EHalu">https://play.golang.org/p/uckj_EHalu</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">hfengError</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        s string
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>h <span style="color: #b58900;">hfengError</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Error</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> h.s
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">adder</span><span style="color: #2aa198;">(</span>i <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>ret <span style="color: #b58900;">int</span>, err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        ret = i + 1
        err = <span style="color: #b58900;">hfengError</span><span style="color: #b58900;">{</span><span style="color: #2aa198;">"Error by hfeng"</span><span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        ret, err := <span style="color: #268bd2;">adder</span><span style="color: #b58900;">(</span>18<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>ret, err<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">19 Error by hfeng</span>
</pre>
</div>
</li>
</ul>
</li>
<li>一旦返回值的error不为nil,那么其返回的前面的值也就不再可以被信任了.在某些特殊
情况下,返回值可能是有意义的.比如,读取一个文件,Reqad()返回它已经成功读取的byte
个数,并且外加一个描述错误的err.这个成功读取的byte个数就是可以被信任的.但是毕
竟这是特例,我们需要在函数的文档里面说清楚
</li>
<li>如今大部分的语言都是把"可以预见的错误"以exception的方式来抛出来,而Go却并不是
它还是沿袭了比较古老的返回值的方式来处理.
</li>
<li>后面的章节我们会看到,Go的确是有exception机制的.但是Go的exception机制是用来报
告"不可以预见的错误"的,这种unexpected的错误往往意味着bug.和Java比较起来:
<ul class="org-ul">
<li>Go使用返回值来报告expected error; Java使用checked exception
</li>
<li>Go使用exception(panic&amp;recover)来处理unexpcted error; Java使用unchecke
exception.大多数情况下,这预示着代码存在着bug
</li>
</ul>
</li>
<li>Go不使用exception来处理expected error有它自己的考虑,因为这意味着excepted
error(routine error)以一种更加复杂的方式展现给用户(充满着不相关的stack trace)
</li>
<li>Go使用了if和return等"常规手段"来对付expected error,这增强了调用者对错误处理
的重视程度.这正是Go设计者想要的
</li>
</ul>
</div>
<div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">Error Handling Stratgies</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>每当function call返回错误的时候,caller有责任和义务去check这个返回值,并且做
出相应的举动.根据情况的不同,处理方式会有五种:
</li>
</ul>
</div>
<div id="outline-container-sec-5-4-1-1" class="outline-5">
<h5 id="sec-5-4-1-1">Propagate the error</h5>
<div class="outline-text-5" id="text-5-4-1-1">
<ul class="org-ul">
<li>这样是最常见的处理方式,也就是把被调用者的错误,通过包装添加些信息以后,变成
调用者的错误
<pre class="example">
A failure in a subroutine becomes a failure of the calling routine.
</pre>
</li>
<li>被调用者的错误,要经过包装,这个包装是添加些信息.这个信息是需要才添加.没有
就不需要添加的,也就是说A failure in a subroutine directly becomes a failure
of the calling routine.:
<ul class="org-ul">
<li>首先看一个不需要添加额外信息的例子.我们findlinks第一步会使用http.Get来获
取某个url的信息.如果失败的话,因为我们并没有做什么其他的事情.http.Get的
error信息就已经包含了全部错误解释.这种情况下,我们直接把被调用者的error信
息返回,作为我们(调用者)的错误信息
<div class="org-src-container">

<pre class="src src-go">resp, err := http.<span style="color: #268bd2;">Get</span><span style="color: #2aa198;">(</span>url<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, err
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>而html处理resp.Body出错的时候.其err就不能覆盖调用者的错误了,我们的调用者
除了调用Parse出错了,我们有两件事情没有在这个err里面体现.第一我们是parse
的时候出的问题,第二我们parse出错的url是什么.所以我们用Errorf里面加了两条
第一parsing,第二url
<div class="org-src-container">

<pre class="src src-go">doc, err := html.<span style="color: #268bd2;">Parse</span><span style="color: #2aa198;">(</span>resp.Body<span style="color: #2aa198;">)</span>
resp.Body.<span style="color: #268bd2;">Close</span><span style="color: #2aa198;">()</span>
<span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"parsing %s as HTML: %v"</span>, url, err<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>这样做的好处是,(最终)我们的main会得到如下一条chain的错误链(例子从NASA acident
来)
<pre class="example">
genesis: crashed: no parachute: G-switch failed: bad relay orientation
</pre>
</li>
<li>这个例子如下的两个特点,易于我们使用grep来对它们进行分析
<ul class="org-ul">
<li>没有大写字母
</li>
<li>没有换行符
</li>
</ul>
</li>
<li>当然,这种良好的error message的返回离不开我们每次都"认真并且简洁有效"的自己
书写error message.才能让总体的message简洁有效.
</li>
<li>Go的standard library是书写良好error message的典范.比如os package里面的函数
一旦出现了error message,其错误信息不仅仅包含错误原因(比如permission denied,
no shu directory等等), 同时还包括了自己所处理的file name.所以caller并不需要
自己再使用fmt.Errorf来再次"自己处理"error了.(也就是和上面例子1. http.Get处
理方法一致)
</li>
<li>讲了这么多,我们可以来总结一下
<pre class="example">
         当我们调用f(x)的时候,如果出现了error. error message里面必须包
         括operation f失误的信息,以及参数x的信息
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-1-2" class="outline-5">
<h5 id="sec-5-4-1-2">Transient or unpredictable problem</h5>
<div class="outline-text-5" id="text-5-4-1-2">
<ul class="org-ul">
<li>第二种比较常见的处理error的策略就是:处理某些transient错误(或者是unpredictable
错误, 也是一个策略)的时候, 我们可以重试几次,当然每次要等一段random的时间.
下面就是这样一个例子
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">WaitForServer</span><span style="color: #2aa198;">(</span>url <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> timeout = 1 * time.Minute
        deadline := time.<span style="color: #268bd2;">Now</span><span style="color: #b58900;">()</span>.<span style="color: #268bd2;">Add</span><span style="color: #b58900;">(</span>timeout<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> tries := 0; time.<span style="color: #268bd2;">Now</span><span style="color: #b58900;">()</span>.<span style="color: #268bd2;">Before</span><span style="color: #b58900;">(</span>deadline<span style="color: #b58900;">)</span>; tries++ <span style="color: #b58900;">{</span>
                _, err := http.<span style="color: #268bd2;">Head</span><span style="color: #268bd2;">(</span>url<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">if</span> err == <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">success</span>
                <span style="color: #268bd2;">}</span>
                log.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"server not responding (%s); retrying..."</span>, err<span style="color: #268bd2;">)</span>
                time.<span style="color: #268bd2;">Sleep</span><span style="color: #268bd2;">(</span>time.Second &lt;&lt; <span style="color: #268bd2;">unit</span><span style="color: #6c71c4;">(</span>tries<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"server %s failed to respond after %s"</span>, url, timeout<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-1-3" class="outline-5">
<h5 id="sec-5-4-1-3">Print the error and stop the program gracefully</h5>
<div class="outline-text-5" id="text-5-4-1-3">
<ul class="org-ul">
<li>第三种情况是,caller可以打印错误,然后直接关闭这个program.这种情况下只能用于
main函数, library是不建议这样做的.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
        <span style="color: #859900; font-weight: bold;">if</span> err := <span style="color: #268bd2;">WaitForServer</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>os.Stderr, <span style="color: #2aa198;">"Site is down: %v\n"</span>, err<span style="color: #268bd2;">)</span>
                os.<span style="color: #268bd2;">Exit</span><span style="color: #268bd2;">(</span>1<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>一种达到那个如上同样,但是更便捷的方法是使用log.Fatalf.千万不要在web server
里面使用log.Fatalf
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">if</span> err := <span style="color: #268bd2;">WaitForServer</span><span style="color: #2aa198;">(</span>url<span style="color: #2aa198;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span>
        log.<span style="color: #268bd2;">Fatalf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Site is down: %v\n"</span>, err<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>使用log是对于long-running server来说特别好的一个方式(对于interactive tool)
来说就有点过了.它一般会打印当前的时间等信息,还可以统一设置prefix,以及控制
打印的格式.还能只打印某种程度以上的错误
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        log.<span style="color: #268bd2;">SetPrefix</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Test logging:"</span><span style="color: #b58900;">)</span>
        log.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"OK by now"</span><span style="color: #b58900;">)</span>
        log.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"By now we have time"</span><span style="color: #b58900;">)</span>
        log.<span style="color: #268bd2;">SetFlags</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">suppress the display of the date and time</span>
        log.<span style="color: #268bd2;">Fatalf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Site is down"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Test logging:2017/01/20 17:51:15 OK by now</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Test logging:2017/01/20 17:51:15 By now we have time</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Test logging:Site is down</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">exit status 1</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-1-4" class="outline-5">
<h5 id="sec-5-4-1-4">Just to log and then continue</h5>
<div class="outline-text-5" id="text-5-4-1-4">
<ul class="org-ul">
<li>第四种情况是error并不影响我们的程序,比如ping某个ip失败,那么"只记录error,
而不返回,让程序继续运行下去".
<ul class="org-ul">
<li>可以只用log来记录(所有log函数都会加回车,如果原字符没有回车的情况下)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">if</span> err := <span style="color: #268bd2;">Ping</span><span style="color: #2aa198;">()</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span>
        log.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"ping failed: %v; networking disabled"</span>, err<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>也可以使用fmt打印到standard error stream
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">if</span> err := <span style="color: #268bd2;">Ping</span><span style="color: #2aa198;">()</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>os.Stderr, <span style="color: #2aa198;">"ping failed: %v; networking disabled\n"</span>, err<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-1-5" class="outline-5">
<h5 id="sec-5-4-1-5">Sefely ignore entirely</h5>
<div class="outline-text-5" id="text-5-4-1-5">
<ul class="org-ul">
<li>第五种情况,就是直接忽略错误,连log一下都不需要!!用到的地方不多.比如删除
temporary文件夹, 这个行为就算我们做失败了,每过一段时间,操作系统也会像清理
zombie进程一样清理temporary文件夹,所以出了error,连记录都不需要
<div class="org-src-container">

<pre class="src src-go">dir, err := ioutil.<span style="color: #268bd2;">TempDir</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">""</span>, <span style="color: #2aa198;">"scratch"</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"failed to create temp dir: %v"</span>, err<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...use temp dir...</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ignore errors; $TMPDIR is cleaned periodically by os</span>
os.<span style="color: #268bd2;">RemoveAll</span><span style="color: #2aa198;">(</span>dir<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-1-6" class="outline-5">
<h5 id="sec-5-4-1-6">Summary</h5>
<div class="outline-text-5" id="text-5-4-1-6">
<ul class="org-ul">
<li>Go的error处理有自己的节奏:往往是先处理failure,然后处理success的情况.所以
如果failure导致了function返回,那么succes也不会运行到,这种情况下,success也
不必再else里面处理了,直接在和'if处理error'一层就好
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">End of File (EOF)</h4>
<div class="outline-text-4" id="text-5-4-2">
<ul class="org-ul">
<li>大多数情况下, function返回的错误是给end user的,而不是给中间的程序(intervening
program)的.这句话怎么理解呢?
<ul class="org-ul">
<li>就是说我们的error的返回值一般是来告诉使用者错误信息的,这个信息是一个描述性
的语句,一般是string,没有enum类型的概念.因为其目的就是传递这个错误信息(string)
</li>
<li>而如果给intervening program来用,必须有类型概念.要不然if判断是什么错误的时
候,总不能以string是内容来判断是什么错误吧.
</li>
</ul>
</li>
<li>仅有不多的几个给intervening program来用的错误中,最具代表性的是EOF错误,这个错
误可以用来告诉用户,你对IO的读取完成了,但是没有读取到你要求的个数,因为文件到
头了.用户要区分'普通的读取错误(比如文件不存在)'和'读取到文件最后的错误(EOF)'
这个时候,我们就要给'读取到文件最后的错误(EOF)'一个类型了,让它能够应用到if里
面
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> io

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"errors"</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">EOF is the error returned by Read when no more input is available.</span>
<span style="color: #859900; font-weight: bold;">var</span> EOF = errors.<span style="color: #268bd2;">New</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"EOF"</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>在if里面的使用方法如下
<div class="org-src-container">

<pre class="src src-go">in := bufio.<span style="color: #268bd2;">NewReader</span><span style="color: #2aa198;">(</span>os.Stdin<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">{</span>
        r, _, err := in.<span style="color: #268bd2;">ReadRune</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> err == io.EOF <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">break</span>           <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">finish reading</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"read failed: %v"</span>, err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...use r ...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Function Values</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li>在Go语言里面, function是first-class value. 它拥有和value一样的特质:
<ul class="org-ul">
<li>拥有自己的类型(type)
</li>
<li>可以assigned给变量
</li>
<li>可以传递给函数
</li>
<li>可以从函数中返回
</li>
</ul>
</li>
<li>function之所以叫first-class value,是因为它还具有value不具有的额外优势:它可以
被调用!
</li>
<li>下面是一个把function"当成变量使"的例子
<a href="https://play.golang.org/p/TjOB996DUS">https://play.golang.org/p/TjOB996DUS</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">square</span><span style="color: #2aa198;">(</span>n <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span>     <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> n * n <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">negative</span><span style="color: #2aa198;">(</span>n <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span>   <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> -n <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">product</span><span style="color: #2aa198;">(</span>m, n <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> m * n <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        f := square
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">f</span><span style="color: #268bd2;">(</span>3<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        f = negative
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">f</span><span style="color: #268bd2;">(</span>3<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, f<span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">////////////////////////////////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// cannot use product (type func(int, int) int) as type func(int) int in assignment        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// f = product                                                                             //</span>
        <span style="color: #93a1a1;">////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">func(int) int</span>
</pre>
</div>
</li>
<li>上面的例子中,我们可以看到,一个function的类型是由两部分组成的:
<ul class="org-ul">
<li>所有的参数的类型
</li>
<li>返回值的类型
</li>
</ul>
</li>
<li>function type的zero value为nil(也就是你声明了这个函数,但是却没有函数"实体")
这种情况下,调用zero value的function会产生panic
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> f <span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span>
<span style="color: #268bd2;">f</span><span style="color: #2aa198;">(</span>3<span style="color: #2aa198;">)</span>                            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panic: call of nil function</span>
</pre>
</div>
</li>
<li>但是zero value function可以和nil相互比较. 但是function之间不可以相互比较!这个
特性是和slice一样的.这种情况下一般都是预示着类型是reference特性:可以和nil(空
指针)比较,但是由于指针类型不能进行算术计算,所以相互之间不能比较
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> f <span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span>
<span style="color: #859900; font-weight: bold;">if</span> f != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">f</span><span style="color: #b58900;">(</span>3<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>function可以作为参数传入另外的function,这样一来,我们可以传给"另外的function"
一个behavior, 而不仅仅是像传统参数一样,传递一个data.
<pre class="example">
Function values let us parameterize our functions over not just data,
but behavior too
</pre>
</li>
<li>标准库里面就有很多实用函数参数,引入"behavior"的例子,比如strings.Map就会把自
己第一个参数的"behavior",应用到第二个参数上.下面的例子中behavior就是把char
的ascii值'加一'
<a href="https://play.golang.org/p/SsRw6jo7Gf">https://play.golang.org/p/SsRw6jo7Gf</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"strings"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">add1</span><span style="color: #2aa198;">(</span>r <span style="color: #b58900;">rune</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">rune</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> r + 1 <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>strings.<span style="color: #268bd2;">Map</span><span style="color: #268bd2;">(</span>add1, <span style="color: #2aa198;">"ABC"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>strings.<span style="color: #268bd2;">Map</span><span style="color: #268bd2;">(</span>add1, <span style="color: #2aa198;">"WXY"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">BCD</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">XYZ</span>
</pre>
</div>
</li>
<li>前面5.2中的findLinks中,实用了一个helper函数visit来对某个节点访问,并且遍历这
些个节点.代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        doc, err := html.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">(</span>os.Stdin<span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">for</span> _, link := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #268bd2;">visit</span><span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">nil</span>, doc<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>link<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">visit</span><span style="color: #2aa198;">(</span>links <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>, n *<span style="color: #b58900;">html.Node</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#33410;&#28857;&#22788;&#29702;&#36923;&#36753;</span>
        <span style="color: #859900; font-weight: bold;">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span style="color: #2aa198;">"a"</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, a := <span style="color: #859900; font-weight: bold;">range</span> n.Attr <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">if</span> a.Key == <span style="color: #2aa198;">"href"</span> <span style="color: #6c71c4;">{</span>
                                links = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #859900;">(</span>links, a.Val<span style="color: #859900;">)</span>
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#36941;&#21382;&#36923;&#36753;</span>
        <span style="color: #859900; font-weight: bold;">for</span> c := n.FirstChild; c != <span style="color: #268bd2; font-weight: bold;">nil</span>; c = c.NextSibling <span style="color: #b58900;">{</span>
                links = <span style="color: #268bd2;">visit</span><span style="color: #268bd2;">(</span>links, c<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> links
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>从代码中我们可以发现,html.Parse()返回的只是一个指针,其他全部的工作都visit做
的,visit做了两件事情:
<ul class="org-ul">
<li>对每个节点进行处理
</li>
<li>负责遍历节点
</li>
</ul>
</li>
<li>使用function value的话,我们可以做到把上面的两个逻辑区分开,helper只负责遍历,
而对每个节点的处理,可以使用传入的function value里面的logic
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">forEachNode calls the functions pre(x) and post(x) for each node</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x in the tree rooted at n. Both functions are optional.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">pre is called before the children are visited (preorder) and</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">post is called after (postorder)</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">forEachNode</span><span style="color: #2aa198;">(</span>n *<span style="color: #b58900;">html.Node</span>, pre, post <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">(</span>n *<span style="color: #b58900;">html.Node</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> pre != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">pre</span><span style="color: #268bd2;">(</span>n<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">for</span> c := n.FirstChild; c != <span style="color: #268bd2; font-weight: bold;">nil</span>; c = c.NextSibling <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">forEachNode</span><span style="color: #268bd2;">(</span>c, pre, post<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">if</span> post != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">post</span><span style="color: #268bd2;">(</span>n<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个新的函数forEachNode比原来的逻辑还先进了一步:它允许访问node之前和访问node
之后调用的函数不一样.我们可以利用这个有点设计如下两个函数startElement和endElement
来分别打印HTML的elment的开始和结束tag,比如&lt;b&gt;&#x2026;&lt;/b&gt;
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>

        <span style="color: #2aa198;">"golang.org/x/net/html"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">var</span> deptrh int

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">startElement</span><span style="color: #2aa198;">(</span>n *<span style="color: #b58900;">html.Node</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> n.Type == html.ElementNode <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%*s&lt;%s&gt;\n"</span>, depth*2, <span style="color: #2aa198;">""</span>, n.Data<span style="color: #268bd2;">)</span>
                depth++
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">endElement</span><span style="color: #2aa198;">(</span>n *<span style="color: #b58900;">html.Node</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> n.Type == html.ElementNode <span style="color: #b58900;">{</span>
                depth--
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%*s&lt;/%s&gt;\n"</span>, depth*2, <span style="color: #2aa198;">""</span>, n.Data<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这里我们又遇到一个fmt.Printf'花式打印'的新例子:使用%*s来打印字符串pad到固定
长度,比如下面就是一个简单的使用例子,注意. 第一个参数提供pad后的长度.第二个参
数提供打印的字符串的长度.如果第一参数小于第二个参数,那么就相当于不起作用
<a href="https://play.golang.org/p/k-TL4FBinE">https://play.golang.org/p/k-TL4FBinE</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%*s\n"</span>, 2, <span style="color: #2aa198;">"fix"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%*s\n"</span>, 3, <span style="color: #2aa198;">"fix"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"--------------------"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%*s\n"</span>, 4, <span style="color: #2aa198;">"fix"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%*s\n"</span>, 5, <span style="color: #2aa198;">"fix"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%*s\n"</span>, 6, <span style="color: #2aa198;">"fix"</span><span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fix</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fix</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">--------------------</span>
<span style="color: #93a1a1;">//  </span><span style="color: #93a1a1;">fix</span>
<span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">fix</span>
<span style="color: #93a1a1;">//    </span><span style="color: #93a1a1;">fix</span>
</pre>
</div>
</li>
<li>我们整个例子的效果如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Outline prints the outline of an HTML document tree.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"net/http"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"golang.org/x/net/html"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, url := <span style="color: #859900; font-weight: bold;">range</span> os.Args<span style="color: #b58900;">[</span>1:<span style="color: #b58900;">]</span> <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">outline</span><span style="color: #268bd2;">(</span>url<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">outline</span><span style="color: #2aa198;">(</span>url <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        resp, err := http.<span style="color: #268bd2;">Get</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> err
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">defer</span> resp.Body.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>

        doc, err := html.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">(</span>resp.Body<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> err
        <span style="color: #b58900;">}</span>

        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+call</span>
        <span style="color: #268bd2;">forEachNode</span><span style="color: #b58900;">(</span>doc, startElement, endElement<span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-call</span>

        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+forEachNode</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">forEachNode calls the functions pre(x) and post(x) for each node</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x in the tree rooted at n. Both functions are optional.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">pre is called before the children are visited (preorder) and</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">post is called after (postorder).</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">forEachNode</span><span style="color: #2aa198;">(</span>n *<span style="color: #b58900;">html.Node</span>, pre, post <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">(</span>n *<span style="color: #b58900;">html.Node</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> pre != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">pre</span><span style="color: #268bd2;">(</span>n<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">for</span> c := n.FirstChild; c != <span style="color: #268bd2; font-weight: bold;">nil</span>; c = c.NextSibling <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">forEachNode</span><span style="color: #268bd2;">(</span>c, pre, post<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">if</span> post != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">post</span><span style="color: #268bd2;">(</span>n<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-forEachNode</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+startend</span>
<span style="color: #859900; font-weight: bold;">var</span> depth int

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">startElement</span><span style="color: #2aa198;">(</span>n *<span style="color: #b58900;">html.Node</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> n.Type == html.ElementNode <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%*s&lt;%s&gt;\n"</span>, depth*2, <span style="color: #2aa198;">""</span>, n.Data<span style="color: #268bd2;">)</span>
                depth++
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">endElement</span><span style="color: #2aa198;">(</span>n *<span style="color: #b58900;">html.Node</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> n.Type == html.ElementNode <span style="color: #b58900;">{</span>
                depth--
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%*s&lt;/%s&gt;\n"</span>, depth*2, <span style="color: #2aa198;">""</span>, n.Data<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-startend</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ go run outline.go http://gopl.io</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;html&gt;</span>
<span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">&lt;head&gt;</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">&lt;meta&gt;</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">&lt;/meta&gt;</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">&lt;title&gt;</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">&lt;/title&gt;</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">&lt;script&gt;</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">&lt;/script&gt;</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">&lt;link&gt;</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">&lt;/link&gt;</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">&lt;style&gt;</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">&lt;/style&gt;</span>
<span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">&lt;/head&gt;</span>
<span style="color: #93a1a1;">//   </span><span style="color: #93a1a1;">&lt;body&gt;</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">&lt;table&gt;</span>
<span style="color: #93a1a1;">//       </span><span style="color: #93a1a1;">&lt;tbody&gt;</span>
<span style="color: #93a1a1;">//         </span><span style="color: #93a1a1;">&lt;tr&gt;</span>
<span style="color: #93a1a1;">//           </span><span style="color: #93a1a1;">&lt;td&gt;</span>
<span style="color: #93a1a1;">//             </span><span style="color: #93a1a1;">&lt;a&gt;</span>
<span style="color: #93a1a1;">//               </span><span style="color: #93a1a1;">&lt;img&gt;</span>
<span style="color: #93a1a1;">//               </span><span style="color: #93a1a1;">&lt;/img&gt;</span>
<span style="color: #93a1a1;">//             </span><span style="color: #93a1a1;">&lt;/a&gt;</span>
<span style="color: #93a1a1;">//             </span><span style="color: #93a1a1;">&lt;br&gt;</span>
<span style="color: #93a1a1;">//             </span><span style="color: #93a1a1;">&lt;/br&gt;</span>
<span style="color: #93a1a1;">//             </span><span style="color: #93a1a1;">&lt;div&gt;</span>
<span style="color: #93a1a1;">//               </span><span style="color: #93a1a1;">&lt;a&gt;</span>
<span style="color: #93a1a1;">//                 </span><span style="color: #93a1a1;">&lt;img&gt;</span>
<span style="color: #93a1a1;">//                 </span><span style="color: #93a1a1;">&lt;/img&gt;</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6">Anonymous Functions</h3>
<div class="outline-text-3" id="text-5-6">
<ul class="org-ul">
<li>在Go中, named function只可以定义在package level,这是C语言开始就有的设定.没有
考虑到函数式编程
</li>
<li>如果希望在任何expression能够出现的地方都能定义function,那么我们不能再使用named
function,而要使用匿名函数anonymous function
</li>
<li>匿名函数(anonymous function)是一个value,其表现形式是function literal
所谓function literal就是
<pre class="example">
A function literal is written like a function declaration, but
without a name following the func keyword
</pre>
</li>
<li>比如上面ascii值"加一"的例子,我们就可以使用function literal来实现
<div class="org-src-container">

<pre class="src src-go">strings.<span style="color: #268bd2;">Map</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">(</span>r <span style="color: #b58900;">rune</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">rune</span> <span style="color: #b58900;">{</span><span style="color: #859900; font-weight: bold;">return</span> r + 1<span style="color: #b58900;">}</span>, <span style="color: #2aa198;">"ABC"</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>匿名函数的优点不是仅仅'少些了一个函数名'这么简单,使用function literal定义的
匿名函数,可以访问"包括匿名函数的scope"里面的变量. 这是所有的"函数式"程序必定
有的一个特性
<a href="https://play.golang.org/p/V7GQNwaV6Q">https://play.golang.org/p/V7GQNwaV6Q</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">squares</span><span style="color: #2aa198;">()</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> x int
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">int</span> <span style="color: #b58900;">{</span>
                x++
                <span style="color: #859900; font-weight: bold;">return</span> x * x
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        f := <span style="color: #268bd2;">squares</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">f</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">f</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">f</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">f</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>

<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">16</span>
</pre>
</div>
</li>
<li>上面的squares 返回了另外一个function作为返回值(类型是func()int)
</li>
<li>对squares()函数的调用会创建一个local variable x,并且返回了类型为func()int类
型的函数(而且是个匿名函数),并赋值给变量f
</li>
<li>变量f就指向了返回的匿名函数,每次f的调用,都会给x加一并且返回其二次方
</li>
<li>需要注意的是,我们再次调用squares()的情况下,就会重新创建local variable x,进而
重新从1开始一次计算
<a href="https://play.golang.org/p/xayBRQZygX">https://play.golang.org/p/xayBRQZygX</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">squares</span><span style="color: #2aa198;">()</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> x int
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">int</span> <span style="color: #b58900;">{</span>
                x++
                <span style="color: #859900; font-weight: bold;">return</span> x * x
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        f := <span style="color: #268bd2;">squares</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">f</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">f</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>

        f2 := <span style="color: #268bd2;">squares</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">f2</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">f2</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>

<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
</pre>
</div>
</li>
<li>squares的例子证明function values不仅仅是code,它同时还有state.这个state就是存
在于enclosing scope(也就是包裹匿名函数的scope)里面的local variable.
</li>
<li>由于function value 可以和enclosing scope里面的local variable有所联系,那么
也就可以认为anonymous function 始终保留着对enclosing scope里面局部变量的"引用",
那么这么看来,function类型被分类为"reference type"也就不足为奇了.
</li>
<li>Go实现这种function value的方法叫做closure.其实这也是绝大部分的functional语言
实现function value的方法
</li>
<li>这里我们再次看到了,在Go里面,variable的lifetime不是由scope决定的:squares里面的
局部变量x会一直存在着(被f调用),即便是squares已经成功返回了.这也预示着使用GC
的语言更容易实现function value
</li>
<li>下面我们来看一个更加学术化的问题:假设我们有一个map里面的key是某一节课,其value
是其key所需要的"先导课程"(必须先上完某些value里面的课,才能开始key的课),要求
输出一个满足"先导"要求的上课顺序
</li>
<li>这种问题在计算机科学里面叫做"拓扑排序(topological sorting)",prerequisite信
息组成了一个有向图(directed graph):每个node都是一个课程,并且每个课程所需要的
"前导"课程和它之间,会有一条边.这个图是不会存在环的
</li>
<li>我们可以使用depth-first的方法通过如下代码来完成遍历
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"sort"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">var</span> prereqs = <span style="color: #859900; font-weight: bold;">map</span><span style="color: #2aa198;">[</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">][]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">{</span>
        <span style="color: #2aa198;">"algorithms"</span>: <span style="color: #b58900;">{</span><span style="color: #2aa198;">"data structures"</span><span style="color: #b58900;">}</span>,
        <span style="color: #2aa198;">"calculus"</span>:   <span style="color: #b58900;">{</span><span style="color: #2aa198;">"linear algebra"</span><span style="color: #b58900;">}</span>,

        <span style="color: #2aa198;">"compilers"</span>: <span style="color: #b58900;">{</span>
                <span style="color: #2aa198;">"data structures"</span>,
                <span style="color: #2aa198;">"formal languages"</span>,
                <span style="color: #2aa198;">"computer organization"</span>,
        <span style="color: #b58900;">}</span>,

        <span style="color: #2aa198;">"data structures"</span>:       <span style="color: #b58900;">{</span><span style="color: #2aa198;">"discrete math"</span><span style="color: #b58900;">}</span>,
        <span style="color: #2aa198;">"databases"</span>:             <span style="color: #b58900;">{</span><span style="color: #2aa198;">"data structures"</span><span style="color: #b58900;">}</span>,
        <span style="color: #2aa198;">"discrete math"</span>:         <span style="color: #b58900;">{</span><span style="color: #2aa198;">"intro to programming"</span><span style="color: #b58900;">}</span>,
        <span style="color: #2aa198;">"formal languages"</span>:      <span style="color: #b58900;">{</span><span style="color: #2aa198;">"discrete math"</span><span style="color: #b58900;">}</span>,
        <span style="color: #2aa198;">"networks"</span>:              <span style="color: #b58900;">{</span><span style="color: #2aa198;">"operating systems"</span><span style="color: #b58900;">}</span>,
        <span style="color: #2aa198;">"operating systems"</span>:     <span style="color: #b58900;">{</span><span style="color: #2aa198;">"data structures"</span>, <span style="color: #2aa198;">"computer organization"</span><span style="color: #b58900;">}</span>,
        <span style="color: #2aa198;">"programming languages"</span>: <span style="color: #b58900;">{</span><span style="color: #2aa198;">"data structures"</span>, <span style="color: #2aa198;">"computer organization"</span><span style="color: #b58900;">}</span>,
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">topoSort</span><span style="color: #2aa198;">(</span>m <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">][]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> order <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>
        seen := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">bool</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">var</span> visitAll <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">(</span>items <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">)</span>

        visitAll = <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">(</span>items <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, item := <span style="color: #859900; font-weight: bold;">range</span> items <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">if</span> !seen<span style="color: #6c71c4;">[</span>item<span style="color: #6c71c4;">]</span> <span style="color: #6c71c4;">{</span>
                                seen<span style="color: #859900;">[</span>item<span style="color: #859900;">]</span> = <span style="color: #268bd2; font-weight: bold;">true</span>
                                <span style="color: #268bd2;">visitAll</span><span style="color: #859900;">(</span>m<span style="color: #b58900;">[</span>item<span style="color: #b58900;">]</span><span style="color: #859900;">)</span>
                                order = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #859900;">(</span>order, item<span style="color: #859900;">)</span>
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">var</span> keys <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>
        <span style="color: #859900; font-weight: bold;">for</span> key := <span style="color: #859900; font-weight: bold;">range</span> m <span style="color: #b58900;">{</span>
                keys = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #268bd2;">(</span>keys, key<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        sort.<span style="color: #268bd2;">Strings</span><span style="color: #b58900;">(</span>keys<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">visitAll</span><span style="color: #b58900;">(</span>keys<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> order
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> i, course := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #268bd2;">topoSort</span><span style="color: #b58900;">(</span>prereqs<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%d:\t%s\n"</span>, i+1, course<span style="color: #268bd2;">)</span>

        <span style="color: #b58900;">}</span>

<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1:   intro to programming</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2:   discrete math</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3:   data structures</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4:   algorithms</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5:   linear algebra</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">6:   calculus</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">7:   formal languages</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">8:   computer organization</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9:   compilers</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10:  databases</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">11:  operating systems</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">12:  networks</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">13:  programming languages</span>
</pre>
</div>
</li>
<li>这里我们使用了匿名函数(所以就可以随心所欲的使用enclosing scope的局部变量,有
种我们原来随意使用global variable的快感!), 而且匿名函数还运用了递归.由于匿名
函数本身没有名字,所以递归的时候,如果不给一个变量名的话,会找不到内存地址.所以
我们这里在递归以前,都使用变量来存储了我们的匿名函数
</li>
<li>我们的findLink也可以使用匿名函数来做递归,代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Extract makes an HTTP GET request to the specified URL, parses</span>
<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"net/http"</span>

        <span style="color: #2aa198;">"golang.org/x/net/html"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">the response as HTML, and returns the links in the HTML document.</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Extract</span><span style="color: #2aa198;">(</span>url <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        resp, err := http.<span style="color: #268bd2;">Get</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, err
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">if</span> resp.StatusCode != http.StatusOK <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"getting %s: %s"</span>, url, resp.Status<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        doc, err := html.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">(</span>resp.Body<span style="color: #b58900;">)</span>
        resp.Body.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"parsing %s as HTML: %v"</span>, url, err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">var</span> links <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>
        visitnode := <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">(</span>n *<span style="color: #b58900;">html.Node</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span style="color: #2aa198;">"a"</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">for</span> _, a := <span style="color: #859900; font-weight: bold;">range</span> n.Attr <span style="color: #6c71c4;">{</span>
                                <span style="color: #859900; font-weight: bold;">if</span> a.Key != <span style="color: #2aa198;">"href"</span> <span style="color: #859900;">{</span>
                                        <span style="color: #859900; font-weight: bold;">continue</span>
                                <span style="color: #859900;">}</span>
                                link, err := resp.Request.URL.<span style="color: #268bd2;">Parse</span><span style="color: #859900;">(</span>a.val<span style="color: #859900;">)</span>
                                <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #859900;">{</span>
                                        <span style="color: #859900; font-weight: bold;">continue</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ignore bad URLS</span>
                                <span style="color: #859900;">}</span>
                                links = <span style="color: #268bd2;">appenda</span><span style="color: #859900;">(</span>links, link.<span style="color: #268bd2;">String</span><span style="color: #b58900;">()</span><span style="color: #859900;">)</span>
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #268bd2;">forEachNode</span><span style="color: #b58900;">(</span>doc, visitNode, <span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">need only pre function</span>
        <span style="color: #859900; font-weight: bold;">return</span> links, <span style="color: #268bd2; font-weight: bold;">nil</span>

<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们刚才讲到的拓扑排序(topoSort)其实是一种对graph的深度优先遍历,而在互联网
应用里面还存在着一种对graph的广度优先遍历,就是爬虫(crawler)
</li>
<li>下面的代码就简单描述了如何做一个广度优先遍历,从而实现爬虫
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Findlinks3 crawls the web, starting with the URLs on the command line.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"gopl.io/ch5/links"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+breadthFirst</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">breadthFirst calls f for each item in the worklist.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Any items returned by f are added to the worklist.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">f is called at most once for each item.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">breadthFirst</span><span style="color: #2aa198;">(</span>f <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">(</span>item <span style="color: #b58900;">string</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>, worklist <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        seen := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">bool</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>worklist<span style="color: #b58900;">)</span> &gt; 0 <span style="color: #b58900;">{</span>
                items := worklist
                worklist = <span style="color: #268bd2; font-weight: bold;">nil</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, item := <span style="color: #859900; font-weight: bold;">range</span> items <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">if</span> !seen<span style="color: #6c71c4;">[</span>item<span style="color: #6c71c4;">]</span> <span style="color: #6c71c4;">{</span>
                                seen<span style="color: #859900;">[</span>item<span style="color: #859900;">]</span> = <span style="color: #268bd2; font-weight: bold;">true</span>
                                worklist = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #859900;">(</span>worklist, <span style="color: #268bd2;">f</span><span style="color: #b58900;">(</span>item<span style="color: #b58900;">)</span>...<span style="color: #859900;">)</span>
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-breadthFirst</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+crawl</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">crawl</span><span style="color: #2aa198;">(</span>url <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        list, err := links.<span style="color: #268bd2;">Extract</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Print</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> list
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-crawl</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+main</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Crawl the web breadth-first,</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">starting from the command-line arguments.</span>
        <span style="color: #268bd2;">breadthFirst</span><span style="color: #b58900;">(</span>crawl, os.Args<span style="color: #268bd2;">[</span>1:<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-main</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ go run findlinks.go https://golang.org</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/doc/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/pkg/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/project/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/help/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/blog/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">http://play.golang.org/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://tour.golang.org/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/dl/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://blog.golang.org/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://developers.google.com/site-policies#restrictions</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/LICENSE</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/doc/tos.html</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">http://www.google.com/intl/en/policies/privacy/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/doc/install</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://code.google.com/p/go-tour/</span>
</pre>
</div>
</li>
<li>一般来说,广度优先遍历都是使用FIFO的队列来实现的,这里通过把worklist设置成nil
然后返回新的worklist来完成两点FIFO
</li>
</ul>
</div>
<div id="outline-container-sec-5-6-1" class="outline-4">
<h4 id="sec-5-6-1">Caveat: Capturing Iteration Variables</h4>
<div class="outline-text-4" id="text-5-6-1">
<ul class="org-ul">
<li>这一小节,我们主要来看一下由于Go的lexical scope(使用了匿名函数才会有)带来的
一些surprising result, 了解这些有助于防止写出错误代码.因为这些问题即便是有
经验的程序员也难以避免
</li>

<li>看下面的这个例子, 这个例子要我们先要创建一系列的文件夹,而我们需要在后面把这
些文件夹一一删除掉
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> rmdirs <span style="color: #2aa198;">[]</span><span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">()</span>

<span style="color: #859900; font-weight: bold;">for</span> _, d := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #268bd2;">tempDirs</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        dir := d                    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: necessary!</span>
        os.<span style="color: #268bd2;">MkdirAll</span><span style="color: #b58900;">(</span>dir, 0755<span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">clean up functions are stored in one slice, will be called</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">one by one later</span>
        rmdirs = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #b58900;">(</span>rmdirs, <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Use anonymous function here</span>
                os.<span style="color: #268bd2;">RemoveAll</span><span style="color: #6c71c4;">(</span>dir<span style="color: #6c71c4;">)</span>
        <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">... do some work...</span>
<span style="color: #859900; font-weight: bold;">for</span> _, rmdir := <span style="color: #859900; font-weight: bold;">range</span> rmdirs <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">rmdir</span><span style="color: #b58900;">()</span>                     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">clean up one by one</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>上面版本"诡异"的地方在于其在每个loop里面都又申请了一个local variable dir而
不是像下面这样,直接使用for里面声明的变量
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> rmdirs <span style="color: #2aa198;">[]</span><span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">()</span>

<span style="color: #859900; font-weight: bold;">for</span> _, dir := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #268bd2;">tempDirs</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        os.<span style="color: #268bd2;">MkdirAll</span><span style="color: #b58900;">(</span>dir, 0755<span style="color: #b58900;">)</span>
        rmdirs = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #b58900;">(</span>rmdirs, <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
                os.<span style="color: #268bd2;">RemoveAll</span><span style="color: #6c71c4;">(</span>dir<span style="color: #6c71c4;">)</span>
        <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这两者的差异在哪里呢?
<ul class="org-ul">
<li>第二种方法等于多个不同的匿名函数共享了一个局部变量dir,最后一一调用的时候
会不断的删除同一个文件夹
</li>
<li>第一种方法等于多个不同的匿名函数每个函数都有一个自己的局部变量dir,最后一
一删除的时候,不会影响其他function
</li>
</ul>
</li>
<li>经过这个例子我们会看到出现这种问题一般需要两个条件:
<ul class="org-ul">
<li>使用多个匿名函数,所以才有可能多个函数引用同一个变量
</li>
<li>delay 匿名函数的调用. 这里的例子是我们根据业务需要些出来的.而在Go语言的
机制里面,defer和go statement是两个最经常使用延时调用的地方,也是容易出现
这个错误的地方
</li>
</ul>
</li>
<li>上面这个例子中使用d和dir的方法当然是可以的,但是也可以定义一个inner的dir,虽
然看起来奇怪,倒是也可以工作
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">for</span> _, dir := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #268bd2;">tempDirs</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        dir := dir              <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">declares inner dir, initialized to outer dir</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个错误不是range才有的,所有的loop都可能会有类似的问题
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> rmdirs <span style="color: #2aa198;">[]</span><span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">()</span>
dirs := <span style="color: #268bd2;">tempDirs</span><span style="color: #2aa198;">()</span>
<span style="color: #859900; font-weight: bold;">for</span> i := 0; i &lt; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>dirs<span style="color: #2aa198;">)</span>; i++ <span style="color: #2aa198;">{</span>
        os.<span style="color: #268bd2;">MkdirAll</span><span style="color: #b58900;">(</span>dirs<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>, 0755<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok</span>
        rmdirs = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #b58900;">(</span>rmdirs, <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
                os.<span style="color: #268bd2;">RemoveAll</span><span style="color: #6c71c4;">(</span>dirs<span style="color: #859900;">[</span>i<span style="color: #859900;">]</span><span style="color: #6c71c4;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: incorrect!</span>
        <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7">Variadic Functions</h3>
<div class="outline-text-3" id="text-5-7">
<ul class="org-ul">
<li>变长参数是一个非常重要的特性,这个特性在c里面就有, go里面支持就不足为奇了.常
见的例子就是fmt.Printf. 它需要一个固定的参数,后面允许有个数不等的参数
</li>
<li>变长参数在go里面的要求是"在声明的时候"最后一个参数的类型为"&#x2026;&lt;Type&gt;", 在调
用的时候,实参可以对应零个或者多个.
<a href="https://play.golang.org/p/3kZckk5wPc">https://play.golang.org/p/3kZckk5wPc</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">sum</span><span style="color: #2aa198;">(</span>vals ...<span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        total := 0
        <span style="color: #859900; font-weight: bold;">for</span> _, val := <span style="color: #859900; font-weight: bold;">range</span> vals <span style="color: #b58900;">{</span>
                total += val
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> total
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">sum</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">sum</span><span style="color: #268bd2;">(</span>3<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">sum</span><span style="color: #268bd2;">(</span>1, 2, 3, 4<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10</span>
</pre>
</div>
</li>
<li>上面例子的Go编译器内部实现机制是:
<ul class="org-ul">
<li>caller创建一个array,把参数都拷贝进去(个数一定,那就用数组就好了)
</li>
<li>caller把指向整个array的slice给予function
</li>
<li>function就可以使用某个slice来代表自己的不定参数了
</li>
</ul>
</li>
<li>上面的三个步骤,不使用"不定参数"也可以实现,只不过稍微麻烦了一点.需要注意的是
我们把一个slice"赋值给"不定参数"做实参"的时候,需要在变量右边加上"&#x2026;",而虚
参则是放在type的左边!
<div class="org-src-container">

<pre class="src src-go">values := <span style="color: #2aa198;">[]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">{</span>1, 2, 3, 4<span style="color: #2aa198;">}</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">sum</span><span style="color: #b58900;">(</span>values...<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"10"</span>
</pre>
</div>
</li>

<li>&#x2026;int类型的(虚参)行为和 integer slice类型[]int是一样的,但是还是不同的类型
<a href="https://play.golang.org/p/Kp1ZaorD9b">https://play.golang.org/p/Kp1ZaorD9b</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">(</span>...<span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">g</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>  <span style="color: #2aa198;">{}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, f<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, g<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">func(...int)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">func([]int)</span>
</pre>
</div>
</li>
<li>variadic function最主要的应用场景就是字符串format,一般来说其参数是interface{}
类型.这就意味着函数可以接受任何类型的输入(然后使用反射来判断其真正的类型)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">errorf</span><span style="color: #2aa198;">(</span>linenum <span style="color: #b58900;">int</span>, format <span style="color: #b58900;">string</span>, args ...<span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-8" class="outline-3">
<h3 id="sec-5-8">Deferred Function Calls</h3>
<div class="outline-text-3" id="text-5-8">
<ul class="org-ul">
<li>为了了解defer的必要性,先来看一个场景:还是我们的findLinks,我们用http.Get来获
取url的内容,然后把这个内容作为input传递给html.Parse.这个流程能够顺利进行的前
提,是我们的html类型是text/html,如果是image, plain text等类型的话,就得不到想
要的结果了,所以我们的例子会进行防御性的'排除'
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">title</span><span style="color: #2aa198;">(</span>url <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        resp, err := http.<span style="color: #268bd2;">Get</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> err
        <span style="color: #b58900;">}</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Check Content-Type is HTML(e.g., "text/html; charset=utf-8").</span>
        ct := resp.Header.<span style="color: #268bd2;">Get</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Content-Type"</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> ct != <span style="color: #2aa198;">"text/html"</span> &amp;&amp; !strings.<span style="color: #268bd2;">HasPrefix</span><span style="color: #b58900;">(</span>ct, <span style="color: #2aa198;">"text/html"</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                resp.Body.<span style="color: #268bd2;">Close</span><span style="color: #268bd2;">()</span>
                <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%s has type %s, not text/html"</span>, url, ct<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        doc, err := html.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">(</span>resp.Body<span style="color: #b58900;">)</span>
        resp.Body.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"parsing %s as HTML: %v"</span>, url, err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        visitNode := <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">(</span>n *<span style="color: #b58900;">html.Node</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> n.Type == html.ElementNode &amp;&amp; n.Dat == <span style="color: #2aa198;">"title"</span> &amp;&amp;
                        n.FirstChild != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Println</span><span style="color: #6c71c4;">(</span>n.FirstChild.Data<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #268bd2;">forEachNode</span><span style="color: #b58900;">(</span>doc, visitNode, <span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们注意到上面由于防御性编程的要求,resp.Body.Close()在代码里面出现了两次,这
样能够保证在failure的情况下,资源也不会泄露.但是随着代码数目的增长,上述repeat
code会成为一大隐患.我们迫切的需要一种"无论成败与否"请记得帮我释放资源(不是
内存)的办法.这个办法在Go里面就是defer
</li>
<li>Go使用defer来进行deferred function call,因为go是自动释放内存的语言,但是却不
能自动释放其他资源,比如打开的文件(或者网络链接),下面一个就是"自动"释放打开
文件的例子. 文件就是一种资源
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> ioutil

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">ReadFile</span><span style="color: #2aa198;">(</span>filename <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">[]</span><span style="color: #b58900;">byte</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        f, err := os.<span style="color: #268bd2;">Open</span><span style="color: #b58900;">(</span>filename<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, err
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">defer</span> f.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">ReadAll</span><span style="color: #b58900;">(</span>f<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>把mutex看成一种资源的话,defer也是一样工作的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> mu sync.Mutex
<span style="color: #859900; font-weight: bold;">var</span> m = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">lookup</span><span style="color: #2aa198;">(</span>key <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        mu.<span style="color: #268bd2;">Lock</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">defer</span> mu.<span style="color: #268bd2;">Unlock</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">return</span> m<span style="color: #b58900;">[</span>key<span style="color: #b58900;">]</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>defer statement还可以用来在debug的时候设置"on entry"和"on exit"动作,这种设置
非常的巧妙.是使用defer调用一个函数,而这个函数是通过另外一个函数的返回值返回
的.
</li>
<li>另外一个函数可以在其内部设置时间戳,表示'开始'就运行.其返回值会被defer标记,从而
在'最后'运行
<a href="https://play.golang.org/p/U1fFJc9jYq">https://play.golang.org/p/U1fFJc9jYq</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">bigSlowOperation</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">defer</span> <span style="color: #268bd2;">trace</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"bigSlowOperation"</span><span style="color: #b58900;">)()</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">don't forget the extra parentheses</span>
        time.<span style="color: #268bd2;">Sleep</span><span style="color: #b58900;">(</span>3 * time.Second<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">trace</span><span style="color: #2aa198;">(</span>msg <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        start := time.<span style="color: #268bd2;">Now</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"enter \t%s\n"</span>, msg<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"exit \t%s after (%v)"</span>, msg, time.<span style="color: #268bd2;">Since</span><span style="color: #6c71c4;">(</span>start<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">bigSlowOperation</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">enter        bigSlowOperation</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">exit         bigSlowOperation after (3.00531379s)</span>
</pre>
</div>
</li>
<li>defer还有一个特性是和匿名函数联手,其原理基于如下几个事实:
<ul class="org-ul">
<li>deferred function是在return statement更新了result variable以后才运行的
</li>
<li>匿名函数是可以访问local variable
</li>
<li>named result也是函数的local variable
</li>
</ul>
</li>
<li>所以,我们可以使用defer 匿名函数的办法来打印某个函数的参数和结果
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">double</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>result <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">defer</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"double(%d) = %d\n"</span>, x, result<span style="color: #268bd2;">)</span> <span style="color: #b58900;">}()</span>
        <span style="color: #859900; font-weight: bold;">return</span> x + x
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        _ = <span style="color: #268bd2;">double</span><span style="color: #b58900;">(</span>4<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">double(4) = 8</span>
</pre>
</div>
</li>
<li>对于double来说,这个trick看起来是很多余的,但是对于多个参数返回的情况下,好好
利用这个trick,会有意想不到的结果
</li>
<li>我们设置可以使用这个trick来设置可以"更改"函数返回值,来创建新的函数(由于defe
r的代价高昂,这并不是一个好主意,只是可行而已)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">double</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> x + x
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">triple</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>result <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">defer</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> result += x <span style="color: #b58900;">}()</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">double</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">triple</span><span style="color: #268bd2;">(</span>4<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">12</span>
</pre>
</div>
</li>
<li>我们的defer只是运行在return之后,但并不是在function execution的"最最后",所以
在loop里面运行defer需要额外的关注.下面的代码有可能会耗尽所有的文件描述符,因
为因为在处理完所有文件之前(函数返回前,defer的运行周期是以当前函数记),没有文
件会被关闭
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">for</span>  _, filename := <span style="color: #859900; font-weight: bold;">range</span> filenames <span style="color: #2aa198;">{</span>
        f, err := os.<span style="color: #268bd2;">Open</span><span style="color: #b58900;">(</span>filename<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> err
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">defer</span> f.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: risky; could run out of file descriptors</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...process f...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>一个更改办法是把loop主体(包括defer)放入到一个function里面,由于defer是在enclosing
它的function结束前运行,所以这会带来更安全的体验
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">for</span> _, filename := <span style="color: #859900; font-weight: bold;">range</span> filenames <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> err := <span style="color: #268bd2;">doFile</span><span style="color: #b58900;">(</span>filename<span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> err
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">doFile</span><span style="color: #2aa198;">(</span>filename <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        f, err := os.<span style="color: #268bd2;">Open</span><span style="color: #b58900;">(</span>filename<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> err
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">defer</span> f.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...process f...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>下面的例子是我们fetch的变体,把结果写入到文件系统,而不是standard output
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Fetch downloads the URL and returns the</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">name and length of the local file.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">fetch</span><span style="color: #2aa198;">(</span>url <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>filename <span style="color: #b58900;">string</span>, n <span style="color: #b58900;">int64</span>, err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        resp, err := http.<span style="color: #268bd2;">Get</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">""</span>, 0, err
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">defer</span> resp.Body.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>

        local := path.<span style="color: #268bd2;">Base</span><span style="color: #b58900;">(</span>resp.Request.URL.Path<span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">if</span> local == <span style="color: #2aa198;">"/"</span> <span style="color: #b58900;">{</span>
                local = <span style="color: #2aa198;">"index.html"</span>
        <span style="color: #b58900;">}</span>

        f, err := os.<span style="color: #268bd2;">Create</span><span style="color: #b58900;">(</span>local<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">""</span>, 0, err

        <span style="color: #b58900;">}</span>
        n, err = io.<span style="color: #268bd2;">Copy</span><span style="color: #b58900;">(</span>f, resp.Body<span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Close file, but prefer error from Copy, if any.</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">IT IS err == nil NOT closeErr == nil</span>
        <span style="color: #859900; font-weight: bold;">if</span> closeErr := f.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>; err == <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                err = closeErr
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> local, n, err
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个例子中的defer resp.Body.Close我们是非常熟悉了,但是我们发现上面例子中,我
们并没有使用defer去调用f.Close.这是基于如下原因
<pre class="example">
       在很多文件系统中(代表是NFS), write错误并不会马上报告,而是会在文件close的
       时刻才报告.而且这些error是不能忽略的
</pre>
</li>
<li>换句话说,resp.Body的close错误是可以忽略的,os.Create得到的f的close错误是不能
忽略的.这种情况下不能使用defer来处理f,因为defer不去管返回值
</li>
<li>io.Copy和f.Close都有错误的情况下,优先报io.Copy的错误,因为它是先发生的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-9" class="outline-3">
<h3 id="sec-5-9">Panic</h3>
<div class="outline-text-3" id="text-5-9">
<ul class="org-ul">
<li>Go在编译期会发现很多错误,但是某些错误,比如out-fo-bounds array access, 或者
nil pointer dereference需要在run time进行处理. 而Go在runtime遇到这种问题的
方法,就是直接panic
</li>
<li>一个panic发生的时候:
<ul class="org-ul">
<li>所有normal execution停止
</li>
<li>deferred function马上执行!
</li>
<li>程序crash并且会产生一个log message. 这个log message 包括panic value(提示
某种类型的错误)和每个goroutine一个的stack trace.对于debug错误,这些信息往往
足够了
</li>
</ul>
</li>
<li>不是所有的panic都来自于runtime,也可以"自制"panic,也就是直接调用panic函数,这个
函数接受任何类型的参赛
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">buitin</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #2aa198;">(</span>v <span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>我们调用panic 函数的时候,往往是impossible情景发生的时候.这种情景"不应该"被
逻辑语句走到
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">switch</span> s := <span style="color: #268bd2;">suit</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">drawCard</span><span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>; s <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">"Spades"</span>:
<span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">"Hearts"</span>:
<span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">"Diamonds"</span>:
<span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">"Clubs"</span>:
<span style="color: #859900; font-weight: bold;">default</span>:
        <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #b58900;">(</span>fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"invalid suit %q"</span>, s<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Joker?</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>需要牢记的是panic总是发生在runtime,你可以调用panic,但是你调用panic是为了向
上面的例子一样提供"额外"的重要信息(上面的default不写的话,遇到Joker也是会panic
的).
</li>
<li>如果不能提供"额外"的信息,那么就让runtime去panic好了,log message足够你去调试
的.下面的例子就不适合panic.因为x是nil这件事情runtime抛出panic的时候,几乎肯
定会写到log message里面
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Reset</span><span style="color: #2aa198;">(</span>x *<span style="color: #b58900;">Buffer</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> x == <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"x is nil"</span><span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">unnecessary!</span>
        <span style="color: #b58900;">}</span>
        x.elements = <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>对于一个程序来说,所有的panic都应该看做是一种bug.在健壮的系统里面,所有的expected
error,比如错误的input,错误配置,failing IO,都应该使用error value来处理,而不是
使用panic!
</li>
<li>除了提供额外的信息以外,使用panic的另外一个情景就是"强制性检查error value,不
对就爆出bug".
</li>
<li>看下面的正则表达式的例子,正则表达式如果错误的话,会返回error value
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> regexp

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Compile</span><span style="color: #2aa198;">(</span>expr <span style="color: #b58900;">string</span><span style="color: #2aa198;">)(</span>*<span style="color: #b58900;">Regexp</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>而如果正则表达式的字符串不是用户输入的,而是在代码里面的,那么如果写错了,意味
着这是一个bug,而不是仅仅是error value.针对这种非常特殊的情况,我们引入了一个
帮助函数MustCompile
</li>
<li>这个Must已经在Go里面是一种命名规范了,表示输入如果不对,就是个bug,不要墨迹啥
error value的事了,因为bug了的话,后面都不会是对的.也就是说这不是expected error
而是expected bug
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> regexp

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">MustCompile</span><span style="color: #2aa198;">(</span>expr <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> *<span style="color: #b58900;">Regexp</span> <span style="color: #2aa198;">{</span>
        re, err := <span style="color: #268bd2;">Compile</span><span style="color: #b58900;">(</span>expr<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> re
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个Must wrapper函数调用起来,就非常的轻松了,不用去管error.字符串错了,就直接
抛出panic
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> httpSchemeRE = regexp.<span style="color: #268bd2;">MustCompile</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">`^https?:`</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"http:" or "https:"</span>
</pre>
</div>
</li>
<li>当panic发生的时候,所有的deferred function都会以相反的顺序被调用.所谓相反的
顺序,就是从stack里面最压的最里的函数开始,到main函数为止.换句话说,就是先defer
的函数后调用!
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">f</span><span style="color: #b58900;">(</span>3<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"f(%d)\n"</span>, x+0/x<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panics if x == 0</span>
        <span style="color: #859900; font-weight: bold;">defer</span> fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"defer %d\n"</span>, x<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">f</span><span style="color: #b58900;">(</span>x - 1<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">f(3)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">f(2)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">f(1)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">defer 1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">defer 2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">defer 3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panic: runtime error: integer divide by zero</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">goroutine 1 [running]:</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panic(0x90b40, 0xc42000a0a0)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/usr/local/Cellar/go/1.7.1/libexec/src/runtime/panic.go:500 +0x1a1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.f(0x0)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:10 +0x1c8</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.f(0x1)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:12 +0x18f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.f(0x2)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:12 +0x18f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.f(0x3)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:12 +0x18f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.main()</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:6 +0x2a</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">exit status 2</span>
</pre>
</div>
</li>
<li>后面我们会看到,panic的结果并不一定是termination!我们可以使用recover来兜底
</li>
<li>从调试的角度讲,我们的runtime package提供了一个函数Stack,可以打印dump stack
信息到IO,下面的例子就是通过defer来在panic的时候打印stack
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"runtime"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">defer</span> <span style="color: #268bd2;">printStack</span><span style="color: #b58900;">()</span>
        <span style="color: #268bd2;">f</span><span style="color: #b58900;">(</span>3<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"f(%d)\n"</span>, x+0/x<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panics if x == 0</span>
        <span style="color: #859900; font-weight: bold;">defer</span> fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"defer %d\n"</span>, x<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">f</span><span style="color: #b58900;">(</span>x - 1<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">printStack</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> buf <span style="color: #b58900;">[</span>4096<span style="color: #b58900;">]</span><span style="color: #b58900;">byte</span>
        n := runtime.<span style="color: #268bd2;">Stack</span><span style="color: #b58900;">(</span>buf<span style="color: #268bd2;">[</span>:<span style="color: #268bd2;">]</span>, <span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #b58900;">)</span>
        os.Stdout.<span style="color: #268bd2;">Write</span><span style="color: #b58900;">(</span>buf<span style="color: #268bd2;">[</span>:n<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">f(3)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">f(2)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">f(1)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">defer 1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">defer 2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">defer 3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">goroutine 1 [running]:</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.printStack()</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:22 +0x6e</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panic(0x911c0, 0xc42000a0a0)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/usr/local/Cellar/go/1.7.1/libexec/src/runtime/panic.go:458 +0x243</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.f(0x0)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:15 +0x1c8</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.f(0x1)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:17 +0x18f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.f(0x2)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:17 +0x18f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.f(0x3)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:17 +0x18f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.main()</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:11 +0x46</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panic: runtime error: integer divide by zero</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">goroutine 1 [running]:</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panic(0x911c0, 0xc42000a0a0)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/usr/local/Cellar/go/1.7.1/libexec/src/runtime/panic.go:500 +0x1a1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.f(0x0)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:15 +0x1c8</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.f(0x1)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:17 +0x18f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.f(0x2)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:17 +0x18f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.f(0x3)</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:17 +0x18f</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.main()</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/panic_demo.go:11 +0x46</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">exit status 2</span>
</pre>
</div>
</li>
<li>值得注意的是runtime.Stack打印了非常全面的stack信息,这得益于Go的panic机制会
在unwind stack之前,调用defer函数,所以defer 函数运行的时候,stack还没有被破坏
</li>
<li>关于unwind的定义,我们可以看下C++中的定义
<pre class="example">
In the C++ exception mechanism, control moves from the throw
statement to the first catch statement that can handle the
thrown type. When the catch statement is reached, all of the
automatic variables that are in scope between the throw and
catch statements are destroyed in a process that is known as
stack unwinding.
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-10" class="outline-3">
<h3 id="sec-5-10">Recover</h3>
<div class="outline-text-3" id="text-5-10">
<ul class="org-ul">
<li>对于绝大多数的出现panic的程序来说来说,放弃这个程序可能是最明智的做法.但是有
时候,我们也是需要"拯救"这个panic,或者至少说"暂时拯救",先做些clean up,然后
再退出.这个"拯救"的过程,叫做recover
</li>
<li>一个最常见的,即便是出现了panic,但是也不应该退出的情况,就是web server:当web
server内部出现错误的时候:
<ul class="org-ul">
<li>如果在development模式下,我们应该显示500错误,把错误报给client.典型的例子比
如rails里面某个变量没定义,rails会在网页端打印这个错误.server不会关闭
</li>
<li>如果在production模式下,我们应该给用户抛出500.server也不会关闭
</li>
</ul>
</li>
<li>让built-in的recover函数其作用,是要有先决条件的:
<ul class="org-ul">
<li>recover是调用在一个defer function里面的. 而这个defer function是嵌入在另外
一个正常的function里面的(一般通过匿名函数,一来使用local variable,二来马上
调用)
</li>
<li>另外一个正常的function发生了panic
</li>
</ul>
</li>
<li>下面就是这样一个例子,我们注意到recover()函数的返回值就是panic函数的参数.如果
需要,我们还可以在后面加上runtime.Stack的信息
<a href="https://play.golang.org/p/cZgdOiJzcQ">https://play.golang.org/p/cZgdOiJzcQ</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Parse</span><span style="color: #2aa198;">(</span>input <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>output <span style="color: #b58900;">int</span>, err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">defer</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> p := <span style="color: #657b83; font-weight: bold;">recover</span><span style="color: #268bd2;">()</span>; p != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        err = fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"internal error: %v"</span>, p<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}()</span>
        <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"panic throw this error"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Parse</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"hello"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0 internal error: panic throw this error</span>
</pre>
</div>
</li>
<li>一旦recover起了作用(证明发生了panic),那么正常的流程(导致panic的流程)就不再走
了,而是完成defer 函数以后,直接就返回了!defer是最后一道工序.所以我们的函数使
用了named result,从而可以更容易的更改返回值
</li>
<li>如果recover被调用在任何其他的地方,它没有任何的效果,返回值总是nil
</li>
<li>不分青红皂白的从panic里面recover是一种不可靠的行为,因为在panic以后,一个package
的variable state是无定义的(或者没有documented的):或许
<ul class="org-ul">
<li>data structure是不完整的
</li>
<li>file(network connection也是一种file)打开了却没有close
</li>
<li>lock获取了,却没有释放
</li>
</ul>
</li>
<li>实际上我们是以一行log来代替了crash,会掩盖很多问题
</li>
<li>对同一个package内部的panic进行recover,是一种处理unexpected error非常好的方式
但是需要注意的是:决不允许revoer 其他package的panic
</li>
<li>同时public API不应该抛出panic,而应该以error来表示错误
</li>
<li>你也不能对'你不能控制的function里面的panic'来进行recover,比如caller provided
callback.虽然这么说,但是我们在写web server的时候,却恰恰recover了用户提供的
函数里面的panic:
<ul class="org-ul">
<li>net/http package提供的web server会把incoming request分发到用户提供的handler
function里面
</li>
<li>这种用户提供的handler function是不受控制的,用户可能写出runtime panic的程序,
当然也可以直接panic
</li>
<li>web server不会让用户handler里面的panic kill掉进程(我们是web server不能没事
就被kill),而是recover这个panic, 打印stack trace,并且继续server的服务
</li>
</ul>
</li>
<li>需要注意的是,这个特例是为了实践上的方便,但是它的确有泄露资源的风险,并且让failed
handler处在了一种unspecified的状态.可能会导致后续的错误.这也是为什么500的错
误总需要修复的原因
</li>
<li>说了这么多,recover最理想的用法是:recover那些panic本来就希望用户能够recover的
情况(这种情况不会多见).为了能够区分这些不多见的panic,我们可以为这些panic的情
况设计一些特别的type,作为panic的参数,也就是recover的返回值.我们可以通过检查
返回值的类型来决定这个recover的合理性:
<ul class="org-ul">
<li>如果recover返回值的类型的我们理想的,那么就返回错误来代替kill process
</li>
<li>否则,直接再次抛出panic+recover的返回值!记住不是简单的kill process,而是还原
原来的panic
</li>
</ul>
</li>
<li>下面的例子就是一个根据recover返回值类型来决定是否把panic降级为error的例子:判
断HTML文档是不是有两个&lt;title&gt; element(当然,从某种程度上来说,有两个&lt;title&gt;有
点类似expected error,这里我们是为了讲述用法,所以可能有些违背我们前面使用error
处理expected error的理念)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">soleTitle</span><span style="color: #2aa198;">(</span>doc *<span style="color: #b58900;">html.Node</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>title <span style="color: #b58900;">string</span>, err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">bailout</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #b58900;">{}</span>

        <span style="color: #859900; font-weight: bold;">defer</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">switch</span> p := <span style="color: #657b83; font-weight: bold;">recover</span><span style="color: #268bd2;">()</span>; p <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #268bd2; font-weight: bold;">nil</span>:
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">no panic</span>
                <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #b58900;">bailout</span><span style="color: #6c71c4;">{}</span>:
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"expected" panic</span>
                        err = fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"multiple title elements"</span><span style="color: #6c71c4;">)</span>
                <span style="color: #859900; font-weight: bold;">default</span>:
                        <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #6c71c4;">(</span>p<span style="color: #6c71c4;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">unexpected panic; carry on panicking</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}()</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Bail out of recursion if we find more than one non-empty title</span>
        <span style="color: #268bd2;">forEachNode</span><span style="color: #b58900;">(</span>doc, <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">(</span>n *<span style="color: #b58900;">html.Node</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span style="color: #2aa198;">"title"</span> &amp;&amp;
                        n.FirstChild != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #6c71c4;">{</span>
                        <span style="color: #859900; font-weight: bold;">if</span> title != <span style="color: #2aa198;">""</span> <span style="color: #859900;">{</span>
                                <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #b58900;">(</span><span style="color: #b58900;">bailout</span><span style="color: #268bd2;">{}</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">multiple title elements</span>
                        <span style="color: #859900;">}</span>
                        title = n.FirstChild.Data
                <span style="color: #6c71c4;">}</span>
        <span style="color: #268bd2;">}</span>, <span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> title == <span style="color: #2aa198;">""</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">""</span>, fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"no title element"</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> title, <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Chapter 06: Methods</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li>从1990年代开始,OOP就已经开始主导了programming 领域.Go也不例外
</li>
<li>从我们Go开发者的角度上讲, object其实就是一个value(或者varaible), 只不过这个value
是拥有method.
</li>
<li>method呢,其实是一种特殊的function, 只不过这个function和一个particular type相
关联.
</li>
<li>所谓OOP,其实就是用户通过'使用method来'表示data structure的property和operation.
而不需要直接访问data structure
</li>
</ul>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Method Declarations</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>前面说过了, method和function只有一处不同,就是和一个Type 相关联, Go的设计就让
这个关联体现在method的declare的时候(而不是像java一样写在class的定义处)
</li>
<li>下面第就是一个method的例子, 多出来的(p Point),就是method的receiver
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> geometry

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"math"</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Point</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #2aa198;">{</span> X, Y float64 <span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">traditional function</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Distance</span><span style="color: #2aa198;">(</span>p, q <span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> math.<span style="color: #268bd2;">Hypot</span><span style="color: #b58900;">(</span>q.X-p.X, q.Y-p.Y<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p <span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Distance</span><span style="color: #2aa198;">(</span>q <span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> math.<span style="color: #268bd2;">Hypot</span><span style="color: #b58900;">(</span>q.X-p.x, q.Y-p.Y<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>在Go里面,我们不使用一个特殊的变量(比如this或者self)来作为receiver,而是像其
他变量一样取一个name,因为这个receiver经常被使用,所以我们可以选择一个比较短
的变量名,一般是Type的第一个小写字母,这里就是p
</li>
<li>声明的时候,我们的receiver是在前面的,这是为了"映射"我们使用时候的情况,使用的
时候type也是在前面的
<div class="org-src-container">

<pre class="src src-go">p := <span style="color: #b58900;">Point</span><span style="color: #2aa198;">{</span>1, 2<span style="color: #2aa198;">}</span>
q := <span style="color: #b58900;">Point</span><span style="color: #2aa198;">{</span>4, 6<span style="color: #2aa198;">}</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">Distance</span><span style="color: #b58900;">(</span>p, q<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"5" function call</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>p.<span style="color: #268bd2;">Distance</span><span style="color: #b58900;">(</span>q<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"5", method call</span>
</pre>
</div>
</li>
<li>p.Distance是一个表达式,叫做selector.名字的来历是因为这个表达式select了type
Point的method Distance.因为selector也会被用在struct type的选择中,比如p.X,所
以,显然我们没办法定义一个名为X的method
</li>
<li>method的类型里面包含了type,所以不同的type可以看成是method的namespace,那么很
显然,不同的type可以拥有名字相同的method.所以我们的type Path也可以拥有一个叫
做Distance的函数
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A Path is a jorney connecting the points with straight lines.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Path</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">Point</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Distance returns the distance traveled along the path.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>path <span style="color: #b58900;">Path</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Distance</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        sum := 0.0
        <span style="color: #859900; font-weight: bold;">for</span> i := <span style="color: #859900; font-weight: bold;">range</span> path <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> i &gt; 0 <span style="color: #268bd2;">{</span>
                        sum += path<span style="color: #6c71c4;">[</span>i-1<span style="color: #6c71c4;">]</span>.<span style="color: #268bd2;">Distance</span><span style="color: #6c71c4;">(</span>path<span style="color: #859900;">[</span>i<span style="color: #859900;">]</span><span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> sum
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>Path说白了就是named slice type,不是像Point一样的struct类型,但是我们依然可以
为它定义method.和其他oo语言不同的是,Go允许method和任意类型相联系
</li>
<li>实践证明,为简单的类型(比如number, string, slice, map甚至是function)定义函数
是非常方便的,需要注意的是可以为本package里面所有的named type定义method,只要
这个named type其本质不是如下两种:
<ul class="org-ul">
<li>pointer类型
</li>
<li>interface类型
</li>
</ul>
</li>
<li>point和path都有Distance method,但是两者是完全不同的类型,虽然path.Distance内
部使用了point.Distance
</li>
<li>下面是一个使用path.Distance的例子,我们来计算一个三角形的边长
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"math"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Point</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #2aa198;">{</span> X, Y float64 <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p <span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Distance</span><span style="color: #2aa198;">(</span>q <span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> math.<span style="color: #268bd2;">Hypot</span><span style="color: #b58900;">(</span>q.X-p.X, q.Y-p.Y<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Path</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">Point</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>path <span style="color: #b58900;">Path</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Distance</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        sum := 0.0
        <span style="color: #859900; font-weight: bold;">for</span> i := <span style="color: #859900; font-weight: bold;">range</span> path <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> i &gt; 0 <span style="color: #268bd2;">{</span>
                        sum += path<span style="color: #6c71c4;">[</span>i-1<span style="color: #6c71c4;">]</span>.<span style="color: #268bd2;">Distance</span><span style="color: #6c71c4;">(</span>path<span style="color: #859900;">[</span>i<span style="color: #859900;">]</span><span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> sum
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        perim := <span style="color: #b58900;">Path</span><span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">{</span>1, 1<span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span>5, 1<span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span>5, 4<span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span>1, 1<span style="color: #268bd2;">}</span>,
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>perim.<span style="color: #268bd2;">Distance</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">12</span>
</pre>
</div>
</li>
<li>前面说过,不同的type里面可以有同名的method,但是相同的type里面肯定不能有同名的
method.而且method的类型里面是包括type的,所以不需要写出PathDistance这种函数名,
这里我们就引出了method相比于常规function的第一个优点:method的名字要短一点.
</li>
<li>当我们在package外面来调用的时候,method的优势会更大一点,因为它可以使用更短的
名字,并且不需要package name
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"gopl.io/ch6/geometry"</span>

perim := geometry.<span style="color: #b58900;">Path</span><span style="color: #2aa198;">{</span><span style="color: #b58900;">{</span>1, 1<span style="color: #b58900;">}</span>, <span style="color: #b58900;">{</span>5, 1<span style="color: #b58900;">}</span>, <span style="color: #b58900;">{</span>5, 4<span style="color: #b58900;">}</span>, <span style="color: #b58900;">{</span>1, 1<span style="color: #b58900;">}</span><span style="color: #2aa198;">}</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>geometry.<span style="color: #268bd2;">PathDistance</span><span style="color: #b58900;">(</span>perim<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"12", standalone function</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>perim.<span style="color: #268bd2;">Distance</span><span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>             <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"12", method of geometry.Path</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">Methods with a Pointer Receiver</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>因为function的调用,会copy每一个argument,所以如果出现下面两种情况,我们一般会选择
使用pointer参数:
<ul class="org-ul">
<li>函数的参数"过大",copy一次很耗费内存
</li>
<li>希望更改这个参数
</li>
</ul>
</li>
<li>我们可以把method的associated type看成是另外一个paramter,那么很明显,我们也需
要再遇到上述两种情况的时候,把associated type设置为pointer类型,比如
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p *<span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">ScaleBy</span><span style="color: #2aa198;">(</span>factor <span style="color: #b58900;">float64</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        p.X *= factor
        p.Y *= factor
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个method的名字就是(*Point).ScaleBy啦,这个括号是必须的如果没有括号,表达式会
被解析成*(Point.ScaleBy)
</li>
<li>使用Type作为method 的associated Type是常见现象,但是如果使用Pointer来作为method
的associated type,那么务必要要让所有的method都使用Pointer来作为associate type,
否则的话,使用(*Pointer).method_a之后,再使用(*Pointer).method_b发现不能调用,
是非常奇怪的行为.
<pre class="example">
In a realistic program, convention dictates that if any method
of Point has a pointer receiver, then all methods of Point should
have a pointer receiver, even ones that don't strictly need it!
</pre>
</li>
<li>当然了,我们这里一个Type,不同的method_a,method_b一会使用Type, 一会使用pointer,
是为了让我们学习两者区别
</li>
<li>在receiver declaration里面,只能出现named type(比如Pointer)或者pointer to named
type(比如*Pointer),为了避免误解,method declaration是不允许使用"自己本身是pointer
type"的named type的,比如
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">P</span> *<span style="color: #b58900;">int</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">p</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>  <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span> <span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: invalid receiver type</span>
</pre>
</div>
</li>
<li>(*Point).ScaleBy method在使用的时候,有如下几种方法:
<ul class="org-ul">
<li>提供一个*Point类型的receiver
<div class="org-src-container">

<pre class="src src-go">r := &amp;<span style="color: #b58900;">Pointer</span><span style="color: #2aa198;">{</span>1, 2<span style="color: #2aa198;">}</span>
r.<span style="color: #268bd2;">ScaleBy</span><span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>*r<span style="color: #2aa198;">)</span>                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"{2, 4}"</span>
</pre>
</div>
</li>
<li>提供一个Pointer类型变量, 然后取这个变量的地址,再调用
<div class="org-src-container">

<pre class="src src-go">p := <span style="color: #b58900;">Point</span><span style="color: #2aa198;">{</span>1, 2<span style="color: #2aa198;">}</span>
pptr := &amp;p
pptr.<span style="color: #268bd2;">ScaleBy</span><span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>p<span style="color: #2aa198;">)</span>                  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"{2, 4}"</span>
</pre>
</div>
</li>
<li>或者更干脆的使用(&amp;p)
<div class="org-src-container">

<pre class="src src-go">p := <span style="color: #b58900;">Point</span><span style="color: #2aa198;">{</span>1, 2<span style="color: #2aa198;">}</span>
<span style="color: #2aa198;">(</span>&amp;p<span style="color: #2aa198;">)</span>.<span style="color: #268bd2;">ScaleBy</span><span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>p<span style="color: #2aa198;">)</span>                  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"{2, 4}"</span>
</pre>
</div>
</li>
</ul>
</li>
<li>三种方法无一例外的都非常的麻烦,所以Go不得已做了一个语言级别的支持.那就是
<pre class="example">
       如果method的associated Type是*Point类型, 我们可以在使用的时候
       提供Point类型, 编译器(注意是编译器)会把Point类型变量p换成(&amp;p)
</pre>
</li>
<li>注意,这种方法的本质是加"取地址符&amp;", 所以只有有地址的类型,比如struct, array,
或者slice element(比如perim),如果一个receiver无法取得地址,那么是无法适用
的!比如下面的情况Point{1, 2}是一个struct literal,它是没有地址的,编译器就无能
为力
<div class="org-src-container">

<pre class="src src-go"><span style="color: #b58900;">Point</span><span style="color: #2aa198;">{</span>1, 2<span style="color: #2aa198;">}</span>.<span style="color: #268bd2;">ScaleBy</span><span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: can't take address ofPoint literal</span>
</pre>
</div>
</li>
<li>反之,如果我们定义的时候是associated type是普通Point类型,那么我们"总是"可以使
用*Point类型的instance的变量来调用它. 这是因为对于任意指针变量,我们总可以取
到它指向的地址里面的value.我们编译器每次帮我们插入(*)而已,只不过对于pointer
来说(*p)总成功(即便是Nil也没事, 后面会介绍)
</li>
<li>我们来总结一下所有的三种情况,因为它们很容易混淆:
<ul class="org-ul">
<li>情况1: receiver argument和receiver paramter拥有一样的类型(要么都是T,要么都
是*T),这种情况下编译器什么都不做
<div class="org-src-container">

<pre class="src src-go"><span style="color: #b58900;">Point</span><span style="color: #2aa198;">{</span>1, 2<span style="color: #2aa198;">}</span>.<span style="color: #268bd2;">Distance</span><span style="color: #2aa198;">(</span>q<span style="color: #2aa198;">)</span>         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Point</span>
pptr.<span style="color: #268bd2;">ScaleBy</span><span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">*Point</span>
</pre>
</div>
</li>
<li>情况2: receiver argument是类型T,而receiver parameter是类型*T.这种情况下编
译器要做取地址操作(只有有内存地址的varaible才能做这个操作,struct literal不可以)
<div class="org-src-container">

<pre class="src src-go">p.<span style="color: #268bd2;">ScaleBy</span><span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>                    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">implicit (&amp;p)</span>
</pre>
</div>
</li>
<li>情况3: receiver argument是类型*T, 而receiver 是类型T,这种情形编译器要做"引
用"(dereference)来获取地址里面的value(所有的地址都能获取value,nil也可以,所
有这个操作总能成功)
<div class="org-src-container">

<pre class="src src-go">pptr.<span style="color: #268bd2;">Distance</span><span style="color: #2aa198;">(</span>q<span style="color: #2aa198;">)</span>                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">implicit (*pptr)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>总结完毕,再来说说不同receiver parameter的具体情况, receiver paramter是定义时
候使用的类型.这个类型其实是相当于method的第"零"个参数
<ul class="org-ul">
<li>如果receiver parameter是类型T(不是*T),那么就意味着第零个参数在method每次调用的
时候,都会复制一遍.所以类型T的instance t是可以到处export(使用)的,因为即便
别人不小心调用了t的method,也不会对t造成影响.典型的例子是time.Duration,它
其实就是一个float64,因为所有的receiver type都是Duration.所以可以放心的到处
使用.设置是作为参数
<a href="https://play.golang.org/p/Ifqp5TccIy">https://play.golang.org/p/Ifqp5TccIy</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">display</span><span style="color: #2aa198;">(</span>inp <span style="color: #b58900;">time.Duration</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>inp<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #268bd2;">display</span><span style="color: #b58900;">(</span>23<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">23ns</span>
</pre>
</div>
</li>
<li>但是如果receiver parameter是pointer receiver的话,那么你就要避免把t到处拷贝
了.因为这个instance到了别的用户手里,一旦调用其method,有可能会更改instance
内部的状态
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1">Nil Is a Valid Receiver Value</h4>
<div class="outline-text-4" id="text-6-2-1">
<ul class="org-ul">
<li>有些function允许其pointer的paramter为nil,而method receiver其实就是一个参数
而已,所以method也肯定可以允许其receiver为nil. 特别是对于某些receiver type来
说,nil是其meaningful的zero value
</li>
<li>比如,下面的例子中nil的*IntList代表empty list.这种情况下,你需要在你的文档中
清晰的描述出nil可以作为receiver.如下.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">An IntList is a Linkedlist of integers.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A nil *IntList represents the empty list.</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">IntList</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Value int
        Tail *IntList
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Sum returns the sum of the list elements.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>list *<span style="color: #b58900;">IntList</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Sum</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> list == <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> 0
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> list.Value + list.Tail.<span style="color: #268bd2;">Sum</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们再来看看net/url package里面Values的例子
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> url

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Values maps a string key to a lit of values.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Values</span> <span style="color: #859900; font-weight: bold;">map</span><span style="color: #2aa198;">[</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">][]</span><span style="color: #b58900;">string</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Get returns the first value associated withe the given key,</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">or "" if there are none.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>v <span style="color: #b58900;">Values</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Get</span><span style="color: #2aa198;">(</span>key <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> vs := v<span style="color: #b58900;">[</span>key<span style="color: #b58900;">]</span>; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>vs<span style="color: #b58900;">)</span> &gt; 0 <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> vs<span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">""</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Add ads the values to key.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">It appends to any existing values associated with key.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>v <span style="color: #b58900;">Values</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Add</span><span style="color: #2aa198;">(</span>key, value <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        v<span style="color: #b58900;">[</span>key<span style="color: #b58900;">]</span> = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #b58900;">(</span>v<span style="color: #268bd2;">[</span>key<span style="color: #268bd2;">]</span>, value<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>对于Values来说,即便是nil也是一个合法的receiver(当Get的时候),当Add的时候就
会报panic错误了
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"net/url"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        m := url.<span style="color: #b58900;">Values</span><span style="color: #b58900;">{</span><span style="color: #2aa198;">"lang"</span>: <span style="color: #268bd2;">{</span><span style="color: #2aa198;">"en"</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">}</span>
        m.<span style="color: #268bd2;">Add</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"item"</span>, <span style="color: #2aa198;">"1"</span><span style="color: #b58900;">)</span>
        m.<span style="color: #268bd2;">Add</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"item"</span>, <span style="color: #2aa198;">"2"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>m.<span style="color: #268bd2;">Get</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"lang"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>m.<span style="color: #268bd2;">Get</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"q"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>m.<span style="color: #268bd2;">Get</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"item"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>m<span style="color: #268bd2;">[</span><span style="color: #2aa198;">"item"</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>
        m = <span style="color: #268bd2; font-weight: bold;">nil</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>m.<span style="color: #268bd2;">Get</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"item"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">/////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// panic: assignment to entry in nil map        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">m.Add("item", "3")                              //</span>
        <span style="color: #93a1a1;">/////////////////////////////////////////////////////</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"--------------------------"</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">en</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2]</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">--------------------------</span>
</pre>
</div>
</li>
<li>这里的url.Values是一个map type,所以url.Values.Add所做的操作立马就能被caller
发现,因为改变的是map指向的内容,我们map的地址并没有改变.我们method没有如下这
种功能
<div class="org-src-container">

<pre class="src src-go">m = <span style="color: #268bd2; font-weight: bold;">nil</span>
</pre>
</div>
</li>
<li>换句话说,如果我们有个一个method叫做url.Values.Dosomething来设置m为nil,是不
会成功的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>v <span style="color: #b58900;">Values</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Dosomething</span><span style="color: #2aa198;">(</span>key, value <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        v = <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">Composing Types by Struct Embedding</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>下例中的ColoredPoint, 我们本可以把ColoredPoint定义成三个field的struct,但是
我们没有这么做,而是把一个Point 嵌入到了ColoredPoint里面.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"image/color"</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Point</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #2aa198;">{</span>X, Y float64<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">ColoredPoint</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Point
        Color color.RGBA
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>embedding会让我们的ColoredPoint拥有Point所有的field,所以ColoredPoint使用Point
的field的时候还可以完全不"mention" Point
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> cp ColoredPoint
cp.X = 1
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>cp.Point.X<span style="color: #2aa198;">)</span>         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"1"</span>
cp.Point.Y = 2
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>cp.Y<span style="color: #2aa198;">)</span>               <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"2"</span>
</pre>
</div>
</li>
<li>不仅仅是field,在使用Point的method的问题上, ColoredPoint也是一点也不含糊.ColoredPoint
可以使用Point的所有method,即便ColoredPoint根本没有声明过它们.这个规则是和field一样的
<div class="org-src-container">

<pre class="src src-go">red := color.<span style="color: #b58900;">RGBA</span><span style="color: #2aa198;">{</span>255, 0, 0, 255<span style="color: #2aa198;">}</span>
blue := color.<span style="color: #b58900;">RGBA</span><span style="color: #2aa198;">{</span>0, 0, 255, 255<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">var</span> p = <span style="color: #b58900;">ColoredPoint</span><span style="color: #2aa198;">{</span><span style="color: #b58900;">Point</span><span style="color: #b58900;">{</span>1, 1<span style="color: #b58900;">}</span>, red<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">var</span> q = <span style="color: #b58900;">ColoredPoint</span><span style="color: #2aa198;">{</span><span style="color: #b58900;">Point</span><span style="color: #b58900;">{</span>5, 4<span style="color: #b58900;">}</span>, blue<span style="color: #2aa198;">}</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>p.<span style="color: #268bd2;">Distance</span><span style="color: #b58900;">(</span>q.Point<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"5"</span>
p.<span style="color: #268bd2;">ScaleBy</span><span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>
q.<span style="color: #268bd2;">ScaleBy</span><span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>p.<span style="color: #268bd2;">Distance</span><span style="color: #b58900;">(</span>q.Point<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"10"</span>
</pre>
</div>
</li>
<li>注意!这里ColoredPoint能够使用Point的method
<pre class="example">
并"不是"因为Point是ColoredPoint的base class, 而恰恰相反,
ColoredPoint "包含"了Point, 所以这里是一个 composition over inheritance
的例子!
</pre>
</li>
<li>从传统的oo语言来的读者可能会把Point看做是ColoredPoint的derived class,或者把
ColoredPoint看成是"is a" Point,但是这里其实不是!这里是ColoredPoint "has a"
Point
</li>
<li>这里编译器其实帮助我们实现了两个wrapper函数,让我们的p可以直接调用Distance,而
不需要p.Point.Distance()
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p <span style="color: #b58900;">ColoredPoint</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Distance</span><span style="color: #2aa198;">(</span>q <span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> p.Point.<span style="color: #268bd2;">Distance</span><span style="color: #b58900;">(</span>q<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p *<span style="color: #b58900;">ColoredPoint</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">ScaleBy</span><span style="color: #2aa198;">(</span>factor <span style="color: #b58900;">float64</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        p.Point.<span style="color: #268bd2;">ScaleBy</span><span style="color: #b58900;">(</span>factor<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>当Point.Distance被调用的时候(如上),它的receiver不是p,而是p.Point,所以p.Point
是不会有机会接触到ColoredPoint的
</li>
<li>匿名field也可以是pointer to a named type.这种情况下,pointer指向的named type
的所有的field和method也会被"收编",例子如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">ColoredPoint</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        *Point
        Color color.RGBA
<span style="color: #2aa198;">}</span>

p := <span style="color: #b58900;">ColoredPoint</span><span style="color: #2aa198;">{</span>&amp;<span style="color: #b58900;">Point</span><span style="color: #b58900;">{</span>1, 1<span style="color: #b58900;">}</span>, red<span style="color: #2aa198;">}</span>
q := <span style="color: #b58900;">ColoredPoint</span><span style="color: #2aa198;">{</span>&amp;<span style="color: #b58900;">Point</span><span style="color: #b58900;">{</span>5, 4<span style="color: #b58900;">}</span>, blue<span style="color: #2aa198;">}</span>

fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>p.<span style="color: #268bd2;">Distance</span><span style="color: #b58900;">(</span>*q.Point<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5</span>
q.Point = p.Point                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">p and q now share the same Point</span>
p.<span style="color: #268bd2;">ScaleBy</span><span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>*p.Point, *q.Point<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"{2 2} {2 2}"</span>
</pre>
</div>
</li>
<li>一个struct还可以有多个匿名field,比如
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">ColoredPoint</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Point
        color.RGBA
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这样一来,新的类型instance就拥有:
<ul class="org-ul">
<li>所有Point的函数
</li>
<li>所有color.RGBA的函数
</li>
<li>所有后来定义在ColoredPoint上面的函数
</li>
</ul>
</li>
<li>method是有类型的funciton,这个类型必须是named type(比如Point),或者是pointer
to named type(*Point),但是由于有embedding,我们可以让unnamed struct type拥有
method
</li>
<li>下面是一个常规的例子:我们使用package level变量mutex来保护一个map
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #2aa198;">(</span>
        mu sync.Mutex
        mapping = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Lookup</span><span style="color: #2aa198;">(</span>key <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        mu.<span style="color: #268bd2;">Lock</span><span style="color: #b58900;">()</span>
        v := mapping<span style="color: #b58900;">[</span>key<span style="color: #b58900;">]</span>
        mu.<span style="color: #268bd2;">Unlock</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">return</span> v
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>下例和上例在功能上相同,但是却巧妙的借助匿名field让unnamed struct(cache)也有
了method
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> cache = <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        sync.Mutex
        mapping <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">string</span><span style="color: #b58900;">]</span><span style="color: #b58900;">string</span>
<span style="color: #2aa198;">}</span> <span style="color: #2aa198;">{</span>

        <span style="color: #268bd2; font-weight: bold;">mapping</span>: <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">)</span>,
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Lookup</span><span style="color: #2aa198;">(</span>key <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        cache.<span style="color: #268bd2;">Lock</span><span style="color: #b58900;">()</span>
        v := cache.mapping<span style="color: #b58900;">[</span>key<span style="color: #b58900;">]</span>
        cache.<span style="color: #268bd2;">Unlock</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">return</span> v
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">Method Values and Expressions</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>一般来说,我们都是1select method然后马上2call method,比如p.Distance(), 但因
为在go里面function是first class citizen. 和function实质一样的method其实也是
"first-class object",也可以被存储起来作为变量(method value), 之后这个变量调
用的时候,就不需要receiver信息了(因为receiver其实是method的第0个参数)
<div class="org-src-container">

<pre class="src src-go">p := <span style="color: #b58900;">Point</span><span style="color: #2aa198;">{</span>1, 2<span style="color: #2aa198;">}</span>
q := <span style="color: #b58900;">Point</span><span style="color: #2aa198;">{</span>4, 6<span style="color: #2aa198;">}</span>

distanceFromP := p.Distance     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">method value</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">distanceFromP</span><span style="color: #b58900;">(</span>q<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"5"</span>
<span style="color: #859900; font-weight: bold;">var</span> origin Point                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{0, 0}</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">distanceFromP</span><span style="color: #b58900;">(</span>origin<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"2.236..."</span>
</pre>
</div>
</li>
<li>method value对如下情况非常有用:package API需要一个function value,普通的function
value当然能够满足要求,比如time.AfterFunc第二个参数为function value,第一个参
数设置多久后调用第二个参数:
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        fv := <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"display"</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">AfterFunc waits for the duration to elapse and then calls f</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">in its own goroutine. It returns a Timer that can</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">be used to cancel the call using its Stop method.</span>

        timer := time.<span style="color: #268bd2;">AfterFunc</span><span style="color: #b58900;">(</span>3*time.Second, fv<span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">defer</span> timer.<span style="color: #268bd2;">Stop</span><span style="color: #b58900;">()</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">So we have to sleep at least 4 seconds to see AfterFunc's goroutine to run</span>

        time.<span style="color: #268bd2;">Sleep</span><span style="color: #b58900;">(</span>4 * time.Second<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">display</span>
</pre>
</div>
</li>
<li>但是如果不是普通函数,而是一个method的情况下,如果没有method value,写法是这样的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Rocket</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span><span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">*/</span><span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>r *<span style="color: #b58900;">Rocket</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Launch</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span><span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">*/</span><span style="color: #2aa198;">}</span>

r := <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Rocket</span><span style="color: #2aa198;">)</span>
time.<span style="color: #268bd2;">AfterFunc</span><span style="color: #2aa198;">(</span>10 * time.Second, <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>r.<span style="color: #268bd2;">Launch</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>拥有method value的写法是这样的
<div class="org-src-container">

<pre class="src src-go">time.<span style="color: #268bd2;">AfterFunc</span><span style="color: #2aa198;">(</span>10 * time.Second, r.Launch<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>和method value相对的是method expression. 这个"对立"是对在"对象上":
<ul class="org-ul">
<li>对于method value来说,其instance是已经指定了的
</li>
<li>而对于method expression来说,其仅仅制定了receiver Type,具体使用哪个instance
还需要在"使用的时候",把receiver放成第一个参数.这再次证明了method的type就是
其第零个参数
<a href="https://play.golang.org/p/9RcF9JYoAR">https://play.golang.org/p/9RcF9JYoAR</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"math"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Point</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #2aa198;">{</span> X, Y float64 <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p <span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Distance</span><span style="color: #2aa198;">(</span>q <span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> math.<span style="color: #268bd2;">Hypot</span><span style="color: #b58900;">(</span>q.X-p.X, q.Y-p.Y<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        p := <span style="color: #b58900;">Point</span><span style="color: #b58900;">{</span>1, 2<span style="color: #b58900;">}</span>
        q := <span style="color: #b58900;">Point</span><span style="color: #b58900;">{</span>4, 6<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>p.<span style="color: #268bd2;">Distance</span><span style="color: #268bd2;">(</span>q<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        distance := Point.Distance
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">distance</span><span style="color: #268bd2;">(</span>p, q<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, Point.Distance<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">func(main.Point, main.Point) float64</span>
</pre>
</div>
</li>
</ul>
</li>
<li>Method expression在如下情况时候非常有用:需要使用value来代表method中的一个,但
是instance还没有确定(调用的时候才确定,作为method expression的第一个参数)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Point</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #2aa198;">{</span> X, Y float64 <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p <span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Add</span><span style="color: #2aa198;">(</span>q <span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">Point</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">Point</span><span style="color: #b58900;">{</span>p.X + q.X, p.Y + q.Y<span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p <span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Sub</span><span style="color: #2aa198;">(</span>q <span style="color: #b58900;">Point</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">Point</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">Point</span><span style="color: #b58900;">{</span>p.X - q.X, p.Y - q.Y<span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Path</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">Point</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>path <span style="color: #b58900;">Path</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">TranslateBy</span><span style="color: #2aa198;">(</span>offset <span style="color: #b58900;">Point</span>, add <span style="color: #b58900;">bool</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> op <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">(</span>p, q <span style="color: #b58900;">Point</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">Point</span>
        <span style="color: #859900; font-weight: bold;">if</span> add <span style="color: #b58900;">{</span>
                op = Point.Add
        <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
                op = Point.Sub
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> i := <span style="color: #859900; font-weight: bold;">range</span> path <span style="color: #b58900;">{</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Call either path[i].Add(offset) or path[i].Sub(offset).</span>
                path<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span> = <span style="color: #268bd2;">op</span><span style="color: #268bd2;">(</span>path<span style="color: #6c71c4;">[</span>i<span style="color: #6c71c4;">]</span>, offset<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        paths := <span style="color: #b58900;">Path</span><span style="color: #b58900;">{</span><span style="color: #b58900;">Point</span><span style="color: #268bd2;">{</span>1, 2<span style="color: #268bd2;">}</span>, <span style="color: #b58900;">Point</span><span style="color: #268bd2;">{</span>2, 4<span style="color: #268bd2;">}</span><span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>paths<span style="color: #b58900;">)</span>
        paths.<span style="color: #268bd2;">TranslateBy</span><span style="color: #b58900;">(</span><span style="color: #b58900;">Point</span><span style="color: #268bd2;">{</span>1, 1<span style="color: #268bd2;">}</span>, <span style="color: #268bd2; font-weight: bold;">true</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>paths<span style="color: #b58900;">)</span>
        paths.<span style="color: #268bd2;">TranslateBy</span><span style="color: #b58900;">(</span><span style="color: #b58900;">Point</span><span style="color: #268bd2;">{</span>1, 1<span style="color: #268bd2;">}</span>, <span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>paths<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[{1 2} {2 4}]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[{2 3} {3 5}]</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[{1 2} {2 4}]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5">Example: Bit Vector Type</h3>
<div class="outline-text-3" id="text-6-5">
<ul class="org-ul">
<li>在Go里面,并没有专门的set类型,我们一般使用map[T]bool类型来替代set,这种方式非
常的灵活,但是有时候我们需要效率更加高的set,也就是常说的bit vector(使用一个bit
的1或者0来替代bool,而set的值则都数值不大的'正整数')
</li>
<li>下面就是我们使用golang来实现的bit vector
<a href="https://play.golang.org/p/gNSsBvrF6T">https://play.golang.org/p/gNSsBvrF6T</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"bytes"</span>
        <span style="color: #2aa198;">"fmt"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">An IntSet is a set of small non-negative integers.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Its zero value represents the empty set.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">IntSet</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        words <span style="color: #b58900;">[]</span><span style="color: #b58900;">uint64</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Has reports whether the set contains the non-negative value x.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>s *<span style="color: #b58900;">IntSet</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Has</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        word, bit := x/64, <span style="color: #268bd2;">uint</span><span style="color: #b58900;">(</span>x%64<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> word &lt; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>s.words<span style="color: #b58900;">)</span> &amp;&amp; s.words<span style="color: #b58900;">[</span>word<span style="color: #b58900;">]</span>&amp;<span style="color: #b58900;">(</span>1&lt;&lt;bit<span style="color: #b58900;">)</span> != 0
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Add adds the non-negative value x to the set.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>s *<span style="color: #b58900;">IntSet</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Add</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        word, bit := x/64, <span style="color: #268bd2;">uint</span><span style="color: #b58900;">(</span>x%64<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> word &gt;= <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>s.words<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                s.words = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #268bd2;">(</span>s.words, 0<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        s.words<span style="color: #b58900;">[</span>word<span style="color: #b58900;">]</span> |= 1 &lt;&lt; bit
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">UnionWith sets s to the union of s and t.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>s *<span style="color: #b58900;">IntSet</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">UnionWith</span><span style="color: #2aa198;">(</span>t *<span style="color: #b58900;">IntSet</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> i, tword := <span style="color: #859900; font-weight: bold;">range</span> t.words <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> i &lt; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>s.words<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        s.words<span style="color: #6c71c4;">[</span>i<span style="color: #6c71c4;">]</span> |= tword
                <span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #268bd2;">{</span>
                        s.words = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #6c71c4;">(</span>s.words, tword<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">String returns the set as a string of the form "{1 2 3}".</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>s *<span style="color: #b58900;">IntSet</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">String</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> buf bytes.Buffer
        buf.<span style="color: #268bd2;">WriteByte</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">'{'</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> i, word := <span style="color: #859900; font-weight: bold;">range</span> s.words <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> word == 0 <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">continue</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #859900; font-weight: bold;">for</span> j := 0; j &lt; 64; j++ <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">if</span> word&amp;<span style="color: #6c71c4;">(</span>1&lt;&lt;<span style="color: #268bd2;">uint</span><span style="color: #859900;">(</span>j<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span> != 0 <span style="color: #6c71c4;">{</span>
                                <span style="color: #859900; font-weight: bold;">if</span> buf.<span style="color: #268bd2;">Len</span><span style="color: #859900;">()</span> &gt; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #859900;">(</span><span style="color: #2aa198;">"{"</span><span style="color: #859900;">)</span> <span style="color: #859900;">{</span>
                                        buf.<span style="color: #268bd2;">WriteByte</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">' '</span><span style="color: #b58900;">)</span>
                                <span style="color: #859900;">}</span>
                                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #859900;">(</span>&amp;buf, <span style="color: #2aa198;">"%d"</span>, 64*i+j<span style="color: #859900;">)</span>
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        buf.<span style="color: #268bd2;">WriteByte</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">'}'</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> buf.<span style="color: #268bd2;">String</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> x, y IntSet
        x.<span style="color: #268bd2;">Add</span><span style="color: #b58900;">(</span>1<span style="color: #b58900;">)</span>
        x.<span style="color: #268bd2;">Add</span><span style="color: #b58900;">(</span>144<span style="color: #b58900;">)</span>
        x.<span style="color: #268bd2;">Add</span><span style="color: #b58900;">(</span>9<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x.<span style="color: #268bd2;">String</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>

        y.<span style="color: #268bd2;">Add</span><span style="color: #b58900;">(</span>9<span style="color: #b58900;">)</span>
        y.<span style="color: #268bd2;">Add</span><span style="color: #b58900;">(</span>42<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>y.<span style="color: #268bd2;">String</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>

        x.<span style="color: #268bd2;">UnionWith</span><span style="color: #b58900;">(</span>&amp;y<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x.<span style="color: #268bd2;">String</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x.<span style="color: #268bd2;">Has</span><span style="color: #268bd2;">(</span>9<span style="color: #268bd2;">)</span>, x.<span style="color: #268bd2;">Has</span><span style="color: #268bd2;">(</span>123<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{1 9 144}</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{9 42}</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{1 9 42 144}</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true false</span>
</pre>
</div>
</li>
<li>我们使用一个slice的unsigned integer来存储我们所有的bit(注意前面说过,不是没
有负数才使用unsigned integer,而是这种bitmap的情况才会使用unsigned integer)
</li>
<li>我们的uint64 slice是连续的内存空间,从slice第一个bit开始,第i个bit为1就表示
第ith个正整数在bit vector里面
</li>
<li>因为我们slice里面的每个成员都是64bit的,所以为了找到某个正整数x是否在bit vector
里面:
<ul class="org-ul">
<li>我们要使用x/64来确定它可能在slice的哪个index里面
</li>
<li>我们要使用x%64来确定是否在特定slice成员的某个bit上
</li>
</ul>
</li>
<li>UnionWith实现的是一个bitmap的 OR操作
</li>
<li>注意,我们实现了String函数,后面我们会看到实现了如下interface的函数,fmt都会特别对待
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Stringer</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">String</span><span style="color: #b58900;">()</span> string
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这里有一个陷阱:为了和其他的函数一致,我们把method String()的receiver也定义成
了*IntSet的.这导致我们的fmt其实只能对*IntSet自动调用String().如果不注意这一
点,fmt的结果可能会很奇怪
<div class="org-src-container">

<pre class="src src-go">fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>&amp;x<span style="color: #2aa198;">)</span>         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{1 9 42 144}</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>x.<span style="color: #268bd2;">String</span><span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{1 9 42 144}</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>x<span style="color: #2aa198;">)</span>          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{[4398046511618 0 65536]}</span>
</pre>
</div>
</li>
<li>第一句fmt会自动调用instance的String()函数
</li>
<li>第二句x虽然不是*IntSet类型,但是编译器会自动加上取地址符给x,这就变成了(&amp;x).String()
</li>
<li>第三句,因为x不是*IntSet类型,而IntSet类型也没有String(),所以fmt就打印了其struct
内部的String()
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6">Encapsulation</h3>
<div class="outline-text-3" id="text-6-6">
<ul class="org-ul">
<li>我们使用过一个object的时候,如果这个object的某些variable和method是我们无法接
触(inaccessible)到的,那么我们就说这个object是封装好的(encapsulated).继承,封
装,多肽是oo编程的三大法宝
</li>
<li>我们前面说过,一个package里面的name是否能够被package外面看到,取决于这个name的
首字母是不是大写
</li>
<li>同样的规则适用于:一个struct里面的name是否能够被struct外面看到,取决于这个name的
首字母是不是大写
</li>
<li>struct的这个特性可以让我们在go里面去封装object:所有不想被外人看到的,作为struct
里面的首字母小写的变量
</li>
<li>这也是为什么前面的IntSet例子中,我们的IntSet其实只有一个单独的[]uint64类型的
域,我们还是要给它"造"一个struct.因为这样完美的对data进行了封装!
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">IntSet</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        words <span style="color: #b58900;">[]</span><span style="color: #b58900;">uint64</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>如果不考虑封装性,我们可以写出实际上完全等价的另外一个版本
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">IntSet</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">uint64</span>
</pre>
</div>
</li>
<li>但是这个版本的问题在于没有封装代表内部状态的data,其他package的client可以随便
读取"并改动"这个slice!
</li>
<li>另外一个特别重要的区别是,无论是package还是struct也好,以首字母来判断是否对"外"
封装的这个方法.里面用来判断"外"的机制不同,在Go看来,本package都是"里",只有其
他package才算外!而其他语言一般是以type为界限的:
<ul class="org-ul">
<li>在Go里面,本package可以方便的访问private的data
<a href="https://play.golang.org/p/MA0489_jNs">https://play.golang.org/p/MA0489_jNs</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">test</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #2aa198;">{</span> x int <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        t := <span style="color: #b58900;">test</span><span style="color: #b58900;">{</span>23<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>t.x<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">23</span>
</pre>
</div>
</li>
<li>在Cpp里面,只有type自己可以访问自己的private data
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;

<span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">Test</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">x</span>;
<span style="color: #859900; font-weight: bold;">private</span>:
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">y</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">Test</span> <span style="color: #268bd2;">t</span>;
    t.x = 23;
    cout &lt;&lt; t.x &lt;&lt; endl;
    <span style="color: #93a1a1;">////////////////////////////////////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// /Users/hfeng/tmp/main.cc:16:7: error: 'y' is a private member of 'Test' //</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">t.y = 24;                                                                  //</span>
    <span style="color: #93a1a1;">////////////////////////////////////////////////////////////////////////////////</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">23</span>
</pre>
</div>
</li>
</ul>
</li>
<li>OO语言(包括Go)并不是反对exported field,而是说一旦这个field export了以后,就不
能改动了,考虑到未来可能出现的变化,真正需要exported 一个field的情况并不是特别多.
</li>
<li>其中一个情况就是time.Duration,通过把time.Duration(实质是一个int64)给export
出来,我们可以把所有对于int64可行的操作,都用在time.Duration上面,减轻了很多的负担
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Duration</span> <span style="color: #b58900;">int64</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #2aa198;">(</span>
        minDuration Duration = -1 &lt;&lt; 63
        maxDuration Duration = 1&lt;&lt;63 - 1
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Common durations. There is no definition for units of Day or larger</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">to avoid confusion across daylight savings time zone transitions.</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">To count the number of units in a Duration, divide:</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">second := time.Second</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">fmt.Print(int64(second/time.Millisecond)) // prints 1000</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">To convert an integer number of units to a Duration, multiply:</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">seconds := 10</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #2aa198;">(</span>
        Nanosecond  Duration = 1
        Microsecond          = 1000 * Nanosecond
        Millisecond          = 1000 * Microsecond
        Second               = 1000 * Millisecond
        Minute               = 60 * Second
        Hour                 = 60 * Minute
<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>使用方法如下
<a href="https://play.golang.org/p/5dCFcdCTR_">https://play.golang.org/p/5dCFcdCTR_</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> day = 24 * time.Hour
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>day.<span style="color: #268bd2;">Seconds</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">86400</span>
</pre>
</div>
</li>
<li>我们前面还有两个例子:
<ul class="org-ul">
<li>一个是没有使用封装的Path
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Path</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">Point</span>
</pre>
</div>
</li>

<li>另外一个是使用了封装的IntSet
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">IntSet</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        words <span style="color: #b58900;">[]</span><span style="color: #b58900;">uint64</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>对于Path来说,我们所有对slice可行的操作,都能对Path来进行,但是对于IntSet来说,
因为加了struct,系统无法识别出来其内部只有一个slice,所以append等操作都是无法
直接运用在IntSet上面的
</li>
<li>而对于IntSet来说,它也有优点,就是内部现在是使用了uint64,但是我们以后可以选择
新的其他的类型来表示,内部实现的改动不会影响到已有代码
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Chapter 07: Interfaces</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>interface 类型表示了其他类型的一种"抽象"和"概括", 总结起来就是: inteface的存
在,让我们的function更加的flexible和adaptble,因为interface不和特定的implementation
相关
</li>
<li>很多OO语言都有interface,但是go的interface是一种叫做"暗自符合(satisfied
implicitly)"的方式存在的,换句话说
<pre class="example">
go并没有必要"显式"的声明一个concrete type符合哪些interface,
只要你有相应的函数,你就"自动"符合某个interface
</pre>
</li>
<li>这种设计带来一个极大的便利:你可以创建一个新的interface, 而已经存在的concrete
type自动的就"符合"了这个interface的要求,但是我们不需要去更改这个concrete type
对于定义在lib里面的我们无法更改的concrete type, 新定义一个interface,lib就能
适应,那是非常美妙的!
</li>
</ul>
</div>
<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Interfaces as Contracts</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>我们前面所有的类型都是concrete type.它们的特点是:
<ul class="org-ul">
<li>列出了自己内部的exact的value, 以及自己支持的operation
</li>
<li>提供一系列的method,可以使用这些method来操作自己的类型
</li>
</ul>
</li>
<li>一旦你拥有了一个concrete type你就非常准确的知道它是什么,以及它可以做什么
</li>
<li>我们这里要介绍的,就是interface type了, 它和concrete type相比,其只展现了第二
个部分,就是method,而且还不是全部的method,只是类型一部分的method.如果你拥有
一个interface type,你只能知道它"至少能做什么",而对它内部,则一无所知
</li>
<li>我们整本书都在使用两个函数fmt.Printf把拼接好的字符串写到standord output, 另
外一个是fmt.Sprintf:把拼接好的字符串返回.这两个函数其实最麻烦的地方(也是功能
相同的地方),就是拼接字符串. DRY原则要求我们最好不要重复书写.而golang源代码里
面就把这部分'共同的逻辑'写在了第三个函数fmt.Fprintf里面, 而这个函数的第一个参
数io.Writer,就是一个interface
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> fmt

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Fprintf</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">io.Writer</span>, format <span style="color: #b58900;">string</span>, args ...<span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Printf</span><span style="color: #2aa198;">(</span>format <span style="color: #b58900;">string</span>, args ...<span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)(</span><span style="color: #b58900;">int</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>os.Stdout, format, args...<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Sprintf</span><span style="color: #2aa198;">(</span>format <span style="color: #b58900;">string</span>, args ...<span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> buf bytes.Buffer
        <span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>&amp;buf, format, args...<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> buf.<span style="color: #268bd2;">String</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个Fprintf里面的F代表文件,意思是这个函数要把结果写入到一个file里面:
<ul class="org-ul">
<li>在Printf的例子里面, 我们直接把结果写入到了os.Stdout(是一个*os.File类型)里
面, 可见*os.File是符合io.Writer interface的.借助godoc,我们得到
<pre class="example">
func (f *File) Write(b []byte) (n int, err error)
    Write writes len(b) bytes to the File. It returns the number of bytes
    written and an error, if any. Write returns a non-nil error when n !=
    len(b).
</pre>
</li>
<li>在Sprintf里面, 传递给Fprintf的是&amp;buf, 这是一个指向memoery buffer的pointer,
专门传递指针,可见这个buffer pointer才是符合io.Writer interface的,借助godoc
我们得到
<pre class="example">
func (b *Buffer) Write(p []byte) (n int, err error)
    Write appends the contents of p to the buffer, growing the buffer as
    needed. The return value n is the length of p; err is always nil. If the
    buffer becomes too large, Write will panic with ErrTooLarge.
</pre>
</li>
</ul>
</li>

<li>Fprintf的第一个参数就是我们的主角:io.Writer interface,它的声明如下.我们后面
说的"形如"Write()函数,仅仅样子像就可以,功能满足comment里面的要求逻辑上更好,
不满足编译器也不可能报错!
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> io

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Writer is the interface that wraps the basic Write method</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Writer</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Write writes len(p) bytes from p to the underlying data stream</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">It returns the numer of bytes written from p  (0 &lt;= n &lt;= len(p))</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">and any error encountered that caused the write to stop early.</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Write must return a non-nil error if it retuns n &lt; len(p).</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Write must not modify the slice data, even temporarily.</span>
        <span style="color: #93a1a1;">//</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Implementations must not retain p.</span>
        <span style="color: #268bd2;">Write</span><span style="color: #b58900;">(</span>p <span style="color: #268bd2;">[]</span><span style="color: #b58900;">byte</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">(</span>n int, err error<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>io.Writer interface就是在Fprintf和它的caller之间创建了一个"合同"(contract),
这个合同规定了双方的责任:
<ul class="org-ul">
<li>caller保证:调用Fprintf的时候,第一个参数T一定要有形如Write(p []byte)的method
</li>
<li>而被调用者Fprintf保证:只要你提供了形如Write(p []byte)的method,我就能满足你
的调用要求
</li>
</ul>
</li>
<li>简言之,就是一旦一个type,它有一个和Write(p []byte) (n int, err error)的声明样
式一样的函数,那么,我们就可以使用这个type来作为参数输入.
</li>
<li>这种不同情况下我们的类型类型判断变得更加的自由:判断不是严格的安装编译器要求,
而是按照某些method是否存在而的判断!这种自由叫做可替换性(substitutability),可
替换下也是OO编程的标志
</li>
<li>比如我们可以让我们的新类型ByteCounter(其实就是int)也符合io.Writer
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">ByteCounter</span> <span style="color: #b58900;">int</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>c *<span style="color: #b58900;">ByteCounter</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Write</span><span style="color: #2aa198;">(</span>p <span style="color: #b58900;">[]</span><span style="color: #b58900;">byte</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        *c += <span style="color: #268bd2;">ByteCounter</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>p<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>p<span style="color: #b58900;">)</span>, <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>既然我们的*ByteCounter也满足io.Writer,我们当然可以传递给Fprintf,只不过我们
的Write()没有把p真正的写入到underlying stream(我们也没underlying stream)里面,
只不过是返回了"需要写入的长度"
<a href="https://play.golang.org/p/skf76y-70D">https://play.golang.org/p/skf76y-70D</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">ByteCounter</span> <span style="color: #b58900;">int</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>c *<span style="color: #b58900;">ByteCounter</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Write</span><span style="color: #2aa198;">(</span>p <span style="color: #b58900;">[]</span><span style="color: #b58900;">byte</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        *c += <span style="color: #268bd2;">ByteCounter</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>p<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>p<span style="color: #b58900;">)</span>, <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #859900; font-weight: bold;">var</span> c ByteCounter

        c.<span style="color: #268bd2;">Write</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"hello"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>c<span style="color: #b58900;">)</span>

        c = 0 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">reset the counter</span>
        <span style="color: #859900; font-weight: bold;">var</span> name = <span style="color: #2aa198;">"Dolly"</span>
        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>&amp;c, <span style="color: #2aa198;">"hello, %s"</span>, name<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>c<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">len("hello, Dolly")</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">12</span>
</pre>
</div>
</li>
<li>除了io.Writer,另外一个对fmt来说更加重要的interface就是Stringer,它决定了某个
类型在打印的时候的格式.在其他语言比如Java中,这个函数叫做toString().在其他语
言里面(比如java),interface是要显示的写名的,所以不可能为了打印写一个interface
让没给类型implement.而Go是implicit implement,所以它也为字符串打印写了这么一
个interface.我们已经多次用到过这个interface了
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> fmt

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The String method is use dto print values passed</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">as an operand to any format that accepts a string</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">or to an unformatted printer such as Print.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Stringer</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">String</span><span style="color: #b58900;">()</span> string
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">Interface Types</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>所谓的Interface Type,是指:一个concrete type如果想被认为是某个interface的instance
的话,它必须要拥有的method
</li>
<li>io.Writer类型是最常用的interface,因为它提供了一种抽象,在这个抽象下面, byte
可以写入各种类型的介质,比如文件, network connection等等
</li>
<li>io package下面还定义了很多有用的interface,比如io.Reader,这个interface表示了
你可以从各种类型介质里面"读取"byte. Closer是你可以"关闭"这种类型的介质(使用
er也是Go对接口的命名规范)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> io
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Reader</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Read</span><span style="color: #b58900;">(</span>p <span style="color: #268bd2;">[]</span><span style="color: #b58900;">byte</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">(</span>n int, err error<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Closer</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span> error
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们还可以把两个interface包裹起来,形成一个新的interface
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">ReadWriter</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        Reader
        Writer
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">ReadWriteCloser</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        Reader
        Writer
        Closer
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>上面的表述方法其实就等同于如下,只是写起来不够简洁.需要注意的是interface里面
method出现的顺序不重要的,只要有这些个method就可以了
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">ReadWriter</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Read</span><span style="color: #b58900;">(</span>p <span style="color: #268bd2;">[]</span><span style="color: #b58900;">byte</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">(</span>n int, err error<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">Write</span><span style="color: #b58900;">(</span>p <span style="color: #268bd2;">[]</span><span style="color: #b58900;">byte</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">(</span>n int, err error<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">mixture of the two style</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">ReadWriter</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Read</span><span style="color: #b58900;">(</span>p <span style="color: #268bd2;">[]</span><span style="color: #b58900;">byte</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">(</span>n int, err error<span style="color: #b58900;">)</span>
        Writer
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">Interface Satisfaction</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>在Go里面,我们说一个concrete type "is a" particular interface type,意思就是
说这个concrete type"暴露"了某个interface所需要的所有的method.比如我们可以说
<pre class="example">
*bytes.Buffer is an io.Writer
</pre>
</li>
<li>一旦一个expression "is a" interface,那么它就可以assigned to 一个interface
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> w io.Writer

w = os.Stdout                   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">OK: *os.File has Write method</span>
w = <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">bytes.Buffer</span><span style="color: #2aa198;">)</span>           <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">OK: *bytes.Buffer has Write method</span>
w = time.Second                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: time.Duration lacks Write method</span>

<span style="color: #859900; font-weight: bold;">var</span> rwc io.ReadWriteCloser
rwc = os.Stdout                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">OK: *os.File has Read, Write, Close methods</span>
rwc = <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">bytes.Buffer</span><span style="color: #2aa198;">)</span>         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: *bytes.Buffer lacks Close method</span>
</pre>
</div>
</li>
<li>这里说的是一旦一个expression "is a" interface.expression的范围很广,不仅仅instance
是expression,我们的interface本身,也是expression.所以
<div class="org-src-container">

<pre class="src src-go">w = rwc                         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">OK: io.ReadWriteCloser has Write method</span>
rwc = w                         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">compile error: io.Writer lacks Close method</span>
</pre>
</div>
</li>
<li>一个值得注意的是,一个type拥有哪些method和它的*type拥有的method并不是共享的,
虽然一个*type拥有了methodA, type可以在编译器的帮助下自动加(&amp;),但这是编译器
的syntactic sugar.某个类型的method还是和定义时候到底选择的type还是*type密切
相关的.比如我们前面的IntSet就没有实现Stringer,是*IntSet实现了Stringer
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">IntSet</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        words <span style="color: #b58900;">[]</span><span style="color: #b58900;">uint64</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>*<span style="color: #b58900;">IntSet</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">String</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">""</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> s IntSet
        <span style="color: #859900; font-weight: bold;">var</span> _ fmt.Stringer = &amp;s
        <span style="color: #93a1a1;">///////////////////////////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// cannot use s (type IntSet) as type fmt.Stringer in assignment:                     //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// IntSet does not implement fmt.Stringer (String method has pointer receiver)        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">var _ fmt.Stringer = s                                                                //</span>
        <span style="color: #93a1a1;">///////////////////////////////////////////////////////////////////////////////////////////</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>还有一种特殊的interface叫做interface{},就是这个interface不要求暴露"任何的
method", 这种interface叫做empty interface type. 因为不需要暴露任何method,所
以所有的type都"符合"empty interface type的要求.
<pre class="example">
We can assign any value to the empty interface
</pre>
</li>
<li>虽然没有明说,但是我们从第一天开始就使用interface{}啦,因为fmt.Println里面能打
印任意的类型,就是因为它的参赛就是interface{}
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>a ...<span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>n <span style="color: #b58900;">int</span>, err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">Fprintln</span><span style="color: #b58900;">(</span>os.Stdout, a...<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>当然了,interface{}只能负责"接受"这些实参.真正使用的时候,我们还是要确认这些
个实参真实的类型,这个时候就要使用type assertion了.换句话说,interface{}总是
和type assertion联合起来起作用的
</li>
<li>因为interface只是和type的method有关系,所以在创建concrete type的时候,由于自己
还不知道自己的method有哪些,所以不可能把自己能够实现的interface在定义的时候
就列出来.但是定义完之后,如果我们真的想使用程序来检查我们的Buffer有没有实现
io.Writer,我们可以写出如下的强制检查语句
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">*bytes.Buffer must satisfy io.Writer</span>
<span style="color: #859900; font-weight: bold;">var</span> w io.Writer = <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">bytes.Buffer</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>上面的强制语句有些复杂,我们可以'简化'一下:
<ul class="org-ul">
<li>我们不必使用new来创建一个新的变量,太浪费.因为即便是*bytes.Buffer的zero值,
也就是nil,也是可以创建一个变量的,而且还不用浪费地址存储
</li>
<li>我们只是用来检查concrete type时候真的实现interface的,所以我们上面的变量w
其实是多余的,我们不会去使用他.可以使用blank identifier来代替
</li>
</ul>
</li>
<li>总结上面两点,我们可以总结出一个新的写法
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">*bytes.Buffer must satisfy io.Writer</span>
<span style="color: #859900; font-weight: bold;">var</span> _ io.Writer = <span style="color: #2aa198;">(</span>*bytes.Buffer<span style="color: #2aa198;">)(</span><span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>非空的interce,比如io.Writer在绝大多数的情况下都是由pointer type(特别是pointer
to struct)实现的.这一点很重要.因为pointer type意味着更大的灵活性(比如可以更
改receiver).
</li>
<li>但是说绝大多数情况,也就是还有例外:
<ul class="org-ul">
<li>小部分情况下Go的reference type也是可以实现很多interface的,比如slice, map,
甚至是function类型,都有可能实现interface
</li>
<li>basic type(无pointer)也是可以满足interface的,只不过不是很常见.因为使用basic
type来做method type的情况就不多.已有的例子是time.Duration实现了fmt.Stringer
godoc结果如下
<pre class="example">
func (d Duration) String() string
    String returns a string representing the duration in the form
    "72h3m0.5s". Leading zero units are omitted. As a special case,
    durations less than one second format use a smaller unit (milli-,
    micro-, or nanoseconds) to ensure that the leading digit is non-zero.
    The zero duration formats as 0s.
</pre>
</li>
</ul>
</li>
<li>一个concrete type可能满足很多不相关的interface,这些不相关的interface其实代表
了对这些concrete type的分类.比如下面的例子,一个在线电子商店(比如amazon)可能
会给自己定义如下的concrete type
<pre class="example">
Album
Book
Movie
Magazine
Podcast
TVEpiosode
Track
</pre>
</li>
<li>我们可以抽出这些concrete type的一些共同点(在程序里面,共同点就是他们实现的一
组函数),来组成一些interface
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Artifact</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Title</span><span style="color: #b58900;">()</span> string
        <span style="color: #268bd2;">Creators</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>
        <span style="color: #268bd2;">Created</span><span style="color: #b58900;">()</span> time.Time
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Text</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Pages</span><span style="color: #b58900;">()</span> int
        <span style="color: #268bd2;">Words</span><span style="color: #b58900;">()</span> int
        <span style="color: #268bd2;">PageSize</span><span style="color: #b58900;">()</span> int
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Audio</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Stream</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">(</span>io.ReadCloser, error<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">RunningTime</span><span style="color: #b58900;">()</span> time.Duration
        <span style="color: #268bd2;">Format</span><span style="color: #b58900;">()</span> string         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">e.g. "MP3"</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Video</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Stream</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">(</span>io.ReadCloser, error<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">RunningTime</span><span style="color: #b58900;">()</span> time.Duration
        <span style="color: #268bd2;">Format</span><span style="color: #b58900;">()</span> string
        <span style="color: #268bd2;">Resolution</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">(</span>x, y int<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>在分组的过程中,我们会发现"视频"和"音频"有很多共同点,我们可以抽出一些新的interface
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Streamer</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Stream</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">(</span>io.ReadCloser, error<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">RunningTime</span><span style="color: #b58900;">()</span> time.Duration
        <span style="color: #268bd2;">Format</span><span style="color: #b58900;">()</span> string
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>和其他语言不通,Go的interface满足是通过implicit的,这种方式更容易设计一些接口
让"其他package(不是我们能改动)"来implements,因为不需要改动"其他pacakge"的代
码就能完成
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4">Parsing Flags with flag.Value</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li>我们先来看一个使用standard interface(flag.Value)的例子
<a href="https://play.golang.org/p/8TN7JVNSKd">https://play.golang.org/p/8TN7JVNSKd</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"flag"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">var</span> period = flag.<span style="color: #268bd2;">Duration</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"period"</span>, 1*time.Second, <span style="color: #2aa198;">"sleep period"</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        flag.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Sleeping for %v...\n"</span>, *period<span style="color: #b58900;">)</span>
        time.<span style="color: #268bd2;">Sleep</span><span style="color: #b58900;">(</span>*period<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Sleeping for 1s...</span>
</pre>
</div>
</li>
<li>这个例子在没有输入任何-period的情况下,默认的停顿一秒了. 我们记得前面的flag.Bool
的例子,所以我们在使用的时候,默认的想法是传入一个int64值,因为time.Duration
本身就是一个int64, 使用"="赋值也能确认这一点
<a href="https://play.golang.org/p/kV2jqbA4DP">https://play.golang.org/p/kV2jqbA4DP</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> t time.Duration
        t = 123
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>t<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">var</span> i int64
        i = 123
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>i<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">123ns</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">123</span>
</pre>
</div>
</li>
<li>但是我们带着以往的经验,给period一个int值的时候,发现是错误的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"flag"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">var</span> period = flag.<span style="color: #268bd2;">Duration</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"period"</span>, 1*time.Second, <span style="color: #2aa198;">"sleep period"</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        flag.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Sleeping for %v...\n"</span>, *period<span style="color: #b58900;">)</span>
        time.<span style="color: #268bd2;">Sleep</span><span style="color: #b58900;">(</span>*period<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt; go run main.go -period 2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">invalid value "2" for flag -period: time: missing unit in duration 2</span>
</pre>
</div>
</li>
<li>而如下的几种设置却可以通过(最后一种不行,使用了双引号),这说明,在flag里面
time.Duration和int64肯定是做了不同的处理
<pre class="example">
$ ./sleep -period 50ms
Sleeping for 50ms...
$ ./sleep -period 2m30s
Sleeping for 2m30s...
$ ./sleep -period 1.5h
Sleeping for 1h30m0s...
$ ./sleep -period "1 day"
invalid value "1 day" for flag -period: time: invalid duration 1 day
</pre>
</li>
<li>通过查找源代码,我们发现了原因:
<ul class="org-ul">
<li>在flag package里面,所有的类型都会被type成'另外的类型'.也就是我们常说的"一人千面"
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-- time.Duration Value</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">durationValue</span> <span style="color: #b58900;">time.Duration</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-- int64 Value</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">int64Value</span> <span style="color: #b58900;">int64</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-- string Value</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">stringValue</span> <span style="color: #b58900;">string</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">....</span>
</pre>
</div>
</li>
<li>type成'另外的类型'以后,这个'另外的类型'需要满足如下的一个interface,也就是
实现两个函数
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Value is the interface to the dynamic value stored in a flag.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">(The default value is represented as a string.)</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">If a Value has an IsBoolFlag() bool method returning true,</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">the command-line parser makes -name equivalent to -name=true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">rather than using the next command-line argument.</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Set is called once, in command line order, for each flag present.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Value</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">String</span><span style="color: #b58900;">()</span> string
        <span style="color: #268bd2;">Set</span><span style="color: #b58900;">(</span>string<span style="color: #b58900;">)</span> error
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>int64和time.Duration实现Set()的时候,方法是不同的,导致flag package设置的时
候需要有不同的输入
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>i *<span style="color: #b58900;">int64Value</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Set</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        v, err := strconv.<span style="color: #268bd2;">ParseInt</span><span style="color: #b58900;">(</span>s, 0, 64<span style="color: #b58900;">)</span>
        *i = <span style="color: #268bd2;">int64Value</span><span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> err
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>d *<span style="color: #b58900;">durationValue</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Set</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        v, err := time.<span style="color: #268bd2;">ParseDuration</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">diff int64 here!</span>
        *d = <span style="color: #268bd2;">durationValue</span><span style="color: #b58900;">(</span>v<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> err
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>通过这个例子,我们学习到了flag对于interface的精妙应用(当然更精妙的是type"一
人千面"的设计):只要能够满足String()和Set()两个函数,就可以被parse.
</li>
<li>这也就提供了更重要的一点意义:我们可以扩展flag来分析"用户定义类型",比如Celsius:
<ul class="org-ul">
<li>首先type一个'新的类型'
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+celsiusFlag</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">*celsiusFlag satisfies the flag.Value interface.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">celsiusFlag</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #2aa198;">{</span> Celsius <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>'新的类型'实现这两个函数(从而实现interface),注意上面的例子是使用struct来
包裹Celsius,从而直接拥有String()函数,所以这里只实现Set()
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>f *<span style="color: #b58900;">celsiusFlag</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Set</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> unit string
        <span style="color: #859900; font-weight: bold;">var</span> value float64
        fmt.<span style="color: #268bd2;">Sscanf</span><span style="color: #b58900;">(</span>s, <span style="color: #2aa198;">"%f%s"</span>, &amp;value, &amp;unit<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">no error check needed</span>
        <span style="color: #859900; font-weight: bold;">switch</span> unit <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">"C"</span>, <span style="color: #2aa198;">"&#176;C"</span>:
                f.Celsius = <span style="color: #268bd2;">Celsius</span><span style="color: #268bd2;">(</span>value<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">"F"</span>, <span style="color: #2aa198;">"&#176;F"</span>:
                f.Celsius = <span style="color: #268bd2;">FToC</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">Fahrenheit</span><span style="color: #6c71c4;">(</span>value<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"invalid temperature %q"</span>, s<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>使用的时候,就可以直接flag
<a href="https://play.golang.org/p/b4xEjEl3z0">https://play.golang.org/p/b4xEjEl3z0</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Tempflag prints the value of its -temp (temperature) flag.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"flag"</span>
        <span style="color: #2aa198;">"fmt"</span>

        <span style="color: #2aa198;">"gopl.io/ch7/tempconv"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">var</span> temp = tempconv.<span style="color: #268bd2;">CelsiusFlag</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"temp"</span>, 20.0, <span style="color: #2aa198;">"the temperature"</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        flag.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>*temp<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt; go run tempflag.go  -temp -18C</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-18&#176;C</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt; go run tempflag.go  -temp 212&#176;F</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100&#176;C</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt; go run tempflag.go  -temp 212F</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100&#176;C</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5">Interface Values</h3>
<div class="outline-text-3" id="text-7-5">
<ul class="org-ul">
<li>任何一个类型的变量都有其value值,而且在没有明确初始化值的情况下,这个变量会有
一个zero值
</li>
<li>interface看成是一种类型的话,interface类型的变量也是要有其值的,这个值叫做
interface value,就好像我们有int value, bool value一样
</li>
<li>interface value和int value(bool value)不一样的地方,在于它在内存中存储的时候,
要有两个部分：
<ul class="org-ul">
<li>dynamic type: 实际满足interface的concrete type是哪个,因为会有很多种concrete
type都会满足统一interface,所以单独列出一个内存区域来存储这个concrete type
是必须的这个部分在内存里面的大小应该是固定的,它只需要存储能够唯一标识concrete
type的字符串即可
<pre class="example">
         在statically typed 语言里面,type是一个compile-time的概念,type不是value,所以
         我们前面说的dynamic type部分里面存储的不能是一个value,而更应该看成是一个存储
         类型名字的字符串.这个字符串能够唯一的定义这个类型就可以了(包括它的名字和method)
         我们下面的例子中,type部分都是使用这个字符串(为了简单,只有name)来表示的,希望
         你理解,这只是一个conceptual model,在内存中并不是真的这么存的.
</pre>
</li>
<li>dynamic value: 根据dynamic type的不同,会分配不同大小的内存来存储value
</li>
</ul>
</li>
<li>我们以下面的这个例子来介绍一下interface value的"概念上的(conceptual)内存布局",
首先总体上来说一说,下面四句话,w共有三个不同的value(第一个和最后一个都是nil)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> w io.Writer
w = os.Stdout
w = <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">bytes.Buffer</span><span style="color: #2aa198;">)</span>
w = <span style="color: #268bd2; font-weight: bold;">nil</span>
</pre>
</div>
</li>
<li>第一句创建io.Writer interface的value w, 因为没有赋值,所以这个时候不知道我们
和哪个concrete type联系上了,所以type是没有名字的,所以是nil(如果我们把这个
conceptual的type想成是string的话,""也是可以的), 所以w也是zero value,
其内存情况如下
<pre class="example">
            w
      +------------+
type  |    nil     |
      +------------+
value |    nil     |
      +------------+
</pre>
</li>
<li>第二句,把一个concrete 类型为*os.File类型的变量(os.Stdout返回值为*os.File)赋
值给w, w的type部分(名字)就是*os.File, value部分是一个指针(因为类型就是一个指
针,那么留给value的肯定只能够放一个指针),指向value值-&gt;指向os.Stdout(类型为os.File)
<pre class="example">
            w
      +------------+
type  |  *os.File  |                      os.File
      +------------+                  +---------------------+
value |     .      |-----------------&gt;|  fd int = 1(stdout) |
      +------------+                  +---------------------+
</pre>
</li>
<li>在第二句赋值完之后,我们是可以调用如下的代码的(因为能赋值成功,说明我们的*os.File
肯定有Write()函数啊)
<div class="org-src-container">

<pre class="src src-go">w.<span style="color: #268bd2;">Write</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"hello"</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"hello"</span>
</pre>
</div>
</li>
<li>w是一个interface type, 无法直接调用Write,所以编译器会生成一段代码,所以上面
的代码会被编译器"改成"如下代码
<div class="org-src-container">

<pre class="src src-go">os.Stdout.<span style="color: #268bd2;">Write</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"hello"</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"hello"</span>
</pre>
</div>
</li>
<li>第三句,w被赋予了*bytes.Buffer类型的值,所以type里面的name就是*bytes.Buffer,
value里面还是一个指针(留给它的空间还是只能是一个指针),其value值-&gt;指向某块内存,
这块内存的类型我bytes.Buffer 其内存模型为
<pre class="example">
            w
      +-------------+
type  |*bytes.Buffer|                     bytes.Buffer
      +-------------+                 +---------------------+
value |     .       |----------------&gt;|                     |
      +-------------+                 +---------------------+
</pre>
</li>
<li>最后一句又把w赋值为zero value,内存模型和第一个一致
</li>
<li>我们的例子刚好value都是pointer类型,其实value值可以是"任何类型",如果不是pointer
类型,而是一个type的话,那么value的内存大小就是type一个值的大小, 也就是说go还
是会存储它们全部!这就是值语义语言的执着,比如下面的语句中的x
<a href="https://play.golang.org/p/qde6sSUv2d">https://play.golang.org/p/qde6sSUv2d</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #859900; font-weight: bold;">var</span> x <span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span> = time.<span style="color: #268bd2;">Now</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017-02-10 14:49:00.369942821 +0800 CST</span>
</pre>
</div>
</li>
<li>x的内存分布如下(注意,这只是conceptual model)
<pre class="example">
                     x
          +---------------------------------+
type      |     time.Time                   |
          |                                 |
          +---------------------------------+
          |+------------------------------+ |
 value    ||    sec: 65567389742          | |
          |+------------------------------+ |
          ||    nsec: 689632918           | |
          |+------------------------------+ |
          ||    loc: "UTC"                | |
          |+------------------------------+ |
          +---------------------------------+
</pre>
</li>
<li>interface value是可以通过==和!=来相互比较的(再次证明了interface value不是一
个reference type).两个interface value相等的条件:
<ul class="org-ul">
<li>两个都是nil
</li>
<li>两个的dynamic type使用==相比较结果为true,而且两个的dynamic value使用==比
较结果为true
</li>
</ul>
</li>
<li>正是因为interface value是comparable的(使用==,!=可以比较),所以他们都可以作为
map里面的key,也可以作为switch statement里面的operand
</li>
<li>但是interface value的比较具有一个特殊的地方,那就是如果interface value的dynamic
type一样,但是dynamic type之间是不能比较的话,那么强制比较会产生panic
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> x <span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span> = <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2, 3<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">///////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// panic: runtime error: comparing uncomparable type []int        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Println(x == x)                                               //</span>
        <span style="color: #93a1a1;">///////////////////////////////////////////////////////////////////////</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[1 2 3]</span>
</pre>
</div>
</li>
<li>在这个方面,interface type是特殊的,因为其他类型要么可以安全的比较(比如basic
type和pointer),要么完全不能比较.所以比较interface type(包括包含interface value
的aggregate type)的时候,一定要注意潜在panic可能发生
</li>
<li>上面的这些信息都是"概念性"的, 并非真是真的内存布局,而interface value的信息
则真的是可以通过fmt里面的%T来取得dynamic type, 而fmt能够实现这个的原因是其
使用了reflection机制
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
    <span style="color: #2aa198;">"bytes"</span>
    <span style="color: #2aa198;">"fmt"</span>
    <span style="color: #2aa198;">"io"</span>
    <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> w io.Writer
    fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, w<span style="color: #b58900;">)</span>

    w = os.Stdout
    fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, w<span style="color: #b58900;">)</span>

    w = <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #b58900;">(</span><span style="color: #b58900;">bytes.Buffer</span><span style="color: #b58900;">)</span>
    fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, w<span style="color: #b58900;">)</span>

<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;nil&gt;                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">*os.File                                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">*bytes.Buffer                                  //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-7-5-1" class="outline-4">
<h4 id="sec-7-5-1">Caveat: An Interface Containing a Nil Pointer Is Non-Nil</h4>
<div class="outline-text-4" id="text-7-5-1">
<ul class="org-ul">
<li>如下两个interface是不相同的:
<ul class="org-ul">
<li>nil interface value: type和value都是nil,前面讲过
</li>
<li>interface value 包括一个正好为nil的pointer: value是nil, type不是nil!
</li>
</ul>
</li>
<li>下面这个例子中,debug为true当然可以正常工作,但是一旦debug为false,就无法正常
工作了
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"bytes"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"io"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">const</span> debug = <span style="color: #268bd2; font-weight: bold;">true</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">const debug = false  // will panic with following errors</span>
<span style="color: #93a1a1;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panic: runtime error: invalid memory address or nil pointer dereference //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[signal 0xb code=0x1 addr=0x68 pc=0x57410]                              //</span>
<span style="color: #93a1a1;">//                                                                         </span><span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">goroutine 1 [running]:                                                  //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">bytes.(*Buffer).Write(0x0, 0xc82000a370, 0x5, 0x8, 0x5, 0x0, 0x0)       //</span>
<span style="color: #93a1a1;">/////////////////////////////////////////////////////////////////////////////</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> buf *bytes.Buffer
        <span style="color: #859900; font-weight: bold;">if</span> debug <span style="color: #b58900;">{</span>
                buf = <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">bytes.Buffer</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #268bd2;">f</span><span style="color: #b58900;">(</span>buf<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">(</span>out <span style="color: #b58900;">io.Writer</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Have a assignment here!!</span>
        <span style="color: #859900; font-weight: bold;">if</span> out != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                out.<span style="color: #268bd2;">Write</span><span style="color: #268bd2;">(</span><span style="color: #6c71c4;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"done!"</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>out<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">done!</span>
</pre>
</div>
</li>
<li>这是因为f(p)的调用中, p会有一次赋值的过程,这个过程就类型于如下代码
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> buf *bytes.Buffer       <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">concrete type</span>
out = buf                   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">out is interface with dynamic type is *bytes.Buffer and dynamic type is nil</span>
</pre>
</div>
</li>
<li>这样一来, out就是我们说的"interface containing a Nil Pointer", 它"不等于" nil!!!
</li>
<li>我们来探求一下这个错误的根源:
<ul class="org-ul">
<li>根源一: interface value是"值",而不是reference
</li>
<li>根源二: interface value的赋值要求很低,只要你的value实现了接口A,就可以赋
值给interface A value
</li>
<li>根源三: interface value很容易接受一个nil pointer,但是由于外面还有一层
interface,所以它本身不是nil, 它的内存分布是这样的(type也为nil,才是nil)
<pre class="example">
            w
      +-------------+
type  |*bytes.Buffer|
      +-------------+
value |     nil     |
      +-------------+
</pre>
</li>
</ul>
</li>
<li>这段代码正常的写法,是把buf本身就设置成interface value(如果不赋值的话type就
是nil)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> buf io.Writer
<span style="color: #859900; font-weight: bold;">if</span> debug <span style="color: #2aa198;">{</span>
        buf = <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #b58900;">(</span><span style="color: #b58900;">bytes.Buffer</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">enable collection of output</span>
<span style="color: #2aa198;">}</span>
<span style="color: #268bd2;">f</span><span style="color: #2aa198;">(</span>buf<span style="color: #2aa198;">)</span>                          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">OK</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6">Sorting with sort.Interface</h3>
<div class="outline-text-3" id="text-7-6">
<ul class="org-ul">
<li>golang 的sort package提供了in-place的排序功能,排序的原则是ordering function
提供的. 这一点是和传统的语言里面差不多的结构
</li>
<li>但是golang不一样的地方在于其ording function不再是要求具体的类型, 而只是要求
interface(行为)就可以了,换句话说,要求"想利用sort功能的type"实现如下一个
interface(sort.Interface)就可以了.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> sort

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Interface</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Len</span><span style="color: #b58900;">()</span> int
        <span style="color: #268bd2;">Less</span><span style="color: #b58900;">(</span>i, j int<span style="color: #b58900;">)</span> bool <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">i, j are indices of sequence elements</span>
        <span style="color: #268bd2;">Swap</span><span style="color: #b58900;">(</span>i, j int<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>需要注意的是, "想利用sort功能"的type,一般来说都"实质上是slice类型"(当然了type
可以做到一人千面)的,而Less比较的,则是这个slice类型里面的"两个item"的大小.比
如下面例子中的byte
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">StringSlice</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p <span style="color: #b58900;">StringSlice</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Len</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>p<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p <span style="color: #b58900;">StringSlice</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Less</span><span style="color: #2aa198;">(</span>i, j <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> p<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span> &lt; p<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span>
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p <span style="color: #b58900;">StringSlice</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Swap</span><span style="color: #2aa198;">(</span>i, j <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        p<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>, p<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span> = p<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span>, p<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>有了上面的代码,我们在排序StringSlice的时候就简单多了
<div class="org-src-container">

<pre class="src src-go">sort.<span style="color: #268bd2;">Sort</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">StringSlice</span><span style="color: #b58900;">(</span>names<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>排列strings数组的需求非常常用,以至于sort package直接提供了sort.Strings(stringslice)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"sort"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        s := <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">{</span><span style="color: #2aa198;">"hijk"</span>, <span style="color: #2aa198;">"lm"</span>, <span style="color: #2aa198;">"a"</span>, <span style="color: #2aa198;">"o"</span>, <span style="color: #2aa198;">"b"</span>, <span style="color: #2aa198;">"cd"</span>, <span style="color: #2aa198;">"efg"</span><span style="color: #b58900;">}</span>
        sort.<span style="color: #268bd2;">Strings</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[a b cd efg hijk lm o]</span>
</pre>
</div>
</li>
<li>如果看看源代码,就会发现,其实sort.String就是通过StringSlice实现的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Strings sorts a slice of strings in increasing order.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Strings</span><span style="color: #2aa198;">(</span>a <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span> <span style="color: #268bd2;">Sort</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">StringSlice</span><span style="color: #268bd2;">(</span>a<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>更多复杂的情况下,就需要我们的type,自己去实现sort.Interface,好看下面的一个复
杂的例子:
<ul class="org-ul">
<li>首先看type,是一个播放列表中的一个item
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Track</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Title string
        Artist string
        Album string
        Year int
        Length time.Duration
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>再看看我们的slice如何写:这里是有窍门的,我们没有使用'值'数组,而是使用了'指
针'数组.因为存储的是指针,所以swap的时候能够极大的减小消耗(指针大小的内存
swap,最多64bit,而一个Track则是一个多word的值).从这里我们可以看到java的"引
用"语义是有意义的,因为可以极大的提高效率.但是Go做的更好,你可以自己来选择
是使用'值'语义还是'引用'语义
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> tracks = <span style="color: #2aa198;">[]</span>*<span style="color: #b58900;">Track</span><span style="color: #2aa198;">{</span>
        <span style="color: #b58900;">{</span><span style="color: #2aa198;">"Go"</span>, <span style="color: #2aa198;">"Delilah"</span>, <span style="color: #2aa198;">"From the Roots Up"</span>, 2012, <span style="color: #268bd2;">length</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"3m38s"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">}</span>,
        <span style="color: #b58900;">{</span><span style="color: #2aa198;">"Go"</span>, <span style="color: #2aa198;">"Moby"</span>, <span style="color: #2aa198;">"Moby"</span>, 1992, <span style="color: #268bd2;">length</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"3m37s"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">}</span>,
        <span style="color: #b58900;">{</span><span style="color: #2aa198;">"Go Ahead"</span>, <span style="color: #2aa198;">"Alicia Keys"</span>, <span style="color: #2aa198;">"As I Am"</span>, 2007, <span style="color: #268bd2;">length</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"4m36s"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">}</span>,
        <span style="color: #b58900;">{</span><span style="color: #2aa198;">"Ready 2 Go"</span>, <span style="color: #2aa198;">"Martin Solveig"</span>, <span style="color: #2aa198;">"Smash"</span>, 2011, <span style="color: #268bd2;">length</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"4m24s"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">}</span>,
<span style="color: #2aa198;">}</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#20351;&#29992;&#19979;&#38754;&#30340;&#20195;&#30721;&#26469;&#36827;&#34892;&#38271;&#24230;&#32479;&#35745;</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">length</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">time.Duration</span> <span style="color: #2aa198;">{</span>
        d, err := time.<span style="color: #268bd2;">ParseDuration</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #268bd2;">(</span>s<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> d
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们可以使用golang提供的tabwriter来更好的格式化代码
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">printTracks</span><span style="color: #2aa198;">(</span>tracks <span style="color: #b58900;">[]</span>*<span style="color: #b58900;">Track</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> format = <span style="color: #2aa198;">"%v\t%v\t%v\t%v\t%v\t\n"</span>
        tw := <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #b58900;">(</span><span style="color: #b58900;">tabwriter.Writer</span><span style="color: #b58900;">)</span>.<span style="color: #268bd2;">Init</span><span style="color: #b58900;">(</span>os.Stdout, 0, 8, 2, <span style="color: #2aa198;">' '</span>, 0<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>tw, format, <span style="color: #2aa198;">"Title"</span>, <span style="color: #2aa198;">"Artist"</span>, <span style="color: #2aa198;">"Album"</span>, <span style="color: #2aa198;">"Year"</span>, <span style="color: #2aa198;">"Length"</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #b58900;">(</span>tw, format, <span style="color: #2aa198;">"-----"</span>, <span style="color: #2aa198;">"------"</span>, <span style="color: #2aa198;">"-----"</span>, <span style="color: #2aa198;">"----"</span>, <span style="color: #2aa198;">"------"</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, t := <span style="color: #859900; font-weight: bold;">range</span> tracks <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        tw.<span style="color: #268bd2;">Flush</span><span style="color: #b58900;">()</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">calculate column widths and print table</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>为了能够sort by Artist field,我们还得必须申请一个新的类型,然后让这个类型
实现sort.Interface接口
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">byArtist</span> <span style="color: #2aa198;">[]</span>*<span style="color: #b58900;">Track</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>x <span style="color: #b58900;">byArtist</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Len</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">int</span>           <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>x <span style="color: #b58900;">byArtist</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Less</span><span style="color: #2aa198;">(</span>i, j <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> x<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>.Artist &lt; x<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span>.Artist <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>x <span style="color: #b58900;">byArtist</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Swap</span><span style="color: #2aa198;">(</span>i, j <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>      <span style="color: #2aa198;">{</span> x<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>, x<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span> = x<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span>, x<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>然后就可以调用了
<div class="org-src-container">

<pre class="src src-go">sort.<span style="color: #268bd2;">Sort</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">byArtist</span><span style="color: #b58900;">(</span>tracks<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">printTracks</span><span style="color: #2aa198;">(</span>tracks<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Title       Artist          Album              Year  Length</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-----       ------          -----              ----  ------</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Go Ahead    Alicia Keys     As I Am            2007  4m36s</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Go          Delilah         From the Roots Up  2012  3m38s</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Ready 2 Go  Martin Solveig  Smash              2011  4m24s</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Go          Moby            Moby               1992  3m37s</span>
</pre>
</div>
</li>
<li>sort package还设计了非常好的"反转"特性
<div class="org-src-container">

<pre class="src src-go">sort.<span style="color: #268bd2;">Sort</span><span style="color: #2aa198;">(</span>sort.<span style="color: #268bd2;">Reverse</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">byArtist</span><span style="color: #268bd2;">(</span>tracks<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Title       Artist          Album              Year  Length</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-----       ------          -----              ----  ------</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Go          Moby            Moby               1992  3m37s</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Ready 2 Go  Martin Solveig  Smash              2011  4m24s</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Go          Delilah         From the Roots Up  2012  3m38s</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Go Ahead    Alicia Keys     As I Am            2007  4m36s</span>
</pre>
</div>
</li>
<li>这个"反转"的写法值得我们关注,因为它使用了composition.sort定义了一个不export
的type reverse,这个type只包含sort.Interface,初始化的时候,只需要给reverse{}
传入data就可以了.所有data的数据都会给reverse,然后我们再重新实现Less
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> sort

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">reverse</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #2aa198;">{</span> Interface <span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">that is, sort.Interface</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>r <span style="color: #b58900;">reverse</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Less</span><span style="color: #2aa198;">(</span>i, j <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> r.Interface.<span style="color: #268bd2;">Less</span><span style="color: #b58900;">(</span>j, i<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Reverse</span><span style="color: #2aa198;">(</span>data <span style="color: #b58900;">Interface</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">Interface</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">reverse</span><span style="color: #b58900;">{</span>data<span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>如果我们想再按照year来排序,需要再次创建一个类型
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">byYear</span> <span style="color: #2aa198;">[]</span>*<span style="color: #b58900;">Track</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>x <span style="color: #b58900;">byYear</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Len</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">int</span>           <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>x <span style="color: #b58900;">byYear</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Less</span><span style="color: #2aa198;">(</span>i, j <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> x<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>.Year &lt; x<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span>.Year <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>x <span style="color: #b58900;">byYear</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Swap</span><span style="color: #2aa198;">(</span>i, j <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>      <span style="color: #2aa198;">{</span> x<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>, x<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span> = x<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span>, x<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span> <span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Title       Artist          Album              Year  Length</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">-----       ------          -----              ----  ------</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Go          Moby            Moby               1992  3m37s</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Go Ahead    Alicia Keys     As I Am            2007  4m36s</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Ready 2 Go  Martin Solveig  Smash              2011  4m24s</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Go          Delilah         From the Roots Up  2012  3m38s</span>
</pre>
</div>
</li>
<li>如果看看我们byArtist还有byYear的代码,我们就会发现Len()和Swap()代码是相同的
如果我们想要满足DRY原则,我们需要一种新的设计类型的形式: Less设计成function
value: 通过function传入逻辑.而不改动的逻辑,直接作为类型的method
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">customSort</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        t    <span style="color: #b58900;">[]</span>*<span style="color: #b58900;">Track</span>
        less <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">(</span>x, y *<span style="color: #b58900;">Track</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">bool</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>x <span style="color: #b58900;">customSort</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Len</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">int</span>           <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>x.t<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>x <span style="color: #b58900;">customSort</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Less</span><span style="color: #2aa198;">(</span>i, j <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> x.<span style="color: #268bd2;">less</span><span style="color: #b58900;">(</span>x.t<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span>, xt<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>x <span style="color: #b58900;">customSort</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Swap</span><span style="color: #2aa198;">(</span>i, j <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>      <span style="color: #2aa198;">{</span> x.t<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>, x.t<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span> = x.t<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>, x.t<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>排序的logic放在一个匿名函数中传入
<div class="org-src-container">

<pre class="src src-go">sort.<span style="color: #268bd2;">Sort</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">customSort</span><span style="color: #b58900;">(</span>tracks, <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">(</span>x, y *<span style="color: #b58900;">Track</span><span style="color: #268bd2;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> x.Title != y.Title <span style="color: #6c71c4;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> x.Title &lt; y.Title
        <span style="color: #6c71c4;">}</span>
        <span style="color: #859900; font-weight: bold;">if</span> x.Year != y.Year <span style="color: #6c71c4;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> x.Year &lt; y.Year
        <span style="color: #6c71c4;">}</span>
        <span style="color: #859900; font-weight: bold;">if</span> x.Length != y.Length <span style="color: #6c71c4;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> x.Length &lt; y.Length
        <span style="color: #6c71c4;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>
<span style="color: #268bd2;">}</span><span style="color: #657b83; background-color: #fdf6e3;">}</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>最后的最后,我们来看看sort package提供的IsSorted function.判断某个sequence是
否是sorted的复杂度是O(N-1),比排序的复杂度(NlogN)要低很多.有些时候会有用.对于
int, float等没有实现sort.Interface的prime类型,sort也提供了IntsAreSorted等"变
体"
<a href="https://play.golang.org/p/kCCgj9e9hq">https://play.golang.org/p/kCCgj9e9hq</a>
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"sort"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">StringSlice</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p <span style="color: #b58900;">StringSlice</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Len</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>p<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p <span style="color: #b58900;">StringSlice</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Less</span><span style="color: #2aa198;">(</span>i, j <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> p<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span> &lt; p<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span>
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>p <span style="color: #b58900;">StringSlice</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Swap</span><span style="color: #2aa198;">(</span>i, j <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        p<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>, p<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span> = p<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span>, p<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        sl := <span style="color: #268bd2;">StringSlice</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"zwf"</span>, <span style="color: #2aa198;">"abc"</span>, <span style="color: #2aa198;">"def"</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>sort.<span style="color: #268bd2;">IsSorted</span><span style="color: #268bd2;">(</span>sl<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        sort.<span style="color: #268bd2;">Sort</span><span style="color: #b58900;">(</span>sl<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>sort.<span style="color: #268bd2;">IsSorted</span><span style="color: #268bd2;">(</span>sl<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>

        values := <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>3, 1, 4, 1<span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>sort.<span style="color: #268bd2;">IntsAreSorted</span><span style="color: #268bd2;">(</span>values<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        sort.<span style="color: #268bd2;">Ints</span><span style="color: #b58900;">(</span>values<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>sort.<span style="color: #268bd2;">IntsAreSorted</span><span style="color: #268bd2;">(</span>values<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-7" class="outline-3">
<h3 id="sec-7-7">The http.Handler Interface</h3>
<div class="outline-text-3" id="text-7-7">
<ul class="org-ul">
<li>go里面处理server,最常见的API的核心接口是http.Handler interface,定义如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">package net/http</span>
<span style="color: #859900; font-weight: bold;">package</span> http

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Handler</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">ServeHTTP</span><span style="color: #b58900;">(</span>w ResponseWriter, r *Request<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>真正起作用的函数,接受两个参数,一个是类型"localhost:8000"这样的host+port字符
串组合, 另外一个就是一个实现了Handler interface的instance啦
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">ListenAndServe</span><span style="color: #2aa198;">(</span>address <span style="color: #b58900;">string</span>, h <span style="color: #b58900;">Handler</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span>
</pre>
</div>
</li>
<li>既然是一个server,那么ListenAndServe函数的特点是:
<ul class="org-ul">
<li>要么启动失败
</li>
<li>要么一直运行
</li>
<li>要么运行的时候奔溃
</li>
<li>总之不会"成功"返回,它的成功就是一直运行
</li>
</ul>
</li>
<li>下面我们来看一个例子:一个电子商城
<ul class="org-ul">
<li>其中的database其实是一个map,把货物映射成美元
</li>
<li>我们让database类型实现我们的Handler interface,那么它也就能放到ListenAndServe
函数里面,作为第二个参数了.
</li>
</ul>
</li>
<li>代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"net/http"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">dollars</span> <span style="color: #b58900;">float32</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>d <span style="color: #b58900;">dollars</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">String</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"$%.2f"</span>, d<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">database</span> <span style="color: #859900; font-weight: bold;">map</span><span style="color: #2aa198;">[</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">]</span><span style="color: #b58900;">dollars</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>db <span style="color: #b58900;">database</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">ServeHTTP</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">http.ResponseWriter</span>, req *<span style="color: #b58900;">http.Request</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> item, price := <span style="color: #859900; font-weight: bold;">range</span> db <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>w, <span style="color: #2aa198;">"%s: %s\n"</span>, item, price<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        db := <span style="color: #b58900;">database</span><span style="color: #b58900;">{</span><span style="color: #2aa198;">"shoes"</span>: 50, <span style="color: #2aa198;">"socks"</span>: 5<span style="color: #b58900;">}</span>
        log.<span style="color: #268bd2;">Fatal</span><span style="color: #b58900;">(</span>http.<span style="color: #268bd2;">ListenAndServe</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"localhost:8000"</span>, db<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ go run main.go</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">go run main.go</span>
</pre>
</div>
</li>
<li>使用curl能够得到服务器的返回值
<div class="org-src-container">

<pre class="src src-sh">$ curl http://localhost:8000
shoes: $<span style="color: #268bd2;">50</span>.00
socks: $<span style="color: #268bd2;">5</span>.00
</pre>
</div>
</li>
<li>当前版本的例子是最简单的,服务器只能在"/"返回所有的db内容,这显然不太实用,真正
的server会有很多的URL,不同的URL会有不同的结果.比如我们要求我们的例子可以提供
如下两个功能:
<ul class="org-ul">
<li>"/list"列出所有的产品
</li>
<li>"/price?item=xxx"列出某个item的价格
</li>
</ul>
</li>
<li>代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"net/http"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">dollars</span> <span style="color: #b58900;">float32</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>d <span style="color: #b58900;">dollars</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">String</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"$%.2f"</span>, d<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">database</span> <span style="color: #859900; font-weight: bold;">map</span><span style="color: #2aa198;">[</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">]</span><span style="color: #b58900;">dollars</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>db <span style="color: #b58900;">database</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">ServeHTTP</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">http.ResponseWriter</span>, req *<span style="color: #b58900;">http.Request</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">switch</span> req.URL.Path <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">"/list"</span>:
                <span style="color: #859900; font-weight: bold;">for</span> item, price := <span style="color: #859900; font-weight: bold;">range</span> db <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #6c71c4;">(</span>w, <span style="color: #2aa198;">"%s: %s\n"</span>, item, price<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">"/price"</span>:
                item := req.URL.<span style="color: #268bd2;">Query</span><span style="color: #268bd2;">()</span>.<span style="color: #268bd2;">Get</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"item"</span><span style="color: #268bd2;">)</span>
                price, ok := db<span style="color: #268bd2;">[</span>item<span style="color: #268bd2;">]</span>
                <span style="color: #859900; font-weight: bold;">if</span> !ok <span style="color: #268bd2;">{</span>
                        w.<span style="color: #268bd2;">WriteHeader</span><span style="color: #6c71c4;">(</span>http.StatusNotFound<span style="color: #6c71c4;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">404</span>
                        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #6c71c4;">(</span>w, <span style="color: #2aa198;">"no such item: %q\n"</span>, item<span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">return</span>
                <span style="color: #268bd2;">}</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>w, <span style="color: #2aa198;">"%s\n"</span>, price<span style="color: #268bd2;">)</span>
        <span style="color: #859900; font-weight: bold;">default</span>:
                w.<span style="color: #268bd2;">WriteHeader</span><span style="color: #268bd2;">(</span>http.StatusNotFound<span style="color: #268bd2;">)</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>w, <span style="color: #2aa198;">"no such page: %s\n"</span>, req.URL<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        db := <span style="color: #b58900;">database</span><span style="color: #b58900;">{</span><span style="color: #2aa198;">"shoes"</span>: 50, <span style="color: #2aa198;">"socks"</span>: 5<span style="color: #b58900;">}</span>
        log.<span style="color: #268bd2;">Fatal</span><span style="color: #b58900;">(</span>http.<span style="color: #268bd2;">ListenAndServe</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"localhost:8000"</span>, db<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">curl http://localhost:8000/price?item=socks</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$5.00</span>
</pre>
</div>
</li>
<li>当然了,这样看起来,我们的代码非常的简介,我们甚至可以无限制的不停把URL加下去,
但是在正式的项目中,每个URL都代表了一个逻辑,这个逻辑一般是由不同的开发人员写
在不同的函数里面.同时相似的URL可能使用同一个逻辑:比如/images/*.png
</li>
<li>基于以上原因net/http 提供了一个叫做ServeMux的request multiplexer来简化URL和
handler之间的设置,说起来简单,但是实现方法却是有点绕:
<ul class="org-ul">
<li>ListenAndServe这个函数是运行所有go server的必备函数,我们是不可能改动这个函
数的.这个函数除了"一直运行"以外,另外一个特点就是第二个参数要求一定要实现
http.Handler,所以ServeMux的第一个基本思想就是自己作为ListenAndServe的第二
个参数,所以ServeMux是肯定实现了http.Handler啦(使用的是指针)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ServeHTTP dispatches the request to the handler whose</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">pattern most closely matches the request URL.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>mux *<span style="color: #b58900;">ServeMux</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">ServeHTTP</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">ResponseWriter</span>, r *<span style="color: #b58900;">Request</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> r.RequestURI == <span style="color: #2aa198;">"*"</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> r.<span style="color: #268bd2;">ProtoAtLeast</span><span style="color: #268bd2;">(</span>1, 1<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        w.<span style="color: #268bd2;">Header</span><span style="color: #6c71c4;">()</span>.<span style="color: #268bd2;">Set</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"Connection"</span>, <span style="color: #2aa198;">"close"</span><span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                w.<span style="color: #268bd2;">WriteHeader</span><span style="color: #268bd2;">(</span>StatusBadRequest<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span>
        <span style="color: #b58900;">}</span>
        h, _ := mux.<span style="color: #268bd2;">Handler</span><span style="color: #b58900;">(</span>r<span style="color: #b58900;">)</span>
        h.<span style="color: #268bd2;">ServeHTTP</span><span style="color: #b58900;">(</span>w, r<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>传统的LinstenAndServe要求所有的http URL的规则都要在第二个参数里面写明,所以
我们肯定要在ServeMux里面为所有的'URL规则'都准备好位置存放,现在的办法是使用
一个map.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Handle registers the handler for the given pattern.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">If a handler already exists for pattern, Handle panics.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>mux *<span style="color: #b58900;">ServeMux</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Handle</span><span style="color: #2aa198;">(</span>pattern <span style="color: #b58900;">string</span>, handler <span style="color: #b58900;">Handler</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        mux.mu.<span style="color: #268bd2;">Lock</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">defer</span> mux.mu.<span style="color: #268bd2;">Unlock</span><span style="color: #b58900;">()</span>

        <span style="color: #859900; font-weight: bold;">if</span> pattern == <span style="color: #2aa198;">""</span> <span style="color: #b58900;">{</span>
                <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"http: invalid pattern "</span> + pattern<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">if</span> handler == <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"http: nil handler"</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">if</span> mux.m<span style="color: #b58900;">[</span>pattern<span style="color: #b58900;">]</span>.explicit <span style="color: #b58900;">{</span>
                <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"http: multiple registrations for "</span> + pattern<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">if</span> mux.m == <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                mux.m = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #6c71c4;">[</span><span style="color: #b58900;">string</span><span style="color: #6c71c4;">]</span><span style="color: #b58900;">muxEntry</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        mux.m<span style="color: #b58900;">[</span>pattern<span style="color: #b58900;">]</span> = <span style="color: #b58900;">muxEntry</span><span style="color: #b58900;">{</span>explicit: <span style="color: #268bd2; font-weight: bold;">true</span>, h: handler, pattern: pattern<span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个map的key是'URL pattern', value是handler function value. 注意这是一个
function value,也就是说是fp编程里面的东西.我们把"逻辑"通过函数传递给map.其
中一个"逻辑"的样子和使用方法如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>db <span style="color: #b58900;">database</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">list</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">http.ResponseWriter</span>, req *<span style="color: #b58900;">http.Request</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> item, price := <span style="color: #859900; font-weight: bold;">range</span> db <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>w, <span style="color: #2aa198;">"%s: %s\n"</span>, item, price<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
        mux.<span style="color: #268bd2;">Handle</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"/list"</span>, http.<span style="color: #268bd2;">HandlerFunc</span><span style="color: #268bd2;">(</span>db.list<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个list函数特别的奇怪,因为它的req这个参数"压根就没有用!!",但是还是要这么
设计,这是为了让http.HandlerFunc能够根据它来创建出符合http.Handler接口的新
instance. 这里的HandlerFunc是一种Go里面接口的特殊用法: 'adapter!'database
的某个method通过'中间类型HandlerFunc'做到了满足http.Handler接口!
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> http

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">HandlerFunc</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">ResponseWriter</span>, r *<span style="color: #b58900;">Request</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>f <span style="color: #b58900;">HandlerFunc</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">ServeHTTP</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">ResponseWriter</span>, r *<span style="color: #b58900;">Request</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">f</span><span style="color: #b58900;">(</span>w, r<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>"使用http.HandlerFunc来adapt一个function value,使得整个function value能够
满足http.Handler"这个用法实在太常见,所以package http又做了新一步的简化,设
计了HandleFunc函数,它和Handle函数是完全等价的.(下面两行代码完全等价)
<div class="org-src-container">

<pre class="src src-go">mux.<span style="color: #268bd2;">Handle</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"/list"</span>, http.<span style="color: #268bd2;">HandlerFunc</span><span style="color: #b58900;">(</span>db.list<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
mux.<span style="color: #268bd2;">HandleFunc</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"/list"</span>, db.list<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>最后一条比较容易忽视,那就是,一般一个program(运行起来的叫做process)只会使
用一个端口.这种情况下,一个program也只会使用一个ServeMux.所以我们把ServeMux
定义成一个全局变量,如果第二个参数为nil的情况下,ListenAndServe都会去寻找这
个全局变量作为自己默认的'第二个变量'
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        db := <span style="color: #b58900;">database</span><span style="color: #b58900;">{</span><span style="color: #2aa198;">"shoes"</span>: 50, <span style="color: #2aa198;">"socks"</span>:5<span style="color: #b58900;">}</span>
        http.<span style="color: #268bd2;">HandleFunc</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"/list"</span>, db.list<span style="color: #b58900;">)</span>
        http.<span style="color: #268bd2;">HandleFunc</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"/price"</span>, db.price<span style="color: #b58900;">)</span>
        log.<span style="color: #268bd2;">Fatal</span><span style="color: #b58900;">(</span>http.<span style="color: #268bd2;">ListenAndServe</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"localhost:8000"</span>, <span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-8" class="outline-3">
<h3 id="sec-7-8">The error Interface</h3>
<div class="outline-text-3" id="text-7-8">
<ul class="org-ul">
<li>从这本书的开始,我们就开始使用error type了,但是没有具体解释,因为error其实是一
个interface
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">error</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Error</span><span style="color: #b58900;">()</span> string
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>最简单的创建一个error的方法就是使用errors.New. 整个errors package只有四行代
码!
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> errors

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">New</span><span style="color: #2aa198;">(</span>text <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> &amp;<span style="color: #b58900;">errorString</span><span style="color: #b58900;">{</span>text<span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">errorString</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span> text string <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>e *<span style="color: #b58900;">errorString</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Error</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> e.text <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们看到errors.New其实就是返回一个errorString类型的指针,而errorString所有的
field加起来只有一个string,但是还是type了struct,而不是type了struct.因为这样
可以保护`text`被"不小心"的更改
</li>
<li>使用指针类型来实现接口也是有原因的:每次使用New都会创建一个完全'不一样'的error
instance.
</li>
<li>这里的'不一样'是指:即便text内容碰巧完全一致,两个error instance是连比较都无
法比较(因为指针类型是ref类型,只能和nil比较)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"errors"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>errors.<span style="color: #268bd2;">New</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"EOF"</span><span style="color: #268bd2;">)</span> == errors.<span style="color: #268bd2;">New</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"EOF"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false</span>
</pre>
</div>
</li>
<li>errors.New是默认的创建error的方法,但是却不会经常在代码中看到.那是因为有另外
的wrapper function来包裹了errors.New,另外做些其他的工作,比如format
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> fmt

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"errors"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Errorf</span><span style="color: #2aa198;">(</span>format <span style="color: #b58900;">string</span>, args ...<span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> errors.<span style="color: #268bd2;">New</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">Sprintf</span><span style="color: #268bd2;">(</span>format, args...<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>*errorString是最简单的error,但是却远远不是唯一的一个.比如syscall package提供
底层的system call API.在许多系统中,这个package都会设计一个叫做Errno的类型来
implement error interface
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> syscall

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Errno</span> <span style="color: #b58900;">uintptr</span>              <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">operating system error code</span>

<span style="color: #859900; font-weight: bold;">var</span> errors = <span style="color: #2aa198;">[</span>...<span style="color: #2aa198;">]</span><span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2; font-weight: bold;">1</span>: <span style="color: #2aa198;">"operation not permitted"</span>, <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">EPERM</span>
        <span style="color: #268bd2; font-weight: bold;">2</span>: <span style="color: #2aa198;">"no such file or directory"</span>, <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ENOENT</span>
        <span style="color: #268bd2; font-weight: bold;">3</span>: <span style="color: #2aa198;">"no such process"</span>,           <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ESRCH</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>e <span style="color: #b58900;">Errno</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Error</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> 0 &lt;= <span style="color: #268bd2;">int</span><span style="color: #b58900;">(</span>e<span style="color: #b58900;">)</span> &amp;&amp; <span style="color: #268bd2;">int</span><span style="color: #b58900;">(</span>e<span style="color: #b58900;">)</span> &lt; <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>errors<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> errors<span style="color: #268bd2;">[</span>e<span style="color: #268bd2;">]</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"errno %d"</span>, e<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>使用方法如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"syscall"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> err error = syscall.<span style="color: #268bd2;">Errno</span><span style="color: #b58900;">(</span>2<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>err<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">no such file or directory</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-9" class="outline-3">
<h3 id="sec-7-9">Example: Expression Evaluator</h3>
<div class="outline-text-3" id="text-7-9">
<ul class="org-ul">
<li>下面的章节,我们要来创建一个简单的例子:来计算算术表达式
</li>
<li>我们使用一个interface Expr来代表任意的一个expression.最开始我们可以使用如下
的代码来定义expression
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">An Expr is an arithmetic expression</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Expr</span> <span style="color: #859900; font-weight: bold;">interface</span><span style="color: #2aa198;">{}</span>
</pre>
</div>
</li>
<li>我们的expression可以拥有如下的特性(成员都是float精度):
<ul class="org-ul">
<li>binary operator: +, -, *, /
</li>
<li>unary operator: -x, +x
</li>
<li>function call: pow(x, y), sin(x), sqrt(x)
</li>
<li>变量:比如x或者pi
</li>
<li>还有就是括号和标准的算术符号优先级
</li>
</ul>
</li>
<li>我们的expression的几个例子如下:
<pre class="example">
sqrt(A / pi)
pow(x, 3) + pow(y, 3)
(F - 32) * 5 / 9
</pre>
</li>
<li>我们用如下代码来表达出各个成员
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A Var identifies a variable, e.g., x.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Var</span> <span style="color: #b58900;">string</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A literal is a numeric constant, e.g., 3.141</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">literal</span> <span style="color: #b58900;">float64</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A unary represents a unary operator expression, e.g., -x.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">unary</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        op rune                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">one of '+', '-'</span>
        x Expr
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A binary represents a binary operator expression, e.g., x + y.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">binary</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        op rune                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">one of '+', '-', '*', '/'</span>
        x, y Expr
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A call represents a function call expression, e.g., sin(x).</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">call</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        fn string               <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">one of "pow", "sin", "sqrt"</span>
        args <span style="color: #b58900;">[]</span><span style="color: #b58900;">Expr</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>为了能够知道"变量"的值,我们需要一个map来存储"变量"和float64直接的转化关系
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Env</span> <span style="color: #859900; font-weight: bold;">map</span><span style="color: #2aa198;">[</span><span style="color: #b58900;">Var</span><span style="color: #2aa198;">]</span><span style="color: #b58900;">float64</span>
</pre>
</div>
</li>
<li>有了这个Env之后,我们每个expression都需要提供一个把expression转换成float64的
函数,我们暂且把这个函数叫做是Eval好了,那么每个expression都需要这个函数,所以
这个函数必须得是在Expr interface里面了.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Expr</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Eval returns the value of this Expr in the environment env.</span>
        <span style="color: #268bd2;">Eval</span><span style="color: #b58900;">(</span>env Env<span style="color: #b58900;">)</span> float64
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>好了,interface定好了后,我们的类型每个都要去实现这个函数.简单的例子如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>v <span style="color: #b58900;">Var</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Eval</span><span style="color: #2aa198;">(</span>env <span style="color: #b58900;">Env</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> env<span style="color: #b58900;">[</span>v<span style="color: #b58900;">]</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>l <span style="color: #b58900;">literal</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Eval</span><span style="color: #2aa198;">(</span>_ <span style="color: #b58900;">Env</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">float64</span><span style="color: #b58900;">(</span>l<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>复杂的例子,也就是单操作数,或者双操作数的例子(它们会把自己管辖的expr的值算出
来),如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>u <span style="color: #b58900;">unary</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Eval</span><span style="color: #2aa198;">(</span>env <span style="color: #b58900;">Env</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">switch</span> u.op <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">'+'</span>:
                <span style="color: #859900; font-weight: bold;">return</span> +u.x.<span style="color: #268bd2;">Eval</span><span style="color: #268bd2;">(</span>env<span style="color: #268bd2;">)</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">'-'</span>:
                <span style="color: #859900; font-weight: bold;">return</span> -u.x.<span style="color: #268bd2;">Eval</span><span style="color: #268bd2;">(</span>env<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #b58900;">(</span>fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"unsupported unary operator: %q"</span>, u.op<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>b <span style="color: #b58900;">binary</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Eval</span><span style="color: #2aa198;">(</span>env <span style="color: #b58900;">Env</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">switch</span> b.op <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">'+'</span>:
                <span style="color: #859900; font-weight: bold;">return</span> b.x.<span style="color: #268bd2;">Eval</span><span style="color: #268bd2;">(</span>env<span style="color: #268bd2;">)</span> + b.y.<span style="color: #268bd2;">Eval</span><span style="color: #268bd2;">(</span>env<span style="color: #268bd2;">)</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">'-'</span>:
                <span style="color: #859900; font-weight: bold;">return</span> b.x.<span style="color: #268bd2;">Eval</span><span style="color: #268bd2;">(</span>env<span style="color: #268bd2;">)</span> - b.y.<span style="color: #268bd2;">Eval</span><span style="color: #268bd2;">(</span>env<span style="color: #268bd2;">)</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">'*'</span>:
                <span style="color: #859900; font-weight: bold;">return</span> b.x.<span style="color: #268bd2;">Eval</span><span style="color: #268bd2;">(</span>env<span style="color: #268bd2;">)</span> * b.y.<span style="color: #268bd2;">Eval</span><span style="color: #268bd2;">(</span>env<span style="color: #268bd2;">)</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">'/'</span>:
                <span style="color: #859900; font-weight: bold;">return</span> b.x.<span style="color: #268bd2;">Eval</span><span style="color: #268bd2;">(</span>env<span style="color: #268bd2;">)</span> / b.y.<span style="color: #268bd2;">Eval</span><span style="color: #268bd2;">(</span>env<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #b58900;">(</span>fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"unsupported unary operator: %q"</span>, u.op<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>函数调用只支持三个
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>c <span style="color: #b58900;">call</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Eval</span><span style="color: #2aa198;">(</span>env <span style="color: #b58900;">Env</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">float64</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">switch</span> c.fn <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">"pow"</span>:
                <span style="color: #859900; font-weight: bold;">return</span> math.<span style="color: #268bd2;">Pow</span><span style="color: #268bd2;">(</span>c.args<span style="color: #6c71c4;">[</span>0<span style="color: #6c71c4;">]</span>.<span style="color: #268bd2;">Eval</span><span style="color: #6c71c4;">(</span>env<span style="color: #6c71c4;">)</span>, c.args<span style="color: #6c71c4;">[</span>1<span style="color: #6c71c4;">]</span>.<span style="color: #268bd2;">Eval</span><span style="color: #6c71c4;">(</span>env<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">"sin"</span>:
                <span style="color: #859900; font-weight: bold;">return</span> math.<span style="color: #268bd2;">Sin</span><span style="color: #268bd2;">(</span>c.args<span style="color: #6c71c4;">[</span>0<span style="color: #6c71c4;">]</span>.<span style="color: #268bd2;">Eval</span><span style="color: #6c71c4;">(</span>env<span style="color: #6c71c4;">)</span>, c.args<span style="color: #6c71c4;">[</span>1<span style="color: #6c71c4;">]</span>.<span style="color: #268bd2;">Eval</span><span style="color: #6c71c4;">(</span>env<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #2aa198;">"sqrt"</span>:
                <span style="color: #859900; font-weight: bold;">return</span> math.<span style="color: #268bd2;">Sqrt</span><span style="color: #268bd2;">(</span>c.args<span style="color: #6c71c4;">[</span>0<span style="color: #6c71c4;">]</span>.<span style="color: #268bd2;">Eval</span><span style="color: #6c71c4;">(</span>env<span style="color: #6c71c4;">)</span>, c.args<span style="color: #6c71c4;">[</span>1<span style="color: #6c71c4;">]</span>.<span style="color: #268bd2;">Eval</span><span style="color: #6c71c4;">(</span>env<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #b58900;">(</span>fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"unsupported unary operator: %q"</span>, u.op<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们的代码是否管用,可以使用go自带的testing package来进行测试
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">TestEval</span><span style="color: #2aa198;">(</span>t *<span style="color: #b58900;">testing.T</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        tests := <span style="color: #b58900;">[]</span><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">{</span>
                expr string
                env  Env
                want string
        <span style="color: #b58900;">}{</span>
                <span style="color: #268bd2;">{</span><span style="color: #2aa198;">"sqrt(A / pi)"</span>, <span style="color: #b58900;">Env</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"A"</span>: 87616, <span style="color: #2aa198;">"pi"</span>: math.Pi<span style="color: #6c71c4;">}</span>, <span style="color: #2aa198;">"167"</span><span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span><span style="color: #2aa198;">"pow(x, 3) + pow(y, 3)"</span>, <span style="color: #b58900;">Env</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"x"</span>: 12, <span style="color: #2aa198;">"y"</span>: 1<span style="color: #6c71c4;">}</span>, <span style="color: #2aa198;">"1729"</span><span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span><span style="color: #2aa198;">"pow(x, 3) + pow(y, 3)"</span>, <span style="color: #b58900;">Env</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"x"</span>: 9, <span style="color: #2aa198;">"y"</span>: 10<span style="color: #6c71c4;">}</span>, <span style="color: #2aa198;">"1729"</span><span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span><span style="color: #2aa198;">"5 / 9 * (F - 32)"</span>, <span style="color: #b58900;">Env</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"F"</span>: -40<span style="color: #6c71c4;">}</span>, <span style="color: #2aa198;">"-40"</span><span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span><span style="color: #2aa198;">"5 / 9 * (F - 32)"</span>, <span style="color: #b58900;">Env</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"F"</span>: 32<span style="color: #6c71c4;">}</span>, <span style="color: #2aa198;">"0"</span><span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span><span style="color: #2aa198;">"5 / 9 * (F - 32)"</span>, <span style="color: #b58900;">Env</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"F"</span>: 212<span style="color: #6c71c4;">}</span>, <span style="color: #2aa198;">"100"</span><span style="color: #268bd2;">}</span>,
                <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-Eval</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">additional tests that don't appear in the book</span>
                <span style="color: #268bd2;">{</span><span style="color: #2aa198;">"-1 + -x"</span>, <span style="color: #b58900;">Env</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"x"</span>: 1<span style="color: #6c71c4;">}</span>, <span style="color: #2aa198;">"-2"</span><span style="color: #268bd2;">}</span>,
                <span style="color: #268bd2;">{</span><span style="color: #2aa198;">"-1 - x"</span>, <span style="color: #b58900;">Env</span><span style="color: #6c71c4;">{</span><span style="color: #2aa198;">"x"</span>: 1<span style="color: #6c71c4;">}</span>, <span style="color: #2aa198;">"-2"</span><span style="color: #268bd2;">}</span>,
                <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+Eval</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">var</span> prevExpr string
        <span style="color: #859900; font-weight: bold;">for</span> _, test := <span style="color: #859900; font-weight: bold;">range</span> tests <span style="color: #b58900;">{</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Print expr only when it changes.</span>
                <span style="color: #859900; font-weight: bold;">if</span> test.expr != prevExpr <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"\n%s\n"</span>, test.expr<span style="color: #6c71c4;">)</span>
                        prevExpr = test.expr
                <span style="color: #268bd2;">}</span>
                expr, err := <span style="color: #268bd2;">Parse</span><span style="color: #268bd2;">(</span>test.expr<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        t.<span style="color: #268bd2;">Error</span><span style="color: #6c71c4;">(</span>err<span style="color: #6c71c4;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">parse error</span>
                        <span style="color: #859900; font-weight: bold;">continue</span>
                <span style="color: #268bd2;">}</span>
                got := fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%.6g"</span>, expr.<span style="color: #268bd2;">Eval</span><span style="color: #6c71c4;">(</span>test.env<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"\t%v =&gt; %s\n"</span>, test.env, got<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">if</span> got != test.want <span style="color: #268bd2;">{</span>
                        t.<span style="color: #268bd2;">Errorf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"%s.Eval() in %v = %q, want %q\n"</span>,
                                test.expr, test.env, got, test.want<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>前面的假设"我们是输入都是正确的",但是这并不能一直保证的.为了保证我们输入正
确,我们再加上一个函数Check()来做static check:不需要运行就知道输入格式正确与
否
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Expr</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #2aa198;">{</span>
        <span style="color: #268bd2;">Eval</span><span style="color: #b58900;">(</span>env Env<span style="color: #b58900;">)</span> float64
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Check reports errors in this Expr and adds its Vars to the set.</span>
        <span style="color: #268bd2;">Check</span><span style="color: #b58900;">(</span>vars <span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">Var</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">bool</span><span style="color: #b58900;">)</span> error
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>下面就是各个类型用来进行Check的代码,其中对literal和Var的check是永远都不会失
败的. 对于操作符则会先检测是否有正确的符号,然后递归检测它自己的expr.对函数
则是检测参数个数对不对,然后递归检测这些参数
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>v <span style="color: #b58900;">Var</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Check</span><span style="color: #2aa198;">(</span>vars <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">Var</span><span style="color: #b58900;">]</span><span style="color: #b58900;">bool</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        vars<span style="color: #b58900;">[</span>v<span style="color: #b58900;">]</span> = <span style="color: #268bd2; font-weight: bold;">true</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">literal</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Check</span><span style="color: #2aa198;">(</span>vars <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">Var</span><span style="color: #b58900;">]</span><span style="color: #b58900;">bool</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>u <span style="color: #b58900;">unary</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Check</span><span style="color: #2aa198;">(</span>vars <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">Var</span><span style="color: #b58900;">]</span><span style="color: #b58900;">bool</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> !strings.<span style="color: #268bd2;">ContainsRun</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"+-"</span>, u.op<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"unexpected unary op %q"</span>, u.op<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> u.x.<span style="color: #268bd2;">Check</span><span style="color: #b58900;">(</span>vars<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>b <span style="color: #b58900;">binary</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Check</span><span style="color: #2aa198;">(</span>vars <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">Var</span><span style="color: #b58900;">]</span><span style="color: #b58900;">bool</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> !strings.<span style="color: #268bd2;">ContainsRune</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"+-*/"</span>, b.op<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"unexpected binary op %q"</span>, b.op<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">if</span> err := b.x.<span style="color: #268bd2;">Check</span><span style="color: #b58900;">(</span>vars<span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> err
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> b.y.<span style="color: #268bd2;">Check</span><span style="color: #b58900;">(</span>vars<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>c <span style="color: #b58900;">call</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Check</span><span style="color: #2aa198;">(</span>vars <span style="color: #859900; font-weight: bold;">map</span><span style="color: #b58900;">[</span><span style="color: #b58900;">Var</span><span style="color: #b58900;">]</span><span style="color: #b58900;">bool</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        arity, ok := numParams<span style="color: #b58900;">[</span>c.fn<span style="color: #b58900;">]</span>
        <span style="color: #859900; font-weight: bold;">if</span> !ok <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"unknown function %q"</span>, c.fn<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>c.args<span style="color: #b58900;">)</span> != arity <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"call to %s has %d args, want %d"</span>,
                        c.fn, <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #6c71c4;">(</span>c.args<span style="color: #6c71c4;">)</span>, arity<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, arg := <span style="color: #859900; font-weight: bold;">range</span> c.args <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> err := arg.<span style="color: #268bd2;">Check</span><span style="color: #268bd2;">(</span>vars<span style="color: #268bd2;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">return</span> err
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> numParams = <span style="color: #859900; font-weight: bold;">map</span><span style="color: #2aa198;">[</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">]</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">{</span><span style="color: #2aa198;">"pow"</span>: 2, <span style="color: #2aa198;">"sin"</span>: 1, <span style="color: #2aa198;">"sart"</span> : 1<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>好了,研究了这么多我们来看看我们"自己创造一个类型,甚至一个小型的解释器"其意
义在哪里?
</li>
<li>一个可行的作用,就是"在url的parameter里面"用来判断input字符串是否合格,合格后
可以马上算出结果:
<ul class="org-ul">
<li>首先我们要有一个函数来把string类型转换成Expr类型(部分代码)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Parse</span><span style="color: #2aa198;">(</span>input <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>_ <span style="color: #b58900;">Expr</span>, err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">defer</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">switch</span> x := <span style="color: #657b83; font-weight: bold;">recover</span><span style="color: #268bd2;">()</span>.<span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">type</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #268bd2; font-weight: bold;">nil</span>:
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">no panic</span>
                <span style="color: #859900; font-weight: bold;">case</span> lexPanic:
                        err = fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"%s"</span>, x<span style="color: #6c71c4;">)</span>
                <span style="color: #859900; font-weight: bold;">default</span>:
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">unexpected panic: resume state of panic.</span>
                        <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #6c71c4;">(</span>x<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}()</span>
        lex := <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #b58900;">(</span><span style="color: #b58900;">lexer</span><span style="color: #b58900;">)</span>
        lex.scan.<span style="color: #268bd2;">Init</span><span style="color: #b58900;">(</span>strings.<span style="color: #268bd2;">NewReader</span><span style="color: #268bd2;">(</span>input<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        lex.scan.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats
        lex.<span style="color: #268bd2;">next</span><span style="color: #b58900;">()</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">initial lookahead</span>
        e := <span style="color: #268bd2;">parseExpr</span><span style="color: #b58900;">(</span>lex<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> lex.token != scanner.EOF <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"unexpected %s"</span>, lex.<span style="color: #268bd2;">describe</span><span style="color: #6c71c4;">()</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> e, <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>首先检查是不是valid的input,返回一个error.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+parseAndCheck</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">parseAndCheck</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">eval.Expr</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> s == <span style="color: #2aa198;">""</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"empty expression"</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        expr, err := eval.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, err
        <span style="color: #b58900;">}</span>
        vars := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">eval.Var</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">bool</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err := expr.<span style="color: #268bd2;">Check</span><span style="color: #b58900;">(</span>vars<span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, err
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> v := <span style="color: #859900; font-weight: bold;">range</span> vars <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> v != <span style="color: #2aa198;">"x"</span> &amp;&amp; v != <span style="color: #2aa198;">"y"</span> &amp;&amp; v != <span style="color: #2aa198;">"r"</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, fmt.<span style="color: #268bd2;">Errorf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"undefined variable: %s"</span>, v<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> expr, <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>如果没有error就可以直接打印值啦(需要导入Env),然后我们把这个函数(plot)做成可
以作为handler的样子.参数是形如<a href="http://localhost:8000/plot?expr=sin(-x)">http://localhost:8000/plot?expr=sin(-x)</a>的样
子
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+plot</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">plot</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">http.ResponseWriter</span>, r *<span style="color: #b58900;">http.Request</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        r.<span style="color: #268bd2;">ParseForm</span><span style="color: #b58900;">()</span>
        expr, err := <span style="color: #268bd2;">parseAndCheck</span><span style="color: #b58900;">(</span>r.Form.<span style="color: #268bd2;">Get</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"expr"</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                http.<span style="color: #268bd2;">Error</span><span style="color: #268bd2;">(</span>w, <span style="color: #2aa198;">"bad expr: "</span>+err.<span style="color: #268bd2;">Error</span><span style="color: #6c71c4;">()</span>, http.StatusBadRequest<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span>
        <span style="color: #b58900;">}</span>
        w.<span style="color: #268bd2;">Header</span><span style="color: #b58900;">()</span>.<span style="color: #268bd2;">Set</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Content-Type"</span>, <span style="color: #2aa198;">"image/svg+xml"</span><span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">surface</span><span style="color: #b58900;">(</span>w, <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">(</span>x, y <span style="color: #b58900;">float64</span><span style="color: #268bd2;">)</span> <span style="color: #b58900;">float64</span> <span style="color: #268bd2;">{</span>
                r := math.<span style="color: #268bd2;">Hypot</span><span style="color: #6c71c4;">(</span>x, y<span style="color: #6c71c4;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">distance from (0,0)</span>
                <span style="color: #859900; font-weight: bold;">return</span> expr.<span style="color: #268bd2;">Eval</span><span style="color: #6c71c4;">(</span>eval.<span style="color: #b58900;">Env</span><span style="color: #859900;">{</span><span style="color: #2aa198;">"x"</span>: x, <span style="color: #2aa198;">"y"</span>: y, <span style="color: #2aa198;">"r"</span>: r<span style="color: #859900;">}</span><span style="color: #6c71c4;">)</span>
        <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>最后就可以把这个plot()设置成某个url(这里是"/plot")的处理函数了
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+main</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        http.<span style="color: #268bd2;">HandleFunc</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"/plot"</span>, plot<span style="color: #b58900;">)</span>
        log.<span style="color: #268bd2;">Fatal</span><span style="color: #b58900;">(</span>http.<span style="color: #268bd2;">ListenAndServe</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"localhost:8000"</span>, <span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-10" class="outline-3">
<h3 id="sec-7-10">Type Assertions</h3>
<div class="outline-text-3" id="text-7-10">
<ul class="org-ul">
<li>所谓type assertion,是形如x.(T)的操作.其中T是类型,而x是interface value.换句
话说type assertion是"只能使用在interface value"上面的类型判断方法.
</li>
<li>这也很好理解,因为普通value的类型是不需要assert的,是static的.只有interface
value的类型才不是固定的:它拥有的是dynamic type.
</li>
<li>至于type assertion:x.(T)的结果,那会根据T的不同而有所不同:
<ul class="org-ul">
<li>如果T是一个concrete type: type assertion会去检查x的dynamic type是不是"完全
等于"T.如果成功的话,assertion的结果就会是x的dynamic value(对的,你没看错,是
dynamic value,换句话说,这个assertion操作在dynamic type对得上的情况下,会给
你dynamic value).如果失败的话,直接panic
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"io"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> w io.Writer
        w = os.Stdout
        f := w.<span style="color: #b58900;">(</span>*<span style="color: #b58900;">os.File</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%T\n"</span>, f<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>f == os.Stdout<span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">/////////////////////////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// panic: interface conversion: io.Writer is *os.File, not *bytes.Buffer        //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">c := w.(*bytes.Buffer)                                                          //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fmt.Println(c)                                                                  //</span>
        <span style="color: #93a1a1;">/////////////////////////////////////////////////////////////////////////////////////</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">*os.File</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
</pre>
</div>
</li>
<li>如果T也是一个interface type的话.assertion就转化为"x的dynamic type是不是满
足T".这种情况下,即便是assertion成功了,也不会"获取"到dynamic value的.但是
assertion之后,会得到一个dynamic type为T, dynamic value不变的,新的interface
value.换句话说,这种情况下的assertion操作是在dynamic value不变的情况下,给你
一个新的dynamic type&#x2013;也就意味着一系列新的method.需要注意的是如果T还是x不
能满足的情况下,依然会panic.下面的例子中w和rw的dynamic value完全相同,但是只
有rw暴露了Write函数
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> w io.Writer
w = os.Stdout
rw := w.<span style="color: #2aa198;">(</span><span style="color: #b58900;">io.ReadWriter</span><span style="color: #2aa198;">)</span>         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">success: *os.File has both Read and Write</span>

w = <span style="color: #657b83; font-weight: bold;">new</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">ByteCounter</span><span style="color: #2aa198;">)</span>
rw = w.<span style="color: #2aa198;">(</span><span style="color: #b58900;">io.ReaderWriter</span><span style="color: #2aa198;">)</span>        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">panic: *ByteCounter has no Read method</span>
</pre>
</div>
</li>
</ul>
</li>
<li>如果x是nil,那么无论T是什么类型,assertion都会失败
</li>
<li>前面说了,T是concrete type和interface type的情况.用到assertion并且T是interface
type的情况下.T和x就都是interface type.绝大多数情况下T的method要多.因为T的method
要少的话,可以直接赋值,没必要assertion了
<div class="org-src-container">

<pre class="src src-go">w = rw                          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">io.ReadWriter is assignable to io.Writer</span>
w = rw.<span style="color: #2aa198;">(</span><span style="color: #b58900;">io.Writer</span><span style="color: #2aa198;">)</span>              <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">falls only if rw == nil</span>
</pre>
</div>
</li>
<li>前面说到,assertion一旦失败的话,就是panic.这对于一般的程序而言,压力有点大.因
为一般的程序大多数的情况下,是不知道类型.不知道类型的时候,总不能试错一次就panic
吧.而go解决这个问题的办法是返回两个值的时候,第二个返回值,就是来验证assertion
是否成功
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"bytes"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"io"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> w io.Writer = os.Stdout
        f, ok := w.<span style="color: #b58900;">(</span>*<span style="color: #b58900;">os.File</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>f == os.Stdout, ok<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">extract dynamic value</span>
        b, ok := w.<span style="color: #b58900;">(</span>*<span style="color: #b58900;">bytes.Buffer</span><span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>b == <span style="color: #268bd2; font-weight: bold;">nil</span>, ok<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">failed, so b is nil</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true true</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true false</span>
</pre>
</div>
</li>
<li>这种第二个返回值为boolean的情况,非常适合马上使用第二个返回值,比如
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">if</span> f, ok := w.<span style="color: #2aa198;">(</span>*<span style="color: #b58900;">os.File</span><span style="color: #2aa198;">)</span>; ok <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">... use f ...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>当我们的type assertion里面的x本身就是一个变量的时候,我们经常会看到assertion
的返回值并没有新申请一个变量,而是直接使用了x,如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">if</span> w, ok := w.<span style="color: #2aa198;">(</span>*<span style="color: #b58900;">os.File</span><span style="color: #2aa198;">)</span>; ok <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">//  </span><span style="color: #93a1a1;">... use w ...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-11" class="outline-3">
<h3 id="sec-7-11">Discriminating Errors with Type Assertions</h3>
<div class="outline-text-3" id="text-7-11">
<ul class="org-ul">
<li>我们下面来看一个os package里面文件错误的例子:I/O可能由于各种各样的原因失败,
但是有三种错误是要特别对待的:
<ul class="org-ul">
<li>file already exists
</li>
<li>file not found
</li>
<li>permission denied
</li>
</ul>
</li>
<li>os package提供了下面三个helper函数来identify三种不同的error value
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> os

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">IsExist</span><span style="color: #2aa198;">(</span>err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">IsNotExist</span><span style="color: #2aa198;">(</span>err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">IsPermission</span><span style="color: #2aa198;">(</span>err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span>
</pre>
</div>
</li>
<li>error 类型之间最大的不同,就是error message.一个非常"天真"的做法就是通过比较
error message来identify错误是不是上面的三种类型
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">IsNotExist</span><span style="color: #2aa198;">(</span>err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: not robust!</span>
        <span style="color: #859900; font-weight: bold;">return</span> strings.<span style="color: #268bd2;">Contains</span><span style="color: #b58900;">(</span>err.<span style="color: #268bd2;">Error</span><span style="color: #268bd2;">()</span>, <span style="color: #2aa198;">"file does not exist"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这种天真的做法至少有如下两个致命的缺点:
<ul class="org-ul">
<li>不同的error可能会报相同的error message,至少是一部分相同的error message
</li>
<li>相同的错误在不同的平台,报的error message字符串也不一定一样
</li>
</ul>
</li>
<li>Go使用的是一种更加可靠的办法来区分不同的error value.其核心是创建一个新的类型
PathError来描述错误.这个类型包括三个部分:Op(操作), Path(路径), 和err(真正的
error类型)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> os

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">PathError records an error and the operation and file path that casued it.</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">PathError</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Op   string
        Path string
        Err  error
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>e *<span style="color: #b58900;">PathError</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Error</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> e.Op + <span style="color: #2aa198;">" "</span> + e.Path + <span style="color: #2aa198;">": "</span> + e.Err.<span style="color: #268bd2;">Error</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>在定义了PathError之后,所有跟filepath相关的错误就不仅仅是一个简单的"报告error
message"的error类型了,而是包含"操作,路径,err"三个的PathError(但是从interface
的角度上来讲,它还是error类型),在得到这种类型之后,使用"#v"打印,就能验证我们
的设想
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        _, err := os.<span style="color: #268bd2;">Open</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"/no/such/file"</span><span style="color: #b58900;">)</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>err<span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">%#v  a Go-syntax representation of the value</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%#v\n"</span>, err<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">open /no/such/file: no such file or directory</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&amp;os.PathError{Op:"open", Path:"/no/such/file", Err:0x2}</span>
</pre>
</div>
</li>
<li>下面的代码是go如何去实现的IsNotExist.需要注意的是,我们这里的error只要是下面
三个值中的一个就可以确定其是IsNotExist:
<ul class="org-ul">
<li>等于syscall.ENOENT
</li>
<li>等于os.ErrNotExist
</li>
<li>是一个*PathError,其error部分是'syscall.ENOENT或者os.ErrNotExist'
</li>
</ul>
</li>
<li>代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"errors"</span>
        <span style="color: #2aa198;">"syscall"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">var</span> ErrNotExist = errors.<span style="color: #268bd2;">New</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"file does not exist"</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">IsNotExist returns a bolean indicating whether the error is known to</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">report that a file or directory does not exist. It is satisfied by</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ErrNotExist as wll as some syscall errors.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">IsNotExist</span><span style="color: #2aa198;">(</span>err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> pe, ok := err.<span style="color: #b58900;">(</span>*<span style="color: #b58900;">PathError</span><span style="color: #b58900;">)</span>; ok <span style="color: #b58900;">{</span>
                err = pe.Err
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> err == syscall.ENOENT || err == ErrNotExist
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>使用方法如下
<div class="org-src-container">

<pre class="src src-go">_, err := os.<span style="color: #268bd2;">Open</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"/no/such/file"</span><span style="color: #2aa198;">)</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>os.<span style="color: #268bd2;">IsNotExist</span><span style="color: #b58900;">(</span>err<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"true"</span>
</pre>
</div>
</li>
<li>error产生后,其message会通过组合,"层层上报". PathError的结构可能在这个过程中
被破坏,所以Error discrimination需要在错误"上报"以前就要完成
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-12" class="outline-3">
<h3 id="sec-7-12">Querying Behaviors with Interface Type Assertions</h3>
<div class="outline-text-3" id="text-7-12">
<ul class="org-ul">
<li>下面一段逻辑是我们模仿的net/http package里面写入content-type的代码.这段代码
需要两次调用Write(),分别写入"Content-Type",和"text/html"(一个例子)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">writeHeader</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">io.Writer</span>, contentType <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> _, err := w.<span style="color: #268bd2;">Write</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Content-Type: "</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> err
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">if</span> _, err := w.<span style="color: #268bd2;">Write</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #268bd2;">(</span>contentType<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> err
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>注意,因为Write需要类型[]byte,所以显示的类型转换[]bytes()的conversiont是必须
的.但是这个conversion却有一个问题:为了创建临时的byte[]类型的变量,会申请一份
内存来存放这个临时变量.而且几乎在函数调用完毕之后.这块内存就被抛弃了
</li>
<li>这个写入header的代码是核心的代码,会被无数次调用.所以直接写入byte[]不是一个好
的选择:我们希望直接写入string类型
</li>
<li>这里说起来就有故事了.这里的w是一个interface value,其dynamic type肯定是能满
足io.Writer的,但是我们可以给这个dynamic type"多做点工作",让它也能写入string.
而net/http里面的的dynamic type就真的做了这么一个函数:
<ul class="org-ul">
<li>net/http里面的io.Writer的concrete类型是Writer:
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Writer</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        err error
        buf <span style="color: #b58900;">[]</span><span style="color: #b58900;">byte</span>
        n   int
        wr  io.Writer
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>Writer它实现了io.Writer interface
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>b *<span style="color: #b58900;">Writer</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Write</span><span style="color: #2aa198;">(</span>p <span style="color: #b58900;">[]</span><span style="color: #b58900;">byte</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>nn <span style="color: #b58900;">int</span>, err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>p<span style="color: #b58900;">)</span> &gt; b.<span style="color: #268bd2;">Available</span><span style="color: #b58900;">()</span> &amp;&amp; b.err == <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">var</span> n int
                <span style="color: #859900; font-weight: bold;">if</span> b.<span style="color: #268bd2;">Buffered</span><span style="color: #268bd2;">()</span> == 0 <span style="color: #268bd2;">{</span>
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Large write, empty buffer.</span>
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Write directly from p to avoid copy.</span>
                        n, b.err = b.wr.<span style="color: #268bd2;">Write</span><span style="color: #6c71c4;">(</span>p<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #268bd2;">{</span>
                        n = <span style="color: #657b83; font-weight: bold;">copy</span><span style="color: #6c71c4;">(</span>b.buf<span style="color: #859900;">[</span>b.n:<span style="color: #859900;">]</span>, p<span style="color: #6c71c4;">)</span>
                        b.n += n
                        b.<span style="color: #268bd2;">flush</span><span style="color: #6c71c4;">()</span>
                <span style="color: #268bd2;">}</span>
                nn += n
                p = p<span style="color: #268bd2;">[</span>n:<span style="color: #268bd2;">]</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">if</span> b.err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> nn, b.err
        <span style="color: #b58900;">}</span>
        n := <span style="color: #657b83; font-weight: bold;">copy</span><span style="color: #b58900;">(</span>b.buf<span style="color: #268bd2;">[</span>b.n:<span style="color: #268bd2;">]</span>, p<span style="color: #b58900;">)</span>
        b.n += n
        nn += n
        <span style="color: #859900; font-weight: bold;">return</span> nn, <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>以及WriteString
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>b *<span style="color: #b58900;">Writer</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">WriteString</span><span style="color: #2aa198;">(</span>s <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        nn := 0
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span> &gt; b.<span style="color: #268bd2;">Available</span><span style="color: #b58900;">()</span> &amp;&amp; b.err == <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                n := <span style="color: #657b83; font-weight: bold;">copy</span><span style="color: #268bd2;">(</span>b.buf<span style="color: #6c71c4;">[</span>b.n:<span style="color: #6c71c4;">]</span>, s<span style="color: #268bd2;">)</span>
                b.n += n
                nn += n
                s = s<span style="color: #268bd2;">[</span>n:<span style="color: #268bd2;">]</span>
                b.<span style="color: #268bd2;">flush</span><span style="color: #268bd2;">()</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">if</span> b.err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> nn, b.err
        <span style="color: #b58900;">}</span>
        n := <span style="color: #657b83; font-weight: bold;">copy</span><span style="color: #b58900;">(</span>b.buf<span style="color: #268bd2;">[</span>b.n:<span style="color: #268bd2;">]</span>, s<span style="color: #b58900;">)</span>
        b.n += n
        nn += n
        <span style="color: #859900; font-weight: bold;">return</span> nn, <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>这种实现WriteString的方法看起来有点像"灰色地带",但其实很多满足io.Writer接口
concrete的类型,都"偷偷"的实现了WriteString,比如*byte.Buffer, *os.File和
*bufio.Writer
</li>
<li>好了,你net/http偷偷实现了WriteStirng,但是我不能assume任何一个io.Writer的w都
有这个福气.毕竟io.Writer只能意味着你实现了Write([]byte),所以我们这个时候又要
用到type assertion了.这里用到了一个技巧,就是临时创建一个interface(stringWriter)
这个类型里面只有WriteString()一个函数,我们能assert这个临时类型成功的话,新的
sw就"扩展了自己的method",就肯定可以调用WriteString啦,否则就调用效率较差的Write()
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">writeString writes s to w</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">If w has a WriteString method, it is invoked insted of w.Write</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">writeString</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">io.Writer</span>, s <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>n <span style="color: #b58900;">int</span>, err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">stringWriter</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">WriteString</span><span style="color: #268bd2;">(</span>string<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span>n int, err error<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">if</span> sw, ok := w.<span style="color: #b58900;">(</span><span style="color: #b58900;">stringWriter</span><span style="color: #b58900;">)</span>; ok <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> sw.<span style="color: #268bd2;">WriteString</span><span style="color: #268bd2;">(</span>s<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">avoid a copy</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> w.<span style="color: #268bd2;">Write</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">[]</span><span style="color: #268bd2;">byte</span><span style="color: #268bd2;">(</span>s<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">allocate temporay copy</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">writeHeader</span><span style="color: #2aa198;">(</span>w <span style="color: #b58900;">io.Writer</span>, contentType <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> _, err := <span style="color: #268bd2;">writeString</span><span style="color: #b58900;">(</span>w, <span style="color: #2aa198;">"Content-Type: "</span><span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> err
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">if</span> _, err := <span style="color: #268bd2;">writeString</span><span style="color: #b58900;">(</span>w, contentType<span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> err
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个例子最令人困惑的地方在于:并没有一个standard interface来定义WriteString,
并且描述清楚WriteString的行为特点.
</li>
<li>我们能够使用WriteString来替代Write([]byte),其实是建立在我们默认WriteString
能够带来和Write([]byte)一样的效果.而WriteString在自己的documentation里面说
明了这一点.这也是Go开发和其他语言开发非常不一样的地方!但是在实际工作中,这样
做并不会有什么问题!
</li>
<li>fmt.Fprintf也使用了同样的"技巧"来区分一个value是不是error(fmt.Stringer)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> fmt
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">formatOneValue</span><span style="color: #2aa198;">(</span>x <span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> err, ok := x.<span style="color: #b58900;">(</span><span style="color: #b58900;">error</span><span style="color: #b58900;">)</span>; ok <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> err.<span style="color: #268bd2;">Error</span><span style="color: #268bd2;">()</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">if</span> str, ok := x.<span style="color: #b58900;">(</span><span style="color: #b58900;">Stringer</span><span style="color: #b58900;">)</span>; ok <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> str.<span style="color: #268bd2;">String</span><span style="color: #268bd2;">()</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">... all other types...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-13" class="outline-3">
<h3 id="sec-7-13">Type Switches</h3>
<div class="outline-text-3" id="text-7-13">
<ul class="org-ul">
<li>从我们已知的知识看,接口主要用在两个"截然不同"的领域:
<ul class="org-ul">
<li>第一个就是像io.Reader, io.Writer, http.Handler, error, sort.Interface一样
表达不同的concrete type之间"相同的部分(能够满足接口)",同时掩盖concrete的
实现细节,其重点是在"共享"的method上,而不是concrete type本身.这也是其他语言
对于interface的共同理解
</li>
<li>第二个用法则有些不同:go和java不一样,go是一个'值语言', 满足interface的变量
是一个有内存地址的value.所以go里面是有interface value概念的.而一个interface
value是可以存储完全不同的concrete type的,而interface则可以看成是这些类型的
"交汇点(union)": type assertion可以让我们的interface value伸缩成不同的type
从而有不同的method.这个用法的重点在于'concrete type',几个concrete type如果
实现了相同的interface,那么可以使用interface value把他们组织起来(使用type
assertion来区分).这种特殊的使用interface的办法叫做discriminated unions
</li>
</ul>
</li>
<li>让我们来看看Go的查询SQL数据库的API,这个API和其他语言处理SQL的API一样,会把改
变的部分和不变的部分区分开,下面是一个例子
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"databse/sql"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">listTracks</span><span style="color: #2aa198;">(</span>db <span style="color: #b58900;">sql.DB</span>, artist <span style="color: #b58900;">string</span>, minYear, maxYear <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        result, err := db.<span style="color: #268bd2;">Exec</span><span style="color: #b58900;">(</span>
                <span style="color: #2aa198;">"SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?"</span>,
                artist, minYear, maxYear<span style="color: #b58900;">)</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这里有三个'?',分别对应于三个变量artist, minYear, maxYear.Exec函数会把所有'?',
出现的地方转换成字符串,而字符串的来源则是"对应的变量(比如artist, minYear)".
</li>
<li>对应的变量可能是任意的类型,这就需要我们有一个逻辑判断:不同的类型转换成对应的
字符串,一个简单的实现如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"fmt"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">sqlQuote</span><span style="color: #2aa198;">(</span>x <span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> x == <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"NULL"</span>
        <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">if</span> _, ok := x.<span style="color: #b58900;">(</span><span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>; ok <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%d"</span>, x<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">if</span> _, ok := x.<span style="color: #b58900;">(</span><span style="color: #b58900;">uint</span><span style="color: #b58900;">)</span>; ok <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%d"</span>, x<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">if</span> b, ok := x.<span style="color: #b58900;">(</span><span style="color: #b58900;">bool</span><span style="color: #b58900;">)</span>; ok <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> b <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"TRUE"</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"FALSE"</span>
        <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">if</span> s, ok := x.<span style="color: #b58900;">(</span><span style="color: #b58900;">string</span><span style="color: #b58900;">)</span>; ok <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">sqlQuoteString</span><span style="color: #268bd2;">(</span>s<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#38450;&#27490;SQL&#27880;&#20837;</span>
        <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
                <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #268bd2;">(</span>fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"unexpected type %T: %v"</span>, x, x<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这一段代码写下来让我们怀念如果有switch case就好了,然后go就果然为这种assertion
专门设计了一种switch(注意,这是switch的特例!switch后面跟关键字type显然不是正
常的例子).这种switch的样子如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">switch</span> x.<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">type</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">case</span> <span style="color: #268bd2; font-weight: bold;">nil</span>: <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">case</span> int, unint: <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">case</span> bool: <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">case</span> string: <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">default</span>: <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>和普通switch一样,这里的switch"自带break":所以type里面有interface的时候,case
的顺序就非常重要了,因为可能有两个case都会被满足,先满足的就先返回了
</li>
<li>我们注意到,上面if-else的例子中,我们有些时候还是需要"类型转换完"的变量的,比如
bool, string的case.为了能够满足这种需要,我们特例的switch还支持如下的"形变"
以便类型可以获得"转换完毕"之后的结果
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">switch</span> x := x.<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">type</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们这里"重用"了x作为"转换完毕"之后的结果,因为type switch"暗地里"创建了一个
新的lexical block.所以这次x的"重新赋值"不会影响到outer block.每个case也会重
新创建一个separate lexical block
</li>
<li>前面if-else的代码,完整的重写代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">sqlQuote</span><span style="color: #2aa198;">(</span>x <span style="color: #859900; font-weight: bold;">interface</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">switch</span> x := x.<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">type</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> <span style="color: #268bd2; font-weight: bold;">nil</span>:
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"NULL"</span>
        <span style="color: #859900; font-weight: bold;">case</span> int, uint:
                <span style="color: #859900; font-weight: bold;">return</span> fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"%d"</span>, x<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">x has type interface{} here.</span>
        <span style="color: #859900; font-weight: bold;">case</span> bool:
                <span style="color: #859900; font-weight: bold;">if</span> x <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"TRUE"</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"FALSE"</span>
        <span style="color: #859900; font-weight: bold;">case</span> string:
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">sqlQuoteString</span><span style="color: #268bd2;">(</span>x<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#38450;&#27490;SQL&#27880;&#20837;</span>
        <span style="color: #859900; font-weight: bold;">default</span>:
                <span style="color: #657b83; font-weight: bold;">panic</span><span style="color: #268bd2;">(</span>fmt.<span style="color: #268bd2;">Sprintf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"unexpected type %T: %v"</span>, x, x<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>在这个版本的代码中:
<ul class="org-ul">
<li>在每个'single case'里面,x的类型都跟'case后面的类型'完全相同!比如string, bool
</li>
<li>如果不是'single case',那么x的类型还是interface{}, 比如int,uint那个case
</li>
</ul>
</li>
<li>在这个例子中,虽然x的类型是interface{},但是我们认为它是int, unit, bool, stirng, nil的"合体"
<pre class="example">
discriminated union of int, uint, boo, string and nil
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-14" class="outline-3">
<h3 id="sec-7-14">Example: Token-Based XML Decoding</h3>
<div class="outline-text-3" id="text-7-14">
<ul class="org-ul">
<li>前面我们介绍了使用encoding/json里面的Marshal和Unmarshal来转换下面两个对象:
<ul class="org-ul">
<li>json文件(string)
</li>
<li>Go data structure
</li>
</ul>
</li>
<li>如果我们希望创建一个document tree, 这种做法非常方便,但是大多数情况下,我们不
需要document tree.
</li>
<li>如果不构建document tree,我们就希望有一个比较low-level的处理文档token的方法,
encoding/xml就为我们提供了这样一组token-based的API:
<ul class="org-ul">
<li>输入是string input
</li>
<li>输出是是一系列的token(每次调用Token函数都会返回一个token),一共有四种类型:
<ol class="org-ol">
<li>StartElement
</li>
<li>EndElement
</li>
<li>CharData
</li>
<li>Comment
</li>
</ol>
</li>
</ul>
</li>
<li>API部分的代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> xml

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Name</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Local string            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">e.g., "Title" or "id"</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Attr</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Name Name
        Value String
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A Token includes StartElement, EndElement, CharData,</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">and Comment, plus a few esoteric type (not shown).</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Token</span> <span style="color: #859900; font-weight: bold;">interface</span><span style="color: #2aa198;">{}</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">StartElement</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span>
        Name Name
        Attr <span style="color: #b58900;">[]</span><span style="color: #b58900;">Attr</span>
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">EndElement</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span> Name Name <span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">e.g., &lt;/name&gt;</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Char</span> <span style="color: #b58900;">Data</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">byte</span>                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">e.g., &lt;p&gt;CharData&lt;/p&gt;</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Comment</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">byte</span>                  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">e.g., &lt;!-- Comment --&gt;</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">Decoder</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span> <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">NewDecoder</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">io.Reader</span><span style="color: #2aa198;">)</span> *<span style="color: #b58900;">Decoder</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #2aa198;">(</span>*<span style="color: #b58900;">Decoder</span><span style="color: #2aa198;">)</span> <span style="color: #268bd2;">Token</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">Token</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">returns next Token in sequence</span>
</pre>
</div>
</li>
<li>我们这里的Token interface就是一个典型的discriminated union的应用,它不是其他
语言里面interface的用法(忽略各个type的不同,重视共同method,各个类型一视同仁),
因为它根本就没有method!!
</li>
<li>没有method的interface也是有重大作用的,它可以作为"起作用的类型"的粘合剂(union)
对于这个'没有method的interface'的操作,在具体实施的时候,都会使用switch case
加上type assertion来挑选合适的concrete type来进行操作
</li>
<li>下面就是典型的discriminated union的操作
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"encoding/xml"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"io"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"strings"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        dec := xml.<span style="color: #268bd2;">NewDecoder</span><span style="color: #b58900;">(</span>os.Stdin<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">var</span> stack <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">stack of element names</span>

        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                tok, err := dec.<span style="color: #268bd2;">Token</span><span style="color: #268bd2;">()</span>
                <span style="color: #859900; font-weight: bold;">if</span> err == io.EOF <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">break</span>
                <span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #6c71c4;">(</span>os.Stderr, <span style="color: #2aa198;">"xmlselect: %v\n"</span>, err<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #859900; font-weight: bold;">switch</span> tok := tok.<span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">type</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">case</span> xml.StartElement:
                        stack = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #6c71c4;">(</span>stack, tok.Name.Local<span style="color: #6c71c4;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">push</span>
                <span style="color: #859900; font-weight: bold;">case</span> xml.EndElement:
                        stack = stack<span style="color: #6c71c4;">[</span>:<span style="color: #657b83; font-weight: bold;">len</span><span style="color: #859900;">(</span>stack<span style="color: #859900;">)</span>-1<span style="color: #6c71c4;">]</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">pop</span>
                <span style="color: #859900; font-weight: bold;">case</span> xml.CharData:
                        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">containsAll</span><span style="color: #6c71c4;">(</span>stack, os.Args<span style="color: #859900;">[</span>1:<span style="color: #859900;">]</span><span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
                                fmt.<span style="color: #268bd2;">Printf</span><span style="color: #859900;">(</span><span style="color: #2aa198;">"%s: %s\n"</span>, strings.<span style="color: #268bd2;">Join</span><span style="color: #b58900;">(</span>stack, <span style="color: #2aa198;">" "</span><span style="color: #b58900;">)</span>, tok<span style="color: #859900;">)</span>
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">containsAll reports whether x contains the elements of y, in order.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">containsAll</span><span style="color: #2aa198;">(</span>x, y <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>y<span style="color: #b58900;">)</span> &lt;= <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>x<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>y<span style="color: #268bd2;">)</span> == 0 <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #859900; font-weight: bold;">if</span> x<span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span> == y<span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span> <span style="color: #268bd2;">{</span>
                        y = y<span style="color: #6c71c4;">[</span>1:<span style="color: #6c71c4;">]</span>
                <span style="color: #268bd2;">}</span>
                x = x<span style="color: #268bd2;">[</span>1:<span style="color: #268bd2;">]</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt; wget http://www.w3.org/TR/2006/REC-xml11-20060816</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt; cat REC-xml11-20060816 | go run discriminated_union.go div div h2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: 1 Introduction</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: 2 Documents</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: 3 Logical Structures</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: 4 Physical Structures</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: 5 Conformance</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: 6 Notation</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: A References</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: B Definitions for Character Normalization</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: C Expansion of Entity and Character References (Non-Normative)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: D Deterministic Content Models (Non-Normative)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: E Autodetection of Character Encodings (Non-Normative)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: F W3C XML Working Group (Non-Normative)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: G W3C XML Core Working Group (Non-Normative)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: H Production Notes (Non-Normative)</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">html body div div h2: I Suggestions for XML Names (Non-Normative)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-15" class="outline-3">
<h3 id="sec-7-15">A Few Words of Advice</h3>
<div class="outline-text-3" id="text-7-15">
<ul class="org-ul">
<li>当设计新的package的时候,新手Go程序员往往会从创建一系列的interface开始,然后
让其他的concrete type来去implement这些接口(java就是这样).
</li>
<li>这种设计会导致非常多的interface,而每种interface只有一个implementation,在Go
语言里面,这不是好的设计,应该禁止!
</li>
<li>如果你想让某个type的method不"泄露",可以使用大小写规则的export mechanism,而
不要采取暴露interface(interface的method肯定外面可以看到),然后让某个concrete
type来实现这个interface的method
</li>
<li>interface,绝大多数情况下只有在discriminated uniform的时候才会用得到(而且用的
很多还是空interface)
</li>
<li>说绝大多数情况,那说明还有少部分情况下,也可以使用interface(即便只有一个
concrete type满足它),那就是在多个package之间合作的时候,interface是绝佳的对
象.因为concrete type有时候因为依赖的原因,无法在其他package出现
</li>
<li>因为Go里面提倡一个interface至少有两三个concrate来实现它,所以Go里面的interface
通常都比较小,很多时候只有一个method,比如io.Writer, fmt.Stringer.
</li>
<li>小的interface更容易被新的type所适应,而interface的最佳实践也要求
<pre class="example">
ask only for what you need
</pre>
</li>
<li>Go对oo编程有非常好的支持,但是这不意味着你一定要使用object.很多时候standalone
function也有他们绝佳的使用方法.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Chapter 08: Goroutines and Channels</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>所谓concurrent programming,就是把一个program表示成多个autonomous activity的
组合体(composition). 在当前的情况下,是最为重要的特性
</li>
<li>当前的手机app就是一个concurrent的例子:在展现给用户动态信息的同时,在后台还要
同时进行进行网络和计算操作
</li>
<li>即使是传统的batch 的问题(读取数据,计算,写入output)也会用到concurrency来利用
多核,同时提高在IO读取时候的效率
</li>
<li>Go支持两种concurrent programming:
<ul class="org-ul">
<li>CSP: communicating sequential process(表现出来就是goroutine和channel):特点
是value在不同的独立activity(goroutine)之间进行传递,variable只能在一个activity
内部存在
</li>
<li>shared memory multithreadin:特点是thread之间会共享内存
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Goroutines</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>在Go里面,每个正在执行的activity都叫做goroutine.比如在一个程序里面有两个function
一个做计算,另外一个写入output,如果两个function相互之间不调用,那么我们就可以
把他们放入到两个activity(goroutine)里面(也就可能同时运行,在有多个核的情况下)
</li>
<li>如果你使用过thread,你可以吧goroutine当做是一种更加轻量级的thread
</li>
<li>存在thread的语言里面,程序开始的时候,只有一个thread,就是main thread.同样的,在
go里面,程序开始的时候,只有一个goroutine,就是main goroutine. thread在c语言里
面就是直接作用于一个函数,在Go里面也是最小可以让一个函数作为一个goroutine,方
法是在函数前面加go
<div class="org-src-container">

<pre class="src src-go"><span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span>                             <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">call f(); wait for it to return</span>
<span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span>                          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">create a new goroutine that call f(); don't wait</span>
</pre>
</div>
</li>
<li>我们下面来看一个Go使用goroutine的例子:如果使用递归的方法来计算斐波那契数45
会是非常慢的一个过程,为了不让用户以为程序已经死掉了,我们使用另外一个goroutine
来打印"正在运算的提示符"
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">spinner</span><span style="color: #b58900;">(</span>100 * time.Microsecond<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">const</span> n = 45
        fibN := <span style="color: #268bd2;">fib</span><span style="color: #b58900;">(</span>n<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"\rFibonacci(%d) = %d\n"</span>, n, fibN<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">spinner</span><span style="color: #2aa198;">(</span>delay <span style="color: #b58900;">time.Duration</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, r := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #2aa198;">`-\|/`</span> <span style="color: #268bd2;">{</span>
                        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"\r%c\n"</span>, r<span style="color: #6c71c4;">)</span>
                        time.<span style="color: #268bd2;">Sleep</span><span style="color: #6c71c4;">(</span>delay<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>

        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">fib</span><span style="color: #2aa198;">(</span>x <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> x &lt; 2 <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> x
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">fib</span><span style="color: #b58900;">(</span>x-1<span style="color: #b58900;">)</span> + <span style="color: #268bd2;">fib</span><span style="color: #b58900;">(</span>x-2<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>fib(45)会经过非常长的时间才会返回,在这期间,另外一个goroutine会每隔0.1秒就打
印一组"正在运行的提示".而当main goroutine计算完fib(45)并打印结果后,它自己会
返回.注意!当main goroutine返回的时候,所有其他的goroutine都会立马结束!
</li>
<li>上面的情况下,我们可以说main goroutine通过返回的方式来关闭了其他的goroutine,
还有一种方式就是某一个goroutine可能会exit整个process,这样一来,其他的goroutine
也就不得不返回了.这是仅有的两种"关闭其他goroutine"的方法.Go里面不存在其他关
闭其他goroutine的方法.但是后面我们会看到,一个goroutine可以request其他goroutine
关闭.当然听不听是另外一回事了
</li>
<li>本节的例子其实就是把如下两个activity进行了compose:
<ul class="org-ul">
<li>spinning
</li>
<li>Fibonacci computation
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">Example: Concurrent Clock Server</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>网络是一个天然的使用concurrency的difang,yinwserver就是默认要同时处理多个不同
的client发来的connection,而且每个client都是相互独立的.(如果从http协议的角度
上来看,甚至每个connection都是独立的)
</li>
<li>前面我们介绍过net/http package,为我们提供了HTTP的网络的函数.这里我们会使用net
package,它会提供更多网络连接的函数,比如:
<ul class="org-ul">
<li>TCP socket
</li>
<li>UDP socket
</li>
<li>Unix domain socket
</li>
</ul>
</li>
<li>首先,我们来看看一个"反例":一个线性的clock server: sequential clock server
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"io"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"net"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        listener, err := net.<span style="color: #268bd2;">Listen</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"tcp"</span>, <span style="color: #2aa198;">"localhost:8000"</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                conn, err := listener.<span style="color: #268bd2;">Accept</span><span style="color: #268bd2;">()</span>
                <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        log.<span style="color: #268bd2;">Print</span><span style="color: #6c71c4;">(</span>err<span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">continue</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #268bd2;">handleConn</span><span style="color: #268bd2;">(</span>conn<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">handleConn</span><span style="color: #2aa198;">(</span>c <span style="color: #b58900;">net.Conn</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">defer</span> c.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                _, err := io.<span style="color: #268bd2;">WriteString</span><span style="color: #268bd2;">(</span>c, time.<span style="color: #268bd2;">Now</span><span style="color: #6c71c4;">()</span>.<span style="color: #268bd2;">Format</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"15:04:05\n"</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">e.g., client disconnected</span>
                <span style="color: #268bd2;">}</span>
                time.<span style="color: #268bd2;">Sleep</span><span style="color: #268bd2;">(</span>1 * time.Second<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>每当有client连接到这个server,这个server会每一秒都写入一个世界给client.功能
上没有什么问题,它的问题在于:每次只能处理一个connection!
</li>
<li>我们来简单的看个这个例子,这个例子大部分是TCP的知识:
<ul class="org-ul">
<li>net.Listen函数是创建listening socket的函数,返回一个listener object
</li>
<li>listener object调用Accept()之后,会一直block,直到有client来"访问",才会返回
注意,Accept()一旦返回,会返回一个net.Conn类型的object(不再是listening
socket,而是一个connected socket).
</li>
<li>正是因为accepted connection和listening connection不相同,所以我们可以在每个
handleConn里面,上来就defer close这个connectin
</li>
<li>handleConn是一个死循环,退出的唯一可能就是WriteString失败,一般也就是意味着
client主动disconnect
</li>
<li>handleConn里面使用了Time.Format函数,这个函数的参数非常有意思,它是一个example,
这是Go里面特有的:接受一个example来作为参数,这种写法明显比HH/MM的样式要直观
如果我们想加上月份和星期几的时候,直接在例子上加上字符串就可以了.位置随意!
<div class="org-src-container">

<pre class="src src-go">_, err := io.<span style="color: #268bd2;">WriteString</span><span style="color: #2aa198;">(</span>c, time.<span style="color: #268bd2;">Now</span><span style="color: #b58900;">()</span>.<span style="color: #268bd2;">Format</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Mon Jan 15:04:05\n"</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>我们使用netcat命令就可以模仿client的访问
<div class="org-src-container">

<pre class="src src-sh">&gt; nc localhost 8000
13:58:54
13:58:55
13:58:56
</pre>
</div>
</li>
<li>netcat的原理很简单,我们完全可以使用Go来实现一遍(代码中直接写死了8080)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"io"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"net"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        conn, err := net.<span style="color: #268bd2;">Dial</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"tcp"</span>, <span style="color: #2aa198;">"localhost:8000"</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">defer</span> conn.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
        <span style="color: #268bd2;">mustCopy</span><span style="color: #b58900;">(</span>os.Stdout, conn<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">mustCopy</span><span style="color: #2aa198;">(</span>dst <span style="color: #b58900;">io.Writer</span>, src <span style="color: #b58900;">io.Reader</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> _, err := io.<span style="color: #268bd2;">Copy</span><span style="color: #b58900;">(</span>dst, src<span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>同时运行两个netcat1,我们会发现,只有第一个client结束了以后,另外一个client才
能获得时间!效果如下,左右是两个netcat1在运行
<pre class="example">
$ go build gopl.io/ch8/netcat1
$ ./netcat1
13:58:54                   $ ./netcat1
13:58:55
13:58:56
^C
                           13:58:57
                           13:58:58
                           13:58:59
                           ^C
$ killall clock1
</pre>
</li>
<li>在Go里面,我们只需要更改server的其中一行,就能做到把sequential的server变成
concurrent的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">{</span>
        conn, err := listener.<span style="color: #268bd2;">Accept</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Print</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">continue</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">handleConn</span><span style="color: #b58900;">(</span>conn<span style="color: #b58900;">)</span>     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Handle connections Concurrently!</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">Example: Concurrent Echo Server</h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li>前面的例子最后的解决方案是每一个connection使用一个goroutine.每个connection
有一个goroutine是保证server concurrent的基本要求,我们的每个connection也是可
以多于一个goroutine的!因为有些时候业务逻辑比较复杂,一个goroutine无法满足要求
本章的echo server就是这样一个例子
</li>
<li>普通的echo server业务逻辑没有那么复杂,它只是把client写入的内容,写回去代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">handleConn</span><span style="color: #2aa198;">(</span>c <span style="color: #b58900;">net.Conn</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        io.<span style="color: #268bd2;">Copy</span><span style="color: #b58900;">(</span>c, c<span style="color: #b58900;">)</span>           <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: ignoring errors</span>
        c.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们这里的"需要多个goroutine"的echo server显然在逻辑上要麻烦一点,我们返回某
个字符串的三个版本:
<ul class="org-ul">
<li>首先返回一个大写版本,比如"HELLO"
</li>
<li>然后过一会返回原始版本"Hello"
</li>
<li>再过一会返回全小写版本"hello".
</li>
</ul>
</li>
<li>一个最简单的server代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"bufio"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"net"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"strings"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        listener, err := net.<span style="color: #268bd2;">Listen</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"tcp"</span>, <span style="color: #2aa198;">"localhost:8000"</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                conn, err := listener.<span style="color: #268bd2;">Accept</span><span style="color: #268bd2;">()</span>
                <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        log.<span style="color: #268bd2;">Print</span><span style="color: #6c71c4;">(</span>err<span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">continue</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">handleConn</span><span style="color: #268bd2;">(</span>conn<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">echo</span><span style="color: #2aa198;">(</span>c <span style="color: #b58900;">net.Conn</span>, shout <span style="color: #b58900;">string</span>, delay <span style="color: #b58900;">time.Duration</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Fprintln</span><span style="color: #b58900;">(</span>c, <span style="color: #2aa198;">"\t"</span>, strings.<span style="color: #268bd2;">ToUpper</span><span style="color: #268bd2;">(</span>shout<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        time.<span style="color: #268bd2;">Sleep</span><span style="color: #b58900;">(</span>delay<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Fprintln</span><span style="color: #b58900;">(</span>c, <span style="color: #2aa198;">"\t"</span>, shout<span style="color: #b58900;">)</span>
        time.<span style="color: #268bd2;">Sleep</span><span style="color: #b58900;">(</span>delay<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Fprintln</span><span style="color: #b58900;">(</span>c, <span style="color: #2aa198;">"\t"</span>, strings.<span style="color: #268bd2;">ToLower</span><span style="color: #268bd2;">(</span>shout<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">handleConn</span><span style="color: #2aa198;">(</span>c <span style="color: #b58900;">net.Conn</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        input := bufio.<span style="color: #268bd2;">NewScanner</span><span style="color: #b58900;">(</span>c<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> input.<span style="color: #268bd2;">Scan</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">echo</span><span style="color: #268bd2;">(</span>c, input.<span style="color: #268bd2;">Text</span><span style="color: #6c71c4;">()</span>, 1*time.Second<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        c.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>client也要有相应的变化,就是要处理从stdin写入的数据到connection,然后要把connection
接受到的数据写给stdout,这里(netcat2)我们再次回用到goroutine
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"io"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"net"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        conn, err := net.<span style="color: #268bd2;">Dial</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"tcp"</span>, <span style="color: #2aa198;">"localhost:8000"</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">defer</span> conn.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">mustCopy</span><span style="color: #b58900;">(</span>os.Stdout, conn<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">mustCopy</span><span style="color: #b58900;">(</span>conn, os.Stdin<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">mustCopy</span><span style="color: #2aa198;">(</span>dst <span style="color: #b58900;">io.Writer</span>, src <span style="color: #b58900;">io.Reader</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> _, err := io.<span style="color: #268bd2;">Copy</span><span style="color: #b58900;">(</span>dst, src<span style="color: #b58900;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>好了,我们来测试下效果(下面左边是client的输入,靠右的是server的返回)
<pre class="example">
$ go build gopl.io/ch8/reverb1
$ ./reverb1 &amp;
$ go build gopl.io/ch8/netcat2
$ ./netcat2
Hello?
     HELLO?
     Hello?
     hello?
Is there anybody there?
     IS THERE ANYBODY THERE?
Yooo-hooo!
     Is there anybody there?
     is there anybody there?
     YOOO-HOOO!
     Yooo-hooo!
     yooo-hooo!
^D
$ killall reverb1
</pre>
</li>
<li>我们会看到非常奇怪的现象:第三个shout要等到第二个shout处理完才能进行,这显然是
不合理的,因为我们的client处理又被"线性化"了.而一个real echo是三次shout相互
之间必须是independent的,而不能"必须一起处理",而block其他的shout(因为我们所有
的输入是在同一个client里面,所以go handleConn是无法分出其他的goroutine的).
</li>
<li>所以,我们要做的,就是把三次shout处理"独立化",方法还是使用go:让处理每次stdin
的输入有有个自己的goroutine
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">handleConn</span><span style="color: #2aa198;">(</span>c <span style="color: #b58900;">net.Conn</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        input := bufio.<span style="color: #268bd2;">NewScanner</span><span style="color: #b58900;">(</span>c<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> input.<span style="color: #268bd2;">Scan</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">echo</span><span style="color: #268bd2;">(</span>c, input.<span style="color: #268bd2;">Text</span><span style="color: #6c71c4;">()</span>, 1*time.Second<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        c.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4">Channels</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li>如果说goroutine是Go program里面的"并行"的activity的话,那么channel就是和这些
activity之间的connection
</li>
<li>Channel是让一个goroutine传递数据给另外一个goroutine的"通信手段"(communication
mechanism)
</li>
<li>channel这个名字非常形象化,更形象的是每个channel都是有类型的.换句话说就是在
某种类型的channel里面只能传递某种类型的数据. channel的类型叫做element type.
element的写法是chan typex. chan typex类型的channel只能传递typex
</li>
<li>chan int类型channel的创建方法如下
<div class="org-src-container">

<pre class="src src-go">ch := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ch has type 'chan int'</span>
</pre>
</div>
</li>
<li>channel是reference类型(所有可以使用make创建的类型都是reference类型),既然是
reference类型,那么就都满足如下特点:
<ul class="org-ul">
<li>拷贝或者传递数据的时候,拷贝的和被拷贝的都会指向同一个data structure
</li>
<li>reference 类型zero value是nil
</li>
<li>两个element type相同的channel可以相互比较,使用==.如果两者指向同一个data
structure,那么==结果为true,否则为false
</li>
</ul>
</li>
<li>channel有两个主要的操作.叫做send和receive.其实说这是channel的操作有点"不正
确",因为在这两个动作里面,channel都是作为"被动接受者".
<ul class="org-ul">
<li>send a statement,其实是"变量"send一个statement给channel, send这个动作是变
量做出来的
<div class="org-src-container">

<pre class="src src-go">ch &lt;- x
</pre>
</div>
</li>
<li>receive expression,,其实是"变量"receive一个expression,receive这个动作也是
变量来"receive"
<div class="org-src-container">

<pre class="src src-go">x = &lt;- ch
</pre>
</div>
</li>
<li>receive statement也可以直接丢弃result
<div class="org-src-container">

<pre class="src src-go">&lt;- ch
</pre>
</div>
</li>
</ul>
</li>
<li>channel还接受第三种操作,就是close.一旦close一个channel以后:
<ul class="org-ul">
<li>其他变量不可以再send statement给这个channel
</li>
<li>其他变量可以再receive statement,直到这个channel里面没有value可以在读取了.
在没有了value之后,再次读取的话,会马上返回zero value
</li>
<li>close的方法如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #657b83; font-weight: bold;">close</span><span style="color: #2aa198;">(</span>ch<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>make()使用一个参数来创建channel的方法,创建出来的是unbuffered channel,也就是
buffer size为0,换句话说如下两句等价
<div class="org-src-container">

<pre class="src src-go">ch = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>             <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">unbuffered channel</span>
ch = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span>, 0<span style="color: #2aa198;">)</span>          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">unbuffered channel</span>
</pre>
</div>
</li>
<li>make接受第二个参数来设置channel的capacity,大于零的情况下,就设置了buffer size
的大小
<div class="org-src-container">

<pre class="src src-go">ch = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span>, 3<span style="color: #2aa198;">)</span>          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">buffered channel with capacity 3</span>
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-8-4-1" class="outline-4">
<h4 id="sec-8-4-1">Unbuffered Channels</h4>
<div class="outline-text-4" id="text-8-4-1">
<ul class="org-ul">
<li>当我们(goroutine X)send数据给某个unbuffered channel的时候,我们的goroutineX
会在如下两个时间点之间处于block的状态:
<ul class="org-ul">
<li>我们(goroutine X)成功send数据给channel
</li>
<li>其他goroutine Y成功从这个channl读取(receive)
</li>
</ul>
</li>
<li>一般情况下,我们写代码的时候,会先写其他goroutineY读取(receive)的代码,这个时
候因为channel里面没数据,所以goroutineY也是会block的.但是其他goroutine Block
没有事,我们main goroutine还可以运行.如果反过来先使用main goroutin来send的
话,程序会无限block下去(其实go编译器不会那么傻的,它会报deadlock的错误)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">fetch</span><span style="color: #2aa198;">(</span>ch <span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>

        time.<span style="color: #268bd2;">Sleep</span><span style="color: #b58900;">(</span>4000 * time.Millisecond<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">var</span> ret int

        ret = &lt;-ch
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>ret<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"BEG"</span><span style="color: #b58900;">)</span>
        x := 12
        ch := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        ch &lt;- x
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">fetch</span><span style="color: #b58900;">(</span>ch<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"END"</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">BEG</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fatal error: all goroutines are asleep - deadlock!</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">goroutine 1 [chan send]:</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">main.main()</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">/Users/hfeng/tmp/inf.go:22 +0xef</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">exit status 2</span>
</pre>
</div>
</li>
<li>最经常的写法是调换send和receive的位置(注意,我们这里有两个output,意思是至少
可能有两种不同的输出)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">fetch</span><span style="color: #2aa198;">(</span>ch <span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>

        time.<span style="color: #268bd2;">Sleep</span><span style="color: #b58900;">(</span>4000 * time.Millisecond<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">var</span> ret int

        ret = &lt;-ch
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>ret<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"BEG"</span><span style="color: #b58900;">)</span>
        x := 12
        ch := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">fetch</span><span style="color: #b58900;">(</span>ch<span style="color: #b58900;">)</span>
        ch &lt;- x
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">()</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"END"</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT1===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">BEG</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">END</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">12</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT2===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">BEG</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">12</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">END</span>
</pre>
</div>
</li>
<li>上面的例子告诉我们,在数据传输完之后,两个goroutine可能分别开始运行(或者一个
运行,或者两个都不运行),之后的情况下就依赖编译器等条件了.我们试着试了试main
goroutine比子goroutine多3微妙的情况下,会大概率同时出现"等得到子goroutine"
和"等不及子goroutine"两种情况:
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">fetch</span><span style="color: #2aa198;">(</span>ch <span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>

        <span style="color: #859900; font-weight: bold;">var</span> ret int

        ret = &lt;-ch
        time.<span style="color: #268bd2;">Sleep</span><span style="color: #b58900;">(</span>1000 * time.Millisecond<span style="color: #b58900;">)</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>ret<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"BEG"</span><span style="color: #b58900;">)</span>
        x := 12
        ch := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">fetch</span><span style="color: #b58900;">(</span>ch<span style="color: #b58900;">)</span>
        ch &lt;- x

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"END"</span><span style="color: #b58900;">)</span>
        time.<span style="color: #268bd2;">Sleep</span><span style="color: #b58900;">(</span>1003 * time.Millisecond<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT1===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">BEG</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">END</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT2===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">BEG</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">END</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">12</span>
</pre>
</div>
</li>
<li>但是可以肯定的是:
<ul class="org-ul">
<li>在我们send数据之前, receive肯定是block的
</li>
<li>在我们receive之前,开始的send也肯定是block的
</li>
</ul>
</li>
<li>换句话说,通过unbuffered channel,我们synchronize了如下两个goroutine:
<ul class="org-ul">
<li>sending goroutine
</li>
<li>receive goroutine
</li>
</ul>
</li>
<li>所以unbuffered channel有些时候被称作synchronous channel:其作用概况起来就是
当一个value被发送到unbuffered channel上的时候,可以保证"接受到这个数据"发生
的时间比"发送的goroutine重新苏醒"的时间要早
<pre class="example">
When a value is sent on an unbuffered channel, the receipt of
the value happens before the reawakening of the sending goroutine
</pre>
</li>
<li>在并发编程的语境里面, 'x在y之前发生'并不仅仅意味着x在时间上早于y运行,而是
意味着一种"依赖关系",因为y发生"肯定比x"晚,我们可以把y需要的一些必要的准备
放在x里面,这样当y发生的时候,x已经把它所需要的都准备好了!
</li>
<li>当我们不能保证x一定发生在y之前的时候,我没说x是和y并发发生的
<pre class="example">
x is concurrent with y
</pre>
</li>
<li>x和y是并发的,也不一定说"x和y一定同时发生",而是说y(或者x)不能指望自己的准备
工作让对方来做了,因为咱们谁先开始还不一定呢.
</li>
<li>goroutine x和 goroutin y是并发的,会让他们变的危险,因为他们可能会同时"访问
一块内存",如果有"同步的goroutine存在"我们就需要一些手段来保证同一时刻某块
内存只能有一个goroutine能访问
</li>
<li>unbuffer channel可以synchronize两个goroutine这件事情,可以用来让main goroutine
等待"其他goroutine".main goroutine一旦结束,无论其他goroutine是否运行完毕,程
序都会立刻结束.所以如果我们希望main goroutine等待其他goroutine的话,可以在
main goroutine和其他goroutine直接设置一个unbuffer channel,并且让main goroutine
依赖于其他goroutine
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"io"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        conn, err := net.<span style="color: #268bd2;">Dail</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"tcp"</span>, <span style="color: #2aa198;">"localhost:8000"</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        done := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #268bd2;">{}</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">anyonmous function!</span>
                io.<span style="color: #268bd2;">Copy</span><span style="color: #268bd2;">(</span>os.Stdout, conn<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Note: ignoring errors</span>
                log.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"done"</span><span style="color: #268bd2;">)</span>
                done &lt;- <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #268bd2;">{}{}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">signal the main goroutine</span>
        <span style="color: #b58900;">}()</span>
        <span style="color: #268bd2;">mustCopy</span><span style="color: #b58900;">(</span>conn, os.Stdin<span style="color: #b58900;">)</span>
        conn.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
        &lt;-done <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">wait for background goroutine to finish</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>上面这个例子当用户关闭standard input stream的时候"第二个"mustCopy就返回了,
然后main goroutine开始调用conn.Close()关闭了network connection.这个关闭过
程就是我们常说由client发起的的"四次分手",四次分手其实是:
<ul class="org-ul">
<li>main client首先关闭conn的write half,表示不会再往里面写了,对面的server会
收到FIN也就是end-of-file condition
</li>
<li>然后server收到main client不再写conn的表示后,知道client close了,自己也再
ACK client FIN的同时发送FIN给client,也就关闭了conn的read half.
</li>
<li>然后background goroutine再想去"读取"这个conn的时候,就被告知不行了"read
from closed conneciton error'
</li>
</ul>
</li>
<li>background goroutine的io.Copy失败以后,自然就会返回啦,然后会写入channel里面
一个struct{}{}, main goroutine也就等到结果啦!
</li>
<li>通常来说发往channel里面的message的value都是包含着"通信"的意味,其内容也必然
重要.但是在上述情况下,其实更重要的是这个message发过来了,其value并不重要.换
句话说,这个message只起到了同步的作用,为了强调这一点,我们往往使用一个特殊的
类型struct{}.当然bool或者int也可以.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-4-2" class="outline-4">
<h4 id="sec-8-4-2">Pipelines</h4>
<div class="outline-text-4" id="text-8-4-2">
<ul class="org-ul">
<li>channel可以用来连接goroutines,从而让某个goroutine的输出作为另外一个goroutine
的输入.这叫做pipeline(和bash里面的pipeline很像).下面就是一个这样的例子
<pre class="example">
+---------+             +-----------+              +---------+
| Counter | 0, 1, 2, 3  |  Squarer  |  0, 1, 4, 9  | Printer |
|         |------------&gt;|           |-------------&gt;|         |
+---------+             +-----------+              +---------+
</pre>
</li>
<li>第一个counter goroutine会产生0, 1, 2, 3这些数字,然后发送给第二个squarer
goroutine.
</li>
<li>第二个squarer goroutine会接受counter产生的数字,计算他们的乘方,然后发送给第
三个printer goroutine
</li>
<li>第三个printer goroutine会接受squarer发送的数字,打印到standard output
</li>
<li>代码如下,这个程序会一直打印下去,不会停
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        naturals := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        squares := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Counter</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> x := 0; ; x++ <span style="color: #268bd2;">{</span>
                        naturals &lt;- x
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}()</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Squarer</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #268bd2;">{</span>
                        x := &lt;-naturals
                        squares &lt;- x * x
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}()</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Printer (in main goroutine)</span>

        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>&lt;-squares<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">16</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">25</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">36</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">49</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">64</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">81</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
</pre>
</div>
</li>
<li>有时候我们产生的数字是有限的,那么我们就不需要一直运行下去."不再想往某个
channel里面传输数据"这件事情,可以使用close(chanelVar)来做到,一旦close了某个
channel:
<ul class="org-ul">
<li>继续向这个channel写数据的话,程序会panic
</li>
<li>channel里面该读取的数据读取完了以后,再次读取,总是会读到zero value
</li>
</ul>
</li>
<li>读到zero value这件事情,其实并不能说明什么.如下例,虽然后面一直读到0,但是第一
次也是读到了0啊,不能说读到零就有错误
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        naturals := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        squares := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Counter</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> x := 0; x &lt; 11; x++ <span style="color: #268bd2;">{</span>
                        naturals &lt;- x
                <span style="color: #268bd2;">}</span>
                <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #268bd2;">(</span>naturals<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}()</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Squarer</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #268bd2;">{</span>
                        x := &lt;-naturals
                        squares &lt;- x * x
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}()</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Printer (in main goroutine)</span>

        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>&lt;-squares<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">16</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">25</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">36</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">49</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">64</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">81</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
</pre>
</div>
</li>
<li>一个可能的方案是传递两个value给channel,第二个value来判断是否channel已经被
closed
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Squarer</span>
<span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                x, ok := &lt;- naturals
                <span style="color: #859900; font-weight: bold;">if</span> !ok <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">break</span>   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">channel was closed and drained</span>
                <span style="color: #268bd2;">}</span>
                squares &lt;- x * x
        <span style="color: #b58900;">}</span>
        <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #b58900;">(</span>squares<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}()</span>
</pre>
</div>
</li>
<li>但是显然这样太麻烦了,而且"读取一个channel直到其被close"是如此的常用,以至于
go内置了这个feature,让range能够操作channel,range循环结束的条件就是channel
被关闭了.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        naturals := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        squares := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Counter</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> x := 0; x &lt; 11; x++ <span style="color: #268bd2;">{</span>
                        naturals &lt;- x
                <span style="color: #268bd2;">}</span>
                <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #268bd2;">(</span>naturals<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}()</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Squarer</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> x := <span style="color: #859900; font-weight: bold;">range</span> naturals <span style="color: #268bd2;">{</span>
                        squares &lt;- x * x
                <span style="color: #268bd2;">}</span>
                <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #268bd2;">(</span>squares<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}()</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Printer (in main goroutine)</span>
        <span style="color: #859900; font-weight: bold;">for</span> x := <span style="color: #859900; font-weight: bold;">range</span> squares <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>x<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">16</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">25</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">36</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">49</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">64</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">81</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100</span>
</pre>
</div>
</li>
<li>channel并不是像"打开的文件描述符"一样是一个必须要close的资源.你close一个
channel并不是说想释放资源,而是想告诉receiving goroutine,所有的数据已经传输
完毕
</li>
<li>所有试图close一个already-closed channel的行为都会panic,close一个nil channel
也会panic
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-4-3" class="outline-4">
<h4 id="sec-8-4-3">Unidirectional Channel Types</h4>
<div class="outline-text-4" id="text-8-4-3">
<ul class="org-ul">
<li>随着程序规模的增加,我们会把程序分成多个部分.上面的例子是把程序的逻辑分成了
三个goroutine,然后通过两个channel通信,是这两个channel是main的local variable
</li>
<li>我们也可以把上面的三个步骤直接设计成函数
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">counter</span><span style="color: #2aa198;">(</span>out <span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">squarter</span><span style="color: #2aa198;">(</span>out, in <span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">printer</span><span style="color: #2aa198;">(</span>in <span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>我们发现,来来回回,就两个channel,在squarter里面有清晰的表述:
<ul class="org-ul">
<li>in channel:负责从这个channel读取
</li>
<li>out chan:负责写入到这个channel
</li>
</ul>
</li>
<li>它们的名字很清晰的告诉了我们这一点,in就是读取的,out就是写入的.但这只是习惯
上的约束,你还是可以从out读取,从in写入.
</li>
<li>因为这种情况非常常见,Go把这种"名字上的约束"转换成了"编译器的约束":只暴露channel
的send或者receive操作.注意这里用的是暴露,指的是使用编译器的力量来检查某些
channel变量(reference)只能读取或者写入.但是这些channel的实例(instance)在别
的,不受控制的环境下,还是可以"既读取,又写入"
<pre class="example">
Go type system provides unidirectional channel types that expose only one or
the other of the send and receive operations.
</pre>
</li>
<li>这两种unidirectional channel类型分别是:
<ul class="org-ul">
<li>send-only channel int如下.这种只能send,但是不能receive,如果试图从这个channel
里面receive的话,会在compile time就报错.send-only channel也是可以被closed,
因为close的定义就是:不允许向channel send更多的数据
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">chan</span>&lt;- <span style="color: #b58900;">int</span>
</pre>
</div>
</li>
<li>receive-only channel int如下.这种只能receive,但是不能send,如果试图send到
这个channel的话,会在compile time报错.receive-only channel是不可以被close
的,一旦试图close receive-only channel也是会触发compile time error
<div class="org-src-container">

<pre class="src src-go">&lt;-<span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span>
</pre>
</div>
</li>
</ul>
</li>
<li>例子如下.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">counter</span><span style="color: #2aa198;">(</span>out <span style="color: #859900; font-weight: bold;">chan</span>&lt;- <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> x := 0; x &lt; 10; x++ <span style="color: #b58900;">{</span>
                out &lt;- x
        <span style="color: #b58900;">}</span>
        <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #b58900;">(</span>out<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">squarer</span><span style="color: #2aa198;">(</span>out <span style="color: #859900; font-weight: bold;">chan</span>&lt;- <span style="color: #b58900;">int</span>, in &lt;-<span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> v := <span style="color: #859900; font-weight: bold;">range</span> in <span style="color: #b58900;">{</span>
                out &lt;- v * v
        <span style="color: #b58900;">}</span>
        <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #b58900;">(</span>out<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">printer</span><span style="color: #2aa198;">(</span>in &lt;-<span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> v := <span style="color: #859900; font-weight: bold;">range</span> in <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>v<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        naturals := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        squares := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">counter</span><span style="color: #b58900;">(</span>naturals<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">squarer</span><span style="color: #b58900;">(</span>squares, naturals<span style="color: #b58900;">)</span>
        <span style="color: #268bd2;">printer</span><span style="color: #b58900;">(</span>squares<span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">16</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">25</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">36</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">49</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">64</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">81</span>
</pre>
</div>
</li>
<li>一个非常值得注意的地方是从bidirectional到unidirectional channel是默认允许的
而且不需要显式转换的,但是从unidirectional channel到bidirectional channel的
转换是不允许的!
<pre class="example">
Conversions from bidirectional to unidirectional channel types
are permitted in any assignment. There is no going back, however:
once you have a value of a unidirectional type such as chan&lt;- int,
there is no way to obtain from it a value fo type chan int that
refers to the same channel data structure
</pre>
</li>
</ul>
</div>
</div>
























































































































<div id="outline-container-sec-8-4-4" class="outline-4">
<h4 id="sec-8-4-4">Buffered Channels</h4>
<div class="outline-text-4" id="text-8-4-4">
<ul class="org-ul">
<li>既然说到了unbuffered channel,那就有必要再说说buffered channel,buffered channel
的size是在创建的时候通过make的第二个参数来决定的,比如创建一个三个string容
量的buffer,方法如下
<div class="org-src-container">

<pre class="src src-go">ch = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">string</span>, 3<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>创建完之后,其情况如下
<pre class="example">
              +---+---+---+
         +--&gt; | / | / | / |
         |    +---+---+---+
+---+    |
|ch |----+
+---+
</pre>
</li>
<li>创建channel完之后,我们可以通过send向channel发送数据.注意,数据是以"先进先出"
的方式加入到channel的buffer里面的,换句话说channel的buffer的一个queue结构,
我们试着写入三个字符串
<div class="org-src-container">

<pre class="src src-go">ch &lt;- <span style="color: #2aa198;">"A"</span>
ch &lt;- <span style="color: #2aa198;">"B"</span>
ch &lt;- <span style="color: #2aa198;">"C"</span>
</pre>
</div>
</li>
<li>这个时候channel的buffer已经满了,其状态为
<pre class="example">
              +---+---+---+
         +--&gt; |"A"|"B"|"C"|
         |    +---+---+---+
+---+    |
|ch |----+
+---+
</pre>
</li>
<li>在这个状态下,继续send就会block,如果我们receive一个,代码如下
<div class="org-src-container">

<pre class="src src-go">fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>&lt;-ch<span style="color: #2aa198;">)</span>               <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"A"</span>
</pre>
</div>
</li>
<li>这个时候属于既不full,也不empty的状态,如下
<pre class="example">
              +---+---+---+
         +--&gt; |"B"|"C"| / |
         |    +---+---+---+
+---+    |
|ch |----+
+---+
</pre>
</li>
<li>这种状态下,无论是send还是receive都不会block了.channel就是通过这种方式"解耦
了"sending goroutine和receiving goroutine
</li>
<li>很少的情况下,程序需要知道channel的buffer大小.方法是
<div class="org-src-container">

<pre class="src src-go">fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">cap</span><span style="color: #b58900;">(</span>ch<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"3"</span>
</pre>
</div>
</li>
<li>而len()返回的则是"当前"channel里面元素的个数.注意!因为是在并发的情况下,所以
这个统计是刚产生出来,就马上过期的,所以是不准确的.只有在某些特定的情况下会
使用
<div class="org-src-container">

<pre class="src src-go">fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>ch<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"2"</span>
</pre>
</div>
</li>
<li>我们继续receive,当receive到第四个的时候,因为buffer已经空了,所以继续receive
是会继续block
<div class="org-src-container">

<pre class="src src-go">fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>&lt;-ch<span style="color: #2aa198;">)</span>               <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"B"</span>
fmt.<span style="color: #268bd2;">Println</span><span style="color: #2aa198;">(</span>&lt;-ch<span style="color: #2aa198;">)</span>               <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"C"</span>
</pre>
</div>
</li>
<li>在这个例子里面,send和receive operation都发生在一个goroutine里面,但是在真实
的程序里面,send和receive通常是在不同的goroutine里面完成的.新手容易犯的一个
错误,就是把buffered channel在某一个goroutine里面当做queue来使用.但这是一个
错误的用法
<pre class="example">
It is a mistake to use buffered channels within a single goroutine
as a queue
</pre>
</li>
<li>错误的原因在于,channel是和goroutine scheduling紧密联系的,如果没有另外的
goroutine对channel进行receiving操作,那么sender goroutine就有可能会变成永远
的block!
</li>
<li>正确的用法是使用slice来作为"先进先出"的queue就可以了.
</li>
<li>下面的例子展示了一个buffered channel的用法.这个程序会"同时"发送request到不
同的三个mirror(内容相同但是地理位置不同的server叫mirror).这三个request的
response会send到一个叫做`responses`的buffered channel.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">mirroredQuery</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        responses := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">string</span>, 3<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> responses &lt;- <span style="color: #268bd2;">request</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"asia.gopl.io"</span><span style="color: #268bd2;">)</span> <span style="color: #b58900;">}()</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> responses &lt;- <span style="color: #268bd2;">request</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"europe.gopl.io"</span><span style="color: #268bd2;">)</span> <span style="color: #b58900;">}()</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> responses &lt;- <span style="color: #268bd2;">request</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"americas.gopl.io"</span><span style="color: #268bd2;">)</span> <span style="color: #b58900;">}()</span>
        <span style="color: #859900; font-weight: bold;">return</span> &lt;-responses
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">request</span><span style="color: #2aa198;">(</span>hostname <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>respose <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>buffered channel只会返回第一个(也就是返回速度最快的那个!)这样我们可以做到
其他的mirror test还没完成的时候,我们的mirroredQuery()函数已经返回了!如果有
些mirror特别慢的话,这个特性就会非常的有用!
<pre class="example">
mirroredQuery returns a result even before the two slower servers
have responded.
</pre>
</li>
<li>如果我们这里使用了unbuffered的话,我们会造成非常严重的后果:goroutine leak,
go虽然是自动回收内存,但是很多其他资源,比如文件描述符,数据库句柄是无法自动释
放的,需要手动close.这里的goroutine虽然不需要手动close,但是却要保证没有goroutine
一直在block
</li>
<li>换句话说,我们有三个goroutine朝一个unbuffered channel里面send,而最终只receive
了一次,那么另外两个goroutine肯定是一直block在那里,goroutine肯定也是无法释放
的,这就造成了leak
</li>
<li>编程的时候选择buffer或是unbuffered channel,需要知道两者的本质:
<ul class="org-ul">
<li>unbuffered channel为send和receive增加了同步保证,事实上是耦合了两者
</li>
<li>buffered channel解耦了send和receive操作
</li>
</ul>
</li>
<li>如果用channel来连接不同的goroutine,只有每个goroutine都有相同的"速率"最终才
能产生类似流水线的效果
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5">Looping in Parallel</h3>
<div class="outline-text-3" id="text-8-5">
<ul class="org-ul">
<li>这一节我们主要考虑一些常见的和循环相关的concurrency pattern
</li>
<li>下面的API是把一个full-size的图片转换成thumbnail-size的图片,API实现的细节和
本节内容没关系,先不写
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> thumbnail

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ImageFile reads an image from infile and writes</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">a thumbnail-size version of it in the same directory.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">It returns the generated file name, e.g., "foo.thumb.jpg".</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">ImageFile</span><span style="color: #2aa198;">(</span>infile <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">string</span>, <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>最简单处理一系列image file的方法是使用循环
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">makeThumbnails makes thumbnails of the specified files.</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">makeThumbnails</span><span style="color: #2aa198;">(</span>filesnames <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, f := <span style="color: #859900; font-weight: bold;">range</span> filenames <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> _, err := thumbnail.<span style="color: #268bd2;">ImageFile</span><span style="color: #268bd2;">(</span>f<span style="color: #268bd2;">)</span>; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        log.<span style="color: #268bd2;">Println</span><span style="color: #6c71c4;">(</span>err<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>很明显的是,我们处理图片的顺序,是没有关系的.谁先处理,谁后处理都不会影响最后
的结果.这种子问题之间相互独立的问题叫做embarrassingly parallel
<pre class="example">
Problems like this that consist entirely of subproblems that are
completely independent of each other are described as embarrassingly
parallel
</pre>
</li>
<li>embarrassingly parallel 问题是最简单的并发问题,在多核的情况下,性能能够得到
线性的提升
</li>
<li>我们先来看看最naive的改法,把每个处理函数都变成一个goroutine
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: incorect!</span>
<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">"gopl.io/ch8/thumbnail"</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">makeThumbnails</span><span style="color: #2aa198;">(</span>filenames <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, f := <span style="color: #859900; font-weight: bold;">range</span> filenames <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">go</span> thumbnail.<span style="color: #268bd2;">ImageFile</span><span style="color: #268bd2;">(</span>f<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: ignoring errors</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个解法运行的特别快,快到即便filenames里面只有一个成员的话,还是比上个版本快
得多.细心的人发现了这肯定里面有问题.
</li>
<li>问题就是这个解法错了,错在为每个函数创建了一个goroutine以后,main函数就返回了
并没有等待它创建的goroutine完成!
</li>
<li>因为goroutine不是thread,所以,并没有直接的方法让main函数来等待goroutine完成
在go里面,能够做到这一点(goroutine之间通信)的,只能是channel.所以我们申请一个
unbuffered channel,然后每个goroutine写入channel,最后channel receive 一个特定
的次数:len(filename)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">makeThumbnails makes thumbnails of the specified files in parallel.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">makeThumbnails3</span><span style="color: #2aa198;">(</span>filenames <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        ch := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #268bd2;">{}</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, f := <span style="color: #859900; font-weight: bold;">range</span> filenames <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">(</span>f <span style="color: #b58900;">string</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        thumbnail.<span style="color: #268bd2;">ImageFiles</span><span style="color: #6c71c4;">(</span>f<span style="color: #6c71c4;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Note ignoring errors</span>
                        ch &lt;= <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #6c71c4;">{}{}</span>
                <span style="color: #268bd2;">}(</span>f<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">wait for goroutines to complete</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #859900; font-weight: bold;">range</span> filenames <span style="color: #b58900;">{</span>
                &lt;-ch
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>注意,我们这里的goroutine的函数是有参数的(f string), 而不是像下面这样之间把
f作为匿名函数的参赛传递进去,因为这会导致问题(只处理最后一个, 我们在5.6.1部分
讲过)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: incorrect</span>
<span style="color: #859900; font-weight: bold;">for</span> _, f := <span style="color: #859900; font-weight: bold;">range</span> filenames <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                thumbnail.<span style="color: #268bd2;">ImageFile</span><span style="color: #268bd2;">(</span>f<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: incorrect!</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
        <span style="color: #b58900;">}()</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>好的,我们暂时获得了一个比较正确的版本.然后,新的需求来了,我们需要把每个worker
的错误信息返回到main.这种情况下,很容易犯错误,因为unbuffered channel满足不了
需求了.下面就是一个典型的错误做法.因为一旦出现了一个error,那么函数就返回了,
所以在循环体里面的&lt;-errors就再也不允许了,那么unbuffered channel就一直无法让
其他的goroutine send入了
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">makeThumbnails4 makes thumbnails for the specified files in paralles.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">It returns an error if any step failed.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">makeThumbnails4</span><span style="color: #2aa198;">(</span>filenames <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #b58900;">error</span> <span style="color: #2aa198;">{</span>
        errors := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">error</span><span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">for</span> _, f := <span style="color: #859900; font-weight: bold;">range</span> filenames <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">(</span>f <span style="color: #b58900;">string</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        _, err := thumbnail.<span style="color: #268bd2;">ImageFile</span><span style="color: #6c71c4;">(</span>f<span style="color: #6c71c4;">)</span>
                        errors &lt;- err
                <span style="color: #268bd2;">}(</span>f<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #859900; font-weight: bold;">range</span> filenames <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> err := &lt;- errors; err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">return</span> err <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: incorrect: goroutine leak!</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>解决的办法自然是使用buffered channel啦,就算是中途退出了,其他的goroutine也可
以最终把自己的结果都发送到buffered channel里面,不至于leak goroutine.buffer
的大小就按照最多的情况考虑,filenames的length
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">makeThumbnails5 makes thumbnails for the specified files in paralles.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">It returns the generated file names in an arbitrary order,</span>
<span style="color: #93a1a1;">//  </span><span style="color: #93a1a1;">or an error if any step failed.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">makeThumbnails5</span><span style="color: #2aa198;">(</span>filenames <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">(</span>thumbfiles <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>, err <span style="color: #b58900;">error</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">item</span> <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">{</span>
                thumbfile string
                err       error
        <span style="color: #b58900;">}</span>

        ch :=  <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #b58900;">ch</span> item, <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #268bd2;">(</span>filenames<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, f := <span style="color: #859900; font-weight: bold;">range</span> filenames <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">(</span>f <span style="color: #b58900;">string</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">var</span> it item
                        it.thumbfile, it.err = thumbnail.<span style="color: #268bd2;">ImageFile</span><span style="color: #6c71c4;">(</span>f<span style="color: #6c71c4;">)</span>
                        ch &lt;- it
                <span style="color: #268bd2;">}(</span>f<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #859900; font-weight: bold;">range</span> filenames <span style="color: #b58900;">{</span>
                it := &lt;- ch
                <span style="color: #859900; font-weight: bold;">if</span> it.err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>, it.err
                <span style="color: #268bd2;">}</span>
                thumbfiles = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #268bd2;">(</span>thumbfiles, it.thumbfile<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> thumbfiles, <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>好了,我们的代码又比较完善了,但是这个时候.新的需求又来了:我们不知道有多少的
image file等待处理,所以不能通过slice来传递fileName给我了,而是通过一个channel
来传递.
</li>
<li>所以这个问题的关键就转换为我们如何记录channel传递来了多少的fileName.这明显是
一个counter,但是我们肯定不可以使用简单的counter,因为这是多goroutine的环境下
面.所以我们的选择是sync.WatiGroup.它的特点就是
<pre class="example">
A counter that can be safely manipulated from multiple goroutines
and that provides a way to wait until it becomes zero
</pre>
</li>
<li>代码如下
</li>
<li>我们看到这个代码的特点, 这些特点适用于处理所有的"不知道数目的loop"的并发操作:
<ul class="org-ul">
<li>Add是用来增加counter的,它必须在worker goroutine开始之前调用.因为我们要保
证在wg.Wait()之前Add
</li>
<li>Add有参数1,但是Done却没有参数, 没有参数的Done等同于Add(-1)
</li>
<li>我们用defer来保证即便出现了error,我们的counter也能够decrement
</li>
</ul>
</li>
<li>我们新的函数需要返回处理的所有的文件的size,我们是通过一个channel(sizes)来统
计这些信息的.最后通过一个range来读取全部的size
</li>
<li>我们还要注意的是,我们的closer goroutine是:
<ol class="org-ol">
<li>先Wait(),然后close(sizes)
</li>
<li>closer goroutine必须和loop over size做到并行
</li>
</ol>
</li>
<li>这两部都是必须的,因为:
<ol class="org-ol">
<li>如果wait在main goroutine里面,并且在loop前面,那么这个函数会死循环, 因为defer
wg Done()这一句要等待sizes&lt;-完成.但是你在main里面确先要Wait(),然后才close()
所以这两个条件的顺序反了,会发生deadlock
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"sync"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        arr := <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2, 3, 4<span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">var</span> wg sync.WaitGroup
        sizes := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, a := <span style="color: #859900; font-weight: bold;">range</span> arr <span style="color: #b58900;">{</span>
                wg.<span style="color: #268bd2;">Add</span><span style="color: #268bd2;">(</span>1<span style="color: #268bd2;">)</span>

                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">worker</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">(</span>a <span style="color: #b58900;">int</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">defer</span> wg.<span style="color: #268bd2;">Done</span><span style="color: #6c71c4;">()</span>
                        log.<span style="color: #268bd2;">Printf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"%d\n"</span>, a<span style="color: #6c71c4;">)</span>
                        sizes &lt;- a
                <span style="color: #268bd2;">}(</span>a<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        wg.<span style="color: #268bd2;">Wait</span><span style="color: #b58900;">()</span>
        <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #b58900;">(</span>sizes<span style="color: #b58900;">)</span>

        <span style="color: #859900; font-weight: bold;">var</span> total int
        <span style="color: #859900; font-weight: bold;">for</span> size := <span style="color: #859900; font-weight: bold;">range</span> sizes <span style="color: #b58900;">{</span>
                total += size
        <span style="color: #b58900;">}</span>
        log.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s at %d\n"</span>, <span style="color: #2aa198;">"finish"</span>, total<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:03:17 4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:03:17 3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:03:17 1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:03:17 2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fatal error: all goroutines are asleep - deadlock!</span>
</pre>
</div>
</li>
<li>如果wait在main goroutine里面,并且在loop后面,那么这个代码就永远不会触及到:
因为关闭(close(sizes))的代码再后面,这个channel永远不会关闭,那么range也就
无法完成(没关闭怎么知道一共有多少)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"sync"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        arr := <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2, 3, 4<span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">var</span> wg sync.WaitGroup
        sizes := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, a := <span style="color: #859900; font-weight: bold;">range</span> arr <span style="color: #b58900;">{</span>
                wg.<span style="color: #268bd2;">Add</span><span style="color: #268bd2;">(</span>1<span style="color: #268bd2;">)</span>

                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">worker</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">(</span>a <span style="color: #b58900;">int</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">defer</span> wg.<span style="color: #268bd2;">Done</span><span style="color: #6c71c4;">()</span>
                        log.<span style="color: #268bd2;">Printf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"%d\n"</span>, a<span style="color: #6c71c4;">)</span>
                        sizes &lt;- a
                <span style="color: #268bd2;">}(</span>a<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">var</span> total int
        <span style="color: #859900; font-weight: bold;">for</span> size := <span style="color: #859900; font-weight: bold;">range</span> sizes <span style="color: #b58900;">{</span>
                total += size
        <span style="color: #b58900;">}</span>

        wg.<span style="color: #268bd2;">Wait</span><span style="color: #b58900;">()</span>
        <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #b58900;">(</span>sizes<span style="color: #b58900;">)</span>
        log.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s at %d\n"</span>, <span style="color: #2aa198;">"finish"</span>, total<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:03:40 4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:03:40 1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:03:40 2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:03:40 3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fatal error: all goroutines are asleep - deadlock!</span>
</pre>
</div>
</li>
<li>即便使用了go func来做closer goroutine,那么也需要在range sizes之前,因为在
range sizes的后面的话,因为closer goroutine在后面,range size不完的话,closer
goroutine根本无法启动嘛!
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"sync"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        arr := <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2, 3, 4<span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">var</span> wg sync.WaitGroup
        sizes := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, a := <span style="color: #859900; font-weight: bold;">range</span> arr <span style="color: #b58900;">{</span>
                wg.<span style="color: #268bd2;">Add</span><span style="color: #268bd2;">(</span>1<span style="color: #268bd2;">)</span>

                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">worker</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">(</span>a <span style="color: #b58900;">int</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">defer</span> wg.<span style="color: #268bd2;">Done</span><span style="color: #6c71c4;">()</span>
                        log.<span style="color: #268bd2;">Printf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"%d\n"</span>, a<span style="color: #6c71c4;">)</span>
                        sizes &lt;- a
                <span style="color: #268bd2;">}(</span>a<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">var</span> total int
        <span style="color: #859900; font-weight: bold;">for</span> size := <span style="color: #859900; font-weight: bold;">range</span> sizes <span style="color: #b58900;">{</span>
                total += size
        <span style="color: #b58900;">}</span>

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"can not go here"</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                wg.<span style="color: #268bd2;">Wait</span><span style="color: #268bd2;">()</span>
                <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #268bd2;">(</span>sizes<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}()</span>
        log.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s at %d\n"</span>, <span style="color: #2aa198;">"finish"</span>, total<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:05:56 2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:05:56 4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:05:56 3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:05:56 1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fatal error: all goroutines are asleep - deadlock!</span>
</pre>
</div>
</li>
<li>正确的简化例子应该如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"sync"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        arr := <span style="color: #b58900;">[]</span><span style="color: #b58900;">int</span><span style="color: #b58900;">{</span>1, 2, 3, 4<span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">var</span> wg sync.WaitGroup
        sizes := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, a := <span style="color: #859900; font-weight: bold;">range</span> arr <span style="color: #b58900;">{</span>
                wg.<span style="color: #268bd2;">Add</span><span style="color: #268bd2;">(</span>1<span style="color: #268bd2;">)</span>

                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">worker</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #268bd2;">(</span>a <span style="color: #b58900;">int</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">defer</span> wg.<span style="color: #268bd2;">Done</span><span style="color: #6c71c4;">()</span>
                        log.<span style="color: #268bd2;">Printf</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"%d\n"</span>, a<span style="color: #6c71c4;">)</span>
                        sizes &lt;- a
                <span style="color: #268bd2;">}(</span>a<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                wg.<span style="color: #268bd2;">Wait</span><span style="color: #268bd2;">()</span>
                <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #268bd2;">(</span>sizes<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}()</span>

        <span style="color: #859900; font-weight: bold;">var</span> total int
        <span style="color: #859900; font-weight: bold;">for</span> size := <span style="color: #859900; font-weight: bold;">range</span> sizes <span style="color: #b58900;">{</span>
                total += size
        <span style="color: #b58900;">}</span>

        log.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%s at %d\n"</span>, <span style="color: #2aa198;">"finish"</span>, total<span style="color: #b58900;">)</span>

        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:05:33 3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:05:33 4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:05:33 2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:05:33 1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2017/04/12 11:05:33 finish at 10</span>
</pre>
</div>
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-6" class="outline-3">
<h3 id="sec-8-6">Example: Concurrent Web Crawler</h3>
<div class="outline-text-3" id="text-8-6">
<ul class="org-ul">
<li>在5.6节中,我们设计了一个breadth-first的爬虫,其代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Findlinks3 crawls the web, starting with the URLs on the command line.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"gopl.io/ch5/links"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+breadthFirst</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">breadthFirst calls f for each item in the worklist.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Any items returned by f are added to the worklist.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">f is called at most once for each item.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">breadthFirst</span><span style="color: #2aa198;">(</span>f <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">(</span>item <span style="color: #b58900;">string</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span>, worklist <span style="color: #b58900;">[]</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        seen := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">bool</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>worklist<span style="color: #b58900;">)</span> &gt; 0 <span style="color: #b58900;">{</span>
                items := worklist
                worklist = <span style="color: #268bd2; font-weight: bold;">nil</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, item := <span style="color: #859900; font-weight: bold;">range</span> items <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">if</span> !seen<span style="color: #6c71c4;">[</span>item<span style="color: #6c71c4;">]</span> <span style="color: #6c71c4;">{</span>
                                seen<span style="color: #859900;">[</span>item<span style="color: #859900;">]</span> = <span style="color: #268bd2; font-weight: bold;">true</span>
                                worklist = <span style="color: #657b83; font-weight: bold;">append</span><span style="color: #859900;">(</span>worklist, <span style="color: #268bd2;">f</span><span style="color: #b58900;">(</span>item<span style="color: #b58900;">)</span>...<span style="color: #859900;">)</span>
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-breadthFirst</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+crawl</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">crawl</span><span style="color: #2aa198;">(</span>url <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        list, err := links.<span style="color: #268bd2;">Extract</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Print</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> list
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-crawl</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+main</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Crawl the web breadth-first,</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">starting from the command-line arguments.</span>
        <span style="color: #268bd2;">breadthFirst</span><span style="color: #b58900;">(</span>crawl, os.Args<span style="color: #268bd2;">[</span>1:<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-main</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ go run findlinks.go https://golang.org</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/doc/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/pkg/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/project/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/help/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/blog/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">http://play.golang.org/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://tour.golang.org/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/dl/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://blog.golang.org/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://developers.google.com/site-policies#restrictions</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/LICENSE</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/doc/tos.html</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">http://www.google.com/intl/en/policies/privacy/</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://golang.org/doc/install</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">https://code.google.com/p/go-tour/</span>
</pre>
</div>
</li>
<li>这个例子的核心就是函数crawl(),但是在上面的例子中,我们只有一个goroutine来调
用(也就是main), 所以效率并不高,我们已经解除了goroutine,所以很自然的,我们希
望每个crawl的调用,都能分配到一个goroutine
</li>
<li>最简单的改造方法就是如下了(main函数替代了原来的breadthFirst), 这种方法使用
worklist(类型为slice)来存储需要访问的url,初始化使用一个goroutine从命令行参
数设置初始值,这是为了防止deadlock.同时子goroutine都使用了link作为自己的函数
参数
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Copyright &#169; 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">License: https://creativecommons.org/licenses/by-nc-sa/4.0/</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">See page 240.</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Crawl1 crawls web links starting with the command-line arguments.</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">This version quickly exhausts available file descriptors</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">due to excessive concurrent calls to links.Extract.</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Also, it never terminates because the worklist is never closed.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"gopl.io/ch5/links"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+crawl</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">crawl</span><span style="color: #2aa198;">(</span>url <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        list, err := links.<span style="color: #268bd2;">Extract</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Print</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> list
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-crawl</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+main</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        worklist := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">)</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Start with the command-line arguments.</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> worklist &lt;- os.Args<span style="color: #268bd2;">[</span>1:<span style="color: #268bd2;">]</span> <span style="color: #b58900;">}()</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Crawl the web concurrently.</span>
        seen := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">bool</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> list := <span style="color: #859900; font-weight: bold;">range</span> worklist <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, link := <span style="color: #859900; font-weight: bold;">range</span> list <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">if</span> !seen<span style="color: #6c71c4;">[</span>link<span style="color: #6c71c4;">]</span> <span style="color: #6c71c4;">{</span>
                                seen<span style="color: #859900;">[</span>link<span style="color: #859900;">]</span> = <span style="color: #268bd2; font-weight: bold;">true</span>
                                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #859900;">(</span>link <span style="color: #b58900;">string</span><span style="color: #859900;">)</span> <span style="color: #859900;">{</span>
                                        worklist &lt;- <span style="color: #268bd2;">crawl</span><span style="color: #b58900;">(</span>link<span style="color: #b58900;">)</span>
                                <span style="color: #859900;">}(</span>link<span style="color: #859900;">)</span>
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-main</span>

<span style="color: #93a1a1;">/*</span>
<span style="color: #93a1a1;">//!+output</span>
<span style="color: #93a1a1;">$ go build gopl.io/ch8/crawl1</span>
<span style="color: #93a1a1;">$ ./crawl1 http://gopl.io/</span>
<span style="color: #93a1a1;">http://gopl.io/</span>
<span style="color: #93a1a1;">https://golang.org/help/</span>

<span style="color: #93a1a1;">https://golang.org/doc/</span>
<span style="color: #93a1a1;">https://golang.org/blog/</span>
<span style="color: #93a1a1;">...</span>
<span style="color: #93a1a1;">2015/07/15 18:22:12 Get ...: dial tcp: lookup blog.golang.org: no such host</span>
<span style="color: #93a1a1;">2015/07/15 18:22:12 Get ...: dial tcp 23.21.222.120:443: socket:</span>
<span style="color: #93a1a1;">                                                        too many open files</span>
<span style="color: #93a1a1;">...</span>
<span style="color: #93a1a1;">//!-output</span>
<span style="color: #93a1a1;">*/</span>
</pre>
</div>
</li>
<li>这个看起来很美的版本,有着如下两个特别明显的问题:
<ul class="org-ul">
<li>运行速度过快,超过了可以打开的文件描述符的数目:goroutine可以完全无视任何的
限制创建,可能创建成千上万个,最终的结果就是拖垮了整个系统.解决的办法是把goroutine
的规模限制在20个,这个限制因为是在多线程的情况下做的,所以我们要使用多线程下
的限制手段buffered channel(同时只能允许20个goroutine获得资源,在教材中,这
种工具叫做counting semaphore)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Copyright &#169; 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">License: https://creativecommons.org/licenses/by-nc-sa/4.0/</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">See page 241.</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Crawl2 crawls web links starting with the command-line arguments.</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">This version uses a buffered channel as a counting semaphore</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">to limit the number of concurrent calls to links.Extract.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"os"</span>

        <span style="color: #2aa198;">"gopl.io/ch5/links"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+sema</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">tokens is a counting semaphore used to</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">enforce a limit of 20 concurrent requests.</span>
<span style="color: #859900; font-weight: bold;">var</span> tokens = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #b58900;">{}</span>, 20<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">crawl</span><span style="color: #2aa198;">(</span>url <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">string</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        tokens &lt;- <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #b58900;">{}{}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">acquire a token</span>
        list, err := links.<span style="color: #268bd2;">Extract</span><span style="color: #b58900;">(</span>url<span style="color: #b58900;">)</span>
        &lt;-tokens <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">release the token</span>

        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Print</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> list
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-sema</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        worklist := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">var</span> n int <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">number of pending sends to worklist</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Start with the command-line arguments.</span>
        n++
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> worklist &lt;- os.Args<span style="color: #268bd2;">[</span>1:<span style="color: #268bd2;">]</span> <span style="color: #b58900;">}()</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Crawl the web concurrently.</span>
        seen := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">bool</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> ; n &gt; 0; n-- <span style="color: #b58900;">{</span>
                list := &lt;-worklist
                <span style="color: #859900; font-weight: bold;">for</span> _, link := <span style="color: #859900; font-weight: bold;">range</span> list <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">if</span> !seen<span style="color: #6c71c4;">[</span>link<span style="color: #6c71c4;">]</span> <span style="color: #6c71c4;">{</span>
                                seen<span style="color: #859900;">[</span>link<span style="color: #859900;">]</span> = <span style="color: #268bd2; font-weight: bold;">true</span>
                                n++
                                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #859900;">(</span>link <span style="color: #b58900;">string</span><span style="color: #859900;">)</span> <span style="color: #859900;">{</span>
                                        worklist &lt;- <span style="color: #268bd2;">crawl</span><span style="color: #b58900;">(</span>link<span style="color: #b58900;">)</span>
                                <span style="color: #859900;">}(</span>link<span style="color: #859900;">)</span>
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-</span>
</pre>
</div>
</li>
<li>第二个问题就是这个程序永远都不会运行完(但是因为你的goroutine太多,很快就failed
了,所以你看不到这个结果).为了改正,我们需要加一个普通的计数器,来保证worklist
空了,并且没有crawl goroutine active的情况下,我们结束程序
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        worklist := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">var</span> n int <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">number of pending sends to worklist</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Start with the command-line agruments</span>
        n++
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> worklist &lt;- os.Args<span style="color: #268bd2;">[</span>1:<span style="color: #268bd2;">]</span> <span style="color: #b58900;">}()</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Crawl the web concurrently.</span>
        seen := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">bool</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> ; n &gt; 0; n-- <span style="color: #b58900;">{</span>
                list := &lt;-worklist
                <span style="color: #859900; font-weight: bold;">for</span> _, link := <span style="color: #859900; font-weight: bold;">range</span> list <span style="color: #268bd2;">{</span>
                        <span style="color: #859900; font-weight: bold;">if</span> !seen<span style="color: #6c71c4;">[</span>link<span style="color: #6c71c4;">]</span> <span style="color: #6c71c4;">{</span>
                                seen<span style="color: #859900;">[</span>link<span style="color: #859900;">]</span> = <span style="color: #268bd2; font-weight: bold;">true</span>
                                n++
                                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #859900;">(</span>link <span style="color: #b58900;">string</span><span style="color: #859900;">)</span> <span style="color: #859900;">{</span>
                                        worklist &lt;- <span style="color: #268bd2;">crawl</span><span style="color: #b58900;">(</span>link<span style="color: #b58900;">)</span>
                                <span style="color: #859900;">}(</span>link<span style="color: #859900;">)</span>
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-7" class="outline-3">
<h3 id="sec-8-7">Multiplexing with select</h3>
<div class="outline-text-3" id="text-8-7">
<ul class="org-ul">
<li>下面是一个模拟火箭发送过程的例子,例子中的time.Tick函数会返回一个channel,然后
他会每隔一段时间(设置在参数里面)向这个channel send内容(Time类型,所以channel
的类型也是channel)
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Commencing countdown."</span><span style="color: #b58900;">)</span>
        tick := time.<span style="color: #268bd2;">Tick</span><span style="color: #b58900;">(</span>1 * time.Second<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> countdown := 10; countdown &gt; 0; countdown-- <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>countdown<span style="color: #268bd2;">)</span>
                &lt;-tick
        <span style="color: #b58900;">}</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"launch!"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">8</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">7</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">6</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">launch!</span>
</pre>
</div>
</li>
<li>但是这个例子有个问题,火箭发射要倒数其实是为了在倒数的时候有问题的话,可以及时
停止,这里完全无法停止,所以要改进.
</li>
<li>改进的办法就是再加一个另外一个goroutine来等待用户输入任意一个键,一旦捕捉到
就停止main goroutine的倒数,直接取消"火箭发射"
</li>
<li>现在,我们main goroutine里面的loop就要"监听"两个不同的channel:
<ul class="org-ul">
<li>ticker channel
</li>
<li>abort event(如果用户输入任何一个键)
</li>
</ul>
</li>
<li>我们要"同时"监听这两个channel,因为如果在loop里面"有先后"的监听某一个channel,
另外一个channel就会被block.所以很明显,我们需要新的特性,这个特性就是select
</li>
<li>select名字的来历,应该是BSD的socket里面的select system call.这个system call
可以"同时监听"多个文件(通过文件描述符)内容的变化,一旦有其中一个文件变化,就
返回并处理.
</li>
<li>这里select的意思和select system call非常相近,只不过不是监听的文件,而是监听
的channel.我们用select来实现一个可以abort的火箭发射,代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Copyright &#169; 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">License: https://creativecommons.org/licenses/by-nc-sa/4.0/</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">See page 244.</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Countdown implements the countdown for a rocket launch.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...create abort channel...</span>

        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-</span>

        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+abort</span>
        abort := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #268bd2;">{}</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                os.Stdin.<span style="color: #268bd2;">Read</span><span style="color: #268bd2;">(</span><span style="color: #657b83; font-weight: bold;">make</span><span style="color: #6c71c4;">(</span><span style="color: #859900;">[]</span><span style="color: #b58900;">byte</span>, 1<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">read a single byte</span>
                abort &lt;- <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #268bd2;">{}{}</span>
        <span style="color: #b58900;">}()</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-abort</span>

        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Commencing countdown.  Press return to abort."</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> &lt;-time.<span style="color: #268bd2;">After</span><span style="color: #268bd2;">(</span>10 * time.Second<span style="color: #268bd2;">)</span>:
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Do nothing.</span>
        <span style="color: #859900; font-weight: bold;">case</span> &lt;-abort:
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Launch aborted!"</span><span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #268bd2;">launch</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">launch</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Lift off!"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt; go run countdown.go</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Commencing countdown.  Press return to abort.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">q</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Launch aborted!</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt; go run countdown.go</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Commencing countdown.  Press return to abort.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Lift off!</span>
</pre>
</div>
</li>
<li>select和switch不一样的地方在于,select的case并没有"前后顺序",它们的地位是相
同的,这也是为什么不能在channel上面使用switch关键字,因为这会让用户以为case会
有先后顺序.下面的例子,巧妙的利用了buffer为1的channel只可能处于两种状态:empty
或者full,所以select也只会碰到一个case ready的情况
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        ch := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span>, 1<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> i := 0; i &lt; 10; i++ <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">case</span> x := &lt;-ch:
                        fmt.<span style="color: #268bd2;">Println</span><span style="color: #6c71c4;">(</span>x<span style="color: #6c71c4;">)</span>
                <span style="color: #859900; font-weight: bold;">case</span> ch &lt;- i:
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">6</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">8</span>
</pre>
</div>
</li>
<li>那么问题来了,如果select遇到多个case都ready的情况下,它怎么选呢?首先明确的是
select不是switch,所以不可能谁在前面选择谁.而是,随机的选择一个case进行下去,
是的,你没看错,是随机的选择一个case!
</li>
<li>随机选择的原因是因为这样让每个case都有equal chance来得到运行的机会,我们来把
上面例子的buffer增大,这样select每次遇到的情况就不再是简单的"要么A ready,要么
B ready啦",它的运行结果,也会是随机的
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        ch := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span>, 2<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> i := 0; i &lt; 10; i++ <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">case</span> x := &lt;-ch:
                        fmt.<span style="color: #268bd2;">Println</span><span style="color: #6c71c4;">(</span>x<span style="color: #6c71c4;">)</span>
                <span style="color: #859900; font-weight: bold;">case</span> ch &lt;- i:
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================POSSIBLE OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">7</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================POSSIBLE OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5</span>
</pre>
</div>
</li>
<li>我们再来看看一个更加直观的例子,那就是十秒倒数,每个数字都打印出来.
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Countdown implements the countdown for a rocket launch.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: the ticker goroutine never terminates if the launch is aborted.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">This is a "goroutine leak".</span>

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...create abort channel...</span>

        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-</span>

        abort := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #268bd2;">{}</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                os.Stdin.<span style="color: #268bd2;">Read</span><span style="color: #268bd2;">(</span><span style="color: #657b83; font-weight: bold;">make</span><span style="color: #6c71c4;">(</span><span style="color: #859900;">[]</span><span style="color: #b58900;">byte</span>, 1<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">read a single byte</span>
                abort &lt;- <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #268bd2;">{}{}</span>
        <span style="color: #b58900;">}()</span>

        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Commencing countdown.  Press return to abort."</span><span style="color: #b58900;">)</span>
        tick := time.<span style="color: #268bd2;">Tick</span><span style="color: #b58900;">(</span>1 * time.Second<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> countdown := 10; countdown &gt; 0; countdown-- <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span>countdown<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">case</span> &lt;-tick:
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Do nothing.</span>
                <span style="color: #859900; font-weight: bold;">case</span> &lt;-abort:
                        fmt.<span style="color: #268bd2;">Println</span><span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"Launch aborted!"</span><span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">return</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #268bd2;">launch</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">launch</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Lift off!"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Commencing countdown.  Press return to abort.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">8</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">7</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">6</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5</span>
<span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Launch aborted!</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Commencing countdown.  Press return to abort.</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">8</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">7</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">6</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Lift off!</span>
</pre>
</div>
</li>
<li>这是我们认为最最合乎人们理解的倒数程序.但是这个程序还是有问题,因为time.Tick
一旦创建,就好比有一个goroutine一直不停的send value.但是如果abort的情况下,其
实是没有receive goroutine的,所以就发生了goroutine leak
</li>
<li>select还有一个特别重要的作用,就是来实现non-blocking communication:也就是说
有时候我们希望send或者receive一个channel,但是如果channel没有ready,我们不希
望等,我们希望马上返回
<pre class="example">
Try to send or receive on a channel but avoid blocking if
the channel is not ready -- a non-blocking communication
</pre>
</li>
<li>select实现的原理基于两个:
<ul class="org-ul">
<li>select和switch一样,有一个default,在所有其他case都不满足的情况下运行default
</li>
<li>channel作为reference type,其zero value是nil, 而且这个nil是有意义的,因为对
nil的send和receive操作都是永远block的,换句话说,对于nil channel的case,永远
都是不会执行的
</li>
</ul>
</li>
<li>简单的例子如下,如果abort为nil的话,我们直接就运行default啦, 而不是继续block
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">select</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">case</span> &lt;-abort:
        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Launch aborted"</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span>
<span style="color: #859900; font-weight: bold;">default</span>:
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">do nothing</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-8" class="outline-3">
<h3 id="sec-8-8">Example: Concurrent Directory Traversal</h3>
<div class="outline-text-3" id="text-8-8">
<ul class="org-ul">
<li>这一节,我们主要来实现一个Unix下面的du命令,最简单的一个版本如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"flag"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"io/ioutil"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"path/filepath"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">walkDir recursively walks the file tree rooted at dir</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">and sends the size of each found file on fileSizes.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">walkDir</span><span style="color: #2aa198;">(</span>dir <span style="color: #b58900;">string</span>, fileSizes <span style="color: #859900; font-weight: bold;">chan</span>&lt;- <span style="color: #b58900;">int64</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, entry := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #268bd2;">dirents</span><span style="color: #b58900;">(</span>dir<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> entry.<span style="color: #268bd2;">IsDir</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
                        subdir := filepath.<span style="color: #268bd2;">Join</span><span style="color: #6c71c4;">(</span>dir, entry.<span style="color: #268bd2;">Name</span><span style="color: #859900;">()</span><span style="color: #6c71c4;">)</span>
                        <span style="color: #268bd2;">walkDir</span><span style="color: #6c71c4;">(</span>subdir, fileSizes<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #268bd2;">{</span>
                        fileSizes &lt;- entry.<span style="color: #268bd2;">Size</span><span style="color: #6c71c4;">()</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>

<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">dirents returns the entries of directory dir.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">dirents</span><span style="color: #2aa198;">(</span>dir <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">os.FileInfo</span> <span style="color: #2aa198;">{</span>
        entries, err := ioutil.<span style="color: #268bd2;">ReadDir</span><span style="color: #b58900;">(</span>dir<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>os.Stderr, <span style="color: #2aa198;">"du1: %v\n"</span>, err<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> entries
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Determine the initial directories.</span>
        flag.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">()</span>
        roots := flag.<span style="color: #268bd2;">Args</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>roots<span style="color: #b58900;">)</span> == 0 <span style="color: #b58900;">{</span>
                roots = <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"."</span><span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Traverse the file tree.</span>
        fileSizes := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int64</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, root := <span style="color: #859900; font-weight: bold;">range</span> roots <span style="color: #268bd2;">{</span>
                        <span style="color: #268bd2;">walkDir</span><span style="color: #6c71c4;">(</span>root, fileSizes<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #268bd2;">(</span>fileSizes<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}()</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Print the results.</span>
        <span style="color: #859900; font-weight: bold;">var</span> nfiles, nbytes int64
        <span style="color: #859900; font-weight: bold;">for</span> size := <span style="color: #859900; font-weight: bold;">range</span> fileSizes <span style="color: #b58900;">{</span>
                nfiles++
                nbytes += size
        <span style="color: #b58900;">}</span>
        <span style="color: #268bd2;">printDiskUsage</span><span style="color: #b58900;">(</span>nfiles, nbytes<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">printDiskUsage</span><span style="color: #2aa198;">(</span>nfiles, nbytes <span style="color: #b58900;">int64</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d files %.1f GB\n"</span>, nfiles, <span style="color: #268bd2;">float64</span><span style="color: #268bd2;">(</span>nbytes<span style="color: #268bd2;">)</span>/1e9<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ go run one.go .</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">257079 files 6.2 GB</span>
</pre>
</div>
</li>
<li>和常规的c语言版本唯一不一样的地方,就是我们使用了一个channel作为walkDir的参数,
同时,除了main goroutine以外,我们还另外起了一个goroutine来调用walDir,并且明确
调用了close来关闭channel,从而让main goroutine可以去统计结果
</li>
<li>第一个例子统计的时候,程序响应的时间过长,一个可能的改进就是每个一秒(或是半秒)
都在命令行提醒一下当前的进度.这种做法其实就是增加了一个channel(除了fileSize
以外,增加了tick),让select去处理
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"flag"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"io/ioutil"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"path/filepath"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">walkDir recursively walks the file tree rooted at dir</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">and sends the size of each found file on fileSizes.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">walkDir</span><span style="color: #2aa198;">(</span>dir <span style="color: #b58900;">string</span>, fileSizes <span style="color: #859900; font-weight: bold;">chan</span>&lt;- <span style="color: #b58900;">int64</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, entry := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #268bd2;">dirents</span><span style="color: #b58900;">(</span>dir<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> entry.<span style="color: #268bd2;">IsDir</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
                        subdir := filepath.<span style="color: #268bd2;">Join</span><span style="color: #6c71c4;">(</span>dir, entry.<span style="color: #268bd2;">Name</span><span style="color: #859900;">()</span><span style="color: #6c71c4;">)</span>
                        <span style="color: #268bd2;">walkDir</span><span style="color: #6c71c4;">(</span>subdir, fileSizes<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #268bd2;">{</span>
                        fileSizes &lt;- entry.<span style="color: #268bd2;">Size</span><span style="color: #6c71c4;">()</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>

<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">dirents returns the entries of directory dir.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">dirents</span><span style="color: #2aa198;">(</span>dir <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">os.FileInfo</span> <span style="color: #2aa198;">{</span>
        entries, err := ioutil.<span style="color: #268bd2;">ReadDir</span><span style="color: #b58900;">(</span>dir<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>os.Stderr, <span style="color: #2aa198;">"du1: %v\n"</span>, err<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> entries
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> verbose = flag.<span style="color: #268bd2;">Bool</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"v"</span>, <span style="color: #268bd2; font-weight: bold;">false</span>, <span style="color: #2aa198;">"show verbose progress message"</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Determine the initial directories.</span>
        flag.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">()</span>
        roots := flag.<span style="color: #268bd2;">Args</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>roots<span style="color: #b58900;">)</span> == 0 <span style="color: #b58900;">{</span>
                roots = <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"."</span><span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Traverse the file tree.</span>
        fileSizes := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int64</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">for</span> _, root := <span style="color: #859900; font-weight: bold;">range</span> roots <span style="color: #268bd2;">{</span>
                        <span style="color: #268bd2;">walkDir</span><span style="color: #6c71c4;">(</span>root, fileSizes<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #268bd2;">(</span>fileSizes<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}()</span>

        <span style="color: #859900; font-weight: bold;">var</span> tick &lt;-<span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">time.Time</span>

        <span style="color: #859900; font-weight: bold;">if</span> *verbose <span style="color: #b58900;">{</span>
                tick = time.<span style="color: #268bd2;">Tick</span><span style="color: #268bd2;">(</span>500 * time.Millisecond<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Print the results.</span>
        <span style="color: #859900; font-weight: bold;">var</span> nfiles, nbytes int64
<span style="color: #268bd2; font-weight: bold;">loop</span>:
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">case</span> size, ok := &lt;-fileSizes:
                        <span style="color: #859900; font-weight: bold;">if</span> !ok <span style="color: #6c71c4;">{</span>
                                <span style="color: #859900; font-weight: bold;">break</span> <span style="color: #268bd2; font-weight: bold;">loop</span>
                        <span style="color: #6c71c4;">}</span>
                        nfiles++
                        nbytes += size
                <span style="color: #859900; font-weight: bold;">case</span> &lt;-tick:
                        <span style="color: #268bd2;">printDiskUsage</span><span style="color: #6c71c4;">(</span>nfiles, nbytes<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #268bd2;">printDiskUsage</span><span style="color: #b58900;">(</span>nfiles, nbytes<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">printDiskUsage</span><span style="color: #2aa198;">(</span>nfiles, nbytes <span style="color: #b58900;">int64</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d files %.1f GB\n"</span>, nfiles, <span style="color: #268bd2;">float64</span><span style="color: #268bd2;">(</span>nbytes<span style="color: #268bd2;">)</span>/1e9<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ go run two.go -v .</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">62037 files 0.6 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">71076 files 0.7 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">80573 files 0.7 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">90270 files 0.7 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100006 files 0.8 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">109496 files 0.8 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">119236 files 0.9 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">128305 files 2.0 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">138797 files 2.1 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">149307 files 2.1 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">158870 files 2.2 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">168483 files 2.3 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">177695 files 2.3 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">186614 files 2.3 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">196181 files 2.4 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">205273 files 2.4 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">216340 files 2.4 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">226519 files 2.5 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">235460 files 3.3 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">243919 files 3.5 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">254259 files 3.5 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">257079 files 6.2 GB</span>
</pre>
</div>
</li>
<li>另外一个改进的思路,是每一次的walkDir都使用一个goroutine,这样显然会非常非常快,
但是操作系统有打开文件描述符的限制,所以我们这里要使用一个couting semaphore来
把goroutine的数目控制在20
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"flag"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"io/ioutil"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"path/filepath"</span>
        <span style="color: #2aa198;">"sync"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">walkDir recursively walks the file tree rooted at dir</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">and sends the size of each found file on fileSizes.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">walkDir</span><span style="color: #2aa198;">(</span>dir <span style="color: #b58900;">string</span>, n *<span style="color: #b58900;">sync.WaitGroup</span>, fileSizes <span style="color: #859900; font-weight: bold;">chan</span>&lt;- <span style="color: #b58900;">int64</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">defer</span> n.<span style="color: #268bd2;">Done</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, entry := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #268bd2;">dirents</span><span style="color: #b58900;">(</span>dir<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">if</span> entry.<span style="color: #268bd2;">IsDir</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
                        n.<span style="color: #268bd2;">Add</span><span style="color: #6c71c4;">(</span>1<span style="color: #6c71c4;">)</span>
                        subdir := filepath.<span style="color: #268bd2;">Join</span><span style="color: #6c71c4;">(</span>dir, entry.<span style="color: #268bd2;">Name</span><span style="color: #859900;">()</span><span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">walkDir</span><span style="color: #6c71c4;">(</span>subdir, n, fileSizes<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #268bd2;">{</span>
                        fileSizes &lt;- entry.<span style="color: #268bd2;">Size</span><span style="color: #6c71c4;">()</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>

<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> sema = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #b58900;">{}</span>, 20<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">dirents returns the entries of directory dir.</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">dirents</span><span style="color: #2aa198;">(</span>dir <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">os.FileInfo</span> <span style="color: #2aa198;">{</span>
        sema &lt;- <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #b58900;">{}{}</span>
        <span style="color: #859900; font-weight: bold;">defer</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> &lt;-sema <span style="color: #b58900;">}()</span>

        entries, err := ioutil.<span style="color: #268bd2;">ReadDir</span><span style="color: #b58900;">(</span>dir<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>os.Stderr, <span style="color: #2aa198;">"du1: %v\n"</span>, err<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> entries
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> verbose = flag.<span style="color: #268bd2;">Bool</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"v"</span>, <span style="color: #268bd2; font-weight: bold;">false</span>, <span style="color: #2aa198;">"show verbose progress message"</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Determine the initial directories.</span>
        flag.<span style="color: #268bd2;">Parse</span><span style="color: #b58900;">()</span>
        roots := flag.<span style="color: #268bd2;">Args</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>roots<span style="color: #b58900;">)</span> == 0 <span style="color: #b58900;">{</span>
                roots = <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"."</span><span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Traverse the file tree.</span>
        fileSizes := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int64</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">var</span> n sync.WaitGroup

        <span style="color: #859900; font-weight: bold;">for</span> _, root := <span style="color: #859900; font-weight: bold;">range</span> roots <span style="color: #b58900;">{</span>
                n.<span style="color: #268bd2;">Add</span><span style="color: #268bd2;">(</span>1<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">walkDir</span><span style="color: #268bd2;">(</span>root, &amp;n, fileSizes<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                n.<span style="color: #268bd2;">Wait</span><span style="color: #268bd2;">()</span>
                <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #268bd2;">(</span>fileSizes<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}()</span>

        <span style="color: #859900; font-weight: bold;">var</span> tick &lt;-<span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">time.Time</span>

        <span style="color: #859900; font-weight: bold;">if</span> *verbose <span style="color: #b58900;">{</span>
                tick = time.<span style="color: #268bd2;">Tick</span><span style="color: #268bd2;">(</span>500 * time.Millisecond<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Print the results.</span>
        <span style="color: #859900; font-weight: bold;">var</span> nfiles, nbytes int64
<span style="color: #268bd2; font-weight: bold;">loop</span>:
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">case</span> size, ok := &lt;-fileSizes:
                        <span style="color: #859900; font-weight: bold;">if</span> !ok <span style="color: #6c71c4;">{</span>
                                <span style="color: #859900; font-weight: bold;">break</span> <span style="color: #268bd2; font-weight: bold;">loop</span>
                        <span style="color: #6c71c4;">}</span>
                        nfiles++
                        nbytes += size
                <span style="color: #859900; font-weight: bold;">case</span> &lt;-tick:
                        <span style="color: #268bd2;">printDiskUsage</span><span style="color: #6c71c4;">(</span>nfiles, nbytes<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #268bd2;">printDiskUsage</span><span style="color: #b58900;">(</span>nfiles, nbytes<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">printDiskUsage</span><span style="color: #2aa198;">(</span>nfiles, nbytes <span style="color: #b58900;">int64</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d files %.1f GB\n"</span>, nfiles, <span style="color: #268bd2;">float64</span><span style="color: #268bd2;">(</span>nbytes<span style="color: #268bd2;">)</span>/1e9<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ go run three.go .</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">257079 files 6.2 GB</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-9" class="outline-3">
<h3 id="sec-8-9">Cancellation</h3>
<div class="outline-text-3" id="text-8-9">
<ul class="org-ul">
<li>有一些情况下,我们想要"主动停止"goroutine.比如,一个client发起了一个计算请求,
server会委任一个goroutine来去做,而且这个计算会很耗费时间,但是在这个时间内server
发现client"失联"了.这种情况下,server会倾向于关闭这个goroutine来节省计算资源
</li>
<li>首先应该明确的是,没有一种方面来让一个goroutine去"直接结束"另外一个goroutine,
因为"直接结束"会让另外的goroutine的所有的shared variable处于一种undefined的
状态
<pre class="example">
There is not way for one goroutine to terminate another directly,
since that would leave all its shared variables in undefined states.
</pre>
</li>
<li>不能"直接关闭",但是可以"间接"的处理,怎么个间接法呢?就是要求让"计算"的goroutine
在自己的逻辑里面,就"注射"进去退出机制:把火箭发射看成是一个"计算"goroutine的
话,在火箭发射的goroutine里面,就有"一旦发展abort channel有问题",我就自己"主动"
关闭的逻辑
</li>
<li>这种"间接"处理的方法,有一个问题,那就是:只能一个goroutine发一个event到channel
上.这种"一一对应"很难精确:
<ul class="org-ul">
<li>如果有N个goroutine,你发送了N个event到channel上面,但是如果这个N个goroutine
有个几个由于其他原因已经关闭了,那么你的channel上面总有几个没有人fetch的event
</li>
<li>如果有个N个goroutine,但是这N个goroutine里面还会产生其他的goroutine,你发送
N个event,就会不够用
</li>
</ul>
</li>
<li>相比于"一一对应"的channel发送,可能广播是一个比较好的解决手段:所有在特定区域
里面的goroutine都可以知道某个event发生了,而且可以在event发生之后回顾"发生过"
哪些event
</li>
<li>golang没有为我们直接提供一个broadcast feature,但是我们可以使用channel的一个
特性来做broeadcast: 一旦一个channel被关闭了以后,后续对这个channel的读取会马
上返回(不会block),获得zero value.所以我们只要设计一个channel,永远不会向这个
channel发送event,而只close这个channel.一旦close了这个channel,就是告诉所有的
能读取这个channel的goroutine:某些事情发送了
<pre class="example">
Recall that after a channel has been closed and drained of
all sent values, subsequent receive operations proceed immediately,
yielding zero values. We can exploit this to create a broadcast
machanism: don't send a value on the channel, close it.
</pre>
</li>
<li>完成这个broadcast需要很多步骤:
<ul class="org-ul">
<li>首先就是我们broadcast channel啦,另外我们还专门为它设计一个utility函数来判
断"中断事件"的广播发生过没有
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">var</span> done = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">cancelled</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> &lt;- done:
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>
        <span style="color: #859900; font-weight: bold;">default</span>:
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们要另外有一个goroutine来时刻监视命令行行为,等待用户是不是真的input了停
止的任何字符串
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        os.Stdin.<span style="color: #268bd2;">Read</span><span style="color: #b58900;">(</span><span style="color: #657b83; font-weight: bold;">make</span><span style="color: #268bd2;">(</span><span style="color: #6c71c4;">[]</span><span style="color: #b58900;">byte</span>,1<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">read a single byte</span>
        <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #b58900;">(</span>done<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}()</span>
</pre>
</div>
</li>
<li>我们新增加了一个channel事件,select肯定是要新增一个case的,但是这个case里面
还要一个比较绝的地方,是它还会去drain fileSize channel,防止walkDir在退出
的过程中无法成功的向fileSize send数据
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> &lt;-done:
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Drain fileSizes to allow existing goroutines to finish</span>
                <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #859900; font-weight: bold;">range</span> fileSizes <span style="color: #268bd2;">{</span>
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Do nothing.</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #859900; font-weight: bold;">return</span>
        <span style="color: #859900; font-weight: bold;">case</span> size, ok := &lt;-fileSizes:
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>walkDir会在运行前去查看广播,如果发现了done广播关闭,那么就直接返回
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">walkDir</span><span style="color: #2aa198;">(</span>dir <span style="color: #b58900;">string</span>, n *<span style="color: #b58900;">sync.WaitGroup</span>, fileSizes <span style="color: #859900; font-weight: bold;">chan</span>&lt;- <span style="color: #b58900;">int64</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">defer</span> n.<span style="color: #268bd2;">Done</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">cancelled</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, entry := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #268bd2;">dirents</span><span style="color: #b58900;">(</span>dir<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>另外,我们通过profiling发现在dirents里面获取semaphore,所以我们加了一段select,
来让"获取semaphore"和"发现done broadcast"变成同等重要的活动,也就是说一旦done
广播了,可以就不用去获取semaphore了,这样可以大大的提高效率:
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">before</span>
sema &lt;- <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #2aa198;">{}{}</span>
<span style="color: #859900; font-weight: bold;">defer</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> &lt;-sema <span style="color: #2aa198;">}()</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">after</span>
<span style="color: #859900; font-weight: bold;">select</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">case</span> sema &lt;- <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #b58900;">{}{}</span>: <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">acquire token</span>
<span style="color: #859900; font-weight: bold;">case</span> &lt;-done:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">cancelled</span>
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">defer</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> &lt;-sema <span style="color: #2aa198;">}()</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">release token</span>
</pre>
</div>
</li>
</ul>
</li>
<li>完整的代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The du4 command computes the disk usage of the files in a directory.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The du4 variant includes cancellation:</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">it terminates quickly when the user hits return.</span>

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
        <span style="color: #2aa198;">"path/filepath"</span>
        <span style="color: #2aa198;">"sync"</span>
        <span style="color: #2aa198;">"time"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+1</span>
<span style="color: #859900; font-weight: bold;">var</span> done = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">cancelled</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">bool</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> &lt;-done:
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>
        <span style="color: #859900; font-weight: bold;">default</span>:
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-1</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Determine the initial directories.</span>
        roots := os.Args<span style="color: #b58900;">[</span>1:<span style="color: #b58900;">]</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">len</span><span style="color: #b58900;">(</span>roots<span style="color: #b58900;">)</span> == 0 <span style="color: #b58900;">{</span>
                roots = <span style="color: #268bd2;">[]</span><span style="color: #b58900;">string</span><span style="color: #268bd2;">{</span><span style="color: #2aa198;">"."</span><span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+2</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Cancel traversal when input is detected.</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                os.Stdin.<span style="color: #268bd2;">Read</span><span style="color: #268bd2;">(</span><span style="color: #657b83; font-weight: bold;">make</span><span style="color: #6c71c4;">(</span><span style="color: #859900;">[]</span><span style="color: #b58900;">byte</span>, 1<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">read a single byte</span>
                <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #268bd2;">(</span>done<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}()</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-2</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Traverse each root of the file tree in parallel.</span>
        fileSizes := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int64</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">var</span> n sync.WaitGroup
        <span style="color: #859900; font-weight: bold;">for</span> _, root := <span style="color: #859900; font-weight: bold;">range</span> roots <span style="color: #b58900;">{</span>
                n.<span style="color: #268bd2;">Add</span><span style="color: #268bd2;">(</span>1<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">walkDir</span><span style="color: #268bd2;">(</span>root, &amp;n, fileSizes<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                n.<span style="color: #268bd2;">Wait</span><span style="color: #268bd2;">()</span>
                <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #268bd2;">(</span>fileSizes<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}()</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Print the results periodically.</span>
        tick := time.<span style="color: #268bd2;">Tick</span><span style="color: #b58900;">(</span>500 * time.Millisecond<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">var</span> nfiles, nbytes int64
<span style="color: #268bd2; font-weight: bold;">loop</span>:
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+3</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">case</span> &lt;-done:
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Drain fileSizes to allow existing goroutines to finish.</span>
                        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #859900; font-weight: bold;">range</span> fileSizes <span style="color: #6c71c4;">{</span>
                                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Do nothing.</span>
                        <span style="color: #6c71c4;">}</span>
                        <span style="color: #859900; font-weight: bold;">return</span>
                <span style="color: #859900; font-weight: bold;">case</span> size, ok := &lt;-fileSizes:
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
                        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-3</span>
                        <span style="color: #859900; font-weight: bold;">if</span> !ok <span style="color: #6c71c4;">{</span>
                                <span style="color: #859900; font-weight: bold;">break</span> <span style="color: #268bd2; font-weight: bold;">loop</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">fileSizes was closed</span>
                        <span style="color: #6c71c4;">}</span>
                        nfiles++
                        nbytes += size
                <span style="color: #859900; font-weight: bold;">case</span> &lt;-tick:
                        <span style="color: #268bd2;">printDiskUsage</span><span style="color: #6c71c4;">(</span>nfiles, nbytes<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #268bd2;">printDiskUsage</span><span style="color: #b58900;">(</span>nfiles, nbytes<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">final totals</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">printDiskUsage</span><span style="color: #2aa198;">(</span>nfiles, nbytes <span style="color: #b58900;">int64</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        fmt.<span style="color: #268bd2;">Printf</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"%d files  %.1f GB\n"</span>, nfiles, <span style="color: #268bd2;">float64</span><span style="color: #268bd2;">(</span>nbytes<span style="color: #268bd2;">)</span>/1e9<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">walkDir recursively walks the file tree rooted at dir</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">and sends the size of each found file on fileSizes.</span>
<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+4</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">walkDir</span><span style="color: #2aa198;">(</span>dir <span style="color: #b58900;">string</span>, n *<span style="color: #b58900;">sync.WaitGroup</span>, fileSizes <span style="color: #859900; font-weight: bold;">chan</span>&lt;- <span style="color: #b58900;">int64</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">defer</span> n.<span style="color: #268bd2;">Done</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">cancelled</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">for</span> _, entry := <span style="color: #859900; font-weight: bold;">range</span> <span style="color: #268bd2;">dirents</span><span style="color: #b58900;">(</span>dir<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
                <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-4</span>
                <span style="color: #859900; font-weight: bold;">if</span> entry.<span style="color: #268bd2;">IsDir</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
                        n.<span style="color: #268bd2;">Add</span><span style="color: #6c71c4;">(</span>1<span style="color: #6c71c4;">)</span>
                        subdir := filepath.<span style="color: #268bd2;">Join</span><span style="color: #6c71c4;">(</span>dir, entry.<span style="color: #268bd2;">Name</span><span style="color: #859900;">()</span><span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">walkDir</span><span style="color: #6c71c4;">(</span>subdir, n, fileSizes<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #268bd2;">{</span>
                        fileSizes &lt;- entry.<span style="color: #268bd2;">Size</span><span style="color: #6c71c4;">()</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+4</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-4</span>

<span style="color: #859900; font-weight: bold;">var</span> sema = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #b58900;">{}</span>, 20<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">concurrency-limiting counting semaphore</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">dirents returns the entries of directory dir.</span>
<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+5</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">dirents</span><span style="color: #2aa198;">(</span>dir <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">[]</span><span style="color: #b58900;">os.FileInfo</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> sema &lt;- <span style="color: #859900; font-weight: bold;">struct</span><span style="color: #268bd2;">{}{}</span>: <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">acquire token</span>
        <span style="color: #859900; font-weight: bold;">case</span> &lt;-done:
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">cancelled</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">defer</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> &lt;-sema <span style="color: #b58900;">}()</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">release token</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...read directory...</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-5</span>

        f, err := os.<span style="color: #268bd2;">Open</span><span style="color: #b58900;">(</span>dir<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>os.Stderr, <span style="color: #2aa198;">"du: %v\n"</span>, err<span style="color: #268bd2;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">defer</span> f.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>

        entries, err := f.<span style="color: #268bd2;">Readdir</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0 =&gt; no limit; read all entries</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintf</span><span style="color: #268bd2;">(</span>os.Stderr, <span style="color: #2aa198;">"du: %v\n"</span>, err<span style="color: #268bd2;">)</span>
                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Don't return: Readdir may return partial results.</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> entries
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ go run four.go .</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">56523 files  3.9 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">108053 files  5.5 GB</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">d</span>
</pre>
</div>
</li>
<li>好了,现在当我们在命令行输入任意一个字符,所有的background goroutine都会快速
结束,然后main goroutine也就返回了.当然了因为我们main返回了,所以很难去"证明"
我们的background的资源都返回了.一个可行的trick就是:我们的cancellation结束后
不是返回main,而是执行一个panic,这个panic dump打印所有的goroutine.如果只有main
goroutine,说明我们的回收成功了.否则说明有泄露的goroutine
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-10" class="outline-3">
<h3 id="sec-8-10">Example: Chat Server</h3>
<div class="outline-text-3" id="text-8-10">
<ul class="org-ul">
<li>最后我们来看一个chat server的例子,这是个简单例子,每个接入chat server的client
都会收到所有其他人的信息,相当于微信里面的群聊
</li>
<li>除了main goroutine以外,例子中的每个client都会单独有一个goroutine,另外我们还
创建了一个broadcaster goroutine来管理来自不同channel的event
</li>
<li>main goroutine的工作比较简单,就是先起一个broadcaster goroutine,然后在for循环
里面等待tcp链接,给每个进来的tcp链接都创建一个handleConn
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        listener, err := net.<span style="color: #268bd2;">Listen</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"tcp"</span>, <span style="color: #2aa198;">"localhost:8000"</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">broadcaster</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                conn, err := listener.<span style="color: #268bd2;">Accept</span><span style="color: #268bd2;">()</span>
                <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        log.<span style="color: #268bd2;">Print</span><span style="color: #6c71c4;">(</span>err<span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">continue</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">handleConn</span><span style="color: #268bd2;">(</span>conn<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>broadcaster()就是来负责群发的啦.go里面和goroutine里面打交道的方法就是通过channel
群发的话,肯定也是通过channel. broadcaster()处理的不只有各个client的信息,还有
各个成员进入群聊和退出群聊的信息.每一类信息都是使用一个channel来完成的,所以
我们的broadcaster()也就需要select来同时处理不同的channel
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">client</span> <span style="color: #859900; font-weight: bold;">chan</span>&lt;- <span style="color: #b58900;">string</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">an outgoing message channel, each client has one client</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #2aa198;">(</span>
        entering = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">client</span><span style="color: #b58900;">)</span>
        leaving  = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">client</span><span style="color: #b58900;">)</span>
        messages = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">string</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">all incoming client messages</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">broadcaster</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        clients := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">client</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">bool</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">all connected clients</span>

        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">case</span> msg := &lt;-messages:
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Broadcast incoming message to all,even itself</span>
                        <span style="color: #859900; font-weight: bold;">for</span> cli := <span style="color: #859900; font-weight: bold;">range</span> clients <span style="color: #6c71c4;">{</span>
                                cli &lt;- msg
                        <span style="color: #6c71c4;">}</span>
                <span style="color: #859900; font-weight: bold;">case</span> cli := &lt;-entering:
                        clients<span style="color: #6c71c4;">[</span>cli<span style="color: #6c71c4;">]</span> = <span style="color: #268bd2; font-weight: bold;">true</span>
                <span style="color: #859900; font-weight: bold;">case</span> cli := &lt;-leaving:
                        <span style="color: #657b83; font-weight: bold;">delete</span><span style="color: #6c71c4;">(</span>clients, cli<span style="color: #6c71c4;">)</span>
                        <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #6c71c4;">(</span>cli<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>broadcaster()是从global的message channel里面读取的信息,那可以想到,每个client
都是把:
<ul class="org-ul">
<li>自己进入群聊的event写入到global的entering channel
</li>
<li>自己离开群聊的event写入到global的leaving channel
</li>
<li>自己聊天的信息写入到global的message channel
</li>
</ul>
</li>
<li>所以client的代码里面充斥着全局变量
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">handleConn</span><span style="color: #2aa198;">(</span>conn <span style="color: #b58900;">net.Conn</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        ch := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">string</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">outgoing client messages</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">clientWriter</span><span style="color: #b58900;">(</span>conn, ch<span style="color: #b58900;">)</span>

        who := conn.<span style="color: #268bd2;">RemoteAddr</span><span style="color: #b58900;">()</span>.<span style="color: #268bd2;">String</span><span style="color: #b58900;">()</span>
        ch &lt;- <span style="color: #2aa198;">"You are "</span> + who
        message &lt;- who + <span style="color: #2aa198;">" Has arrived"</span>
        entering &lt;- ch

        input := bufio.<span style="color: #268bd2;">NewScanner</span><span style="color: #b58900;">(</span>conn<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> input.<span style="color: #268bd2;">Scan</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                message &lt;- who + <span style="color: #2aa198;">": "</span> + input.<span style="color: #268bd2;">Text</span><span style="color: #268bd2;">()</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Note: ignoring potential errors from input.Err()</span>

        leaving &lt;- ch
        messages &lt;- who + <span style="color: #2aa198;">" has left"</span>
        conn.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">clientWriter</span><span style="color: #2aa198;">(</span>conn <span style="color: #b58900;">net.Conn</span>, ch &lt;-<span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> msg := <span style="color: #859900; font-weight: bold;">range</span> ch <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintln</span><span style="color: #268bd2;">(</span>conn, msg<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这段代码有一个地方不太好理解,就是ch.不好理解的原因在于entering和leaving这两
个全局channel其实是"channel的channel",所以ch只是传入到这里面而已,传进去以后
ch就变成了clients这个map的一个成员."并没有读取ch里面的值!"
</li>
<li>所以我们可以另外起一个goroutine clientWriter,源源不断的读取ch,然后写入到conn
里面.理解"channel的channel"比较重要
</li>
<li>完整代码如下
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Chat is a server that lets clients chat with each other.</span>
<span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"bufio"</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"log"</span>
        <span style="color: #2aa198;">"net"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+broadcaster</span>
<span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900;">client</span> <span style="color: #859900; font-weight: bold;">chan</span>&lt;- <span style="color: #b58900;">string</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">an outgoing message channel</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #2aa198;">(</span>
        entering = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">client</span><span style="color: #b58900;">)</span>
        leaving  = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">client</span><span style="color: #b58900;">)</span>
        messages = <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">string</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">all incoming client messages</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">broadcaster</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        clients := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">map</span><span style="color: #268bd2;">[</span><span style="color: #b58900;">client</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">bool</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">all connected clients</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                <span style="color: #859900; font-weight: bold;">select</span> <span style="color: #268bd2;">{</span>
                <span style="color: #859900; font-weight: bold;">case</span> msg := &lt;-messages:
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Broadcast incoming message to all</span>
                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">clients' outgoing message channels.</span>
                        <span style="color: #859900; font-weight: bold;">for</span> cli := <span style="color: #859900; font-weight: bold;">range</span> clients <span style="color: #6c71c4;">{</span>
                                cli &lt;- msg
                        <span style="color: #6c71c4;">}</span>

                <span style="color: #859900; font-weight: bold;">case</span> cli := &lt;-entering:
                        clients<span style="color: #6c71c4;">[</span>cli<span style="color: #6c71c4;">]</span> = <span style="color: #268bd2; font-weight: bold;">true</span>

                <span style="color: #859900; font-weight: bold;">case</span> cli := &lt;-leaving:
                        <span style="color: #657b83; font-weight: bold;">delete</span><span style="color: #6c71c4;">(</span>clients, cli<span style="color: #6c71c4;">)</span>
                        <span style="color: #657b83; font-weight: bold;">close</span><span style="color: #6c71c4;">(</span>cli<span style="color: #6c71c4;">)</span>
                <span style="color: #268bd2;">}</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-broadcaster</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+handleConn</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">handleConn</span><span style="color: #2aa198;">(</span>conn <span style="color: #b58900;">net.Conn</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        ch := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">string</span><span style="color: #b58900;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">outgoing client messages</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">clientWriter</span><span style="color: #b58900;">(</span>conn, ch<span style="color: #b58900;">)</span>

        who := conn.<span style="color: #268bd2;">RemoteAddr</span><span style="color: #b58900;">()</span>.<span style="color: #268bd2;">String</span><span style="color: #b58900;">()</span>
        ch &lt;- <span style="color: #2aa198;">"You are "</span> + who
        messages &lt;- who + <span style="color: #2aa198;">" has arrived"</span>
        entering &lt;- ch

        input := bufio.<span style="color: #268bd2;">NewScanner</span><span style="color: #b58900;">(</span>conn<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> input.<span style="color: #268bd2;">Scan</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                messages &lt;- who + <span style="color: #2aa198;">": "</span> + input.<span style="color: #268bd2;">Text</span><span style="color: #268bd2;">()</span>
        <span style="color: #b58900;">}</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: ignoring potential errors from input.Err()</span>

        leaving &lt;- ch
        messages &lt;- who + <span style="color: #2aa198;">" has left"</span>
        conn.<span style="color: #268bd2;">Close</span><span style="color: #b58900;">()</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">clientWriter</span><span style="color: #2aa198;">(</span>conn <span style="color: #b58900;">net.Conn</span>, ch &lt;-<span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">string</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> msg := <span style="color: #859900; font-weight: bold;">range</span> ch <span style="color: #b58900;">{</span>
                fmt.<span style="color: #268bd2;">Fprintln</span><span style="color: #268bd2;">(</span>conn, msg<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOTE: ignoring network errors</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-handleConn</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!+main</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
        listener, err := net.<span style="color: #268bd2;">Listen</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"tcp"</span>, <span style="color: #2aa198;">"localhost:8000"</span><span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #b58900;">{</span>
                log.<span style="color: #268bd2;">Fatal</span><span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>

        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">broadcaster</span><span style="color: #b58900;">()</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">{</span>
                conn, err := listener.<span style="color: #268bd2;">Accept</span><span style="color: #268bd2;">()</span>
                <span style="color: #859900; font-weight: bold;">if</span> err != <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #268bd2;">{</span>
                        log.<span style="color: #268bd2;">Print</span><span style="color: #6c71c4;">(</span>err<span style="color: #6c71c4;">)</span>
                        <span style="color: #859900; font-weight: bold;">continue</span>
                <span style="color: #268bd2;">}</span>
                <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #268bd2;">handleConn</span><span style="color: #268bd2;">(</span>conn<span style="color: #268bd2;">)</span>
        <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">!-main</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Chapter 09: Concurrency with Shared Variables</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li>前面一章,我们展现了使用goroutine和channel来处理并发问题.这种处理方式自然而直
接,但是在处理的过程当中,我们也发现了一些重要的注意事项,需要我们的程序员来注意
</li>
<li>本章,我们会更进一步的学习并发的机制.特别的,我们会处理"多个goroutine共享变量"
的问题.
</li>
<li>"多goroutine共享变量"这个问题难还在于,我们需要特殊的方法来分析出这种问题的存
在.也就是analytical techniques for recoginzing theose problems
</li>
<li>我们会还会列举解决"多goroutine共享变量"的经典pattern
</li>
<li>最后,我们还会列举一下goroutine和操作系统thread之间的技术上的不同(technical
difference)
</li>
</ul>
</div>
<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">Race Conditions</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>在线性的程序里面(线性的程序,sequential program, 就是只有一个goroutine的程序),
程序允许的顺序是严格的安装logic来的,容易被人所理解.
</li>
<li>但是当程序里面出现多个goroutine的时候,每个goroutine内部还是按照它们的logic顺
序执行,但是我们无法判断来自两个goroutine的event的运行先后顺序.比如eventX发
生在goroutine1里面, eventY发生在goroutine2里面.我们是无法判断这两个event谁
先运行,谁后运行的
</li>
<li>当我们无法自信的说出两个event哪个先运行,哪个后运行的时候,我没说这两个event是
并行的
<pre class="example">
When we cannot confidently say that one event happens before the
other, then the events x and y are concurrent.
</pre>
</li>
<li>一个在线性程序里面正确运行的程序,如果并行的被调用(called concurrently,就是说
在没有额外的同步手段的情况下,从多个goroutine里面来调用这个函数)的时候,依然能
够正确的运行,那我们说这个function是线程安全的
<pre class="example">
Function is concurrency-safe if it continues to work correctly
even when called concurrently, that is, from two or more goroutine
with no additional synchronization.
</pre>
</li>
<li>对一个function的线程安全判断可以扩展到一个type.如果一个type的所有的可以接触
到的method和operation都是线程安全的,那么这个type就是线程安全的
</li>
<li>注意type的线程安全是一个比较模糊的判断,并不是像function这么具体,type的线程
安全与否很多时候都是体现在文档里面
</li>
<li>我们可以通过很多的"同步手段"来让我们的程序编程线程安全的,使用这个"同步手段"
是因为很多function或者type本身不是线程安全的.换句话说,一个程序可以做到线程
安全,即便组成这个程序的type或是function有些不是线程安全的
</li>
<li>golang里面比较特殊的是,它还有package level的函数.这种函数因为其特殊性,所以
一般来说都是要求线程安全的.因为这些函数都是会被多个goroutine引用的.而package
level的variable就更麻烦了,因为没有function的包裹,所以无法做到线程安全,而这
些变量还可能会被多个goroutine所引用.所以,我们约定更改package-level变量的function
一定要加互斥(获取锁才能访问这个变量)
<pre class="example">
Since package-level variables cannot be confined to a single
goroutine, functions that modify them must enforce mutual exclusion
</pre>
</li>
<li>正常的发布的go library应该不会暴露可以更改的package-level变量,暴露的肯定也是
const的
</li>
<li>一个在普通模式下正常,但是在多线程下工作不正常的function变得不正常的原因常见
的有以下几个:
<ul class="org-ul">
<li>deadlock: 用英语简单描述就是"Me first, Me first"
</li>
<li>livelock: 用英语简单描述就是"You first, You first"
</li>
<li>starvation: 用英语简单描述就是"Some first, Otehr never"
</li>
<li>race condition: 用英语的简单描述就是"race to write the global variable"
</li>
</ul>
</li>
<li>对于deadlock(死锁)和livelock(活锁)问题可以用哲学家吃面条(两个叉子)问题来解释:
<pre class="example">
       五位哲学家在一个圆桌吃面条,每次吃面条的时候,都要拿起两个叉子
       死锁:每个哲学家都拿起左手的叉子,永远等待右手的叉子(系统永远
       不会进行到下一个状态)
       活锁:每个哲学家同时拿起左手的叉子,等待五分钟后又同时放下左手
       的叉子,并且再过五分钟同时再尝试.这种方法消除了死锁(系统总会
       进入到下一个状态),但是这种状态也只是空空浪费资源,所以叫活锁
</pre>
</li>
<li>我们可以看到,活锁很多时候是为了解决死锁而产生的问题
</li>
<li>至于starvation就比较好理解了,是某些个运行的process被调度器(scheduler)完全忽
略的情形.虽然某些process完全可以运行,但是它永远不会被调度器选中.某些情况下
共同运行的thread里面,有些个greedy thread从来不给其他thread运行的机会,就会造
成其他thread的starvation
</li>
<li>我们这一节主要介绍的就是race condition,race condition的发生原因在于两个thread
(在go里面就是goroutine啦)不加保护的共同访问全局变量.race condition不仅危害巨
大而且由于其是在特定的情况下才发生,所以非常不容易被察觉,下面就是一个go的race
conditon的例子
<div class="org-src-container">

<pre class="src src-go"><span style="color: #859900; font-weight: bold;">package</span> main

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">(</span>
        <span style="color: #2aa198;">"fmt"</span>
        <span style="color: #2aa198;">"os"</span>
<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">var</span> balance int

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Deposit</span><span style="color: #2aa198;">(</span>amount <span style="color: #b58900;">int</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
        balance = balance + amount
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">Balance</span><span style="color: #2aa198;">()</span> <span style="color: #b58900;">int</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> balance <span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">func</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>

        ch := <span style="color: #657b83; font-weight: bold;">make</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">chan</span> <span style="color: #b58900;">int</span>, 2<span style="color: #b58900;">)</span>
        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">Deposit</span><span style="color: #268bd2;">(</span>200<span style="color: #268bd2;">)</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"A="</span>, <span style="color: #268bd2;">Balance</span><span style="color: #6c71c4;">()</span><span style="color: #268bd2;">)</span>
                ch &lt;- 0
        <span style="color: #b58900;">}()</span>

        <span style="color: #859900; font-weight: bold;">go</span> <span style="color: #859900; font-weight: bold;">func</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
                <span style="color: #268bd2;">Deposit</span><span style="color: #268bd2;">(</span>100<span style="color: #268bd2;">)</span>
                fmt.<span style="color: #268bd2;">Println</span><span style="color: #268bd2;">(</span><span style="color: #2aa198;">"B="</span>, <span style="color: #268bd2;">Balance</span><span style="color: #6c71c4;">()</span><span style="color: #268bd2;">)</span>
                ch &lt;- 0
        <span style="color: #b58900;">}()</span>

        &lt;-ch
        &lt;-ch

        fmt.<span style="color: #268bd2;">Println</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"R="</span>, <span style="color: #268bd2;">Balance</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>
        os.<span style="color: #268bd2;">Exit</span><span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">}</span>


<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A= 200</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">B= 300</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">R= 300</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A= 300</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">B= 100</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">R= 300</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">B= 100</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A= 300</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">R= 300</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">B= 300</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A= 200</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">R= 300</span>
</pre>
</div>
</li>
<li>从结果的多变性来看,多线程环境下的变数就很多了.但是看起来却真的没有什么错,因
为首先结果都是300,只不过先运行A还是先运行B会导致中间的结果不一样.但是前面说
了,race condition的问题在于非常多次的运行才会有一次的发生.我们做了个实验在
运行了上面的程序1000次以后,终于有一次错误的输出
<div class="org-src-container">

<pre class="src src-go"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">A= 200</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">B= 100</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">R= 200</span>
</pre>
</div>
</li>
<li>这种错误的来源在于什么呢,在于A读取数据之后,和A写入数据之前,如果B写入了数据,
那么B的写入就会被A的写入所覆盖.换句话说,B在race中,输给了A,它的写入没有算数
<pre class="example">
B's deposit occurs in the middle of A's deposit, after the blance
has been read but before it has been updated, causing B's transaction
to disappear. A's deposit operation is really a sequence of two operation,
a read and a write. We should keep the whole transaction run without
being interrupted
</pre>
</li>
<li>我们使用下面的图标来表示下
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="right" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Action</th>
<th scope="col" class="right">Balance</th>
<th scope="col" class="left">Code</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">A read</td>
<td class="right">0</td>
<td class="left">&#x2026; = balance + amount</td>
</tr>

<tr>
<td class="left">B read&amp;write</td>
<td class="right">100</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">A write</td>
<td class="right">200</td>
<td class="left">balance = &#x2026;</td>
</tr>

<tr>
<td class="left">Final</td>
<td class="right">200</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</li>
<li>这种由于多个线程访问内存引起的race condition有一个特别的名字,叫做data race,
而且data race有其严格的定义: data race 发生在两个goroutine并发的访问同一个
变量,并且其中一个访问是write
<pre class="example">
A data race occurs whenever two goroutines access the same
variable concurrently and at least one of the access is a write
</pre>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
