<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>meta</title>
<!-- 2017-05-02 Tue 10:44 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">meta</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 1 The M Word</a>
<ul>
<li><a href="#sec-1-1">Ghost Towns and Marketplaces</a></li>
<li><a href="#sec-1-2">The Story of Bob, Metaprogrammer</a></li>
<li><a href="#sec-1-3">Metaprogramming and Ruby</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 2: Monday: The Object Model</a>
<ul>
<li><a href="#sec-2-1">Open Classes</a></li>
<li><a href="#sec-2-2">Inside the Object Model</a></li>
<li><a href="#sec-2-3">Wht Happends When You Call a Method?</a></li>
</ul>
</li>
<li><a href="#sec-3">Chapter 3: Tuesday:Methods</a>
<ul>
<li><a href="#sec-3-1">A Duplication Problem</a></li>
<li><a href="#sec-3-2">Dynamic Methods</a>
<ul>
<li><a href="#sec-3-2-1">The Pry Example</a></li>
<li><a href="#sec-3-2-2">Defining Methods Dynamically</a></li>
</ul>
</li>
<li><a href="#sec-3-3">method_missing</a>
<ul>
<li><a href="#sec-3-3-1">The Hashie Example</a></li>
<li><a href="#sec-3-3-2">Dynamic Proxies</a></li>
<li><a href="#sec-3-3-3">Refactoring the Computer Class(Again)</a></li>
<li><a href="#sec-3-3-4">respond_to_missing?</a></li>
</ul>
</li>
<li><a href="#sec-3-4">Blank Slates</a></li>
</ul>
</li>
<li><a href="#sec-4">Chapter 4: Wednesday: Blocks</a>
<ul>
<li><a href="#sec-4-1">The Day of the Blocks</a></li>
<li><a href="#sec-4-2">Quiz: Ruby#</a></li>
<li><a href="#sec-4-3">Blocks Are Closures</a>
<ul>
<li><a href="#sec-4-3-1">Scope</a></li>
<li><a href="#sec-4-3-2">Scope Gates</a></li>
<li><a href="#sec-4-3-3">Flattening the Scope</a></li>
<li><a href="#sec-4-3-4">Sharing the Scope</a></li>
<li><a href="#sec-4-3-5">Closures Wrap-Up</a></li>
</ul>
</li>
<li><a href="#sec-4-4">instance_eval()</a>
<ul>
<li><a href="#sec-4-4-1">Breaking Encapsulation</a></li>
<li><a href="#sec-4-4-2">Padrino Example</a></li>
<li><a href="#sec-4-4-3">Clean Rooms</a></li>
</ul>
</li>
<li><a href="#sec-4-5">Callable Objects</a>
<ul>
<li><a href="#sec-4-5-1">Proc Objects</a></li>
<li><a href="#sec-4-5-2">The &amp; Operator</a></li>
<li><a href="#sec-4-5-3">Proc vs. Lambdas</a></li>
<li><a href="#sec-4-5-4">Method Objects</a></li>
<li><a href="#sec-4-5-5">Unbound Methods</a></li>
</ul>
</li>
<li><a href="#sec-4-6">Writing a Domain-Specific Language</a></li>
</ul>
</li>
<li><a href="#sec-5">Chapter 5: Thursday: Class Definitions</a>
<ul>
<li><a href="#sec-5-1">Class Definitions Demystified</a>
<ul>
<li><a href="#sec-5-1-1">The Current Class</a></li>
<li><a href="#sec-5-1-2">Class Instance Variables</a></li>
<li><a href="#sec-5-1-3">Working on Bookworm Again</a></li>
</ul>
</li>
<li><a href="#sec-5-2">Quiz: Class Taboo</a></li>
<li><a href="#sec-5-3">Singleton Methods</a>
<ul>
<li><a href="#sec-5-3-1">Introducing Singleton Methods</a></li>
<li><a href="#sec-5-3-2">The Truth About Class Methods</a></li>
<li><a href="#sec-5-3-3">Class Macros</a></li>
</ul>
</li>
<li><a href="#sec-5-4">Singleton Classes</a>
<ul>
<li><a href="#sec-5-4-1">The Mystery of Singleton Methods</a></li>
<li><a href="#sec-5-4-2">Singleton Classes Revealed</a></li>
<li><a href="#sec-5-4-3">Method Lookup Revisited</a></li>
<li><a href="#sec-5-4-4">Singleton Classes and Inheritance</a></li>
<li><a href="#sec-5-4-5">The Great Unified Theory</a></li>
<li><a href="#sec-5-4-6">Class Methods Syntaxes</a></li>
<li><a href="#sec-5-4-7">Singleton Classes and instance_eval()</a></li>
<li><a href="#sec-5-4-8">Class Attributes</a></li>
</ul>
</li>
<li><a href="#sec-5-5">Quiz: Module Trouble</a>
<ul>
<li><a href="#sec-5-5-1">Quiz Solution</a></li>
<li><a href="#sec-5-5-2">Object#extend</a></li>
</ul>
</li>
<li><a href="#sec-5-6">Method Wrappers</a></li>
</ul>
</li>
<li><a href="#sec-6">Chapter 6: Friday: Code That Writes Code</a>
<ul>
<li><a href="#sec-6-1">Coding Your Way to the Weekend</a></li>
</ul>
</li>
<li><a href="#sec-7">Chapter 7: Epilogue</a></li>
<li><a href="#sec-8">Chapter 8: Preparing for a Rails Tour</a>
<ul>
<li><a href="#sec-8-1">Ruby on Rails</a></li>
</ul>
</li>
<li><a href="#sec-9">Chapter 9: The Design of Active Record</a>
<ul>
<li><a href="#sec-9-1">A Short Active Record Example</a></li>
<li><a href="#sec-9-2">How Active Record Is Put Together</a></li>
<li><a href="#sec-9-3">The Autoloading Mechanism</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 1 The M Word</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>所谓metaprogramming其实就是让某些code自己写code
<pre class="example">
Metaprogramming is writing code that writes code
</pre>
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Ghost Towns and Marketplaces</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>把你的源代码理解成包含如下多种成员的城市, 我们可以把这些都叫做language
construct:
<ul class="org-ul">
<li>variable
</li>
<li>class
</li>
<li>method
</li>
</ul>
</li>
<li>对于大部分的语言来说,language construct就像鬼城里面的成员:
<ul class="org-ul">
<li>你可以在源代码里面看到它们
</li>
<li>但是当program变成了process的时候,它们就消失了
</li>
</ul>
</li>
<li>以cpp为例,一旦编译器完成了工作,那么variable,method等等就变成了冷冰冰的内存
地址.你不能ask一个类,你有哪些函数,因为当运行的时候,class甚至都已经不存在了!
</li>
<li>反之,以ruby为例,runtime就更像是一个活跃的市场,你完全可以问一个language construct
它当前的信息,这种功能叫做introspection(内省)
</li>
<li>这里插播一句,除了introspection(内省),我们还会遇到reflection(反射),这两次在
java里面都有,比较容易比较.简单点说就是introspection是"看"对象有什么property,
method.而reflection比较高级,会去"改"当前对象的property,method等
<pre class="example">
In computing, type introspection is the ability of a program to
examine the type or properties of an object at runtime. Some
programming languages possess this capability.

Introspection should not be confused with reflection, which goes
a step further and is the ability for a program to manipulate the
values, meta-data, properties and/or functions of an object at
runtime. Some programming languages, e.g. Java, also possess
that capability.
</pre>
</li>
<li>下面是一段ruby的代码,我们后面可以演示如何对my_object进行introspection
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Greeting</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>text<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@text</span> = text
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">welcome</span>
    <span style="color: #268bd2;">@text</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

my_object = <span style="color: #b58900;">Greeting</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"hello"</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>内省就是可以把所有的信息,包括object的类是什么,类有哪些method,object有哪些
instance variable,都打印出来
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">p</span> my_object.class            <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; Greeting</span>
<span style="color: #657b83; font-weight: bold;">p</span> my_object.class.instance_methods<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:welcome]</span>
<span style="color: #657b83; font-weight: bold;">p</span> my_object.instance_variables            <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:@text]</span>
</pre>
</div>
</li>
<li>我们前面说了,连java都会有reflection的功能(也就是不光"看"还可以"改"),那么ruby
可以么?答案是肯定的!下面就是一个例子
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">The Story of Bob, Metaprogrammer</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>Bob是一个ruby新兵,他的一个想法是使用ruby把所有的movie都总结一下,他需要设计
一个数据库,数据库里面主要保留movie和对movie的评论.
</li>
<li>数据库中一个表对应oo语言中的一个类,数据库中的一行对应oo语言中的一个instance
已经是深入人心的事情,所以ORM也诞生了无数的作品.Bob也希望自己写一个orm来完成
对Movie和Review的持久化操作,下面是他的第一次尝试
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Entity</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:table</span>, <span style="color: #268bd2; font-weight: bold;">:ident</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>table, ident<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@table</span> = table
    <span style="color: #268bd2;">@ident</span> = ident
    <span style="color: #b58900;">Database</span>.sql <span style="color: #2aa198;">"INSERT INTO </span><span style="color: #268bd2;">#{@table}</span><span style="color: #2aa198;"> (id) VALUES (</span><span style="color: #268bd2;">#{@ident}</span><span style="color: #2aa198;">)"</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">set</span><span style="color: #2aa198;">(</span>col, val<span style="color: #2aa198;">)</span>
    <span style="color: #b58900;">Database</span>.sql <span style="color: #2aa198;">"UPDATE </span><span style="color: #268bd2;">#{@table}</span><span style="color: #2aa198;"> SET </span><span style="color: #268bd2;">#{col}</span><span style="color: #2aa198;"> = '</span><span style="color: #268bd2;">#{val}</span><span style="color: #2aa198;">' WHERE id=</span><span style="color: #268bd2;">#{@ident}</span><span style="color: #2aa198;">"</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get</span><span style="color: #2aa198;">(</span>col<span style="color: #2aa198;">)</span>
    <span style="color: #b58900;">Database</span>.sql <span style="color: #2aa198;">(</span><span style="color: #2aa198;">"SELECT </span><span style="color: #268bd2;">#{col}</span><span style="color: #2aa198;"> FROM </span><span style="color: #268bd2;">#{@table}</span><span style="color: #2aa198;"> WHERE id=</span><span style="color: #268bd2;">#{@ident}</span><span style="color: #2aa198;">"</span><span style="color: #2aa198;">)[</span>0<span style="color: #2aa198;">][</span>0<span style="color: #2aa198;">]</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>在这之后,创建一个Movie的类来继承我们的orm
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Movie</span> &lt; <span style="color: #b58900;">Entity</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>ident<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">super</span> <span style="color: #2aa198;">"movies"</span>, ident
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">title</span>
    get <span style="color: #2aa198;">"title"</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">title=</span><span style="color: #2aa198;">(</span>value<span style="color: #2aa198;">)</span>
    set <span style="color: #2aa198;">"title"</span>, value
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">director</span>
    get <span style="color: #2aa198;">"director"</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">director=</span><span style="color: #2aa198;">(</span>value<span style="color: #2aa198;">)</span>
    set <span style="color: #2aa198;">"director"</span>, value
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>上面这段title,和title=的函数,就是java中非常常见的getter和setter.而在ruby里面
因为其强大的reflect,你甚至可以不去写setter和getter,就能够拥有他们(当然了,具体
set什么get什么,是从数据库里面读取的,比如数据库的一个叫做movies的表,如果有一
个列叫做title,那么我们就可以在runtime创造出两个title和title=函数
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Movie</span> &lt; <span style="color: #b58900;">ActiveRecord</span>::<span style="color: #b58900;">Base</span>
<span style="color: #859900; font-weight: bold;">end</span>

movie = <span style="color: #b58900;">Movie</span>.create
movie.title = <span style="color: #2aa198;">"Doctor Strangelove"</span>
movie.title                     <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "Doctor Strangelove"</span>
</pre>
</div>
</li>
<li>好了,我们现在就可以对metaprogramming进行重新的,更详细的定义了
<pre class="example">
Metaprogramming is writing code the manipulates languages
constructs at runtime
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Metaprogramming and Ruby</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>ruby是对metaprogramming特别友好的语言,他不存在compile time,而在runtime所有
的construct都是可见的
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 2: Monday: The Object Model</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Open Classes</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>首先看这么一个问题,legacy代码中存在一个叫做去除string中的特殊字符的函数,从c
语言过来的我们,很自然的就会想到如下代码
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">to_alphanumeric</span><span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>
  s.gsub<span style="color: #2aa198;">(</span><span style="color: #2aa198;">/[^\w\s]/</span>, <span style="color: #2aa198;">''</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>ruby牛逼的地方在于,class对于它来说,不过是一个scope而已,任何人都可以打开一个
scope向里面添加自己需要的method,即便是standard library也不例外,比如
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">String</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">to_alphanumeric</span>
    gsub<span style="color: #2aa198;">(</span><span style="color: #2aa198;">/[^\w\s]/</span>, <span style="color: #2aa198;">''</span><span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>你在多个地方定义了一个Class D,其实只不过是"多次"打开某个scope里面而已
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">D</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">x;</span> <span style="color: #2aa198;">'x'</span>; <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">D</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">y;</span> <span style="color: #2aa198;">'y'</span>; <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">D</span>.new
<span style="color: #657b83; font-weight: bold;">p</span> obj.x
<span style="color: #657b83; font-weight: bold;">p</span> obj.y

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"x"                                            #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"y"                                            #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>但是open class不能乱用,特别是对standard library 里面的class,因为standard
library 里面可能已经有同名的method了,如果你再用的话,那就会覆盖以往的method
</li>
<li>这种覆盖standard library里面的method的行为有个不好听的名字叫做:monkey patch
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Inside the Object Model</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>ruby的object model和其他语言有很大不同,我们先看一个例子
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span>
    <span style="color: #268bd2;">@v</span> = 1
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">MyClass</span>.new
obj.class                       <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; MyClass</span>
</pre>
</div>
</li>
<li>第一点要强调的是,ruby里面"即便是继承于同一个class"的不同的object会有不同的
instance variable!这个和java是不一样的,在java里面,所有的object(继承于同一个
class)是有相同的instance variable的,只不过里面的值可能不一样.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span>
    <span style="color: #268bd2;">@v</span> = 1
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj1 = <span style="color: #b58900;">MyClass</span>.new
obj2 = <span style="color: #b58900;">MyClass</span>.new

<span style="color: #657b83; font-weight: bold;">p</span> obj1.instance_variables
obj2.my_method
<span style="color: #657b83; font-weight: bold;">p</span> obj2.instance_variables

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[]                                             #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[:@v]                                          #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>和java一样的是,所有的object(继承于同一个class)的method是相同的!也就是说met
hod和instance variable的待遇是不同的,那么我们也可以意识到其存储方式也是不同
的.真实的情况是,instance variable是和object存储在一起的,而methods则是存储在
class里面,object会有指针指向自己的class
<pre class="example">
   Object                          Class
+------------+               +-------------------+
|            |               |                   |
|  obj2      |               |  MyClass          |
|            |--------------&gt;|                   |
+------------+               +-------------------+
| @v = 1     |               |  my_method()      |
+------------+               +-------------------+
</pre>
</li>
<li>下面是比较拗口的一个解释,你可以说:
<ul class="org-ul">
<li>obj2有一个instance variable叫做@v
</li>
<li>obj2有一个method叫做my_method
</li>
</ul>
</li>
<li>但是你不能说:
<ul class="org-ul">
<li>MyClass有一个method叫做my_method
</li>
</ul>
</li>
<li>但是,MyClass看起来和my_method的的确确是有点联系的,这个联系我们取个说法叫做:
<ul class="org-ul">
<li>myClass有一个`instance method`叫做my_method!
</li>
</ul>
</li>
<li>下面这个例子就可以证明class string的instance method其实就是普通字符串object
的method
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">String</span>.instance_methods == <span style="color: #2aa198;">"abc"</span>.methods <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; true</span>
<span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">String</span>.methods == <span style="color: #2aa198;">"abc"</span>.methods          <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; false</span>
</pre>
</div>
</li>
<li>从class可以拥有"instance method",而这个object可以拥有"instance variable"来
看, object和class有点像,而在ruby里面,class就是一个object!
<pre class="example">
classes themselves are nothing but objects
</pre>
</li>
<li>这个抽象一出,那么所有的object拥有的能力,class也必须拥有
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #2aa198;">"hello"</span>.class <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; String</span>
<span style="color: #b58900;">String</span>.class  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; Class</span>
</pre>
</div>
</li>
<li>在java里面,我们在reflect里面,也会看到类似Class类的东西,但是那个类是个只读的,
而ruby里面,你甚至可以在runtime更改这个Class类!
<pre class="example">
Wheile other languages allow you to read class-related information,
Ruby allows you to write that information at runtime.
</pre>
</li>
<li>好了,我们的普通类都是object,那么普通类的method,其实也就是class类的instance
method.那我们来看看Class的instance variable(非继承的)有哪些
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">Class</span>.instance_methods<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #2aa198;">)</span>   <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:allocate, :new, :superclass]</span>
</pre>
</div>
</li>
<li>new是创建object用的,allocate是辅助new的,而superclass就是最常见的,查找自己的
parent类
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">Array</span>.superclass                <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; Object</span>
<span style="color: #b58900;">Object</span>.superclass               <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; BasicObject</span>
<span style="color: #b58900;">BasicObject</span>.superclass          <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; nil</span>
</pre>
</div>
</li>
<li>好了,我们可以看一个终极问题, class的superclass是谁
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">Class</span>.superclass                <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; Module</span>
</pre>
</div>
</li>
<li>结果令人惊讶,Class的parent是module,那么也就是说Class的object,也就是普通的类
其本质上也是一个module.用更准确的语言来说就是
<pre class="example">
class is a module with three additional instance methods(You
can see from Class.instance_methods(false)) that allow you to
create objects or arrange classes into hierarchies.
</pre>
</li>
<li>根据module和class本质的不同(三个函数),我们可以知道该如何取舍:
<ul class="org-ul">
<li>如果你想把某些代码在其他的地方被include,那么你就使用module
</li>
<li>如果你想实例化类或者类被其他人继承,那么你就选择使用class
</li>
</ul>
</li>
<li>下面是一段表达object和class关系的代码
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>; <span style="color: #859900; font-weight: bold;">end</span>
obj1 = <span style="color: #b58900;">MyClass</span>.new
obj2 = <span style="color: #b58900;">MyClass</span>.new
</pre>
</div>
</li>
<li>我们使用图表的方式来表达它们的组织结构:
<pre class="example">
                                +--------------+               +--------------+
                                |   Object     |               |   Module     |
                                +--------------+               |              |
                                |   to_s(),... |               |              |
+--------+                      +--------------+               +--------------+
|        |  class                      ^                               ^
| obj1   +--------+                    |                               |
+--------+        |                    |                               |
                  |                    | superclass                    | superclass
                  |             +------+-------+               +-------+------+
                  +------------&gt;|  MyClass     +--------------&gt;|   Class      |
                  |             |              | class         +--------------+
+--------+        |             |              |               |  new(),...   |
|        |  class |             +--------------+               +--------------+
| obj2   +--------+
+--------+
</pre>
</li>
<li>就像所有的其他object都可以存储在variable里面一样,我们也可以使用一个变量来存
储一个Class,就像下面一样
<div class="org-src-container">

<pre class="src src-ruby">my_class = <span style="color: #b58900;">MyClass</span>
</pre>
</div>
</li>
<li>my_class和MyClass一样,它们都指向(reference)同一个Class的instance,但是它们也
有不同:
<ul class="org-ul">
<li>my_class是一个变量
</li>
<li>MyClass是一个常量
</li>
</ul>
</li>
<li>换句话说, 就像class不过是object一样, class name只不过是constant
</li>
<li>所有以大写字母开头的reference(包括class name和module name)都是常量:
<ul class="org-ul">
<li>对于起到常量作用的值来说,其命名一般是全大写,使用下划线分割,比如LIKE_THIS
</li>
<li>对于class或者module名字来说使用首字母大写的驼峰命名法,比如LikeThis
</li>
</ul>
</li>
<li>你可能会惊奇的是ruby竟然允许更改常量!虽然这会导致一些warning
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">HELLO</span> = <span style="color: #2aa198;">'helloworld'</span>
<span style="color: #b58900;">HELLO</span> = <span style="color: #2aa198;">'helloworld2'</span>
<span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">HELLO</span>

<span style="color: #93a1a1;">################################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;               #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">example.rb:2: warning: already initialized constant HELLO    #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">example.rb:1: warning: previous definition of HELLO was here #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"helloworld2"                                                #</span>
<span style="color: #93a1a1;">################################################################</span>
</pre>
</div>
</li>
<li>既然constant的值也是可以更改的,那么创造constant的原因何在,其和variable的本
质不同在哪里?
</li>
<li>本质上一个重要的不同const和variable定义的位置和scope不同
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Hello</span>
  <span style="color: #b58900;">PI</span> = 3.14159
  <span style="color: #268bd2;">@not_used</span> = 3.15
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">print</span>
    pi = <span style="color: #b58900;">PI</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"pi is </span><span style="color: #268bd2;">#{pi}</span><span style="color: #2aa198;">"</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"PI is </span><span style="color: #268bd2;">#{PI}</span><span style="color: #2aa198;">"</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"not used is </span><span style="color: #268bd2;">#{@not_used}</span><span style="color: #2aa198;">"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

hello = <span style="color: #b58900;">Hello</span>.new
hello.print

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">pi is 3.14159                                  #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">PI is 3.14159                                  #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">not used is                                    #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>上面例子中,可以看出,普通variable主要是定义在method里面的, 如果定义在class(或
者Module)里面,必须是instance variable,然而因为没有在initialize()里面,所以是
没有值的(not_used)
</li>
<li>而constant就可以光明正大的在class(或者module)体内定义,而且可以在这个class(或
者module)生命期里面都有效
</li>
<li>普通constant定义在class(或者module)里面.这里出现的三个词,普通constant,class,
module其实三个都是广义上的constant,它们结合起来还有更重要的用法.那就是作为
Namespace,比如下面的M::C::X,通过`:`连接的,都必须是常量!
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M</span>
  <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">C</span>
    <span style="color: #b58900;">X</span> = <span style="color: #2aa198;">'a constant'</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">M</span>::<span style="color: #b58900;">C</span>::<span style="color: #b58900;">X</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"a constant"                                   #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>把普通常量看成是文件的话,那么class或者module其实就是文件夹(文件夹也是一种文
件哦,只不过普通用户不能改动的文件),这也是ruby项目组织代码的一种方式.
</li>
<li>文件夹里面的文件名和另外文件夹里面的文件名是可以重复的,而在root文件夹的名字
有个特点是:没有path路径,文件系统里面我们使用"/"来处理root文件,而在ruby里面
我们使用'::'来起到相同的功能
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">Y</span> = <span style="color: #2aa198;">'a root-level constant'</span>

<span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M</span>
  <span style="color: #b58900;">Y</span> = <span style="color: #2aa198;">'a constant in M'</span>
  <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">Y</span>
  <span style="color: #657b83; font-weight: bold;">p</span> ::<span style="color: #b58900;">Y</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"a constant in M"                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"a root-level constant"                        #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>ruby中提供了两个函数来打印constant:
<ul class="org-ul">
<li>一个是class method(就是self.xxx定义的)用来返回当前程序running time中所有
的常量:
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">Module</span>.constants   <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:Object, :Module, :Class,...]</span>
</pre>
</div>
</li>
<li>另外是一个instance method,用来返回调用者(一个module object)里面所有的常量
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M</span>
  <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">C</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #b58900;">Y</span> = <span style="color: #2aa198;">'A test'</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">M</span>.constants

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[:C, :Y]                                       #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</li>
<li>还可以使用nesting函数来打印当前的"路径"
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M</span>
  <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">C</span>
    <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M2</span>
      <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">Module</span>.nesting
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[M::C::M2, M::C, M]                            #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>前面我们已经把Object, Class, Module等等的关系通过一个图展示出来了,但是经过
一系列的学习,我们希望获得对他们更多的认识,简言之就是回答下面几个问题:
<ul class="org-ul">
<li>Object的class类型是什么
</li>
<li>Module的superclass是什么
</li>
<li>Class的class类型是什么
</li>
</ul>
</li>
<li>下面就是最后的结果
<pre class="example">
                                     superclass
                         +-------------------------------+
                         |                               |
                         V                               |
                      +--------------+           +-------+------+
                      |   Object     |           |   Module     |
                      +--------------+ class     |              |
                      |   to_s(),... +------+    |              |
+----+                +------^-------+      |    +-------^------+
|    |  class                |              |            |
|obj1+--------+              |              |            |
+----+        |              |              |            |
              |              | superclass   |            | superclass
              |       +------+-------+      +---&gt;+-------+------+
              +------&gt;|  MyClass     +----------&gt;|   Class      |----+
              |       |              | class     +--------------+    |
+----+        |       |              |           |  new(),...   |    |
|    |  class |       +--------------+           +------^-------+    |
|obj2+--------+                                         |      class |
+----+                                                  |            |
                                                        +------------+
</pre>
</li>
<li>总体的趋势是Class是所有class的"终点", Object是所有superclass的"终点"
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Wht Happends When You Call a Method?</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>知道了这个图以后,就可以了解ruby是如何调用代码的了,这个过程分成了两个步骤:
<ul class="org-ul">
<li>首先去寻找method(因为method并不是在object里面),这个过程叫做method lookup
</li>
<li>然后会去执行method,执行的时候,需要知道self是谁
</li>
</ul>
</li>
<li>寻找method的过程,可以使用书面语简答的解释为"one step to the right, then up"
的规则.其实就是object去自己的class里面找,找不到就到class的superclass去找,一
直找到root class
<pre class="example">
                       +---------------+
                       |    Object     |
                       |               |            ^
                       +-------^-------+            |
                               |                    |
                               |                UP  |
                               |                    |
                               | superclass         |
                       +-------+-------+            |
                       |   MyClass     |            |
                       +---------------+            |
                       |  my_method()  |            |
                       +-------^-------+            |
                               |                    |
                               |                    |
                               | superclasss        |
+---------+            +-------+-------+            |
|  obj    |  class     |  MySubclass   |            |
|         +-----------&gt;|               |            |
+---------+            +---------------+            |


        --------------------------&gt;  RIGHT
</pre>
</li>
<li>上图对应的代码如下
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method;</span> <span style="color: #2aa198;">'my_method()'</span>; <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MySubclass</span> &lt; <span style="color: #b58900;">MyClass</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">MySubclass</span>.new
obj.my_method<span style="color: #2aa198;">()</span>                 <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "my_method()"</span>
</pre>
</div>
</li>
<li>我们可以使用ancestors这个函数来查看我们整个"then up"的过程
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">MySubclass</span>.ancestors
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [MySubclass, MyClass, Object, Kernel, BasicObject]</span>
</pre>
</div>
</li>
<li>从ruby2.0开始,我们还可以使用prepend"插入"一个module
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">C2</span>
  <span style="color: #657b83; font-weight: bold;">prepend</span> <span style="color: #b58900;">M2</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">D2</span> &lt; <span style="color: #b58900;">C2</span>; <span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #b58900;">D2</span>.ancestors  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [D2, M2, C2, Object, Kernel, BasicObject]</span>
</pre>
</div>
</li>
<li>而传统的include则是在当前class"之上"加入一个module. 区别如下
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M1</span>; <span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M3</span>
  <span style="color: #657b83; font-weight: bold;">prepend</span> <span style="color: #b58900;">M1</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">M2</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #b58900;">M3</span>.ancestors   <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [M1, M3, M2]</span>
</pre>
</div>
</li>
<li>这里还有一个非常容易出错的地方,就是include和prepend是可以"嵌套"的,而为了避
免这种情况,ruby里面不允许嵌套的存在:也就是说,一个module只能出现一次
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M1</span>; <span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M2</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">M1</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M3</span>
  <span style="color: #657b83; font-weight: bold;">prepend</span> <span style="color: #b58900;">M1</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">M2</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #b58900;">M3</span>.ancestors   <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [M1, M3, M2]</span>
</pre>
</div>
</li>
<li>前面的ancestor chain里面出现了一个Kernel,这其实是一个Module,我们知道既然设
计成Module,那么就是不想被继承,只想被include的主.而Kernel则被Object给include
了,这也就意味着,所有的对象都可以使用Kernel里面的代码
</li>
<li>我们经常可以直接在一行里面使用print xxx,就是因为Ruby代码其实这是在某个object
里面运行的,这个object肯定也是include了Kernel Module的代码.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">Kernel</span>.private_instance_methods.grep /^<span style="color: #657b83; font-weight: bold;">p</span>/
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:printf, :print, :putc, :puts, :p, :proc]</span>
</pre>
</div>
</li>
<li>前面是"find method"的过程,后面我们讲的是如何"调用"这个method,比如下面的代码
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span>
  temp = <span style="color: #268bd2;">@x</span> + 1
  my_other_method<span style="color: #2aa198;">(</span>temp<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>我们要调用这个代码,就会遇到很多问题,比如:
<ul class="org-ul">
<li>第一这@x是一个instance variable,那么它属于哪个object呢?
</li>
<li>第二这my_other_method是一个method,但是前面没有calller,那么它属于哪个object
呢?
</li>
</ul>
</li>
<li>在ruby里面,上面的问题有一个统一的答案,那就是self(因为你可以使用保留关键字
self随时取出这个值).上面的例子就可以使用下面的代码来处理self就是一个class
Other的instance
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Other</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span>
    <span style="color: #268bd2;">@x</span> = 35
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span>
    temp = <span style="color: #268bd2;">@x</span> + 1
    my_other_method<span style="color: #2aa198;">(</span>temp<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_other_method</span><span style="color: #2aa198;">(</span>temp<span style="color: #2aa198;">)</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"temp is </span><span style="color: #268bd2;">#{temp}</span><span style="color: #2aa198;">"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #b58900;">Other</span>.new.my_method
</pre>
</div>
</li>
<li>在ruby里面因为"everything is object",所以self的变化非常的频繁.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">A</span>
  <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #859900; font-weight: bold;">self</span>
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">B</span>
    <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #859900; font-weight: bold;">self</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">tester</span>
    <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #859900; font-weight: bold;">self</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #859900; font-weight: bold;">self</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #b58900;">A</span>.new.tester

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">A                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">A::B                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">A                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">#&lt;A:0x007f8401176bf0&gt;                          #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>上面的self历经class A, module A::B, objectA最后又回到了class A.上述这种是最
常见的情况,也不是特别的难以理解.但是还是有很多时候是难以理解的,比如:
<ul class="org-ul">
<li>The Top Level: 就是在.rb文件里面上来就打印self,结果往往是返回一个叫做main
的object,这个main是class Object的一个object
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">self</span>                            <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; main</span>
<span style="color: #859900; font-weight: bold;">self</span>.class                      <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; Object</span>
</pre>
</div>
</li>
<li>private的self的抵触,如果我告诉你self.private_method会失败,你一定开始不太
理解.但是这就是ruby里面对于private的定义:一定要使用implicit的receiver,而
不能使用explicit的receiver,即便是self也不行.
</li>
</ul>
</li>
<li>Ruby2.0引入了refinement来解决Monkey patch的问题,它不再是global的改变library,
因为在refine的时候,还"一定"要引入一个module.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">StringExtensions</span>
  <span style="color: #657b83; font-weight: bold;">refine</span> <span style="color: #b58900;">String</span> <span style="color: #859900; font-weight: bold;">do</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">reverse</span>
      <span style="color: #2aa198;">"esrver"</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>所以在用的时候还是要使用一个using来进入这个module
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">StringBuffer</span>
  <span style="color: #657b83; font-weight: bold;">using</span> <span style="color: #b58900;">StringExtensions</span>
  <span style="color: #2aa198;">"my_stirng"</span>.reverse           <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "esrever"</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #2aa198;">"my_string"</span>.reverse             <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "gnirts_ym"</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 3: Tuesday:Methods</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>前一章我们学习了Ruby object model,这一章我们主要研究methods
</li>
<li>在oo语言中, object是"看上去"的主体,不同的object之间也会经常性的"交流",在Java
这种语言之中,compiler会去check这些"交流"是不是可以正常执行的:换句话说就是比
如你要在Lawyer object上面去调用函数talk_simple, 编译器就要去查询这个object是
否有函数talk_simple
</li>
<li>Python, Ruby等动态语言没有编译期,所以不会"在编译器"做上面的检查,这个"检查"只
会在调用的那一刻,也就是Lawyer调用talk_simple的时候,才回去做.换言之,如果你的
逻辑从来不会进入到lawyer.talk_simple()这一句,那么错误就永不会发生
</li>
<li>静态语言比较严谨,会帮助我们检查.动态语言灵活,不会帮我们检查.我们使用动态语言
开发web,需要灵活运用这种对method的"宽容期"(知道调用才会真正检查)
</li>
</ul>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">A Duplication Problem</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>我们看一个例子,这个例子需要对超过99美元的外设做出警告
</li>
<li>我们的问题是,我们必须使用一段legacy的code
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DS</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">connect to data source...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_cpu_info</span><span style="color: #2aa198;">(</span>workstation_id<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_cpu_price</span><span style="color: #2aa198;">(</span>workstation_id<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_mouse_info</span><span style="color: #2aa198;">(</span>workstation_id<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_mouse_price</span><span style="color: #2aa198;">(</span>workstation_id<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_keyboard_info</span><span style="color: #2aa198;">(</span>workstation_id<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_keyboard_price</span><span style="color: #2aa198;">(</span>workstation_id<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_display_info</span><span style="color: #2aa198;">(</span>workstation_id<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_display_price</span><span style="color: #2aa198;">(</span>workstation_id<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...and so on</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>代码的使用也非常简单,ctor会创建一个DS object,然后调用相应的代码就可以得到外
设的描述和价格
<div class="org-src-container">

<pre class="src src-ruby">ds = <span style="color: #b58900;">DS</span>.new
ds.get_cpu_info<span style="color: #2aa198;">(</span>42<span style="color: #2aa198;">)</span>
ds.get_cpu_price<span style="color: #2aa198;">(</span>42<span style="color: #2aa198;">)</span>
ds.get_mouse_info<span style="color: #2aa198;">(</span>42<span style="color: #2aa198;">)</span>
ds.get_mouse_price<span style="color: #2aa198;">(</span>42<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 60</span>
</pre>
</div>
</li>
<li>把DS想成是数据库的话,也就是我们可以提供一个id就得到任意我们想得到的数据了.
下面就是把我们的"外设"给具体化,这里我们要明白,提供给DS的id是每台计算机的id,
所以我们没法抽象所有的"外设",但是我们可以抽象出每台计算机出来.类似java的写
法会得到如下的代码
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Computer</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>computer_id, data_source<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@id</span> = computer_id
    <span style="color: #268bd2;">@data_source</span> = data_source
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">mouse</span>
    info = <span style="color: #268bd2;">@data_source</span>.get_mouse_info<span style="color: #2aa198;">(</span><span style="color: #268bd2;">@id</span><span style="color: #2aa198;">)</span>
    price = <span style="color: #268bd2;">@data_source</span>.get_mouse_price<span style="color: #2aa198;">(</span><span style="color: #268bd2;">@id</span><span style="color: #2aa198;">)</span>
    result = <span style="color: #2aa198;">"Mouse: </span><span style="color: #268bd2;">#{info}</span><span style="color: #2aa198;"> ($</span><span style="color: #268bd2;">#{price}</span><span style="color: #2aa198;">)"</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"* </span><span style="color: #268bd2;">#{result}</span><span style="color: #2aa198;">"</span> <span style="color: #859900; font-weight: bold;">if</span> price &gt;= 100
    result
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">cpu</span>
    info = <span style="color: #268bd2;">@data_source</span>.get_cpu_info<span style="color: #2aa198;">(</span><span style="color: #268bd2;">@id</span><span style="color: #2aa198;">)</span>
    price = <span style="color: #268bd2;">@data_source</span>.get_cpu_price<span style="color: #2aa198;">(</span><span style="color: #268bd2;">@id</span><span style="color: #2aa198;">)</span>
    result = <span style="color: #2aa198;">"Cpu: </span><span style="color: #268bd2;">#{info}</span><span style="color: #2aa198;"> ($</span><span style="color: #268bd2;">#{price}</span><span style="color: #2aa198;">)"</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"* </span><span style="color: #268bd2;">#{result}</span><span style="color: #2aa198;">"</span> <span style="color: #859900; font-weight: bold;">if</span> price &gt;= 100
    result
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">keyboard</span>
    info = <span style="color: #268bd2;">@data_source</span>.get_keyboard_info<span style="color: #2aa198;">(</span><span style="color: #268bd2;">@id</span><span style="color: #2aa198;">)</span>
    price = <span style="color: #268bd2;">@data_source</span>.get_keyboard_price<span style="color: #2aa198;">(</span><span style="color: #268bd2;">@id</span><span style="color: #2aa198;">)</span>
    result = <span style="color: #2aa198;">"Keyboard: </span><span style="color: #268bd2;">#{info}</span><span style="color: #2aa198;"> ($</span><span style="color: #268bd2;">#{price}</span><span style="color: #2aa198;">)"</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"* </span><span style="color: #268bd2;">#{result}</span><span style="color: #2aa198;">"</span> <span style="color: #859900; font-weight: bold;">if</span> price &gt;= 100
    result
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">require_relative</span> <span style="color: #2aa198;">'unit_test'</span>
</pre>
</div>
</li>
<li>如果这样写代码的话,那直接用java就好了.对于ruby来说,有两种方法能够减少duplicated
code,分别是:
<ul class="org-ul">
<li>Dynamic Method
</li>
<li>method_missing
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Dynamic Methods</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>对于oo语言的认识是否深刻,就看能不能够理解:在oo语言里面,当你调用method的时候,
其实相当于你给object发送message
<pre class="example">
When you call a method, you're actually sending a message
to an object.
</pre>
</li>
<li>所有的oo语言,差不多都是使用standard dot notation
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span><span style="color: #2aa198;">(</span>my_arg<span style="color: #2aa198;">)</span>
    my_arg * 2
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">MyClass</span>.new
obj.my_method<span style="color: #2aa198;">(</span>3<span style="color: #2aa198;">)</span>                <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 6</span>
</pre>
</div>
</li>
<li>在ruby里面,直接让"send a message to an object"变成了一个内置的函数Object#send
注意,在ruby里面XXClass#XXmethod的意思就是在XXClass里面定义了XXmethod
<div class="org-src-container">

<pre class="src src-ruby">obj.send<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">:my_method</span>, 3<span style="color: #2aa198;">)</span>         <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 6</span>
</pre>
</div>
</li>
<li>这个send从外表来看,就是"把method name,变成了一个parameter",那这样有什么好处
呢?
</li>
<li>好处就是我们前面说的,ruby没有编译期,对于method的check会在"调用前的最后一刻"
进行,那么我们也可以使用send,在running time并且"最后的check之前才决定使用哪
些函数"
</li>
<li>更重要的是,我们这些函数可能在代码里面并没有,可能是我们在running time自己通过
ruby的反射原理,自己加入的!
</li>
<li>使用send,在最后一刻决定使用什么函数的方法叫做Dynamic Dispatch
</li>
</ul>
</div>
<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">The Pry Example</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>我们遇到的问题很多人也都遇到过,比如Pry library,相信它们的解决方案也会是我
们的解决方案.
</li>
<li>Pry遇到的问题同样是duplicated code: pry的refresh函数允许通过options参数的
方式来初始化自己的default值, 这其实也是ruby种最为常见的使用方法(hash类型的
名叫options的参数作为最后一个参数)
<div class="org-src-container">

<pre class="src src-ruby">pry.refresh<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">:memory_size</span> =&gt; 99, <span style="color: #268bd2; font-weight: bold;">:quiet</span> =&gt; <span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>pry遇到的代码重复的问题可以简单的罗列如下,和我们前面的重复很像:就是使用self
的setter进行初始化,如果options里面有值呢就用option里面的值,否则就使用default
hash里面的值,而这个defaults的哈希值还得一个一个的算出来.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">refresh</span><span style="color: #2aa198;">(</span>options=<span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>
  defaults<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">:memory_size</span><span style="color: #2aa198;">]</span> = <span style="color: #b58900;">Pry</span>.memory_size
  <span style="color: #859900; font-weight: bold;">if</span> options<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">:memory_size</span><span style="color: #2aa198;">]</span>
    <span style="color: #859900; font-weight: bold;">self</span>.memory_size = options<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">:memory_szie</span><span style="color: #2aa198;">]</span>
  <span style="color: #859900; font-weight: bold;">else</span>
    <span style="color: #859900; font-weight: bold;">self</span>.memory_size = defaults<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">:memory_szie</span><span style="color: #2aa198;">]</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  defaults<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">:quiet</span><span style="color: #2aa198;">]</span> = <span style="color: #b58900;">Pry</span>.quiet
  <span style="color: #859900; font-weight: bold;">if</span> options<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">:quiet</span><span style="color: #2aa198;">]</span>
    <span style="color: #859900; font-weight: bold;">self</span>.quiet = options<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">:quiet</span><span style="color: #2aa198;">]</span>
  <span style="color: #859900; font-weight: bold;">else</span>
    <span style="color: #859900; font-weight: bold;">self</span>.quiet = defaults<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">:quiet</span><span style="color: #2aa198;">]</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">same for all the other attributes...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>下面就是pry解决重复代码的办法,一个直观的感受就是:解决重复其实就是使用循环
来替代重复的部分,这个循环肯定是数组(或者hash)产生的,然后在循环体里面,使用
数组的"每一个元素",进行类似的操作(因为ruby允许method调用的参数化).
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">refresh</span><span style="color: #2aa198;">(</span>options=<span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>
  defaults   = <span style="color: #2aa198;">{}</span>
  attributes = <span style="color: #2aa198;">[</span> <span style="color: #268bd2; font-weight: bold;">:input</span>, <span style="color: #268bd2; font-weight: bold;">:output</span>, <span style="color: #268bd2; font-weight: bold;">:commands</span>, <span style="color: #268bd2; font-weight: bold;">:print</span>, <span style="color: #268bd2; font-weight: bold;">:quiet</span>,
                 <span style="color: #268bd2; font-weight: bold;">:exception_handler</span>, <span style="color: #268bd2; font-weight: bold;">:hooks</span>, <span style="color: #268bd2; font-weight: bold;">:custom_completions</span>,
                 <span style="color: #268bd2; font-weight: bold;">:prompt</span>, <span style="color: #268bd2; font-weight: bold;">:memory_size</span>, <span style="color: #268bd2; font-weight: bold;">:extra_sticky_locals</span> <span style="color: #2aa198;">]</span>

  attributes.each <span style="color: #859900; font-weight: bold;">do</span> |attribute|
    defaults<span style="color: #2aa198;">[</span>attribute<span style="color: #2aa198;">]</span> = <span style="color: #b58900;">Pry</span>.send attribute
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>

      defaults<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">:input_stack</span><span style="color: #2aa198;">]</span> = <span style="color: #b58900;">Pry</span>.input_stack.dup
  defaults.merge!<span style="color: #2aa198;">(</span>options<span style="color: #2aa198;">)</span>.each <span style="color: #859900; font-weight: bold;">do</span> |key, value|
    send<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{key}</span><span style="color: #2aa198;">="</span>, value<span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">if</span> respond_to?<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{key}</span><span style="color: #2aa198;">="</span><span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>上面这个代码有点难以理解的就是下面这句
<div class="org-src-container">

<pre class="src src-ruby">send<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{key}</span><span style="color: #2aa198;">="</span>, value<span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">if</span> respond_to?<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{key}</span><span style="color: #2aa198;">="</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>对照一下,其实就理解了.说白了就是如下代码的改版."#{key}="其实一个例子就是
"quiet="
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">self</span>.quiet = options<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">:quiet</span><span style="color: #2aa198;">]</span> <span style="color: #859900; font-weight: bold;">if</span> options<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">:quiet</span><span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
<li>"能力越大,责任也越大",send可以调用任何的函数,甚至是private method,这就一定
意义上破坏了封装.如果在意封装的话,我们可以使用public_send,其只能使用public
method
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">Defining Methods Dynamically</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li>前面我们学习了dynamic dispatch,意思就是说,我们可以最后时刻再决定调用函数的
名字,原因在于我们可以"动态"的添加method(得益于reflection)
</li>
<li>动态添加method当然可以使用def,但是为了能够"批量"动态添加method,ruby还设计
了一个"最后时刻决定函数名字"的添加method的方式,也就是Dynamic Method
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #657b83; font-weight: bold;">define_method</span> <span style="color: #268bd2; font-weight: bold;">:my_method</span> <span style="color: #859900; font-weight: bold;">do</span> |my_arg|
    my_arg * 3
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">MyClass</span>.new
obj.my_method<span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>                <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 6</span>
</pre>
</div>
</li>
<li>动态化其实就是压缩每个代码的长度.而动态化则是把多个数量的重复减少成一个循
环,动态化都已经做好以后,下面就是"批量化"了.
</li>
<li>好了,我们掌握了足够多的知识可以开始正式的去除我们的代码中的重复代码了,整个
过程分成了三步:
<ol class="org-ol">
<li>运用我们最开始学的dynamic dispatch,把method(cpu, mouse, keyboard)里面的
逻辑,集中到component函数里面,算是个DRY的过程.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Computer</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>computer_id, data_source<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@id</span> = computer_id
    <span style="color: #268bd2;">@data_source</span> = data_source
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">mouse</span>
    component <span style="color: #268bd2; font-weight: bold;">:mouse</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">cpu</span>
    component <span style="color: #268bd2; font-weight: bold;">:cpu</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">keyboard</span>
    component <span style="color: #268bd2; font-weight: bold;">:keyboard</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">component</span><span style="color: #2aa198;">(</span>name<span style="color: #2aa198;">)</span>
    info = <span style="color: #268bd2;">@data_source</span>.send <span style="color: #2aa198;">"get_</span><span style="color: #268bd2;">#{name}</span><span style="color: #2aa198;">_info"</span>, <span style="color: #268bd2;">@id</span>
    price = <span style="color: #268bd2;">@data_source</span>.send <span style="color: #2aa198;">"get_</span><span style="color: #268bd2;">#{name}</span><span style="color: #2aa198;">_pice"</span>, <span style="color: #268bd2;">@id</span>
    result = <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{name.capitalize}</span><span style="color: #2aa198;">: </span><span style="color: #268bd2;">#{info}</span><span style="color: #2aa198;"> ($</span><span style="color: #268bd2;">#{price}</span><span style="color: #2aa198;">)"</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"* </span><span style="color: #268bd2;">#{result}</span><span style="color: #2aa198;">"</span> <span style="color: #859900; font-weight: bold;">if</span> price &gt;= 100
    result
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>下面我们使用dynamic method来"动态生成"我们上面的三个def method.值得注意
的是,在method里面self是object,而在class体里面self是class.所以为了能够在
class Computer里面调用define_component,我们需要把define_componenet设计
成class method
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Computer</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>computer_id, data_source<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@id</span> = computer_id
    <span style="color: #268bd2;">@data_source</span> = data_source
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">define_component</span><span style="color: #2aa198;">(</span>name<span style="color: #2aa198;">)</span>
    <span style="color: #657b83; font-weight: bold;">define_method</span><span style="color: #2aa198;">(</span>name<span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span>
      info = <span style="color: #268bd2;">@data_source</span>.send <span style="color: #2aa198;">"get_</span><span style="color: #268bd2;">#{name}</span><span style="color: #2aa198;">_info"</span>, <span style="color: #268bd2;">@id</span>
      price = <span style="color: #268bd2;">@data_source</span>.send <span style="color: #2aa198;">"get_</span><span style="color: #268bd2;">#{name}</span><span style="color: #2aa198;">_price"</span>, <span style="color: #268bd2;">@id</span>
      result = <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{name.capitalize}</span><span style="color: #2aa198;">: </span><span style="color: #268bd2;">#{info}</span><span style="color: #2aa198;"> ($</span><span style="color: #268bd2;">#{price}</span><span style="color: #2aa198;">)"</span>
      <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"* </span><span style="color: #268bd2;">#{result}</span><span style="color: #2aa198;">"</span> <span style="color: #859900; font-weight: bold;">if</span> price &gt;= 100
      result
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  define_component <span style="color: #268bd2; font-weight: bold;">:mouse</span>
  define_component <span style="color: #268bd2; font-weight: bold;">:cpu</span>
  define_component <span style="color: #268bd2; font-weight: bold;">:keyboard</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>最后,我们再"批量化"我们的调用.批量化调用需要一个数组(或者哈希表)来限定
我们起作用的范围,在这个例子中使用methods.grep
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Computer</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>computer_id, data_source<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@id</span> = computer_id
    <span style="color: #268bd2;">@data_source</span> = data_source
    data_source.methods.grep<span style="color: #2aa198;">(</span><span style="color: #2aa198;">/^get_(.*)_info$/</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span> <span style="color: #b58900;">Computer</span>.define_component <span style="color: #657b83; font-weight: bold;">$1</span><span style="color: #2aa198;">}</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">define_component</span><span style="color: #2aa198;">(</span>name<span style="color: #2aa198;">)</span>
    <span style="color: #657b83; font-weight: bold;">define_method</span><span style="color: #2aa198;">(</span>name<span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ol>
</li>
<li>上面的代码还需要你理解grep和$1. grep的`//`里面有括号的部分,会最后放到$1里
面存储起来.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">method_missing</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>上面的dynamic method和dynamic dispatch属于dynamic派的,ruby还有method missing
派的做法来消除duplicated code
</li>
<li>ruby里面会在running time调用method之前进行check,所以我们可以写如下的代码,而
且可以运行.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Lawyer</span>; <span style="color: #859900; font-weight: bold;">end</span>
nick = <span style="color: #b58900;">Lawyer</span>.new
nick.talk_simple

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">`&lt;main&gt;': undefined method `talk_simple'       #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">for #&lt;Lawyer:0x007ff9328bb568&gt; (NoMethodError) #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>但是ruby所谓的"在调用之前check"其实并不是check,而是设计了一个"兜底"的函数,
如果没有找到其他函数的情况下,就会调用这个函数,这个函数叫做method_missing
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">BasicObject</span>.private_instance_methods.grep /missing/ <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:method_missing]</span>
</pre>
</div>
</li>
<li>method_missing是从来不需要被调用的,它需要被override,从而让你可以调用"你从来
没def过的method", 原因嘛,因为你可以看到没定义的函数的名字,参数,你可以最后补
救般的为它赶紧新设计一个
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Lawyer</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">method_missing</span><span style="color: #2aa198;">(</span>method, *args, &amp;block<span style="color: #2aa198;">)</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"You called: </span><span style="color: #268bd2;">#{method}</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">#{args.join(', ')}</span><span style="color: #2aa198;">)"</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"&lt;==You also passed it a block==&gt;"</span> <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">block_given?</span>
    block.call
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

bob = <span style="color: #b58900;">Lawyer</span>.new
bob.talk_simple<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'a'</span>, <span style="color: #2aa198;">'b'</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Here is inside the block"</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">You called: talk_simple(a, b)                  #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;==You also passed it a block==&gt;               #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Here is inside the block                       #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>通过上面的例子我们可以看到,我们可以获悉这个"无法调用"的函数的名字,参数,block
而我们这个最后的"补救"就好比告诉object,"If they ask you something and you
don't understand, do this".
</li>
<li>这种在method_missing里面"补救"一个method,让caller感受不到任何异常的方法叫做
Ghost Method
</li>
</ul>
</div>
<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">The Hashie Example</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>Hashie gem里面有一个很magic的class叫做Hashie:Mash, 其是一个"超强版本"的hash
如果你想要一个新的attribute,那么你直接assign一个value给这个attribute就可以
了
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'hashie'</span>

icecream = <span style="color: #b58900;">Hashie</span>::<span style="color: #b58900;">Mash</span>.new
icecream.flavor = <span style="color: #2aa198;">"strawberry"</span>
<span style="color: #657b83; font-weight: bold;">puts</span> icecream.flavor

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">strawberry                                     #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>功劳当然就是Ghost method的, method_missing里面通过判断method_name是不是含
      有等号`=`来判断是一个setter还是一个getter
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">Hashie</span>
  <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Mash</span> &lt; <span style="color: #b58900;">Hashie</span>::<span style="color: #b58900;">Hash</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">method_missing</span><span style="color: #2aa198;">(</span>method_name, *args, &amp;blk<span style="color: #2aa198;">)</span>
      <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #2aa198;">[](</span>method_name, &amp;blk<span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">if</span> key?<span style="color: #2aa198;">(</span>method_name<span style="color: #2aa198;">)</span>
      match = method_name.to_s.match<span style="color: #2aa198;">(</span><span style="color: #2aa198;">/(.*?)([?=!]?)$/</span><span style="color: #2aa198;">)</span>
      <span style="color: #859900; font-weight: bold;">case</span> match<span style="color: #2aa198;">[</span>2<span style="color: #2aa198;">]</span>
      <span style="color: #859900; font-weight: bold;">when</span> <span style="color: #2aa198;">"="</span>
        <span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">[</span>match<span style="color: #b58900;">[</span>1<span style="color: #b58900;">]</span><span style="color: #2aa198;">]</span> = args.first
        <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
      <span style="color: #859900; font-weight: bold;">else</span>
        default<span style="color: #2aa198;">(</span>method_name, *args, &amp;blk<span style="color: #2aa198;">)</span>
      <span style="color: #859900; font-weight: bold;">end</span>
    <span style="color: #859900; font-weight: bold;">end</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2">Dynamic Proxies</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>dynamic proxy严格说来,是对method_missing的一种"使用扩展",是针对如下这种情
况(本质是更换object来调用method)
<pre class="example">
method_missing引入的这个method_name,虽然self不能调用,但是你却可以
使用另外的object来explicit的send这个method_name
</pre>
</li>
<li>我们有如下的一个例子,User作为一个对用户的抽象,想在object user上面调用各种
getter,但是getter并没有在class User里面设计,需要去data source里面取,这种情
况下dynamic proxy就起作用了
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">SourceData</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>name, email, location<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@name</span> = name
    <span style="color: #268bd2;">@email</span> = email
    <span style="color: #268bd2;">@location</span> = location
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_name;</span> <span style="color: #268bd2;">@name</span>; <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_email;</span> <span style="color: #268bd2;">@email</span>; <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_location;</span> <span style="color: #268bd2;">@location</span>; <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">User</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>source_data<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@source_data</span> = source_data
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">method_missing</span><span style="color: #2aa198;">(</span>name, *args<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@source_data</span>.send<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"get_</span><span style="color: #268bd2;">#{name}</span><span style="color: #2aa198;">"</span><span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

data = <span style="color: #b58900;">SourceData</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"john"</span>, <span style="color: #2aa198;">"john@example.com"</span>, <span style="color: #2aa198;">"London"</span><span style="color: #2aa198;">)</span>
user = <span style="color: #b58900;">User</span>.new<span style="color: #2aa198;">(</span>data<span style="color: #2aa198;">)</span>

<span style="color: #657b83; font-weight: bold;">puts</span> user.name
<span style="color: #657b83; font-weight: bold;">puts</span> user.email
<span style="color: #657b83; font-weight: bold;">puts</span> user.location

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">john                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">john@example.com                               #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">London                                         #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3">Refactoring the Computer Class(Again)</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>下面我们使用method missing来再次重构一遍Computer Class
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Computer</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>computer_id, data_source<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@id</span> = computer_id
    <span style="color: #268bd2;">@data_source</span> = data_source
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">method_missing</span><span style="color: #2aa198;">(</span>name<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">super</span> <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900; font-weight: bold;">!</span><span style="color: #268bd2;">@data_source</span>.respond_to?<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"get_</span><span style="color: #268bd2;">#{name}</span><span style="color: #2aa198;">_info"</span><span style="color: #2aa198;">)</span>
    info = <span style="color: #268bd2;">@data_source</span>.send<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"get_</span><span style="color: #268bd2;">#{name}</span><span style="color: #2aa198;">_info"</span>, <span style="color: #268bd2;">@id</span><span style="color: #2aa198;">)</span>
    price = <span style="color: #268bd2;">@data_source</span>.send<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"get_</span><span style="color: #268bd2;">#{name}</span><span style="color: #2aa198;">_pric"</span>, <span style="color: #268bd2;">@id</span><span style="color: #2aa198;">)</span>
    result = <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{name.capitalize}</span><span style="color: #2aa198;">: </span><span style="color: #268bd2;">#{info}</span><span style="color: #2aa198;"> ($</span><span style="color: #268bd2;">#{price}</span><span style="color: #2aa198;">)"</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"* </span><span style="color: #268bd2;">#{result}</span><span style="color: #2aa198;">"</span> <span style="color: #859900; font-weight: bold;">if</span> price &gt;= 100
    result
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>这个和前面的User, ds的例子很像,只不过ds不是我们自己实现的(legacy code),我
们会使用respond_to?来判断legacy code里面有没有实现相应函数,如果没有的话,我
们就会去调用BasicObject#method_missing,就是报错了.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-4" class="outline-4">
<h4 id="sec-3-3-4">respond_to_missing?</h4>
<div class="outline-text-4" id="text-3-3-4">
<ul class="org-ul">
<li>ruby中有个常用的method,我们刚刚也看到了,就是respond_to?这个命令会用来判断
当object是否能"相应"相应的method.
</li>
<li>respond_to?的显然不能包括"method_missing处理的method",那样的话,respond_to?
会肯定返回true,就没有意义了
</li>
<li>ruby既然设计了methond_missing,当然也会想到我们"自己override method missing"
肯定只会处理"一部分函数",这一部分函数在前面就是如下这句处理的.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900; font-weight: bold;">!</span><span style="color: #268bd2;">@data_source</span>.respond_to?<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"get_</span><span style="color: #268bd2;">#{name}</span><span style="color: #2aa198;">_info"</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>ruby的respond_to?判断某个函数"虽然没有定义但有可能是用户自定义的Ghost Method"
的办法就是调用respond_to_missing?我们可以override这个函数,让我们"想处理的那
一部分函数"能够返回true,从而留在respond_to?里面
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Computer</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">respond_to_missing?</span><span style="color: #2aa198;">(</span>method, include_private=<span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@data_source</span>.respond_to?<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"get_</span><span style="color: #268bd2;">#{method}</span><span style="color: #2aa198;">_info"</span><span style="color: #2aa198;">)</span> || <span style="color: #859900; font-weight: bold;">super</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>好了,我们已经介绍完了dynamic method和method_missing.根据以往的总结,我们只
有在不得已的时候,才要去使用method_missing,大部分情况下dynamic method是更好
的选择
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Blank Slates</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>前面说method_missing有很多陷阱,一个重要的陷阱就是:你调用了一个你认为是ghost method
的函数,但是去发现没有按照你想象的进入你设计的ghost method
<div class="org-src-container">

<pre class="src src-ruby">my_computer = <span style="color: #b58900;">Computer</span>.new<span style="color: #2aa198;">(</span>42, <span style="color: #b58900;">DS</span>.new<span style="color: #2aa198;">)</span>
my_computer.display             <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; nil</span>
</pre>
</div>
</li>
<li>出现这个问题的原因,是存在一个真的method,也叫这个名字!
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">Object</span>.instance_methods.grep /^d/
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:dup, :display, :define_singleton_method]</span>
</pre>
</div>
</li>
<li>换句话说就是
<pre class="example">
When the name of a Ghost Method clashes with the name of
a real, inherited method, the latter wins.
</pre>
</li>
<li>如果你不想受次困扰,一个简单的办法就是不要继承那么多的函数,这些函数主要是从
Object继承来的(不写继承于谁,默认是Object),所以你"明确"选择继承函数更少的
BasicObject,就能完成blank slate的壮举
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">BasicObject</span>.instance_methods
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__]</span>
</pre>
</div>
</li>
<li>还有一种办法就是删掉class里面的method:
<ul class="org-ul">
<li>Module#undef_method:这个会删除所有的method,包括inherited method
</li>
<li>Module#remove_method:这个会删除所有的method,但不包括inherited method
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 4: Wednesday: Blocks</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>block是用来control scope的,在其他语言中是使用`{}`来创建一个scope.
</li>
<li>ruby中只不过给scope起了明确的名字,而且:
<ul class="org-ul">
<li>除了`{}`还可以使用`begin..end`来包裹一个block
</li>
<li>ruby中的这个block还是一种"可以被调用"的scope
</li>
</ul>
</li>
<li>block是一种来自functional programming语言(比如lisp)的特性,如果从oo语言的角度
上理解,我们可以把block叫做是callable object
</li>
</ul>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">The Day of the Blocks</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>下面是一个简单的block的例子:我们可以把'block当做普通变量'一样传递给method,而
在method内部,则是通过yield来调用我们传入的block
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">a_method</span><span style="color: #2aa198;">(</span>a, b<span style="color: #2aa198;">)</span>
  a + <span style="color: #859900; font-weight: bold;">yield</span><span style="color: #2aa198;">(</span>a, b<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">p</span> a_method<span style="color: #2aa198;">(</span>1, 2<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span> |x, y| <span style="color: #b58900;">(</span>x + y<span style="color: #b58900;">)</span> * 3 <span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">10                                             #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>block是"callable object"的一种,也就是和method有很多相似的地方:
<ul class="org-ul">
<li>可以带参数,上面的例子就带了x,y两个参数
</li>
<li>block还会把自己的结果返回(上面的10,就是block返回值9加1得到的)
</li>
</ul>
</li>
<li>我们可以使用Kernel#block_given?来判断当前的call是否含有block
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">a_method</span>
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">block_given?</span>
  <span style="color: #2aa198;">'no block'</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">p</span> a_method
<span style="color: #657b83; font-weight: bold;">p</span> a_method <span style="color: #2aa198;">{</span> <span style="color: #2aa198;">"here'a a block!"</span> <span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"no block"                                     #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"here'a a block!"                              #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Quiz: Ruby#</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>csharp里面的using关键字有很多种用法,其中一种是
<pre class="example">
       当在某个代码段中使用了类的实例，而希望无论因为什么原因，只要
       离开了这个代码段就自动调用这个类实例的Dispose。
</pre>
</li>
<li>比如我们的远程连接,无论是正常结束还是抛出exception,都会被using调用Dispose给
释放掉
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b58900;">RemoteConnection</span> <span style="color: #268bd2;">conn</span> = new RemoteConnection<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"some_remote_server"</span><span style="color: #2aa198;">)</span>;
<span style="color: #268bd2;">using</span> <span style="color: #2aa198;">(</span>conn<span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    conn.ReadData<span style="color: #b58900;">()</span>;
    DoMoreStuff<span style="color: #b58900;">()</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>ruby的block可以使用begin end,也可以使用{}来包裹一个block,我们可以利用这个规
定,加上block的一些特点,来实现csharp里面的using关键字
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">Kernel</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">using</span><span style="color: #2aa198;">(</span>resource<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">begin</span>
      <span style="color: #859900; font-weight: bold;">yield</span>
    <span style="color: #859900; font-weight: bold;">ensure</span>
      resource.dispose
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Blocks Are Closures</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>block虽然是从"参数里面引入一个可运行的代码段", 但是这个"可运行的代码段"也必
须得有"正常运行代码段"所有需要一切环境信息,比如:
<ul class="org-ul">
<li>local variable
</li>
<li>instance variable
</li>
<li>self
</li>
</ul>
</li>
<li>这些环境信息因为都是和object有关系,所以给它们取名叫做bindings
</li>
<li>而block获取自己bindigs的方法就是在"成功定义block"的那一刻,记录当时所有的
bindings,然后带着这些bindings一起进入到method里面(作为参数),而不是使用method
自己的bindings!!!
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span>
  x = <span style="color: #2aa198;">"Goodbye"</span>                 <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">method bindings</span>
  <span style="color: #859900; font-weight: bold;">yield</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"cruel"</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">end</span>

x = <span style="color: #2aa198;">"Hello"</span>                     <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">top-level bindings</span>
<span style="color: #657b83; font-weight: bold;">p</span> my_method <span style="color: #2aa198;">{</span>|y| <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{x}</span><span style="color: #2aa198;">, </span><span style="color: #268bd2;">#{y}</span><span style="color: #2aa198;"> world"</span> <span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"Hello, cruel world"                           #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>除了可以capture"定义block那一刻"的bindings,你也可以在method内部自己定义binding
但是这些bindings的作用域就是当前block,不会出现在main local binding的域里面
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">just_yield</span>
  <span style="color: #859900; font-weight: bold;">yield</span>
<span style="color: #859900; font-weight: bold;">end</span>

top_level_variable = 1

just_yield <span style="color: #859900; font-weight: bold;">do</span>
  top_level_variable += 1
  local_to_block = 1
<span style="color: #859900; font-weight: bold;">end</span>

top_level_variable            <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2</span>
local_to_block                <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">undefined local ....</span>
</pre>
</div>
</li>
<li>这种capture"创建那一刻的binding"并且带着这些binding进入method的行为,在计算
机科学界有个名字,叫做closure. js中这就是最重要的概念
</li>
</ul>
</div>
<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1">Scope</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>想要理解closure,首先要理解scope,因为我们所有的binding都是存在于一个scope里
面的
</li>
<li>Kernel#local_variables是非常好的一个函数,它可以打印当前的scope里面的local
variable有哪些
<div class="org-src-container">

<pre class="src src-ruby">v1 = 1

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  v2 = 2
  <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #657b83; font-weight: bold;">local_variables</span>             <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:v2]</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span>
    v3 = 3
    <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #657b83; font-weight: bold;">local_variables</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #657b83; font-weight: bold;">local_variables</span>             <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:v2]</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">MyClass</span>.new
obj.my_method                   <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:v3]</span>
obj.my_method                   <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:v3]</span>
<span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #657b83; font-weight: bold;">local_variables</span>               <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[:v1, :obj]</span>
</pre>
</div>
</li>
<li>v1是定义在top level scope的local variable,但是到了MyClass里面却看不到了,这
和其他的高级语言是不一样的!在java或者c#里面, "innsert scope"是可以看到来自
"outer scope"的变量的
</li>
<li>在ruby里面,scope是被严格的分开的:一旦你进入一个新的scope,老的scope里面的bindings
就全部被新的scope里面的binding取代了.这也就是为什么进入了MyClass scope以后,
v1就不再可见了.
</li>
<li>值得注意的是,我们调用了两次my_method,两次虽然都打印了[:v3],但是这两个v3并
不是同一个local variable,因为当第一次的method退出的时候,那个local variable
v3已经消失了!第二次调用函数创建的local variable只不过也是同名叫做v3而已
</li>
<li>下面这句话非常重要,进入一个新的scope,bindings并非全部改变,而是有例外,那就是
instance variable.而local variable则是不停改变的,否则也不会叫做"local"
<pre class="example">
If a method calls another method on the same object,
intance variables stay in scope throught the call!
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2">Scope Gates</h4>
<div class="outline-text-4" id="text-4-3-2">
<ul class="org-ul">
<li>一个新的scope的产生,在ruby里面肯定是有明确标记的,标记一共有三个
<ul class="org-ul">
<li>类的定义符号class
</li>
<li>模块的定义符号module
</li>
<li>函数的定义符号def
</li>
</ul>
</li>
<li>当然了,在这三个定义符号之外的,就是top-level scope啦
</li>
<li>我们前面说过,block之间的instance variable都是不相通的,如果我们希望在不同的
scope之间相互传递variable的时候,就需要新的概念引入了
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-3" class="outline-4">
<h4 id="sec-4-3-3">Flattening the Scope</h4>
<div class="outline-text-4" id="text-4-3-3">
<ul class="org-ul">
<li>ruby里面,破除scope之间的办法,就是flat scope.其原理也非常简单,说起来就是如
下:
<ul class="org-ul">
<li>使用Class.new替代class
</li>
<li>使用Module.new替代module
</li>
<li>使用define_method替代def
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-4" class="outline-4">
<h4 id="sec-4-3-4">Sharing the Scope</h4>
<div class="outline-text-4" id="text-4-3-4">
<ul class="org-ul">
<li>flatten scope的一个使用sharing the scope的例子.就是把两个函数"定义在同一个
scope gate里面", 这两个函数使用define_method,所以相互之间可以看到彼此的scope
同时还可以看到自己scope gate里面的内容
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">define_methods</span>
  shared = 0

  <span style="color: #b58900;">Kernel</span>.send <span style="color: #268bd2; font-weight: bold;">:define_method</span>, <span style="color: #268bd2; font-weight: bold;">:counter</span> <span style="color: #859900; font-weight: bold;">do</span>
    shared
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #b58900;">Kernel</span>.send <span style="color: #268bd2; font-weight: bold;">:define_method</span>, <span style="color: #268bd2; font-weight: bold;">:inc</span> <span style="color: #859900; font-weight: bold;">do</span> |x|
    shared += x
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

define_methods

<span style="color: #657b83; font-weight: bold;">p</span> counter                       <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 0</span>
<span style="color: #657b83; font-weight: bold;">p</span> inc<span style="color: #2aa198;">(</span>4<span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">p</span> counter                       <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 4</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-5" class="outline-4">
<h4 id="sec-4-3-5">Closures Wrap-Up</h4>
<div class="outline-text-4" id="text-4-3-5">
<ul class="org-ul">
<li>前面的例子是"在一个scope gate里面"的不同method能看到彼此的变量,其实彼此的
bindings也是可以看到的.也就是可以在不同的method之间传递scope
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">instance_eval()</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>ruby中有个函数BasicObject#instance_eval,可以看到当前block里面所有的context
信息
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span>
    <span style="color: #268bd2;">@v</span> = 1
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">MyClass</span>.new

obj.instance_eval <span style="color: #859900; font-weight: bold;">do</span>
  <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #859900; font-weight: bold;">self</span>                        <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; #&lt;MyClass:0x00000003139c20 @v=1&gt;</span>
  <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #268bd2;">@v</span>                          <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 1</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>我们可以看到instance_eval其实是把receiver(也就是obj)作为self来研究的.而我们
的obj.instance_eval定义的地方,也是有scope的,我们可以看到top level的信息,所
以我们可以结合起来
<div class="org-src-container">

<pre class="src src-ruby">v = 2
obj.instance_eval <span style="color: #2aa198;">{</span> <span style="color: #268bd2;">@v</span> = v <span style="color: #2aa198;">}</span>
obj.instance_eval <span style="color: #2aa198;">{</span> <span style="color: #268bd2;">@v</span> <span style="color: #2aa198;">}</span>        <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 2</span>
</pre>
</div>
</li>
<li>所以,instance_eval有其特殊的作用:通过instance_eval传递一个block给某个object
     从而改动这个object的内容!这个传入的block叫做Context Probe
</li>
</ul>
</div>
<div id="outline-container-sec-4-4-1" class="outline-4">
<h4 id="sec-4-4-1">Breaking Encapsulation</h4>
<div class="outline-text-4" id="text-4-4-1">
<ul class="org-ul">
<li>使用了Context Probe以后,我们可以破坏封装,甚至可以更改private信息,这就是ruby
的特点:并不要求完全的封装,也就是说你可以在irb里面通过instance_eval来查看任
意一个object的内部信息!
</li>
<li>ruby的这种"破坏"封装的特点,有时候很有用,比如下面这个例子
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4-2" class="outline-4">
<h4 id="sec-4-4-2">Padrino Example</h4>
<div class="outline-text-4" id="text-4-4-2">
<ul class="org-ul">
<li>Padrino是一个web框架,它定义了一个Logger class,这个Logger把自己的configuration
信息存储在instance variable里面,比如@log_static如果为true,那么application就
必须存储对static文件的所有访问!
</li>
<li>Padrino的unit test需要改变application的logger配置,而我们的Padrino则直接使
用了Context Probe直接打开这个Object,更改了它的instance variable
<div class="org-src-container">

<pre class="src src-ruby">should <span style="color: #2aa198;">'allow turning on static assets logging'</span> <span style="color: #859900; font-weight: bold;">do</span>
  <span style="color: #b58900;">Padrino</span>.logger.instance_eval<span style="color: #2aa198;">{</span> <span style="color: #268bd2;">@log_static</span> = <span style="color: #268bd2; font-weight: bold;">true</span><span style="color: #2aa198;">}</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4-3" class="outline-4">
<h4 id="sec-4-4-3">Clean Rooms</h4>
<div class="outline-text-4" id="text-4-4-3">
<ul class="org-ul">
<li>有时候,你创建了一个object,只是为了evaluate它里面的block,这种object就被称之
为Clean Room
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">CleanRoom</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">current_temperature</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

clean_room = <span style="color: #b58900;">CleanRoom</span>.new
clean_room.instance_eval <span style="color: #859900; font-weight: bold;">do</span>
  <span style="color: #859900; font-weight: bold;">if</span> current_temperature &lt; 20
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">TODO: wear jacket</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>大多数情况下,我们不希望clean room里面有太多的method,而希望这个class更纯粹
一点,这个时候BasicObject就是一个比较好的clean room的选择
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Callable Objects</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>所谓callable object就是这么一类对象:"package code first, call it later",在
ruby中,至少有如下三种callable object:
<ul class="org-ul">
<li>proc, 其实就是block变成的object
</li>
<li>lambda,是proc的一种变体
</li>
<li>method
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-4-5-1" class="outline-4">
<h4 id="sec-4-5-1">Proc Objects</h4>
<div class="outline-text-4" id="text-4-5-1">
<ul class="org-ul">
<li>虽然ruby中绝大部分的东西都是object,但是block却是特例.这有时候就会带来一些
问题,比如,你想存储一个block,之后再去调用它,那么你需要一个object来"保存"这
个block
</li>
<li>Ruby的解决办法就是Proc class,这个class的ctor接受一个block.而Proc的object可
以使用Proc#call来调用"存储在自己内部的block".这种技术也叫Deferred Evaluation
<div class="org-src-container">

<pre class="src src-ruby">inc = <span style="color: #b58900;">Proc</span>.new <span style="color: #2aa198;">{</span> |x| x + 1 <span style="color: #2aa198;">}</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">more code...</span>
inc.call<span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>                     <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 3</span>
</pre>
</div>
</li>
<li>创建proc的方法还有一个就是Kernel#proc
</li>
<li>如果把lambda看做是proc的变体的话,那么Kernel#lambda也是一种创建proc的方法
<div class="org-src-container">

<pre class="src src-ruby">dec = <span style="color: #657b83; font-weight: bold;">lambda</span> <span style="color: #2aa198;">{</span>|x| x - 1 <span style="color: #2aa198;">}</span>
dec.class                       <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; Proc</span>
dec.call<span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span>                     <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 1</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5-2" class="outline-4">
<h4 id="sec-4-5-2">The &amp; Operator</h4>
<div class="outline-text-4" id="text-4-5-2">
<ul class="org-ul">
<li>对于method来说,block就像是"一个额外的参数",大多数情况下,我们不需要关注这个
额外的参数,只需要yield来调用就可以了,但是有如下两种情况导致我们不得不需要
了解这个额外的参数:
<ul class="org-ul">
<li>你希望把当前method的block传递给自己调用的另外的method
</li>
<li>你希望把block转换成Proc
</li>
</ul>
</li>
<li>使用&amp;+&lt;variable&gt;的方式,可以把method的block转换成一个参数,这个参数必须是最
后一个,而且参数前面必须有`&amp;`.而这个variable就自然的是一个proc object啦
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span><span style="color: #2aa198;">(</span>&amp;the_proc<span style="color: #2aa198;">)</span>
  the_proc
<span style="color: #859900; font-weight: bold;">end</span>

p = my_method <span style="color: #2aa198;">{</span> |name| <span style="color: #2aa198;">"Hello, </span><span style="color: #268bd2;">#{name}</span><span style="color: #2aa198;">!"</span><span style="color: #2aa198;">}</span>
p.class                         <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; Proc</span>
p.call<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Bill"</span><span style="color: #2aa198;">)</span>                  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "hello, Bill!"</span>
</pre>
</div>
</li>
<li>更神奇的是'&amp;'还可以把你的proc object"转换回成"block
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span><span style="color: #2aa198;">(</span>greeting<span style="color: #2aa198;">)</span>
  <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{greeting}</span><span style="color: #2aa198;">, </span><span style="color: #268bd2;">#{yield}</span><span style="color: #2aa198;">!"</span>
<span style="color: #859900; font-weight: bold;">end</span>

my_proc = <span style="color: #657b83; font-weight: bold;">proc</span> <span style="color: #2aa198;">{</span> <span style="color: #2aa198;">"Bill"</span> <span style="color: #2aa198;">}</span>
my_method<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"hello"</span>, &amp;my_proc<span style="color: #2aa198;">)</span>    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "hello, Bill!"</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5-3" class="outline-4">
<h4 id="sec-4-5-3">Proc vs. Lambdas</h4>
<div class="outline-text-4" id="text-4-5-3">
<ul class="org-ul">
<li>前面我们讲了很多种创建proc object的方法,其中一种是使用lambda{}, 这种方法和
其他所有的方法有一处不同:其创建出来的object是lambda类型的,而非proc类型
</li>
<li>lambda是一种"变形"了的proc,其有两处和proc不同.
</li>
<li>第一处不同是和return有关的:
<ul class="org-ul">
<li>在lambda中,return只是说我们从lambda里面跳出来
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">double</span><span style="color: #2aa198;">(</span>callable_object<span style="color: #2aa198;">)</span>
  callable_object.call * 2
<span style="color: #859900; font-weight: bold;">end</span>

l = <span style="color: #657b83; font-weight: bold;">lambda</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> 10 <span style="color: #2aa198;">}</span>
double<span style="color: #2aa198;">(</span>l<span style="color: #2aa198;">)</span>                       <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 20</span>
</pre>
</div>
</li>
<li>在proc里面,return是从proc定义的scope里面出来,所以如下的代码会出错!
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">double</span><span style="color: #2aa198;">(</span>callable_object<span style="color: #2aa198;">)</span>
  callable_object.call * 2
<span style="color: #859900; font-weight: bold;">end</span>

p = <span style="color: #b58900;">Proc</span>.new <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> 10 <span style="color: #2aa198;">}</span>
double<span style="color: #2aa198;">(</span>p<span style="color: #2aa198;">)</span>                       <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; LocalJumpError</span>
</pre>
</div>
</li>
</ul>
</li>
<li>你可avoid这个缺陷,通过"不使用return"
<div class="org-src-container">

<pre class="src src-ruby">p = <span style="color: #b58900;">Proc</span>.new <span style="color: #2aa198;">{</span> 10 <span style="color: #2aa198;">}</span>
double<span style="color: #2aa198;">(</span>p<span style="color: #2aa198;">)</span>                       <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 20</span>
</pre>
</div>
</li>
<li>第二处不同是对Argument数量不对的容忍度:
<ul class="org-ul">
<li>lambda的容忍度比较低,所以参数数量不对就会报ArgumentError错
</li>
<li>proc的容忍度比较高,参数所了就放弃,参数少了就设置为nil
<div class="org-src-container">

<pre class="src src-ruby">p = <span style="color: #b58900;">Proc</span>.new <span style="color: #2aa198;">{</span> |a, b| <span style="color: #b58900;">[</span>a, b<span style="color: #b58900;">]</span> <span style="color: #2aa198;">}</span>
p.call<span style="color: #2aa198;">(</span>1, 2, 3<span style="color: #2aa198;">)</span>                 <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [1, 2]</span>
p.call<span style="color: #2aa198;">(</span>1<span style="color: #2aa198;">)</span>                       <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=. [1, nil]</span>
</pre>
</div>
</li>
</ul>
</li>
<li>通过这两个不同,可以发现,总体上来说,lambda更直观,也更接近method,因为它对参
数的严格要求,更加正常的return逻辑.所以很多ruby程序员更喜欢使用proc
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5-4" class="outline-4">
<h4 id="sec-4-5-4">Method Objects</h4>
<div class="outline-text-4" id="text-4-5-4">
<ul class="org-ul">
<li>既然已经把proc和lambda都objec化了,那么把method给object化也是非常容易理解的
其实ruby就是这样做的
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>value<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@x</span> = value
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span>
    <span style="color: #268bd2;">@x</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

object = <span style="color: #b58900;">MyClass</span>.new<span style="color: #2aa198;">(</span>1<span style="color: #2aa198;">)</span>
m = object.method <span style="color: #268bd2; font-weight: bold;">:my_method</span>
m.call                          <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 1</span>
</pre>
</div>
</li>
<li>使用Kernel#method就创建了一个Method object,然后我们使用Method#call来调用就
可以了.
</li>
<li>Ruby还有另外一种Method叫做Unbound Method
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5-5" class="outline-4">
<h4 id="sec-4-5-5">Unbound Methods</h4>
<div class="outline-text-4" id="text-4-5-5">
<ul class="org-ul">
<li>UnboundMethods,顾名思义,就是和原来的class(或者module)脱离了关系的method可
以使用Method#unbind来创建一个Unbound Method,也可以使用Module#instance_method
来创建
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">MyModule</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span>
    42
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

unbound = <span style="color: #b58900;">MyModule</span>.instance_method<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">:my_method</span><span style="color: #2aa198;">)</span>
unbound.class                   <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; UnboundMethod</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">Writing a Domain-Specific Language</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li>RedFlag是一款通知sales people的工具,当某一系列的事情发生的时候,它应当发送
message给销售人员
</li>
<li>TODO
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 5: Thursday: Class Definitions</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Class Definitions Demystified</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>不要仅仅把class看做是declare method的地方,真实的情况是你可以把任意的代码放
到class定义里面
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">'Hello'</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Hello                                          #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>就像method和block一样,class definition也会返回自己的最后一个statement!这是
平常想不到的!
<div class="org-src-container">

<pre class="src src-ruby">result = <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Myclass</span>
           <span style="color: #859900; font-weight: bold;">self</span>
         <span style="color: #859900; font-weight: bold;">end</span>
result                        <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; Myclass</span>
</pre>
</div>
</li>
<li>上面这个例子也说明了,class(module)其实就是一个object,class内部的self就是代
表它自己!
</li>
</ul>
</div>
<div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1">The Current Class</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>我们的ruby程序始终都有自己的self,其实我们的也始终有自己的current class(module)
每当你定义一个method的时候,你其实就是给current class定义了一个instance method
</li>
<li>current class由于有module等信息,所以不便于设计一个self一样的字段.好在判断
current class也不是什么难事:
<ul class="org-ul">
<li>在程序的top level, current class就是Object. 因为Object是main的类.换句话
说,就是你在top level define了一个method的话,那个method就变成了Object的
instance method
</li>
<li>在一个method里面定义另外的method,那么这个innter method就是self的class的
instance method
</li>
<li>在一个class keyword包裹的代码里面定义method,就是为这个class定义instance
method
</li>
</ul>
</li>
<li>除了使用class关键字来"打开"一个class(从而改变current class)外,你还可以使用
Module#class_eval函数来完成同样的工作
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">add_method_to</span><span style="color: #2aa198;">(</span>a_class<span style="color: #2aa198;">)</span>
  a_class.class_eval <span style="color: #859900; font-weight: bold;">do</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">m;</span> <span style="color: #2aa198;">'Hello!'</span>; <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

add_method_to <span style="color: #b58900;">String</span>
<span style="color: #2aa198;">"abc"</span>.m                         <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "Hello!"</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2">Class Instance Variables</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>Ruby会把当前的所有的instance variable"分配给"self,注意在class关键字体内(并
且不在任何method内), self是指代的class,而不是class的object.所以下面的例子
就区别了"object的instance variable"和"class的instance variable"
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #268bd2;">@my_var</span> = 1
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">read;</span> <span style="color: #268bd2;">@my_var</span>; <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">write;</span> <span style="color: #268bd2;">@my_var</span> = 2; <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">read;</span> <span style="color: #268bd2;">@my_var</span>; <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">MyClass</span>.new
obj.read                        <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; nil</span>
obj.write
obj.read                        <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 2</span>
<span style="color: #b58900;">MyClass</span>.read                    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 1</span>
</pre>
</div>
</li>
<li>上面的例子定义了两个instance variable,一个属于MyClass,一个属于obj,只不过它
俩的名字"碰巧"都叫@my_var
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-1-3" class="outline-4">
<h4 id="sec-5-1-3">Working on Bookworm Again</h4>
<div class="outline-text-4" id="text-5-1-3">
<ul class="org-ul">
<li>日常的工作当中，会遇到一些非常不好写的测试用例,比如下面的这个class,其中的to_s
      是和"创建时刻"的时间有关的
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Loan</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>book<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@book</span> = book
    <span style="color: #268bd2;">@time</span> = <span style="color: #b58900;">Time</span>.now
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">to_s</span>
    <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{@book.upcase}</span><span style="color: #2aa198;"> loaned on </span><span style="color: #268bd2;">#{@time}</span><span style="color: #2aa198;">"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>解决办法就是class instance variable,而且看起来有点绕:
<ul class="org-ul">
<li>首先我们要改动源代码,创建一个class method叫做time_class来返回"不同"的Time
class:在生产环境使用Time,而测试环境使用class instance variable的@time_class
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Loan</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>book<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@book</span> = book
    <span style="color: #268bd2;">@time</span> = <span style="color: #b58900;">Loan</span>.time_class.now
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">time_class</span>
    <span style="color: #268bd2;">@time_class</span> || <span style="color: #b58900;">Time</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">to_s</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">....</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>其次我们要设计新的测试用例:在测试的时候使用一个永远返回固定时间的"fake"
Time class
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">FakeTime</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">now;</span> <span style="color: #2aa198;">'Mon Apr 06 12:15:50'</span>; <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'test/unit'</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">TestLoan</span> &lt; <span style="color: #b58900;">Test</span>::<span style="color: #b58900;">Unit</span>::<span style="color: #b58900;">TestCase</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">test_conversion_to_string</span>
    <span style="color: #b58900;">Loan</span>.instance_eval <span style="color: #2aa198;">{</span> <span style="color: #268bd2;">@time_class</span> = <span style="color: #b58900;">FakeTime</span> <span style="color: #2aa198;">}</span>
    loan = <span style="color: #b58900;">Loan</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'War and Peace'</span><span style="color: #2aa198;">)</span>
    asser_equal <span style="color: #2aa198;">'WAR AND PEACE loaned on Mon Apr 06 12:15:50'</span>, loan.to_s
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Quiz: Class Taboo</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>Taboo游戏是有一个关键字,使用"其他所有的什么关键字"来形容这个关键字
</li>
<li>我们有如下的一个类,我们希望能使用另外一种方式来实现它,不要使用关键字class
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span> &lt; <span style="color: #b58900;">Array</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span>
    <span style="color: #2aa198;">'Hello!'</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>解决的办法如下,就是使用Class.new来创建一个新的class,因为普通的class的其实就
是Class的一个instance么
<div class="org-src-container">

<pre class="src src-ruby">c = <span style="color: #b58900;">Class</span>.new<span style="color: #2aa198;">(</span><span style="color: #b58900;">Array</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span>
    <span style="color: #2aa198;">'Hello!'</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>而我们的这个c类,还是没有名字的,因为class的名字都是const,必须是大写.而给匿名
类取名的方式很特别
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">MyClass</span> = c
</pre>
</div>
</li>
<li>如果不取名的话,匿名类的名字是nil
<div class="org-src-container">

<pre class="src src-ruby">c = <span style="color: #b58900;">Class</span>.new<span style="color: #2aa198;">(</span><span style="color: #b58900;">Array</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method</span>
    <span style="color: #2aa198;">'Hello'</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">p</span> c
<span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">String</span>.name
<span style="color: #657b83; font-weight: bold;">p</span> c.name
<span style="color: #b58900;">MyClass</span> = c
<span style="color: #657b83; font-weight: bold;">p</span> c.name

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">#&lt;Class:0x007fc01008b768&gt;                      #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"String"                                       #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">nil                                            #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"MyClass"                                      #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Singleton Methods</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>我们有如下的class定义Paragraph
</li>
<li>Paragraph#title?这个函数很特别:只有一个instance会调用它!
</li>
<li>那我们再想,只有一个instance调用这个函数.为这一个函数添加一个method是不是太
浪费了?减少浪费的办法就是ruby的另外一个特性:singleton method
</li>
</ul>
</div>
<div id="outline-container-sec-5-3-1" class="outline-4">
<h4 id="sec-5-3-1">Introducing Singleton Methods</h4>
<div class="outline-text-4" id="text-5-3-1">
<ul class="org-ul">
<li>所谓singleton method,其实就是专门为某个object才生效的函数
</li>
<li>其实singleton method的原理看起来也非常简单:把某个object看成是一个class,然
后设置这个class的class method,其实也就是这个object的singleton method
<div class="org-src-container">

<pre class="src src-ruby">str = <span style="color: #2aa198;">"just a regular string"</span>

<span style="color: #859900; font-weight: bold;">def</span> str.<span style="color: #268bd2;">title?</span>
  <span style="color: #859900; font-weight: bold;">self</span>.upcase == <span style="color: #859900; font-weight: bold;">self</span>
<span style="color: #859900; font-weight: bold;">end</span>

str.title?                      <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; false</span>
str.methods.grep<span style="color: #2aa198;">(</span><span style="color: #2aa198;">/title?/</span><span style="color: #2aa198;">)</span>      <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:title?]</span>
str.singleton_methods           <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:title?]</span>
</pre>
</div>
</li>
<li>除了上面的方法,我们还可以使用Object#define_singleton_method来定义singleton
      method
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3-2" class="outline-4">
<h4 id="sec-5-3-2">The Truth About Class Methods</h4>
<div class="outline-text-4" id="text-5-3-2">
<ul class="org-ul">
<li>前面我们说了,所谓singleton method其实就是Class Method:只对这个object起作用
的函数'等同于'只在这个class里面起作用的函数
</li>
<li>如果把class看成是一个object,而把一个class method看成普通method的话,就会得
到如下两个例子是等同的
<div class="org-src-container">

<pre class="src src-ruby">an_object.a_method
<span style="color: #b58900;">AClass</span>.a_class_method
</pre>
</div>
</li>
<li>如果更仔细一点的话,我们可以分别总结一下:
<ul class="org-ul">
<li>第一个例子是一个"被variable引用"的object调用了一个method
</li>
<li>第二个例子是一个"被const引用"的object调用了一个method
</li>
</ul>
</li>
<li>再从定义的方法来看看, singleton method和class method的定义方法一样
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> obj.<span style="color: #268bd2;">a_singleton_method;</span> <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #b58900;">MyClass</span>.<span style="color: #268bd2;">another_class_method;</span> <span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>我们把上面两种定义singleton_method的方法总结一下就是:
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> obj_or_const_or_self.<span style="color: #268bd2;">method</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Method body here</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>也就是说def后面,method前面可以是如下三种:
<ul class="org-ul">
<li>object
</li>
<li>const
</li>
<li>self
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3-3" class="outline-4">
<h4 id="sec-5-3-3">Class Macros</h4>
<div class="outline-text-4" id="text-5-3-3">
<ul class="org-ul">
<li>ruby不和java相同的地方就是它没有setter和getter的写法,如果我们实在要写的话
ruby版本的setter和getter如下
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_attribute=</span><span style="color: #2aa198;">(</span>value<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@my_attribute</span> = value
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_attribute</span>
    <span style="color: #268bd2;">@my_attribute</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">MyClass</span>.new
obj.my_attribute = <span style="color: #2aa198;">'x'</span>
obj.my_attribute                <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 'x'</span>
</pre>
</div>
</li>
<li>其实我们完全没必要自己写,因为存在一个class method叫做Module#attr_accessor
      就起到了both getter和setter的作用.attr_accessor前面没有任何的receiver其实
      就是默认使用self(在当前也就是MyClass)
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:my_attribute</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>attr_*系列函数(Module#attr_reader, Module#attr_accessor)是Module的函数,也
就意味着只要是在class内部或者module内部,我们都可以使用(比如MyClass)
</li>
<li>类似attr_accessor这样的method,我们把它们叫做Class Macro, 所谓Class Macro其
实就是class method,只不过
<pre class="example">
Class Macros look like keywords, but they'are just regular class
method that are ment to be used in a class definition
</pre>
</li>
<li>attr_x是standard library为我们提供的class macro,我们也可以自己根据需要来写
一系列的class macro.比如我们的Book原来有三个函数分别叫GetTitle, title2和
LEND_TO_USER,显然这三个名字是非常不ruby-style的,我们希望使用title, sutitle
和lend_to函数来替代.但是我们同时希望警告使用我们old-style函数的其他代码,这
些函数我们已经把它们列为deprecated了
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Book</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">title</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">..</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">subtitle</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">lend_to</span><span style="color: #2aa198;">(</span>user<span style="color: #2aa198;">)</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Lending to </span><span style="color: #268bd2;">#{user}</span><span style="color: #2aa198;">"</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">deprecate</span><span style="color: #2aa198;">(</span>old_method, new_method<span style="color: #2aa198;">)</span>
    <span style="color: #657b83; font-weight: bold;">define_method</span><span style="color: #2aa198;">(</span>old_method<span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span> |*args, &amp;block|
      <span style="color: #657b83; font-weight: bold;">warn</span> <span style="color: #2aa198;">"Warning: </span><span style="color: #268bd2;">#{old_method}</span><span style="color: #2aa198;">() is deprecated. Use </span><span style="color: #268bd2;">#{new_method}</span><span style="color: #2aa198;">()."</span>
      send<span style="color: #2aa198;">(</span>new_method, *args, &amp;block<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  deprecate <span style="color: #268bd2; font-weight: bold;">:GetTitle</span>, <span style="color: #268bd2; font-weight: bold;">:title</span>
  deprecate <span style="color: #268bd2; font-weight: bold;">:LEND_TO_USER</span>, <span style="color: #268bd2; font-weight: bold;">:lend_to</span>
  deprecate <span style="color: #268bd2; font-weight: bold;">:title2</span>, <span style="color: #268bd2; font-weight: bold;">:subtitle</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>使用起来的效果如下
<div class="org-src-container">

<pre class="src src-ruby">b = <span style="color: #b58900;">Book</span>.new
b.LEND_TO_USER<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Bill"</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">################################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;               #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Warning: LEND_TO_USER() is deprecated. Use lend_to().        #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Lending to Bill                                              #</span>
<span style="color: #93a1a1;">################################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Singleton Classes</h3>
<div class="outline-text-3" id="text-5-4">
</div><div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">The Mystery of Singleton Methods</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>现在回顾一下,最简单的查找method的方法,就是"right"进入receiver的class,然后
从class的继承序列里面查找需要的method
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method;</span> <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">MyClass</span>.new
obj.my_method
</pre>
</div>
</li>
<li>其method查找的图例如下
<pre class="example">
                        +---------------+
                        |               |
                        |    Object     |
                        |               |
                        +-------^-------+
                                |
                                |
                                |
                                | superclass
                       +--------+---------+
                       |  MyClass         |
+------+    class      +------------------+
|      +--------------&gt;|                  |
| obj  |               | my_method()      |
+------+               +------------------+
</pre>
</li>
<li>问题出现在当我们为obj定义了一个singleton method的时候,如下,这种情况下,我们
很难在上面的chart里面找到singleton method的位置
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> obj.<span style="color: #268bd2;">my_singleton_method;</span> <span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>图上总共只有三个位置:
<ul class="org-ul">
<li>obj:肯定不能是这里,obj不是一个class,其顶多可以放一些instance variable
</li>
<li>MyClass:也不能放这里,因为如果放这里的话,所有的MyClass的instance都会share
</li>
<li>Object:和MyClass一样的原因(不能共享), singleton method也不可以放在这里
</li>
</ul>
</li>
<li>MyClass也可以有自己的singleton method,也就是class method.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #b58900;">MyClass</span>.<span style="color: #268bd2;">my_class_method;end</span>
</pre>
</div>
</li>
<li>同样的,我们在下图里面找不到地方存放这个singleton method
<pre class="example">
                         +---------------+
                         |               |
                         |    Object     |
                         |               |
                         +-------^-------+
                                 |
                                 |
                                 |
                                 | superclass
                        +--------+---------+
                        |  Class           |
+-------+    class      +------------------+
|       +--------------&gt;|                  |
|MyClass|               | ....             |
+-------+               +------------------+
</pre>
</li>
<li>上诉两个问题的答案就在ruby"隐藏"的singleton class
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">Singleton Classes Revealed</h4>
<div class="outline-text-4" id="text-5-4-2">
<ul class="org-ul">
<li>当你请求一个object的class的时候(使用Object#class), ruby并没有"如实说出"所
有的事实.
</li>
<li>真实的情况是,每个object都有一个自己的singleton class,而Object#class是非常
小心的隐藏了singleton class的存在的.
</li>
<li>我们知道class keyword可以把我们带入到class的内部(就是self指向class),而ruby
也设计了"打开"singleton class的方法
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; an_object
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">you code here</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>如果你想获得refer to singleton class,你可以直接在上面的scope里面直接返回
self
<div class="org-src-container">

<pre class="src src-ruby">obj = <span style="color: #b58900;">Object</span>.new

singleton_class = <span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; obj
                    <span style="color: #859900; font-weight: bold;">self</span>
                  <span style="color: #859900; font-weight: bold;">end</span>

singleton_class.class                 <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; Class</span>
</pre>
</div>
</li>
<li>和上面的方法等价的是Object#singleton_class
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #2aa198;">"abc"</span>.singleton_class           <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; #&lt;Class:#&lt;String:0x007fddcb0ea1e0&gt;&gt;</span>
</pre>
</div>
</li>
<li>从上面的例子我们可以看出两点:
<ul class="org-ul">
<li>singleton_class也是一种class(其Object#class的结果是Class)
</li>
<li>只有通过Object#singleton_class,或者class&lt;&lt;obj这两种方式才能"看到"singleton
class的存在
</li>
</ul>
</li>
<li>另外有几点是ruby设计的时候制定的:
<ul class="org-ul">
<li>singleton class只能有一个instance(这也是它名字的来历)
</li>
<li>singleton class不能被继承(但是可以继承别的class)
</li>
<li>singleton class是singleton method存放的地方
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> obj.<span style="color: #268bd2;">my_singleton_method;</span> <span style="color: #859900; font-weight: bold;">end</span>
singleton_class.instance_methods.grep<span style="color: #2aa198;">(</span><span style="color: #2aa198;">/my_/</span><span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:my_singleton_method]</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-3" class="outline-4">
<h4 id="sec-5-4-3">Method Lookup Revisited</h4>
<div class="outline-text-4" id="text-5-4-3">
<ul class="org-ul">
<li>我们先来看一个在没有singleton class这个概念引入之前,我们就能解决的问题"right
then up to top"的查找函数:
<ul class="org-ul">
<li>代码如下
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">C</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">a_method</span>
    <span style="color: #2aa198;">'C#a_method()'</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">D</span> &lt; <span style="color: #b58900;">C</span>; <span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">D</span>.new
obj.a_method                    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "C#a_method()"</span>
</pre>
</div>
</li>
<li>图例如下
<pre class="example">
                             +------------+
                             |            |
                             |  Object    |
                             |            |
                             +------^-----+
                                    |
                                    |
                                    |superclass
                             +------+-----+
                             |     C      |
                             +------------+
                             | a_method() |
                             +------^-----+
                                    |
                                    |
                                    |
                                    |superclass
+------------+    class      +------+-----+
|            +--------------&gt;|            |
|   obj      |               |     D      |
|            |               |            |
+------------+               +------------+
</pre>
</li>
</ul>
</li>
<li>好加入了singleton_class以后的情况下如下(为了分辨,#obj用来指代obj的singleton
class)
<ul class="org-ul">
<li>代码如下:
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; obj
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">a_singleton_method</span>
    <span style="color: #2aa198;">'obj#a_singleton_method()'</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>图例如下
<pre class="example">
                             +------------+
                             |            |
                             |  Object    |
                             |            |
                             +------^-----+
                                    |
                                    |
                                    |superclass
                             +------+-----+
                             |     C      |
                             +------------+
                             | a_method() |
                             +------^-----+
                                    |
                                    |
                                    |superclass
                             +------+-----+
                             |            |
                             |     D      |
                             |            |
                             +------^-----+
                                    |
                                    |
                                    |superclass
+------------+               +------+------------------+
|            +--------------&gt;|     #obj                |
|   obj      |               +-------------------------+
|            |               |    a_singleton_method() |
+------------+               +-------------------------+
</pre>
</li>
</ul>
</li>
<li>我们可以看到,所谓singleton class其实就是在obj和'obj的class'之间,多加了一道
"工序"
</li>
<li>这个工序是每个obj都不同的,所以我们可以把obj和#obj看成一个整体,这个整体是D
的instance.只不过ruby的分类更加牛逼,把一个instance里面"更加class的部分"给
单独拎出来,整了个叫做singleton class的类
</li>
<li>我们的singleton_class的Class#superclass就是obj的Object#class
<div class="org-src-container">

<pre class="src src-ruby">obj.singleton_class.superclass  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; D</span>
</pre>
</div>
</li>
<li>值得注意的是我们现在讨论的是singleton method, class method也是一种singleton
method,但是因为它的作用主体为'类instance',所以它们的实现还有些不同
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-4" class="outline-4">
<h4 id="sec-5-4-4">Singleton Classes and Inheritance</h4>
<div class="outline-text-4" id="text-5-4-4">
<ul class="org-ul">
<li>我们为class C创建一个class method(也就是singleton method),我们会看到其实所
有的class都有自己的singleton class!代码如下
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">C</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">a_method</span>
    <span style="color: #2aa198;">'C#a_method()'</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; <span style="color: #859900; font-weight: bold;">self</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">a_class_method</span>
      <span style="color: #2aa198;">'C.a_class_method()'</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">D</span> &lt; <span style="color: #b58900;">C</span>; <span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">D</span>.new

<span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; obj
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">a_singleton_method</span>
    <span style="color: #2aa198;">'obj#a_singleton_method()'</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">D</span>.singleton_class
<span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">C</span>.singleton_class

<span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">D</span>.singleton_class.superclass
<span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">C</span>.singleton_class.superclass

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">#&lt;Class:D&gt;                                     #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">#&lt;Class:C&gt;                                     #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">#&lt;Class:C&gt;                                     #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">#&lt;Class:Object&gt;                                #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>所有的一切,尽在图中, class method作为class 的singleton method,存在了class
的singleton class里面.class的singleton class和object的singleton class稍有
不同:它们可以被继承!
<pre class="example">
                                          +-------------+
                                          |   Class     |
                                          +------^------+
                                                 |
                                                 | S
                 +-------------+ C        +------+------+
                 | BasicObject +---------&gt;| #BasicObject|
                 +------^------+          +------^-----+
                        |                        |
                        | S                      | S
                 +------+------+ C        +------+------+
                 |  Object     +---------&gt;| #Object     |
                 +------+------+          +------^------+
                        | S                      | S
                 +------+------+ C        +------+-------+
                 |     C       +---------&gt;|    #C        |
                 +-------------+          +--------------+
                 |  a_method   |          |a_class_method|
                 +------^------+          +------^-------+
                        |                        |
                        | S                      | S
                 +------+------+ C        +------+------+
                 |     D       +---------&gt;|    #D       |
                 +------^------+          +-------------+
                        |
                        | S
+------+  C      +------+------------+
|      +---------&gt;   #obj            |     C = (singleton)Class
| obj  |         +-------------------+
|      |         | a_singleton_method|     S = Superclass
+------+         +-------------------+
</pre>
</li>
<li>ruby的这个实现很"工整",singleton也被很好地保护起来,比如调用obj.class,因为
Object#method并不知道singleton class的事情,它主动返回D,虽然obj实际上的class
其实是#obj,而#obj的superclass才是D
</li>
<li>ruby的这些singleton class之间也是和普通class一样'对称'的格式,比如#D的superclass
还是#C,同样的D的superclass是C. 这种对称用英文来说就是
<pre class="example">
The superclass of singleton class is the singleton class of
the superclass
</pre>
</li>
<li>Ruby实现这种"对称而又复杂"的类继承格式,最后的目的是为了能够让subclass也调
用parent class的class method
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">D</span>.a_class_method                <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "C.a_class_method()"</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-5" class="outline-4">
<h4 id="sec-5-4-5">The Great Unified Theory</h4>
<div class="outline-text-4" id="text-5-4-5">
<ul class="org-ul">
<li>ruby的大一统的设计最终总结出来是七条准则:
<ol class="org-ol">
<li>There is only one kind of object &#x2013; be it a regular object or a module
</li>
<li>There is only one kind of module &#x2013; be a regular module, a class, or a
singleton class
</li>
<li>There is only one kind of method, and it lives in a module &#x2013; most
often in a class
</li>
<li>Every object, classes included, has it own "real class", be a regular
class or a singleton class
</li>
<li>Every class, withe the exception of BasicObject, has exactly one
ancestor &#x2013; either a superclass or a module. This means you have a
single chain of ancestors from any class up to BasicObject
</li>
<li>The superclass of the singleton class of an object is the object's
class.The superclass of the singleton class of a class is the singleton
class of the class's superclass(普通singleton method和class method的些
许不同)
</li>
<li>When you call a method, Ruby goes "right" in the receiver's real class
and then "up" the ancestors chain. That's all there is to know about
the way Ruby finds methods
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-6" class="outline-4">
<h4 id="sec-5-4-6">Class Methods Syntaxes</h4>
<div class="outline-text-4" id="text-5-4-6">
<ul class="org-ul">
<li>因为class methods其实就是存在class的singleton class里面的singleton method,
所以我们有很多种方法来定义一个class method:
<ul class="org-ul">
<li>第一种,直接定义成MyClass的singleton method,这种方法不容易重构
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #b58900;">MyClass</span>.<span style="color: #268bd2;">a_class_method;</span> <span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>第二种,在class里面,使用self来替代class,也是定义singleton method的方法
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">another_class_method;end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>第三种,打开class的singleton class,在这里面定义一个method
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; <span style="color: #859900; font-weight: bold;">self</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">yet_another_class_method;</span> <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-7" class="outline-4">
<h4 id="sec-5-4-7">Singleton Classes and instance_eval()</h4>
<div class="outline-text-4" id="text-5-4-7">
<ul class="org-ul">
<li>我们前面介绍过instance_eval,知道这个BasicObject#instance_eval其作用,是打开
某个object的内部,可以替换某个object的self等
</li>
<li>原来觉得这个函数的实现好像很牛逼,其实说白了就是"打开了object的singleton
class", 可以看下面一个例子三种方法效果一样,都是打开了singleton class,我们
的instance_eval只不过看起来"比较简单而已"
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span>
    <span style="color: #268bd2;">@v</span> = 0
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">MyClass</span>.new

obj.instance_eval <span style="color: #859900; font-weight: bold;">do</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">s_method1</span>
    <span style="color: #268bd2;">@v</span> = 1
    <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #859900; font-weight: bold;">self</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">def</span> obj.<span style="color: #268bd2;">s_method2</span>
  <span style="color: #268bd2;">@v</span> = 2
  <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #859900; font-weight: bold;">self</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; obj
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">s_method3</span>
    <span style="color: #268bd2;">@v</span> = 3
    <span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #859900; font-weight: bold;">self</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">p</span> obj.singleton_methods

obj.s_method1
obj.s_method2
obj.s_method3

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[:s_method1, :s_method2, :s_method3]           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">#&lt;MyClass:0x007fca3701a370 @v=1&gt;               #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">#&lt;MyClass:0x007fca3701a370 @v=2&gt;               #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">#&lt;MyClass:0x007fca3701a370 @v=3&gt;               #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>所以使用instance_eval来定义singleton method也是常见做法.
</li>
<li>instance_eval的语义就是"作用在instance上面,而且希望更改这个instance的self,
无论是self的instance variable,还是instance的singleton method"
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-8" class="outline-4">
<h4 id="sec-5-4-8">Class Attributes</h4>
<div class="outline-text-4" id="text-5-4-8">
<ul class="org-ul">
<li>我们再来看看singleton的另外一个应用,前面讲到过class macros,也知道class
macros就是class method,只不过这个method是在class内部调用(不加self)看起来像
个key word而已
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:a</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">MyClass</span>.new
obj.a = 2
obj.a                           <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 2</span>
</pre>
</div>
</li>
<li>上面的例子会为"MyClass的每个obj"定义一个attribute,叫做a.话说回来了,如果我
们想为每个`class`定义一个attribute怎么办呢?典型的办法是把MyClass看成是Class
的instance,然后实现方法如下
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>; <span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Class</span>
  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:b</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #b58900;">MyClass</span>.b = 42
<span style="color: #b58900;">MyClass</span>.b                       <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; 42</span>
</pre>
</div>
</li>
<li>这种办法当然可行,但是缺点是所有的`class`,无论String还是Integer,都被带上了
一个attribute b,这个在继承上面太重了.
</li>
<li>如果了解了singleton class,就应该知道,MyClass的"真正"的类型应该是#MyClass,
这个#MyClass只有一个instance就是MyClass,我们可以把我们的attribute设置到这
个singleton class里面去
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; <span style="color: #859900; font-weight: bold;">self</span>
    <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:c</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #b58900;">MyClass</span>.c = <span style="color: #2aa198;">'It works!'</span>
<span style="color: #b58900;">MyClass</span>.c                       <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "It works!"</span>
</pre>
</div>
</li>
<li>我们再来看看这个例子的图例
<pre class="example">
C = (singleton)Class                           +-------------+
S = Superclass                                 |   Class     |
                                               +-------------+
                                               |   b()       |
                                               |   b=()      |
                                               +------^------+
                                                      |
                                                      | S
                      +-------------+ C        +------+------+
                      | BasicObject +---------&gt;| #BasicObject|
                      +------^------+          +------^-----+
                             |                        |
                             | S                      | S
                      +------+------+ C        +------+------+
                      |  Object     +---------&gt;| #Object     |
                      +------+------+          +------^------+
                             | S                      | S
+------+  C           +------+------+ C        +------+-------+
|      +-------------&gt;|  MyClass    +---------&gt;|  #MyClass    |
| obj  |              +-------------+          +--------------+
|      |              |  a()        |          |    c()       |
+------+              |  a=()       |          |    c=()      |
                      +-------------+          +--------------+
</pre>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Quiz: Module Trouble</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li>ruby中定义module的一个用处就是"通过include module来定义method",但是通过如下
的方法,却发现module里面的method没有被成功的include
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">MyModule</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">my_method;</span> <span style="color: #2aa198;">'hello'</span>; <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">MyModule</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #b58900;">MyClass</span>.my_method               <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">NoMethodError!</span>
</pre>
</div>
</li>
<li>之所以上面的问题出现,是因为,当class include一个module的时候,它会获取这个
module的所有的instance method,而不是class method.因为class method是在module
的singleton class里面,include触及不到
</li>
<li>另外需要注意的是,你是使用MyClass来调用my_method, MyClass只能调用#MyClass(也
就是其singleton class)里面的method.换句话说,要把my_method设计成class method
</li>
</ul>
</div>
<div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1">Quiz Solution</h4>
<div class="outline-text-4" id="text-5-5-1">
<ul class="org-ul">
<li>我们的解决方案来了,方案就是改动了两点:
<ul class="org-ul">
<li>把module里面的method定义在非singleton class里面,这样include才能找到它
</li>
<li>在class里面,把include语义写在singleton class里面,这样就把这个method定义
成了class method
</li>
</ul>
</li>
<li>代码如下
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">MyModule</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method;</span> <span style="color: #2aa198;">'hello'</span>; <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; <span style="color: #859900; font-weight: bold;">self</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">MyModule</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #b58900;">MyClass</span>.my_method               <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "hello"</span>
</pre>
</div>
</li>
<li>上面这种给class增加class method的方法叫做Class Extension
</li>
<li>把上面这种技法应用到object上面,就叫Object Extension,简单点说,就是通过include
module给object增加singleton method
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">MyModule</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method;</span> <span style="color: #2aa198;">'hello'</span>; <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">Object</span>.new

<span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; obj
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">MyModule</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj.my_method                   <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "hello"</span>
obj.singleton_methods           <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; [:my_method]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-5-2" class="outline-4">
<h4 id="sec-5-5-2">Object#extend</h4>
<div class="outline-text-4" id="text-5-5-2">
<ul class="org-ul">
<li>Object Extension和Class Extension的使用如此的普遍,以至于每次使用`class&lt;&lt;`
太麻烦了,所以创建了一个新的函数叫做Object#extend来直接include一个module到
自己的singleton class
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">MyModule</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">my_method;</span> <span style="color: #2aa198;">'hello'</span>; <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

obj = <span style="color: #b58900;">Object</span>.new
obj.extend <span style="color: #b58900;">MyModule</span>
obj.my_method                   <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "hello"</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MyClass</span>
  <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">MyModlue</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #b58900;">MyClass</span>.my_method               <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "hello"</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6">Method Wrappers</h3>
<div class="outline-text-3" id="text-5-6">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Chapter 6: Friday: Code That Writes Code</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Coding Your Way to the Weekend</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>老板在自己学习class macro的过程中,觉得attr_accessor非常好用,所以她希望自己
实现一个attr_checked,也就是用来validate的attribute:
<ul class="org-ul">
<li>attr_checked的参数一是一个name
</li>
<li>attr_checked的block参赛是用来check这个name的方法, 返回true表示没有问题
</li>
</ul>
</li>
<li>attr_checked不能污染standard library,需要include CheckedAttribute以后才能使
用, 如下
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Person</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">CheckedAttributes</span>

  attr_checked <span style="color: #268bd2; font-weight: bold;">:age</span> <span style="color: #859900; font-weight: bold;">do</span> |v|
    v &gt;= 18
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

me = <span style="color: #b58900;">Person</span>.new
me.age = 39                     <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">OK</span>
me.age = 12                     <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Exception</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Chapter 7: Epilogue</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Chapter 8: Preparing for a Rails Tour</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>前面我们学到了很多技术，如何使用这些技术正是rails做的非常好的地方。
</li>
</ul>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Ruby on Rails</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>安装rails其实就是安装一个gem包
<div class="org-src-container">

<pre class="src src-sh">gem install rails -v 4.1.0
</pre>
</div>
</li>
<li>rails gem其实质包含了helper, 比如:
<ul class="org-ul">
<li>code generator
</li>
<li>rake task
</li>
<li>将其他代码"粘合"在一起的胶水语言
</li>
</ul>
</li>
<li>而真正起作用的是'其他'gem,最重要的是三个:
<ul class="org-ul">
<li>activerecord: MVC中的M
</li>
<li>actionpack: MVC中的VC
</li>
<li>activesupport: 一些帮助函数,比如time calculation和log
</li>
</ul>
</li>
<li>可以使用如下命令把某个版本的代码存储在当前文件夹下(当然你懂git checkout就不需要这个了)
<div class="org-src-container">

<pre class="src src-sh">gem unpack activerecord -v=4.1.0
</pre>
</div>
</li>
<li>rails的代码非常难以理解,当无法理解其中原理的时候,可以借助测试用例来查看其意图
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Chapter 9: The Design of Active Record</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li>Active Record是rails里面用来映射Ruby object到database record的library(俗称
orm)
</li>
<li>我们本书中更注重library'如何做到的',而不是'做到了什么'
</li>
</ul>
</div>
<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">A Short Active Record Example</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>先看一个例子,数据库中有一个表叫做ducks,ducks有一个field叫做name.我们想把这
个table映射成一个class
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'active_record'</span>
<span style="color: #b58900;">ActiveRecord</span>::<span style="color: #b58900;">Base</span>.establish_connection <span style="color: #268bd2; font-weight: bold;">:adapter</span> =&gt; <span style="color: #2aa198;">"sqlite3"</span>,
                                        <span style="color: #268bd2; font-weight: bold;">:database</span> =&gt; <span style="color: #2aa198;">"dbfile"</span>
</pre>
</div>
</li>
<li>ActiveReord::Base是AR里面最重要的一个class啦,当然首先它包括了'建立'数据库的
代码如上,其次,它是所有"被映射class"的superclass
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Duck</span> &lt; <span style="color: #b58900;">ActiveRecord</span>::<span style="color: #b58900;">Base</span>
  validate <span style="color: #859900; font-weight: bold;">do</span>
    errors.add<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">:base</span>, <span style="color: #2aa198;">"Illegal duck name"</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">unless</span> name<span style="color: #2aa198;">[</span>0<span style="color: #2aa198;">]</span> == <span style="color: #2aa198;">'D'</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>如上例,我们继承了ActiveRecord::Base以后,可以调用它的class method validate,
这个class method带了一个block,回去判断block里面的情况,如果不妙:
<ul class="org-ul">
<li>save!会失败并且抛出exception
</li>
<li>更外层的save会"默默"失败
</li>
</ul>
</li>
<li>下面重点的来了,ActiveRecord会得知table一切的field,然后使用ghost method来为
这每一个field'自动'创建一个attribute
<div class="org-src-container">

<pre class="src src-ruby">my_duck = <span style="color: #b58900;">Duck</span>.new
my_duck.name = <span style="color: #2aa198;">"Donald"</span>
my_duck.valid?                  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; true</span>
my_duck.save!                   <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">save it to the database</span>

duck_from_database = <span style="color: #b58900;">Duck</span>.first
duck_from_database.name         <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">=&gt; "Donalid"</span>
duck_from_database.delete
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">How Active Record Is Put Together</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li>如果你使用过一段时间的Active Record,你就会发现里面函数特别的多,如果从java的
经验来看,这个class应该非常的大.常见的函数save和validate也都会有体现
</li>
<li>但是如果你看了ActiveRecord::Base的代码,你会发现代码非常的少,而且竟然找不到
save和validate的定义的地方!
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">The Autoloading Mechanism</h3>
<div class="outline-text-3" id="text-9-3">
<ul class="org-ul">
<li>好我们来看看4.1.0版本的active_record.rb,打开以后,发现这个代码竟然只有170行,
然后主要的代码结构如下
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'active_support'</span>
<span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'active_support/rails'</span>
<span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'active_model'</span>
<span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'arel'</span>

<span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'active_record/version'</span>

<span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">ActiveRecord</span>
  <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">ActiveSupport</span>::<span style="color: #b58900;">Autoload</span>

  <span style="color: #657b83; font-weight: bold;">autoload</span> <span style="color: #268bd2; font-weight: bold;">:Base</span>
  <span style="color: #657b83; font-weight: bold;">autoload</span> <span style="color: #268bd2; font-weight: bold;">:Callbacks</span>
  <span style="color: #657b83; font-weight: bold;">autoload</span> <span style="color: #268bd2; font-weight: bold;">:Core</span>
  <span style="color: #657b83; font-weight: bold;">autoload</span> <span style="color: #268bd2; font-weight: bold;">:ConnectionHandling</span>
  <span style="color: #657b83; font-weight: bold;">autoload</span> <span style="color: #268bd2; font-weight: bold;">:CounterCache</span>
  <span style="color: #657b83; font-weight: bold;">autoload</span> <span style="color: #268bd2; font-weight: bold;">:DynamicMatchers</span>
  <span style="color: #657b83; font-weight: bold;">autoload</span> <span style="color: #268bd2; font-weight: bold;">:Enum</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">....</span>
</pre>
</div>
</li>
<li>require了五个library,其中最重点的是两个:
<ul class="org-ul">
<li>Active Support
</li>
<li>Active Model
</li>
</ul>
</li>
<li>文件开始就extend的一个Active Support的'子module' ActiveSupport::Autoload,这
个module里面有个函数非常重要,叫做autoload,代码就不贴了看不懂,其作用自动帮你
找到需要的module,然后引入需要的代码.也就是
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">autoload</span> <span style="color: #268bd2; font-weight: bold;">:Base</span>
<span style="color: #657b83; font-weight: bold;">autoload</span> <span style="color: #268bd2; font-weight: bold;">:NoTouching</span>
</pre>
</div>
</li>
<li>换句话说,Active Record就像是一个namespace,而你使用ActiveRecord::Base的时候,
其实代码真正的都在active_record/base.rb,通过autoload引入进ActiveRecord Module
里面.
</li>
<li>注意,autoload是你用到了,才会去include,不用的话,不include,为什么呢,因为代码
太多了
</li>
<li>如果你看了ActiveRecord::Base的代码就会发现,是纯引用.而且每个引用里面都会有
大量的代码
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">ActiveRecord</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Base</span>
    <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">ActiveModel</span>::<span style="color: #b58900;">Naming</span>
    <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">ActiveSupport</span>::<span style="color: #b58900;">Benchmarkable</span>
    <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">ActiveSupport</span>::<span style="color: #b58900;">DescendantsTracker</span>
    <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">ConnectionHandling</span>
    <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">QueryCache</span>::<span style="color: #b58900;">ClassMethods</span>
    <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">Querying</span>
    <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">Translation</span>
    <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">DynamicMatchers</span>
    <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">Explain</span>
    <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">Enum</span>
    <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">Delegation</span>::<span style="color: #b58900;">DelegateCache</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Core</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Persistence</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">NoTouching</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">ReadonlyAttributes</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">ModelSchema</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Inheritance</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Scoping</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Sanitization</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">AttributeAssignment</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">ActiveModel</span>::<span style="color: #b58900;">Conversion</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Integration</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Validations</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">CounterCache</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Locking</span>::<span style="color: #b58900;">Optimistic</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Locking</span>::<span style="color: #b58900;">Pessimistic</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">AttributeMethods</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Callbacks</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Timestamp</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Associations</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">ActiveModel</span>::<span style="color: #b58900;">SecurePassword</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">AutosaveAssociation</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">NestedAttributes</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Aggregations</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Transactions</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Reflection</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Serialization</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Store</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Core</span>
<span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #b58900;">ActiveSupport</span>.run_load_hooks<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">:active_record</span>, <span style="color: #b58900;">Base</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>有些代码很容易找到"出处",比如save
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">ActiveRecord</span>
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">Persistence</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">save</span><span style="color: #2aa198;">(</span>*<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
    <span style="color: #859900; font-weight: bold;">end</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">save!</span><span style="color: #2aa198;">(</span>*<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
    <span style="color: #859900; font-weight: bold;">end</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">delete</span> <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>有些代码就很难找到"出处",比如validate
</li>
<li>TODO
</li>
<li>只需要知道ActiveRecord的module是特殊的,如果你include了它们,你会同时得到:
<ul class="org-ul">
<li>instance method
</li>
<li>class method
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
