<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>eloquent</title>
<!-- 2017-05-02 Tue 10:44 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">eloquent</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 01: Write Code That Looks Like Ruby</a>
<ul>
<li><a href="#sec-1-1">The Very Basic Basics</a></li>
<li><a href="#sec-1-2">Go Easy on the Comments</a></li>
<li><a href="#sec-1-3">Camels for Classes, Snakes Everywhere Else</a></li>
<li><a href="#sec-1-4">Parentheses Are Optional but Are Occasionally Forbidden</a></li>
<li><a href="#sec-1-5">Folding Up Those Lines</a></li>
<li><a href="#sec-1-6">Folding Up THose Code Blocks</a></li>
<li><a href="#sec-1-7">Staying Out of Trouble</a></li>
<li><a href="#sec-1-8">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 02: Choose the Right Control Structure</a>
<ul>
<li><a href="#sec-2-1">If, Unless, While, and Until</a></li>
<li><a href="#sec-2-2">Use the Modifier Forms Where Appropriate</a></li>
<li><a href="#sec-2-3">Use each, Not for</a></li>
<li><a href="#sec-2-4">A Case of Programming Logic</a></li>
<li><a href="#sec-2-5">Staying Out of Trouble</a></li>
<li><a href="#sec-2-6">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-3">Chapter 03: Take Advantage of Ruby's Smart Collections</a>
<ul>
<li><a href="#sec-3-1">Literal Shortcuts</a></li>
<li><a href="#sec-3-2">Instant Arrays and Hashes from Method Calls</a></li>
<li><a href="#sec-3-3">Running Through Your Collection</a></li>
<li><a href="#sec-3-4">Beware the Bang!</a></li>
<li><a href="#sec-3-5">Rely on the Order of Your Hashes</a></li>
<li><a href="#sec-3-6">In the Wild</a></li>
<li><a href="#sec-3-7">Staying Out</a></li>
</ul>
</li>
<li><a href="#sec-4">Chapter 04: Take Advantage of Ruby's Smart Strings</a>
<ul>
<li><a href="#sec-4-1">Coming Up with a String</a></li>
<li><a href="#sec-4-2">Another API to Master</a></li>
<li><a href="#sec-4-3">The String: A Place for Your Lines, Characters, and Bytes</a></li>
<li><a href="#sec-4-4">In the Wild</a></li>
<li><a href="#sec-4-5">Staying Out of Trouble</a></li>
</ul>
</li>
<li><a href="#sec-5">Chapter 05: Find the Right String with Regular Expressions</a>
<ul>
<li><a href="#sec-5-1">Matching One Character at a Time</a></li>
<li><a href="#sec-5-2">Sets, Ranges, and Alternatives</a></li>
<li><a href="#sec-5-3">The Regular Expression Star</a></li>
<li><a href="#sec-5-4">Regular Expressions in Ruby</a></li>
<li><a href="#sec-5-5">Beginnings and Endings</a></li>
<li><a href="#sec-5-6">In the Wild</a></li>
<li><a href="#sec-5-7">Staying Out of Trouble</a></li>
</ul>
</li>
<li><a href="#sec-6">Chapter 06: Use Symbols to Stand for Something</a>
<ul>
<li><a href="#sec-6-1">The Two Faces of Strings</a></li>
<li><a href="#sec-6-2">Not Quite a String</a></li>
<li><a href="#sec-6-3">Optimized to Stand for Something</a></li>
<li><a href="#sec-6-4">In the Wild</a></li>
<li><a href="#sec-6-5">Staying Out of Trouble</a></li>
</ul>
</li>
<li><a href="#sec-7">Chapter 07: Treat Everything Like an Object &#x2013; Because Everything Is</a>
<ul>
<li><a href="#sec-7-1">A Quick Review of Clases, Instances, and Methods</a></li>
<li><a href="#sec-7-2">Objects All the Way Down</a></li>
<li><a href="#sec-7-3">The Importance of Being an Object</a></li>
<li><a href="#sec-7-4">Public, Private, and Protected</a></li>
<li><a href="#sec-7-5">In the Wild</a></li>
<li><a href="#sec-7-6">Staying Out of Trouble</a></li>
</ul>
</li>
<li><a href="#sec-8">Chapter 08: Embrace Dynamic Typing</a>
<ul>
<li><a href="#sec-8-1">Shorter Programs, But Not the Way You Think</a></li>
<li><a href="#sec-8-2">Extreme Decoupling</a></li>
<li><a href="#sec-8-3">Required Ceremony Versus Programmer-Driven Clarity</a></li>
<li><a href="#sec-8-4">Staying Out of Trouble</a></li>
<li><a href="#sec-8-5">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-9">Chapter 09: Write Specs!</a>
<ul>
<li><a href="#sec-9-1">Test::Unit: When Your Documents Just Have to Work</a></li>
<li><a href="#sec-9-2">A Plethora of Assertions</a></li>
<li><a href="#sec-9-3">Don't Test Il, Spec It!</a></li>
<li><a href="#sec-9-4">A Tidy Spec Is a Readable Spec</a></li>
</ul>
</li>
<li><a href="#sec-10">Chapter 10: Construct Your Classes from Short, Focused Methods</a>
<ul>
<li><a href="#sec-10-1">Compressing Specifications</a></li>
<li><a href="#sec-10-2">Composing Methods for Humans</a></li>
<li><a href="#sec-10-3">Composing Ruby Methods</a></li>
<li><a href="#sec-10-4">One Way Out?</a></li>
<li><a href="#sec-10-5">Staying Out of Trouble</a></li>
<li><a href="#sec-10-6">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-11">Chapter 11: Define Operators Respectfully</a>
<ul>
<li><a href="#sec-11-1">Defining Operators in Ruby</a></li>
<li><a href="#sec-11-2">A Sampling of Operators</a></li>
<li><a href="#sec-11-3">Operating Across Classes</a></li>
<li><a href="#sec-11-4">Staying Out of Trouble</a></li>
<li><a href="#sec-11-5">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-12">Chapter 12: Create Classes That Understand Equality</a>
<ul>
<li><a href="#sec-12-1">An Identifier for Your Documents</a></li>
<li><a href="#sec-12-2">An Embarrassment of Equality</a></li>
<li><a href="#sec-12-3">Double Equals for Everyday Use</a></li>
<li><a href="#sec-12-4">Broadening the Appeal of the == Method</a></li>
<li><a href="#sec-12-5">Well-Behaved Equality</a></li>
<li><a href="#sec-12-6">Triple Equals for Case Statements</a></li>
<li><a href="#sec-12-7">Hash Tables and the eql? Method</a></li>
<li><a href="#sec-12-8">Building a Well-Behaved Hash Key</a></li>
<li><a href="#sec-12-9">Staying Out of Trouble</a>
<ul>
<li><a href="#sec-12-9-1">In the Wild</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-13">Chapter 13: Get the Behavior You Nedd with Singleton and Class Methods</a>
<ul>
<li><a href="#sec-13-1">A Stubby Puzzle</a></li>
<li><a href="#sec-13-2">A Hidden, but Real Class</a></li>
<li><a href="#sec-13-3">Class Methods: Singletons in Plain Sight</a></li>
<li><a href="#sec-13-4">In the Wild</a></li>
<li><a href="#sec-13-5">Staying Out of Trouble</a></li>
</ul>
</li>
<li><a href="#sec-14">Chapter 14: Use Class Instance Variables</a>
<ul>
<li><a href="#sec-14-1">A Quick Review of Class Variables</a></li>
<li><a href="#sec-14-2">Wandering Variables</a></li>
<li><a href="#sec-14-3">Getting Control of the Data in Your Class</a></li>
<li><a href="#sec-14-4">Class Instance Variable and Subclasses</a></li>
<li><a href="#sec-14-5">Adding Some Convenience to Your Class Instance</a></li>
<li><a href="#sec-14-6">In the Wild</a></li>
<li><a href="#sec-14-7">Staying Out of Trouble</a></li>
</ul>
</li>
<li><a href="#sec-15">Chapter 15: Use Modules as Name Spaces</a>
<ul>
<li><a href="#sec-15-1">A Place for Your Stuff, with a Name</a></li>
<li><a href="#sec-15-2">A Home for Those Utility Methods</a></li>
<li><a href="#sec-15-3">Building Modules a Little at a Time</a></li>
<li><a href="#sec-15-4">Treat Modules Like the Objects That They Are</a></li>
<li><a href="#sec-15-5">Staying Out of Trouble</a></li>
<li><a href="#sec-15-6">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-16">Chapter 16: Use Modules as Mixins</a>
<ul>
<li><a href="#sec-16-1">Better Books with Modules</a></li>
<li><a href="#sec-16-2">Mixin Modules to the Rescue</a></li>
<li><a href="#sec-16-3">Extending a Module</a></li>
<li><a href="#sec-16-4">Staying Out of Trouble</a></li>
<li><a href="#sec-16-5">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-17">Chapter 17: Use Blocks to Iterate</a>
<ul>
<li><a href="#sec-17-1">A Quick Review of Code Blocks</a></li>
<li><a href="#sec-17-2">One Word after Another</a></li>
<li><a href="#sec-17-3">As Many Iterators as You Like</a></li>
<li><a href="#sec-17-4">Iterating over the Ethereal</a></li>
<li><a href="#sec-17-5">Enumerable: Your Iterator on Steroids</a></li>
<li><a href="#sec-17-6">Staying Out of Trouble</a></li>
<li><a href="#sec-17-7">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-18">Chapter 18: Execute Around with a Block</a>
<ul>
<li><a href="#sec-18-1">Add a Little Logging</a></li>
<li><a href="#sec-18-2">Carring the Answers Back</a></li>
<li><a href="#sec-18-3">When It Absolutely Must Happen</a></li>
<li><a href="#sec-18-4">Setting Up Objects with an Initialization Block</a></li>
<li><a href="#sec-18-5">Dragging Your Scope along with the Block</a></li>
<li><a href="#sec-18-6">Carrying the Answers Back</a></li>
<li><a href="#sec-18-7">Staying Out of Trouble</a></li>
<li><a href="#sec-18-8">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-19">Chapter 19: Save Blocks to Execute Later</a>
<ul>
<li><a href="#sec-19-1">Explicit Blocks</a></li>
<li><a href="#sec-19-2">The Call Back Problem</a></li>
<li><a href="#sec-19-3">Banking Blocks</a></li>
<li><a href="#sec-19-4">Saving Code Blocks for Lazy Initialization</a></li>
<li><a href="#sec-19-5">Instant Block objects</a></li>
<li><a href="#sec-19-6">Staying Out of Trouble</a></li>
<li><a href="#sec-19-7">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-20">Chapter 20: Use Hooks to Keep Your Program Informed</a>
<ul>
<li><a href="#sec-20-1">Waking Up to a New Subclass</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 01: Write Code That Looks Like Ruby</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">The Very Basic Basics</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Ruby style的核心:
<ul class="org-ul">
<li>首先,代码要清晰
<pre class="example">
Good code tells the reader exactly what it is trying to do.
Great code shouts its intent
</pre>
</li>
<li>其次,代码要简单, 简单才更容易清晰
</li>
</ul>
</li>
<li>看个例子
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:title</span>, <span style="color: #268bd2; font-weight: bold;">:author</span>, <span style="color: #268bd2; font-weight: bold;">:content</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>title, author, content<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@title</span>         title
    <span style="color: #268bd2;">@author</span>        author
    <span style="color: #268bd2;">@content</span>       content
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">words</span>
    <span style="color: #268bd2;">@content</span>.split
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">word_count</span>
    words.size
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>上面的代码,可以看到ruby缩进的规则
<ul class="org-ul">
<li>ruby使用了2空格的缩进,基本上是能察觉到的最短的缩进,为了写更多的代码
</li>
<li>ruby绝不使用tab,而是使用2空格代替
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Go Easy on the Comments</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>ruby有两种的不同的注释手段:
<ul class="org-ul">
<li>使用'#'在行首
</li>
<li>使用=begin 和=end
</li>
</ul>
</li>
<li>ruby是一种self-explain的语言,所以如果代码能够解释自己的话,就不需要注释
</li>
<li>最需要写的注释是"如何使用你的代码", 而不是"我为什么要这样写代码, 你使用了什
么算法, 你以后要做什么改进", 比如,下面就是一个很好的comment
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Class that models a plain text document, complete with title and author</span>
<span style="color: #93a1a1;">#</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">doc Document.new('Hamlet', 'Shakespeare', 'To be or ...')</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">puts doc.title</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">puts doc.author</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">puts doc.content</span>
<span style="color: #93a1a1;">#</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Document instances know how to parse their content into words:</span>
<span style="color: #93a1a1;">#</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">puts doc.words</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">puts doc.word_count</span>
<span style="color: #93a1a1;">#</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">class omitted..</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>还有一种好的comment是"代码如何工作"
</li>
<li>此外还有作者信息,版权信息
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Camels for Classes, Snakes Everywhere Else</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>函数变量命名的方式,总结起来就是:
<ul class="org-ul">
<li>类名使用首字母大写的"骑驼峰"
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>常亮使用全部大写,以下划线分割
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">ANTLERS_PER_MALE_MOOSE</span> 2
</pre>
</div>
</li>
<li>其他全部的情况都是小写字母,以下划线分割
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">count_words_in</span><span style="color: #2aa198;">(</span>the_string<span style="color: #2aa198;">)</span>
  the_words the_string.split
  the_words.size
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Parentheses Are Optional but Are Occasionally Forbidden</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>ruby让你可以省略括号!无论是定义还是使用的时候:
<ul class="org-ul">
<li>比如下面的代码
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">find_document</span><span style="color: #2aa198;">(</span>title, author<span style="color: #2aa198;">)</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Body omitted...</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
find_document<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Frankenstein'</span>, <span style="color: #2aa198;">'Shelley'</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>可以完全去掉括号,写成如下
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">find_document</span> title, author
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Body ommited...</span>
<span style="color: #859900; font-weight: bold;">end</span>

find_document <span style="color: #2aa198;">'Frankenstein'</span>, <span style="color: #2aa198;">'Shelley'</span>
</pre>
</div>
</li>
</ul>
</li>
<li>在括号这件事情上,即便是懒惰的ruby工程师也觉得做的过火了.所以并没有多少情况
下, 括号是可以被省略的,总结起来,也就如下几种:
<ul class="org-ul">
<li>函数参数只有一个, 而且大家非常熟悉的函数,比如puts
</li>
<li>函数参数没有, 即便大家不熟悉,也可以不使用括号,比如
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">words</span>
  <span style="color: #268bd2;">@content</span>.split
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">is more often used than</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">words</span><span style="color: #2aa198;">()</span>
  <span style="color: #268bd2;">@content</span>.split
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>在条件判断的时候,我们也倾向去不使用括号
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">if</span> words.size &gt; 100
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"The document is not very long"</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">is more often used than</span>

<span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>words.size &gt; 100<span style="color: #2aa198;">)</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"The document is not very long"</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Folding Up Those Lines</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>几行代码写成一行的时候,要使用分号.不过这个规则不常用
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">puts</span> doc.title; <span style="color: #657b83; font-weight: bold;">puts</span> doc.author
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Folding Up THose Code Blocks</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>{} 和 do/end都能处理block, 前者处理单行的, 后者处理多行的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>尽管ruby可以让你少些代码,写短代码,但是"可读性"仍然是最最重要的
<ul class="org-ul">
<li>{}尽快是控制一行的,但是如果这个行太长,还是可以使用do/end替代
<div class="org-src-container">

<pre class="src src-ruby">doc.word.each <span style="color: #2aa198;">{</span>|word| some_really_really_long<span style="color: #b58900;">(</span>with .....<span style="color: #b58900;">)</span><span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>有些时候某个函数还是加上括号比较好,比如instance_of?的参数很长的时候
<div class="org-src-container">

<pre class="src src-ruby">doc.instance_of? <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.class.superclass.class<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">In the Wild</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>学习ruby的一个好的办法是阅读源代码,比如set.rb
</li>
<li>从set.rb的源代码中,我们可以看到,所有的查询是否存在的函数都是以"?"结尾的,这
不是ruby的语法糖, "?"是函数的一个部分
</li>
<li>所有以"!"结尾的函数,也是一样,代表比较危险的函数
</li>
<li>当然,源代码里面也是有很多的漏洞的,比如最常见的就是Float不小心被写成了一个method
而不是一个class.
</li>
<li>当然了很多人认为Float函数情有可原,因为它的返回值是一个Float类型(传入参数是
string)
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 02: Choose the Right Control Structure</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">If, Unless, While, and Until</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>ruby 为了简洁,引入了unless,其作用和if not相同.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">unless</span> <span style="color: #268bd2;">@read_only</span>
  <span style="color: #268bd2;">@title</span> = new_title
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>上面的例子可以理解为, "除非你是read_only的,我们惹不起,否则我们一定要改变当
前的标题内容"
</li>
<li>unless看似是一小步,但是简化了很多的逻辑思考.
</li>
<li>while也像if一样,有个"false的版本",叫做until. 不过我不怎么喜欢用
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Use the Modifier Forms Where Appropriate</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>即便使用了unless, 还是不够简约,我们甚至可以把unless放到后面,形成一个modifier
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #268bd2;">@title</span> = new_title <span style="color: #859900; font-weight: bold;">unless</span> <span style="color: #268bd2;">@read_only</span>
<span style="color: #268bd2;">@title</span> = new_title <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">@writable</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Use each, Not for</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>相比看起来很奇怪的unless, ruby提供的for却很友好, 和python的很像
<div class="org-src-container">

<pre class="src src-ruby">fonts = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'courier'</span>, <span style="color: #2aa198;">'times roman'</span>, <span style="color: #2aa198;">'helvetica'</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">for</span> font <span style="color: #859900; font-weight: bold;">in</span> fonts
  <span style="color: #657b83; font-weight: bold;">puts</span> font
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"courier"                                      #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"times roman"                                  #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"helvetica"                                    #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>但是, 如果你要写的更"ruby"的话,就不要使用for! 主要基于下面两点的原因:
<ul class="org-ul">
<li>for其实在内部就是调用了each, 干嘛不直接使用each
</li>
<li>for其实创建了以新的local的code block(namespace), 不会造成命名冲突
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">A Case of Programming Logic</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>case也有两种表现形式:
<ul class="org-ul">
<li>和传统的语言相似的方法
<div class="org-src-container">

<pre class="src src-ruby">title = <span style="color: #2aa198;">'hello world'</span>

<span style="color: #859900; font-weight: bold;">case</span> title
<span style="color: #859900; font-weight: bold;">when</span> <span style="color: #2aa198;">'War And Peace'</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">'Tolstoy'</span>
<span style="color: #859900; font-weight: bold;">when</span> <span style="color: #2aa198;">'Romeo And Juliet'</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">'Shakespeare'</span>
<span style="color: #859900; font-weight: bold;">else</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Don't know"</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Don't know                                     #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>还可以把case做成一个部分,然后再赋值给一个变量
<div class="org-src-container">

<pre class="src src-ruby">author = <span style="color: #859900; font-weight: bold;">case</span> title
         <span style="color: #859900; font-weight: bold;">when</span> <span style="color: #2aa198;">'War And Peace'</span>
           <span style="color: #2aa198;">'Tolstoy'</span>
         <span style="color: #859900; font-weight: bold;">when</span> <span style="color: #2aa198;">'Romeo And Juliet'</span>
           <span style="color: #2aa198;">'Shakespeare'</span>
         <span style="color: #859900; font-weight: bold;">else</span>
           <span style="color: #2aa198;">"Don't know"</span>
         <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #657b83; font-weight: bold;">puts</span> author

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Don't know                                     #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</li>
<li>上面的第二个例子才是我们"更ruby"的写法.这种把一个"逻辑判断"赋值给一个变量的
做法还可以更进一步的"简化":
<ul class="org-ul">
<li>使用then, 使其变成一行
<div class="org-src-container">

<pre class="src src-ruby">author = <span style="color: #859900; font-weight: bold;">case</span> title
         <span style="color: #859900; font-weight: bold;">when</span> <span style="color: #2aa198;">'War and Peace'</span> <span style="color: #859900; font-weight: bold;">then</span> <span style="color: #2aa198;">'Tolstoy'</span>
         <span style="color: #859900; font-weight: bold;">when</span> <span style="color: #2aa198;">'Romeo And Juliet'</span> <span style="color: #859900; font-weight: bold;">then</span> <span style="color: #2aa198;">'Shake'</span>
         <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #2aa198;">"Don't know"</span>
         <span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">puts</span> author

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Don't know                                     #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>其实我们author如果在title没有已知value的情况下,希望得到第一个nil,而不是一
个"Don't know", 这种情况下,就可以省略else
<div class="org-src-container">

<pre class="src src-ruby">author = <span style="color: #859900; font-weight: bold;">case</span> title
         <span style="color: #859900; font-weight: bold;">when</span> <span style="color: #2aa198;">'War and Pease'</span> <span style="color: #859900; font-weight: bold;">then</span> <span style="color: #2aa198;">'Tolstoy'</span>
         <span style="color: #859900; font-weight: bold;">when</span> <span style="color: #2aa198;">'Romeo And Juliet'</span> <span style="color: #859900; font-weight: bold;">then</span> <span style="color: #2aa198;">'Shakespeare'</span>
         <span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">p</span> author
<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">nil                                            #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</li>
<li>case最为让人值得记住的是
<pre class="example">
case 是使用'==='(三个等号)来进行比对的
</pre>
</li>
<li>=== 有很多用处:
<ul class="org-ul">
<li>class使用===来判断某个object是不是自己的instance
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
<span style="color: #859900; font-weight: bold;">end</span>

doc = <span style="color: #b58900;">Document</span>.new

<span style="color: #859900; font-weight: bold;">case</span> doc
<span style="color: #859900; font-weight: bold;">when</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">" It's a document !"</span>
<span style="color: #859900; font-weight: bold;">when</span> <span style="color: #b58900;">String</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">" It's a string"</span>
<span style="color: #859900; font-weight: bold;">else</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Don't know what it is!"</span>
<span style="color: #859900; font-weight: bold;">end</span>


<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">It's a document !                              #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>正则表达式使用===来判断字符串是否匹配
<div class="org-src-container">

<pre class="src src-ruby">title = <span style="color: #2aa198;">"Remeo and Apple"</span>
<span style="color: #859900; font-weight: bold;">case</span> title
<span style="color: #859900; font-weight: bold;">when</span> <span style="color: #2aa198;">/War And .*/</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">'Maybe Tolstoy?'</span>
<span style="color: #859900; font-weight: bold;">when</span> <span style="color: #2aa198;">/Remeo and .*/</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">'Maybe Shakespeare?'</span>
<span style="color: #859900; font-weight: bold;">else</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">'Absolutely no idea...'</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Maybe Shakespeare?                             #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>Ruby 和其他语言(主要是C)不一样的地方是, 它只把false和nil认为是FALSE, 0都是
是TRUE.所以下面两种情况都是TRUE,要小心
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Sorry Dennis Richie, but 0 is true!"</span> <span style="color: #859900; font-weight: bold;">if</span> 0
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Sorry Dennis Richie, but 'false' is not false"</span> <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">'false'</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Sorry Dennis Richie, but 0 is true!            #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Sorry Dennis Richie, but 'false' is not false  #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>在ruby里面,只有两个事物是false,绝大部分都是true,所以"绝对不要测试事物是否为
TRUE", 这很危险,比如如下的例子中defined?并不是返回true, 而是返回定义的类型
比如("local-variable")
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
<span style="color: #859900; font-weight: bold;">end</span>

doc = <span style="color: #b58900;">Document</span>.new
<span style="color: #657b83; font-weight: bold;">puts</span> flag = <span style="color: #859900; font-weight: bold;">defined?</span><span style="color: #2aa198;">(</span>doc<span style="color: #2aa198;">)</span>

<span style="color: #859900; font-weight: bold;">if</span> flag == <span style="color: #268bd2; font-weight: bold;">true</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"TRUE"</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">local-variable                                 #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>相反的也不要认为只有nil是FALSE, false也会FALSE的,比如IO的输入是遇到nil就退
出,但是你设计一个函数,取得下一个object的函数,就不能处理nil就完了,因为false
也要考虑.所以要"明确"的写出nil
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Broken in a subtle way ...</span>
<span style="color: #859900; font-weight: bold;">while</span> next_object = get_next_object
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Do something with the object</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Should use following version</span>
<span style="color: #859900; font-weight: bold;">until</span> <span style="color: #2aa198;">(</span>next_object = get_next_object<span style="color: #2aa198;">)</span> == <span style="color: #268bd2; font-weight: bold;">nil</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Do something with the object</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">OR following</span>
<span style="color: #859900; font-weight: bold;">until</span> <span style="color: #2aa198;">(</span>next_object = get_next_object<span style="color: #2aa198;">)</span>.nil?
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Do something with the object</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">In the Wild</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>?: 操作符来自c语言,然后非常符合ruby的哲学,所以被吸纳进来了
<div class="org-src-container">

<pre class="src src-ruby">all = <span style="color: #268bd2; font-weight: bold;">nil</span>
file = all ? <span style="color: #2aa198;">'specs'</span> : <span style="color: #2aa198;">'latest_specs'</span>

<span style="color: #657b83; font-weight: bold;">puts</span> file

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">latest_specs                                   #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>ruby更近一步,为"如果这个变量没有被申请过,就申请,否则还是用它原来的值"这种情
况来设计了一个操作符||=
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #268bd2;">@first_name</span> ||= <span style="color: #2aa198;">''</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Actually Equals to</span>

<span style="color: #268bd2;">@first_name</span> = <span style="color: #268bd2;">@first_name</span> || <span style="color: #2aa198;">''</span>
</pre>
</div>
</li>
<li>上面这种用法在first_name是false的情况下就是一个悲剧.所以不要使用||=来初始化
boolean
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 03: Take Advantage of Ruby's Smart Collections</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Literal Shortcuts</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>最常见的literal形式是这样的
<div class="org-src-container">

<pre class="src src-ruby">poem_words = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'twinkle'</span>, <span style="color: #2aa198;">'little'</span>, <span style="color: #2aa198;">'star'</span>, <span style="color: #2aa198;">'how'</span>, <span style="color: #2aa198;">'I'</span>, <span style="color: #2aa198;">'wonder'</span><span style="color: #2aa198;">]</span>
<span style="color: #657b83; font-weight: bold;">p</span> poem_words

<span style="color: #93a1a1;">#######################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;      #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">["twinkle", "little", "star", "how", "I", "wonder"] #</span>
<span style="color: #93a1a1;">#######################################################</span>
</pre>
</div>
</li>
<li>ruby不喜欢写那么多的'', 所以可以简化成
<div class="org-src-container">

<pre class="src src-ruby">poem_words = <span style="color: #2aa198;">%w{twinkle little star ho I wonder}</span>
<span style="color: #657b83; font-weight: bold;">p</span> poem_words

<span style="color: #93a1a1;">######################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;     #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">["twinkle", "little", "star", "ho", "I", "wonder"] #</span>
<span style="color: #93a1a1;">######################################################</span>
</pre>
</div>
</li>
<li>hash 最开始的格式是这样的. 基本上就是把格式严格的书写一遍
<div class="org-src-container">

<pre class="src src-ruby">freq = <span style="color: #2aa198;">{</span><span style="color: #2aa198;">"I"</span> =&gt; 1, <span style="color: #2aa198;">"don't"</span> =&gt; 1, <span style="color: #2aa198;">"like"</span> =&gt; 1, <span style="color: #2aa198;">"spam"</span> =&gt; 963<span style="color: #2aa198;">}</span>
<span style="color: #657b83; font-weight: bold;">p</span> freq

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{"I"=&gt;1, "don't"=&gt;1, "like"=&gt;1, "spam"=&gt;963}   #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>hash在symbol出现以后,就不再推荐使用字符串了,而是使用:sym的symbol作为key,既
能保证唯一,又好书写
<div class="org-src-container">

<pre class="src src-ruby">book_info = <span style="color: #2aa198;">{</span><span style="color: #268bd2; font-weight: bold;">:first_name</span>=&gt; <span style="color: #2aa198;">'Russ'</span>, <span style="color: #268bd2; font-weight: bold;">:last_name</span> =&gt; <span style="color: #2aa198;">'Olsen'</span><span style="color: #2aa198;">}</span>
<span style="color: #657b83; font-weight: bold;">p</span> book_info

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Can be even written like this</span>

book_info = <span style="color: #2aa198;">{</span><span style="color: #268bd2; font-weight: bold;">first_name:</span> <span style="color: #2aa198;">'Russ'</span>, <span style="color: #268bd2; font-weight: bold;">last_name:</span> <span style="color: #2aa198;">'Olsen'</span><span style="color: #2aa198;">}</span>
<span style="color: #657b83; font-weight: bold;">p</span> book_info

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{:first_name=&gt;"Russ", :last_name=&gt;"Olsen"}     #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">{:first_name=&gt;"Russ", :last_name=&gt;"Olsen"}     #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Instant Arrays and Hashes from Method Calls</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>给参数一个默认值,然后使用的时候可以少输入几个参数,没什么奇怪的,这是所有高级语言的特性
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">load_font</span><span style="color: #2aa198;">(</span>name, size = 12<span style="color: #2aa198;">)</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Go font hunting...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>ruby还支持可变参数,就是参数到底是几个不一定. 使用*args作为参数,等到使用的时
候, 真正传入的这些参数就"装进"一个名叫args的数组
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">echo_all</span><span style="color: #2aa198;">(</span>*args<span style="color: #2aa198;">)</span>
  args.each <span style="color: #2aa198;">{</span>|arg| <span style="color: #657b83; font-weight: bold;">p</span> arg<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">end</span>

echo_all<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"hello"</span>, <span style="color: #2aa198;">"world"</span>, <span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"hello"                                        #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"world"                                        #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">false                                          #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>利用ruby可以帮你转换数组这个事实,你可以在设计函数的时候,就加上*, 然后这个参
数在使用的时候,就可以被当做一个数组啦, 传参数的时候又非常的惬意
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">add_authors</span><span style="color: #2aa198;">(</span>*names<span style="color: #2aa198;">)</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Author is "</span> + <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{names.join(' ')}</span><span style="color: #2aa198;">"</span>
<span style="color: #859900; font-weight: bold;">end</span>

add_authors<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Strunk'</span>, <span style="color: #2aa198;">'White'</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Inside of following</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">add_authors_another</span><span style="color: #2aa198;">(</span>names<span style="color: #2aa198;">)</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Author is "</span> + <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{names.join(' ')}</span><span style="color: #2aa198;">"</span>
<span style="color: #859900; font-weight: bold;">end</span>

add_authors_another<span style="color: #2aa198;">(</span><span style="color: #b58900;">[</span><span style="color: #2aa198;">'Strunk'</span>, <span style="color: #2aa198;">'White'</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Author is Strunk White                         #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Author is Strunk White                         #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>*args作为参数,可以放在函数参数的任意位置(从1.9开始才可以,原来是必须放到末尾)
</li>
<li>hash可以作为函数的参数,而且,更重要的是如果hash是函数最后一个参数的话,可以不
写大括号!!非常重要,因为不懂这个规则在很多代码面前都很疑惑
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">load_font</span><span style="color: #2aa198;">(</span>specification_hash<span style="color: #2aa198;">)</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Load a font according to specification_hash[:name] etc.</span>
<span style="color: #859900; font-weight: bold;">end</span>

load_font<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span><span style="color: #268bd2; font-weight: bold;">:name</span> =&gt; <span style="color: #2aa198;">'Times roman'</span>, <span style="color: #268bd2; font-weight: bold;">:size</span>=&gt;12<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Can be repalced with following</span>
load_font<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">:name</span> =&gt; <span style="color: #2aa198;">'Times roman'</span>, <span style="color: #268bd2; font-weight: bold;">:size</span>=&gt;12<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Running Through Your Collection</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>遍历collection可以使用类python的方法,但是还是那句话,只是可以这么写,但是不要
这么写
<div class="org-src-container">

<pre class="src src-ruby">words = <span style="color: #2aa198;">%w{ Mary had a little lamb }</span>

<span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> 0..words.size
  <span style="color: #657b83; font-weight: bold;">puts</span>  words<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Mary                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">had                                            #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">a                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">little                                         #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">lamb                                           #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>要这样写, ruby总是偏爱code block
<div class="org-src-container">

<pre class="src src-ruby">words = <span style="color: #2aa198;">%w{ Mary had a little lamb }</span>

words.each <span style="color: #2aa198;">{</span>|word| <span style="color: #657b83; font-weight: bold;">puts</span> word<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Mary                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">had                                            #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">a                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">little                                         #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">lamb                                           #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>hash也要使用code block的循环方式,因为hash是"key/value的紧密组合", 所以只使
用一个code block变量的话,会打印出数组来.使用两个code block变量就没事了
<div class="org-src-container">

<pre class="src src-ruby">movie = <span style="color: #2aa198;">{</span><span style="color: #268bd2; font-weight: bold;">title:</span> <span style="color: #2aa198;">'2001'</span>, <span style="color: #268bd2; font-weight: bold;">genre:</span> <span style="color: #2aa198;">'sci fi'</span>, <span style="color: #268bd2; font-weight: bold;">rating:</span> 10<span style="color: #2aa198;">}</span>

movie.each <span style="color: #2aa198;">{</span>|entry| <span style="color: #657b83; font-weight: bold;">p</span> entry<span style="color: #2aa198;">}</span>

movie.each <span style="color: #2aa198;">{</span>|name, value| <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{name}</span><span style="color: #2aa198;"> =&gt; </span><span style="color: #268bd2;">#{value}</span><span style="color: #2aa198;">"</span><span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[:title, "2001"]                               #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[:genre, "sci fi"]                             #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[:rating, 10]                                  #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">title =&gt; 2001                                  #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">genre =&gt; sci fi                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">rating =&gt; 10                                   #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>hash和数组背后都有非常强大的API支持,因为ruby只支持这两种collection(这两个
collection稍加更改就能做其他语言里面的stack,heap等).如果你要在collection增
加一些功能的话,查询一些API,可能大部分功能都有了,只需要稍许改变.比如查找某个
word在数组中的位置,如果自己不了解Array API直接写的话
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">index_for</span><span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span>
  i = 0
  words.each <span style="color: #859900; font-weight: bold;">do</span> |this_word|
    <span style="color: #859900; font-weight: bold;">return</span> i <span style="color: #859900; font-weight: bold;">if</span> word == this_word
    i += 1
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>查询过API后,可以发现可以利用find_index的帮助
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">index_for</span><span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span>
  words.find_index <span style="color: #2aa198;">{</span>|this_word| word == this_word<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>前面介绍了each和index_for, 另外两个对于collection至关重要的函数是:
<ul class="org-ul">
<li>map: 也是遍历的方法,但是并不是像index_for一样遍历途中遇到什么情况就返回,
而是保证每个element都遍历,最后把结果都保存下来(这点又和each很像), 比如下
面的例子是求每个单词的长度
<div class="org-src-container">

<pre class="src src-ruby">words = <span style="color: #2aa198;">%w{ I love you China}</span>

<span style="color: #657b83; font-weight: bold;">p</span> words.map <span style="color: #2aa198;">{</span>|word| word.size<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">You can see the all-lowercase version of the words in following way</span>
<span style="color: #657b83; font-weight: bold;">p</span> words.map <span style="color: #2aa198;">{</span>|word| word.downcase<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[1, 4, 3, 5]                                   #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">["i", "love", "you", "china"]                  #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>inject: 也是会像each一样遍历整个数组,但是它总是会在每一步的遍历途中记录两
个值1.累计值2.当前值. inject在运行的时候还要初始化累计值(当然也可以不指定,
那么数组第一个值就是默认值了, 但是第一个例子必须初始化否则初始值是一个字符
串无法加上其他数字).
<div class="org-src-container">

<pre class="src src-ruby">words = <span style="color: #2aa198;">%w{ I love you China}</span>

total = words.inject<span style="color: #2aa198;">(</span>0.0<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>|result, word| word.size + result<span style="color: #2aa198;">}</span>
<span style="color: #657b83; font-weight: bold;">puts</span> total / words.size

connect = words.inject <span style="color: #2aa198;">{</span>|result, word| result + word<span style="color: #2aa198;">}</span>
<span style="color: #657b83; font-weight: bold;">puts</span> connect

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">3.25                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">IloveyouChina                                  #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Beware the Bang!</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>ruby的collection中元素的顺序是可以改变的.而且可以改变的元素顺序的函数大部分
都再最后加上了!.比如:
<ul class="org-ul">
<li>sort是返回一个sorted的数组, sort!是直接把原数组排序
</li>
<li>reverse是返回一个reversed的数组,reverse!是直接把原数组reverse
</li>
</ul>
</li>
<li>!的意思并不是改变,而是危险.所以有些会改变元素但是"不危险"的函数就没有加!了,
比如push, pop, delete等等
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Rely on the Order of Your Hashes</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>array的顺序是固定的这个是所有编程语言的常识
</li>
<li>从ruby1.9开始,ruby的hash也是顺序固定的了,这个很重要.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">In the Wild</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>java中,可能会为每一个它认为特别的数据集合创建一个比如叫做ForSepcialCollection
的类,然后这个类是某个类的子类. 而ruby不这么想,ruby重复的,到处使用其仅有的两
个collection: map和array. 因为ruby认为: 东西越多,越容易混乱.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7">Staying Out</h3>
<div class="outline-text-3" id="text-3-7">
<ul class="org-ul">
<li>collection也有很多的陷阱,比如下面删除负数的例子,由于删除了第一个-10的时候,
吧index搞乱了,最后可能出现的结果就是有的负数没有被删掉
<div class="org-src-container">

<pre class="src src-ruby">array = <span style="color: #2aa198;">[</span>0, -10, -9, 5, 9<span style="color: #2aa198;">]</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Wrong! mess up the internal index</span>
array.each_index <span style="color: #2aa198;">{</span>|i| array.delete_at<span style="color: #b58900;">(</span>i<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">if</span> array<span style="color: #b58900;">[</span>i<span style="color: #b58900;">]</span> &lt; 0<span style="color: #2aa198;">}</span>

<span style="color: #657b83; font-weight: bold;">p</span> array

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[0, -9, 5, 9]                                  #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>其实除了array和hash, ruby还是有set这个数据结构的,只不过不是内置的需要require
一把
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'set'</span>

word_set = <span style="color: #b58900;">Set</span>.new<span style="color: #2aa198;">(</span>words<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 04: Take Advantage of Ruby's Smart Strings</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Coming Up with a String</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>和python一样,ruby支持单引号和双引号两种方法创建字符串. 这种做法的好处是因为
单引号双引号相互之间不是特殊字符,我们可以在需要其中一种时候,在外面包裹另外
一种,比如
<div class="org-src-container">

<pre class="src src-ruby">str = <span style="color: #2aa198;">"\"Stop\", she said, \"I cannot deal with the backslashes.\""</span>
<span style="color: #657b83; font-weight: bold;">puts</span> str

str2 = <span style="color: #2aa198;">'"Stop", she said, "I cannot deal with the backslashes."'</span>
<span style="color: #657b83; font-weight: bold;">puts</span> str2

<span style="color: #93a1a1;">###########################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;          #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"Stop", she said, "I cannot deal with the backslashes." #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"Stop", she said, "I cannot deal with the backslashes." #</span>
<span style="color: #93a1a1;">###########################################################</span>
</pre>
</div>
</li>
<li>如果双引号,单引号,双引号交替三次以上出现,那么就得使用%q了
<div class="org-src-container">

<pre class="src src-ruby">str = <span style="color: #2aa198;">%q{"Stop", she said, "I can't live without 's and "s."}</span>

<span style="color: #657b83; font-weight: bold;">puts</span> str

<span style="color: #93a1a1;">#######################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;      #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"Stop", she said, "I can't live without 's and "s." #</span>
<span style="color: #93a1a1;">#######################################################</span>
</pre>
</div>
</li>

<li>#{}加变量的方法是ruby独有的
<div class="org-src-container">

<pre class="src src-ruby">author = <span style="color: #2aa198;">"Ben Bova"</span>
title = <span style="color: #2aa198;">"Mars"</span>
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{title}</span><span style="color: #2aa198;"> is written by </span><span style="color: #268bd2;">#{author}</span><span style="color: #2aa198;">"</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Mars is written by Ben Bova                    #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>还有和python""""""对应的多行输入.注意大写字母是任意的,只要对称就可以
<div class="org-src-container">

<pre class="src src-ruby">heres_one = <span style="color: #2aa198;">&lt;&lt;EOF</span>
<span style="color: #2aa198;">This is the beginning of my here document.</span>
<span style="color: #2aa198;">And this is the end.</span>
<span style="color: #2aa198;">EOF</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Another API to Master</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>String系列API是我们必须要掌握的:
<ul class="org-ul">
<li>lstrip, rstrip是去除左右空格的
</li>
<li>chomp去掉尾部的一个换行(如果有三个剩下两个,如果一个没有,就不去)
</li>
<li>chop去掉尾部一个char,不管是什么
</li>
<li>把字符串和数组完美结合的是split, 参数会显示依靠"什么"来分割这些字符串
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #2aa198;">'It was a dark and stormy night'</span>.split
<span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #2aa198;">'Bill:Shakespeare:Playwright:Globe'</span>.split<span style="color: #2aa198;">(</span> <span style="color: #2aa198;">':'</span> <span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">########################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;       #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">["It", "was", "a", "dark", "and", "stormy", "night"] #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">["Bill", "Shakespeare", "Playwright", "Globe"]       #</span>
<span style="color: #93a1a1;">########################################################</span>
</pre>
</div>
</li>
<li>index函数是寻找某个字符串在原字符串的位置
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">The String: A Place for Your Lines, Characters, and Bytes</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>array的话,因为在定义的时候就有分割,所以很容易使用each来"个个"输出, 而string
在ruby里面是没有明显的输出的.换句话说,你可以使用多种方法来"分割"他们:
<ul class="org-ul">
<li>by char: 这个是和c语言一样了
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #2aa198;">"Clarke"</span>.each_char <span style="color: #2aa198;">{</span>|c| <span style="color: #657b83; font-weight: bold;">puts</span> c<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">C                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">l                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">a                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">r                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">k                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">e                                              #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>by byte: 每个char其实也是一个byte
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #2aa198;">"Clarke"</span>.each_byte <span style="color: #2aa198;">{</span>|b| <span style="color: #657b83; font-weight: bold;">puts</span> b<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">67                                             #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">108                                            #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">97                                             #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">114                                            #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">107                                            #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">101                                            #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>by line: 这个很好理解,就是通过newline来区分
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">In the Wild</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>ruby的很多操作都是针对字符串的,所以字符串的理解无比重要
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>Ruby字符串是mutable的,这个是跟Java完全相反的!
</li>
<li>Ruby的字符串也是class,也分ref和object,所以下面的两个字符串其实是一个
<div class="org-src-container">

<pre class="src src-ruby">first_name = <span style="color: #2aa198;">'Karen'</span>
given_name = first_name

<span style="color: #657b83; font-weight: bold;">p</span> first_name
<span style="color: #657b83; font-weight: bold;">p</span> given_name

first_name<span style="color: #2aa198;">[</span>0<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">'D'</span>

<span style="color: #657b83; font-weight: bold;">p</span> first_name
<span style="color: #657b83; font-weight: bold;">p</span> given_name

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"Karen"                                        #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"Karen"                                        #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"Daren"                                        #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"Daren"                                        #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>所以把ruby看成是和collection一样的,可更改的数据集合.因为是可更改的,所以是可
以被赋值的. 赋值的用法也更为便于阅读和理解
<div class="org-src-container">

<pre class="src src-ruby">first_name = first_name.upcase

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Instead of</span>
first_name.upcase!
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 05: Find the Right String with Regular Expressions</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Matching One Character at a Time</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>正则表达式里面对应一个字符的情况有两种:
<ul class="org-ul">
<li>字符和数字是简单的"和自己"一对一的关系(大小写区分)
</li>
<li>regular expression中的标点符号就不是和自己的字符对应了,但是有些还是对应一
个比如"."就是对应一个任意的字符:
<ol class="org-ol">
<li>. 对应r,或%,或~
</li>
<li>..对应xx,或者4F,或者[!
</li>
<li>\.对应.
</li>
<li>3\.14对应3.14
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Sets, Ranges, and Alternatives</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>除了这种"一一对应"的单挑用法,还有一种"多对一"的用法,就是一堆的字符最终只为
匹配一个字符.好比"三英战吕布", 这"三英"分别是:
<ul class="org-ul">
<li>Sets: 就是括号里面写上所有的可能项目,都是一一列举:
<ol class="org-ol">
<li>[ 0123456789 ]对应一个单个字母
</li>
<li>[Rr]会对应r或者R
</li>
<li>[aApP][mM]会对应am, aM, pM, PM等8种写法
</li>
</ol>
</li>
<li>Range: Sets因为要一一列举有些繁琐,适合Rr这种情况较少的, Range就是可以把情
况一股脑的全部列出:
<ol class="org-ol">
<li>[0-9abcdef]会对应单个的十六进制数字
</li>
<li>[a-z]会对应全部的小写字母
</li>
<li>转移字符是一种"\"加一个字母来替代一个复杂的range的做法.所以不再需要[]
了.比如\d 对应所有的digit, \d\d对应00到99. \w对应所有的字符. \s对应所
有的空格,包括tab, newline
</li>
</ol>
</li>
<li>Alternatives: range的特点是太宽泛,有时候没有这么宽泛的对应,比如我只支持AM和PM,
但是因为是两个字母,sets又没办法实现.所以就设计了"Set的多字母版本,窄对应"
版本Alternatives:
<ol class="org-ol">
<li>AM|PM就对应AM或者PM
</li>
<li>The (cat|boat) is red 就对应 The cat is red 或者 The boat is red
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">The Regular Expression Star</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>star的定义值得深思,其需要*前面的字母配合
<pre class="example">
In regular expressions, an asterisk (*) matcches zero or more of the
thing that came just before it
</pre>
</li>
<li>所以*可以说是"双对多":
<ul class="org-ul">
<li>AB* 可以对应哪个AB
</li>
<li>AB* 可以对应哪个ABBBBBBBBBBBBB
</li>
<li>AB* 还可以对应A
</li>
</ul>
</li>
<li>star强大的"两对多"功能还可以跟其他的"多或者一对一"的正则表达式进行合作:
<ul class="org-ul">
<li>和Set合作,那么[aeiou]*就对应任意多个元音的组合, [0-9]*就对应多个数字的组合
</li>
<li>和.合作.也就是.*: 这个正则表达式世界里面最最常用的式子.因为它可以对应
anything!, 当然了对应anything是没有意义的,把".*"和其他字符串对应会起到非
常好的作用:
<ul class="org-ul">
<li>George.* 会对应所有以George开头的字符串
</li>
<li>.*George 会对应所有以George结尾的字符串
</li>
<li>.*George.*会对应所有含有George的字符串
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Regular Expressions in Ruby</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>在ruby中,regular express收到非常高的礼遇,其就是一种内置的数据类型.其特点是
被"/"包裹, 下面就是一个Regexp的例子
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #2aa198;">/\d\d:\d\d (AM|PM)/</span>
</pre>
</div>
</li>
<li>Regexp的匹配也有自己的操作符就是=~, 其返回值为匹配位置,如果完全无法匹配返回
nil, 而且=~ 和 == 一样是不分左右的, Regexp放在左边或者右边都没有关系
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #2aa198;">'10:24 PM'</span> =~ <span style="color: #2aa198;">/\d\d:\d\d (AM|PM)/</span>

<span style="color: #657b83; font-weight: bold;">p</span> /\d\d:\d\d <span style="color: #2aa198;">(</span><span style="color: #b58900;">AM</span>|<span style="color: #b58900;">PM</span><span style="color: #2aa198;">)</span>/ =~ <span style="color: #2aa198;">'10:24 PM'</span>

<span style="color: #657b83; font-weight: bold;">p</span> /<span style="color: #b58900;">PM</span>/ =~ <span style="color: #2aa198;">'10:24 PM'</span>

<span style="color: #657b83; font-weight: bold;">p</span> /<span style="color: #b58900;">May</span>/ =~ <span style="color: #2aa198;">'Something in June'</span>


<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">0                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">0                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">6                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">nil                                            #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>Regexp是case sensitive的,但是你可以在Regexp的最后加上i来表示其忽略大小写
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"It matches!"</span> <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">/AM/</span><span style="color: #268bd2;">i</span> =~ <span style="color: #2aa198;">'am'</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">It matches!                                    #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>Regexp还能发挥查找的作用,在String的gsub函数里面可以发挥它的作用
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">obscure_times!</span>
  <span style="color: #268bd2;">@content</span>.gsub!<span style="color: #2aa198;">(</span><span style="color: #2aa198;">/\d\d:\d\d (AM|PM)/</span>, <span style="color: #2aa198;">'**:** **'</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Beginnings and Endings</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li>前面的Regexp没有对开始匹配的位置进行要求,一个字符串如果能从中间匹配也是可以
的, 如果要求必须要从开头匹配,那么就要使用\A
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #2aa198;">/\AOnce upon a time/</span>
</pre>
</div>
</li>
<li>反之如果想字符串必须匹配最后的字符,那么必须使用\z
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #2aa198;">/and they all lived happily ever after\z/</span>
</pre>
</div>
</li>
<li>更高深的是,如果我不是从文章开头,而是一段文章的某一行的开头,或结尾,那么我们
就要使用^和$. 这个是和Vim的操作对待行时候的字符操作是一样的
<div class="org-src-container">

<pre class="src src-ruby">content = <span style="color: #2aa198;">'The Princess And the Monkey</span>

<span style="color: #2aa198;">Once upon a time there was a princess...</span>
<span style="color: #2aa198;">... and they all lived happily ever after.</span>
<span style="color: #2aa198;">The End'</span>

<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Found the beginning"</span> <span style="color: #859900; font-weight: bold;">if</span> content =~ <span style="color: #2aa198;">/^Once upon a time/</span>
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Found the ending"</span> <span style="color: #859900; font-weight: bold;">if</span> content =~ <span style="color: #2aa198;">/happily ever after\.$/</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Found the beginning                            #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Found the ending                               #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>做过我们像来个全文匹配,中间不知道的地方使用万能的.*来替代的话,会发现有问题,
因为.*默认屏蔽了多行匹配,加上参数m, 代表multiple(就像i是ignore一样), 就可以
跨行匹配了
<div class="org-src-container">

<pre class="src src-ruby">content = <span style="color: #2aa198;">'The Princess And the Monkey</span>

<span style="color: #2aa198;">Once upon a time there was a princess...</span>
<span style="color: #2aa198;">... and they all lived happily ever after.</span>
<span style="color: #2aa198;">The End'</span>

<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Found the whole"</span> <span style="color: #859900; font-weight: bold;">if</span> content =~ <span style="color: #2aa198;">/^Once upon a time.*happily ever after\.$/</span><span style="color: #268bd2;">m</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Found the whole                                #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6">In the Wild</h3>
<div class="outline-text-3" id="text-5-6">
<ul class="org-ul">
<li>ruby 源代码里面有很多处使用Regexp的例子,比如测试zone是否符合某个字符串格式
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">/\A([+-])(\d\d):?(\d\d)\z/</span> =~ zone
</pre>
</div>
</li>
<li>这里的:?的意思是"零个或者1个:", ?和*有相似的功能,不过其能力只能到1,无法到无穷
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-5-7">
<ul class="org-ul">
<li>ruby在Regexp上面最容易犯的错误有两种:
<ul class="org-ul">
<li>使用==, 而不是=~来判断是否匹配
</li>
<li>匹配成功返回的结果是开始匹配的位置,所以0也是成功,而且是非常成功. nil才表
示匹配不成功.
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Chapter 06: Use Symbols to Stand for Something</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">The Two Faces of Strings</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>symbol是ruby的一种创造. 一个symbol很容易被看成是一个stirng. 比如在rails的代
码中, 想要取得所有的记录的方法如下
<div class="org-src-container">

<pre class="src src-ruby">book = <span style="color: #b58900;">Book</span>.find<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">:all</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>其实我们也可以使用字符串.没有太大的区别
<div class="org-src-container">

<pre class="src src-ruby">book = <span style="color: #b58900;">Book</span>.find<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'all'</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>ruby提供symbol必有其其他目的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">Not Quite a String</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>其实symobl的使用更类似于其他语言的枚举类型(enum), 是一个符号,计算机无所谓什
么类型,但是人类希望他更容易"标示", 但不要是String. 因为String还有传达数据的
作用.不要和"标示"相互混淆
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">Optimized to Stand for Something</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>既然是"标示"作用,那么symbol的一大特点就是唯一性.无论在哪里,你写下了:all那么
就是相等的.被:all赋值的数据无论用什么方法比较都是相等的
<div class="org-src-container">

<pre class="src src-ruby">a = <span style="color: #268bd2; font-weight: bold;">:all</span>
c = <span style="color: #268bd2; font-weight: bold;">:all</span>

<span style="color: #657b83; font-weight: bold;">puts</span> a == c
<span style="color: #657b83; font-weight: bold;">puts</span> a === c
<span style="color: #657b83; font-weight: bold;">puts</span> a.eql?<span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">puts</span> a.equal?<span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">true                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">true                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">true                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">true                                           #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>如果是字符串的话,就不一定了
<div class="org-src-container">

<pre class="src src-ruby">a = <span style="color: #2aa198;">"all"</span>
c = <span style="color: #2aa198;">"all"</span>

<span style="color: #657b83; font-weight: bold;">puts</span> a == c
<span style="color: #657b83; font-weight: bold;">puts</span> a === c
<span style="color: #657b83; font-weight: bold;">puts</span> a.eql?<span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">puts</span> a.equal?<span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">true                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">true                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">true                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">false                                          #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>symbol的另外一大好处是其为immutable的,一旦创建,不会改变!所以非常适合做hash
的key. 实际的情况是hash即便是接受了"字符串"作为hash的key,其内部也会拷贝一份
的. 字符串的传入在创建hash的时刻就确定了.不会因为原来字符串改变而改变.
<div class="org-src-container">

<pre class="src src-ruby">author = <span style="color: #2aa198;">"abc"</span>
title = <span style="color: #2aa198;">"xyz"</span>
hash = <span style="color: #2aa198;">{</span>author=&gt;title<span style="color: #2aa198;">}</span>
author.upcase!
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"hash[author] is </span><span style="color: #268bd2;">#{hash[author]}</span><span style="color: #2aa198;">"</span>
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"hash[author.downcase] is </span><span style="color: #268bd2;">#{hash[author.downcase]}</span><span style="color: #2aa198;">"</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">hash[author] is                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">hash[author.downcase] is xyz                   #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">In the Wild</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>在ruby中,symbol和stirng可以相互之间轻易转换.
<div class="org-src-container">

<pre class="src src-ruby">the_string = <span style="color: #268bd2; font-weight: bold;">:all</span>.to_s
the_symbol = <span style="color: #2aa198;">"all"</span>.to_sym

<span style="color: #657b83; font-weight: bold;">p</span> the_string
<span style="color: #657b83; font-weight: bold;">p</span> the_symbol

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">"all"                                          #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">:all                                           #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>1.9以前的ruby在public_methods的返回值上面犯了个错误,其会返回字符串数组, 但
是函数名是一个class的某些"标示", 其实应该是symbol的,所以在1.9中,这个错误被
更改过来了
<div class="org-src-container">

<pre class="src src-ruby">x = <span style="color: #b58900;">Object</span>.new
<span style="color: #657b83; font-weight: bold;">p</span> x.public_methods

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[:nil?, :===, :=~, :!~, :eql?, :hash, :&lt;=&gt;,    #</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">...]                                          #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-6-5">
<ul class="org-ul">
<li>对于symbol来说,最容易出错的地方,是一定要记住hash一定要使用symbol来作为key,
在使用的时候也要回去看看到底自己是不是用了symbol. 如果设置的时候使用了symbol
的话,使用的时候使用字符串肯定是不行的
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Chapter 07: Treat Everything Like an Object &#x2013; Because Everything Is</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">A Quick Review of Clases, Instances, and Methods</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>对于ruby来说, class就意味着两件事情:
<ul class="org-ul">
<li>class首先是method的容器
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">words</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>class其次是创建instance的工厂
<div class="org-src-container">

<pre class="src src-ruby">doc = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Ethics"</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>ruby和python一样都有self这个概念,但是ruby里面你不需要再"明确的"写出一个self
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">Objects All the Way Down</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>在ruby中,绝大多数你看到的东西都是object,连数字和true false都是, 甚至nil都是
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">puts</span> -3.class
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #268bd2; font-weight: bold;">true</span>.class
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #268bd2; font-weight: bold;">false</span>.class
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #268bd2; font-weight: bold;">nil</span>.class

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Fixnum                                         #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">TrueClass                                      #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">FalseClass                                     #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">NilClass                                       #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">The Importance of Being an Object</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>基本上所有的object都是Object的子类,所以可以使用Object提供的一大票的函数:
<ul class="org-ul">
<li>class: 查询父类名称
</li>
<li>instance_of?: 查询是否是某个class的instance
</li>
<li>to_s: 转化为字符串
</li>
</ul>
</li>
<li>Object的很多函数,其实是存在于Kernel module,然后mixed into到Object里面的
</li>
<li>Object还有很多奇异的函数:
<ul class="org-ul">
<li>eval: 接受一个字符串,这个字符串会被看成是ruby代码. (这个eval的名字估计来
自elisp), 在eval的帮助下,你可以快速实现一个irb
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2; font-weight: bold;">true</span>
  <span style="color: #657b83; font-weight: bold;">print</span> <span style="color: #2aa198;">"Cmd&gt;"</span>
  cmd = gets
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">eval</span><span style="color: #b58900;">(</span>cmd<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">bash-3.2$ ruby eval_irb.rb                     #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Cmd&gt;2 + 2                                      #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">4                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Cmd&gt;puts "hello world"                         #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">hello world                                    #</span>
<span style="color: #93a1a1;">#                                                </span><span style="color: #93a1a1;">#</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Cmd&gt;                                           #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>public_methods: 列出所有类的成员函数
</li>
<li>instance_variables: 列出所有的成员变量
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4">Public, Private, and Protected</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li>和其他语言一样,ruby也有三种访问模式:
<ul class="org-ul">
<li>public: 所有人都能看到
</li>
<li>protected: 只有自己的继承序列能看到
</li>
<li>private: 和其他语言理解的有所不同, ruby的private函数是无法使用instance调
用而已,在class内部当然不需要instance调用就使用.同样的在subclass内部,也可
以不使用instance就使用函数,所以,也是可以调用的.
</li>
</ul>
</li>
<li>在ruby里面,所有的private,其实只是"君子协定",你完全可以使用其他方法来规避,比
如Object里面提供的send函数
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">private</span> <span style="color: #268bd2; font-weight: bold;">:word_count</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">word_count</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"word count"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

doc = <span style="color: #b58900;">Document</span>.new

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">doc.send(:word_count)</span>
doc.word_count
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5">In the Wild</h3>
<div class="outline-text-3" id="text-7-5">
<ul class="org-ul">
<li>在ruby中,如下情况在内部确实不是通过函数实现的:
<ul class="org-ul">
<li>给一个变量赋值
</li>
<li>if 判断
</li>
<li>while 判断
</li>
</ul>
</li>
<li>但是确实是有些情况是函数实现的,虽然表面上看不出来
<ul class="org-ul">
<li>private, public, protected的实现也是通过函数
</li>
<li>require其实也是一种函数: 读取某个文件的内容,然后把它的内容当做ruby代码来
进行执行
</li>
<li>attr_accessor也是函数
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-7-6">
<ul class="org-ul">
<li>Object带来了50个"一出生就能使用的函数", 代价是有50次name collision的机会,所
以对Object的所有成员都了解是非常必要的
</li>
<li>出错机会小的一种办法是少些代码:你从来没写过的代码会一直正常运行!
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Chapter 08: Embrace Dynamic Typing</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Shorter Programs, But Not the Way You Think</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>动态语言的短小精悍绝不是来自于少些了几个int或者string,而是:
来自于不再需要书写类似java中的bstract class, 或者interface(在java中
abstract class是一种不纯粹的interface). 在ruby中,我们并不严格的要求某个object
必须是什么类型的,是其他类型就不对,我们只要求它有"足够用的method"就可以了
<pre class="example">
Duck typing: If an object has the right methods, then it is the right kind of object
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">Extreme Decoupling</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>短小精悍不是动态语言的唯一优点
</li>
<li>前面我们设计过Document类,它有string类型的title和author
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:title</span>, <span style="color: #268bd2; font-weight: bold;">:author</span>, <span style="color: #268bd2; font-weight: bold;">:content</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>title, author, content<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@title</span> = title
    <span style="color: #268bd2;">@author</span> = author
    <span style="color: #268bd2;">@content</span> = content
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>现在我们有了下面两个新的类来代表"题目"和"作者", 然后你会要求Document也要支持
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Title</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:long_nam</span>, <span style="color: #268bd2; font-weight: bold;">:short_name</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:isbn</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>long_name, short_name, isbn<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@long_name</span> = long_name
    <span style="color: #268bd2;">@short_name</span> = short_name
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Author</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:first_name</span>, <span style="color: #268bd2; font-weight: bold;">:last_name</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>first_name, last_name<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@first_name</span> = first_name
    <span style="color: #268bd2;">@last_name</span> = last_name
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>然后你发现,你"不需要写任何代码!", Document已经支持两个新的类型了!这就是动态
语言厉害的另外的地方:非常松的耦合!
<div class="org-src-container">

<pre class="src src-ruby">two_cities = <span style="color: #b58900;">Title</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'A Tale of Two Cities'</span>,
                       <span style="color: #2aa198;">'2 Cities'</span>, <span style="color: #2aa198;">'0-999-9999-9'</span><span style="color: #2aa198;">)</span>
dickens = <span style="color: #b58900;">Author</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Charles'</span>, <span style="color: #2aa198;">'Dickens'</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">##############################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">now Document works!                        #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">previously Document may be written like    #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">doc = Document.new("A Tale of Two Cities", #</span>
<span style="color: #93a1a1;">#                    </span><span style="color: #93a1a1;">"Charles Dickens"       #</span>
<span style="color: #93a1a1;">#                    </span><span style="color: #93a1a1;">'It was the best...')   #</span>
<span style="color: #93a1a1;">##############################################</span>

doc = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span>two_cities, dickens, <span style="color: #2aa198;">'It was the best...'</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>这种松耦合是动态语言的特质,千万不要像下面的例子一样,再去判断输入是否是stirng,
因为这样写有一天不是string了,我们就不能能用了
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>title, author, content<span style="color: #2aa198;">)</span>
  <span style="color: #657b83; font-weight: bold;">raise</span> <span style="color: #2aa198;">"Title isn't a String"</span> <span style="color: #859900; font-weight: bold;">unless</span> title.kind_of? <span style="color: #b58900;">String</span>
  <span style="color: #657b83; font-weight: bold;">raise</span> <span style="color: #2aa198;">"Author isn't a String"</span> <span style="color: #859900; font-weight: bold;">unless</span> title.kind_of? <span style="color: #b58900;">String</span>
  <span style="color: #657b83; font-weight: bold;">raise</span> <span style="color: #2aa198;">"Content isn't a String"</span> <span style="color: #859900; font-weight: bold;">unless</span> content.kind_of? <span style="color: #b58900;">String</span>
  <span style="color: #268bd2;">@title</span> = title
  <span style="color: #268bd2;">@author</span> = author
  <span style="color: #268bd2;">@content</span> = content
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">Required Ceremony Versus Programmer-Driven Clarity</h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li>动态语言和传统高级语言的不同在于:
<ul class="org-ul">
<li>传统高级语言是依靠编译器来强制指定类型:这是有好处的,因为声明为int类型的参
数如果在使用的时候给了一个string类型的输入,编译器就会警告你
</li>
<li>在动态语言里面, 对类型的判断的任务交给了程序员,你要书写更清晰的变量名,更
清晰的注释来让麻烦变得尽可能的少
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li>ruby中,我们最常见到的错误就是和类型相关的,比如你"认为"一个object是Title类型
的,所以你调用了Title的函数long_name, 结果却得到了如下的错误提示(因为其实你
提供的不是Title类型,而是String类型)
<div class="org-src-container">

<pre class="src src-sh">NoMethodError: undefined method <span style="color: #6c71c4; font-weight: bold;">`long_name`</span> <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">"TwoCities"</span>:String
</pre>
</div>
</li>
<li>ruby不回避这种问题的存在,应对的方法是两个:
<ul class="org-ul">
<li>书写更加简洁清新的代码
</li>
<li>高质量全覆盖的测试用例
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5">In the Wild</h3>
<div class="outline-text-3" id="text-8-5">
<ul class="org-ul">
<li>ruby的设计不是像java那样,有森严的类之间的继承体系,可以多多的重用代码.在ruby
里面,更多的是从实用的角度上来设计,并且尽可能的"疏远类之间的关系",比如下面代码
中的open_file和open_string, 他们有着几乎一致的api,比如seek, readline等等,但
是他俩第一个共同的祖先竟然是Object(也就是说他们没有什么重用代码,都是自己各
搞了一份). 从这里看,ruby的实用哲学一览无余
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Chapter 09: Write Specs!</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">Test::Unit: When Your Documents Just Have to Work</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>Test::Unit是Xunit系列在ruby的代言, 其他语言的代言有Junit, cppUnit等等
</li>
<li>Test::Unit的使用也和其他XUnit差不多.下面是一个例子
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DocumentTest</span> &lt; <span style="color: #b58900;">Test</span>::<span style="color: #b58900;">Unit</span>::<span style="color: #b58900;">TestCase</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">setup</span>
    <span style="color: #268bd2;">@text</span> = <span style="color: #2aa198;">'A Bunch of words'</span>
    <span style="color: #268bd2;">@doc</span> = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'test'</span>, <span style="color: #2aa198;">'nobody'</span>, <span style="color: #268bd2;">@test</span><span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">test_that_docment_holds_onto_contents</span>
    assert_equal <span style="color: #268bd2;">@text</span>, <span style="color: #268bd2;">@doc</span>.content, <span style="color: #2aa198;">'Contents are still there'</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">test_that_word_count_is_correct</span>
    assert_equal 4, <span style="color: #268bd2;">@doc</span>.word_count, <span style="color: #2aa198;">'Word count is correct'</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">A Plethora of Assertions</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li>assert当然有很多其他情况,比如:
<ul class="org-ul">
<li>assert_not_equal
</li>
<li>assert_nil
</li>
<li>assert_not_nil
</li>
<li>assert_match: 能够判断字符串是否符合正则表达式
<div class="org-src-container">

<pre class="src src-ruby">assert_match <span style="color: #2aa198;">/times.*/</span>, <span style="color: #2aa198;">'times new roman'</span>
</pre>
</div>
</li>
<li>assert_instance_of
<div class="org-src-container">

<pre class="src src-ruby">assert_instance_of <span style="color: #b58900;">String</span>, <span style="color: #2aa198;">'hello'</span>
</pre>
</div>
</li>
<li>assert_raise: 抛出异常
<div class="org-src-container">

<pre class="src src-ruby">assert_raise <span style="color: #b58900;">ZeroDivisionError</span> <span style="color: #859900; font-weight: bold;">do</span>
  x = 1 / 0
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>assert_nothing_thrown: 不抛出异常
<div class="org-src-container">

<pre class="src src-ruby">assert_nothing_thrown <span style="color: #859900; font-weight: bold;">do</span>
  x = 1 / 2
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">Don't Test Il, Spec It!</h3>
<div class="outline-text-3" id="text-9-3">
<ul class="org-ul">
<li>随着时代的发展, Test::Unit不再那么适应时代(或者更确切的说是适应ruby,因为其
他Xunit还是活的风生水起). Ruby社区诞生了Rspec
</li>
<li>Rspec更像是一个specification,而不是unit test,我们来看一段Rspec代码
<div class="org-src-container">

<pre class="src src-ruby">describe <span style="color: #b58900;">Document</span> <span style="color: #859900; font-weight: bold;">do</span>
  it <span style="color: #2aa198;">'should hold on to the contents'</span> <span style="color: #859900; font-weight: bold;">do</span>
    text = <span style="color: #2aa198;">'A bunch of words'</span>
    doc = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'test'</span>, <span style="color: #2aa198;">'nobody'</span>, text<span style="color: #2aa198;">)</span>
    doc.content.should == text
  <span style="color: #859900; font-weight: bold;">end</span>

  it <span style="color: #2aa198;">'should return all of the words in the document'</span> <span style="color: #859900; font-weight: bold;">do</span>
    text = <span style="color: #2aa198;">'A bunch of words'</span>
    doc = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'test'</span>, <span style="color: #2aa198;">'nobody'</span>, text<span style="color: #2aa198;">)</span>
    doc.words.include?<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'A'</span><span style="color: #2aa198;">)</span>.should == <span style="color: #268bd2; font-weight: bold;">true</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>Rspec的特点就是包含大量的should,它不再使用生硬的assert,使用更柔和的should
</li>
<li>Rspec和每个rb文件对应Document.rb的spec文件就是Document_spec.rb
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-4" class="outline-3">
<h3 id="sec-9-4">A Tidy Spec Is a Readable Spec</h3>
<div class="outline-text-3" id="text-9-4">
<ul class="org-ul">
<li>Rspec也要解决DIY的问题,Rspec的setup叫做before, Rspec的teardown叫做after
<div class="org-src-container">

<pre class="src src-ruby">describe <span style="color: #b58900;">Document</span> <span style="color: #859900; font-weight: bold;">do</span>
  before <span style="color: #268bd2; font-weight: bold;">:each</span> <span style="color: #859900; font-weight: bold;">do</span>
    <span style="color: #268bd2;">@text</span> = <span style="color: #2aa198;">'A bunch of words'</span>
    <span style="color: #268bd2;">@doc</span> = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'test'</span>, <span style="color: #2aa198;">'nobody'</span>, <span style="color: #268bd2;">@text</span><span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Chapter 10: Construct Your Classes from Short, Focused Methods</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>Ruby设计函数的原则和Unix一样:
<pre class="example">
short methods that stick to doing one thing and doing it well
</pre>
</li>
</ul>
</div>
<div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">Compressing Specifications</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>讲解函数设计的技巧就必须得通过例子,下面是一个压缩字符串的例子.一个字符串被
输入后会被分解成两个array, 一个array放所有出现过的单词(多次出现只写一次,更
像是一个set).另外一个array保存单词出现的位置,一个新学ruby的人会马上堆出如下
代码
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">TextCompressor</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:unique</span>, <span style="color: #268bd2; font-weight: bold;">:index</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>text<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@unique</span> = <span style="color: #2aa198;">[]</span>
    <span style="color: #268bd2;">@index</span> = <span style="color: #2aa198;">[]</span>

    words = text.split
    words.each <span style="color: #859900; font-weight: bold;">do</span> |word|
      i = <span style="color: #268bd2;">@unique</span>.index<span style="color: #2aa198;">(</span> word <span style="color: #2aa198;">)</span>
      <span style="color: #859900; font-weight: bold;">if</span> i
        <span style="color: #268bd2;">@index</span> &lt;&lt; i
      <span style="color: #859900; font-weight: bold;">else</span>
        <span style="color: #268bd2;">@unique</span> &lt;&lt; word
        <span style="color: #268bd2;">@index</span> &lt;, unique.size - 1
      <span style="color: #859900; font-weight: bold;">end</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

text = <span style="color: #2aa198;">"This specification is the spec for a specification"</span>
compressor = <span style="color: #b58900;">TextCompressor</span>.new<span style="color: #2aa198;">(</span>text<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>这个版本只能说差强人意,我们试着改编一下,让它看起来更加的清晰
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">TextCompressor</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:unique</span>, <span style="color: #268bd2; font-weight: bold;">:index</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>text<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@unique</span> = <span style="color: #2aa198;">[]</span>
    <span style="color: #268bd2;">@index</span> = <span style="color: #2aa198;">[]</span>

    words = text.split
    words.each <span style="color: #859900; font-weight: bold;">do</span> |word|
      i = unique_index_of<span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span>
      <span style="color: #859900; font-weight: bold;">if</span> i
        <span style="color: #268bd2;">@index</span> &lt;&lt; i
      <span style="color: #859900; font-weight: bold;">else</span>
        <span style="color: #268bd2;">@index</span> &lt;, add_unique_word<span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span>
      <span style="color: #859900; font-weight: bold;">end</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">unique_index_of</span><span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@unique</span>.index<span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">add_unique_word</span><span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@unique</span> &lt;&lt; word
    unique.size - 1
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>这个版本已经进步很大了,我们把繁琐的"加入array"的代码写成了method放在别的地
方,减轻了我们阅读initialize函数的负担,但是initialize依然看起来十分的臃肿
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">TextCompressor</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:unique</span>, <span style="color: #268bd2; font-weight: bold;">:index</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initiaize</span><span style="color: #2aa198;">(</span>text<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@unique</span> = <span style="color: #2aa198;">[]</span>
    <span style="color: #268bd2;">@index</span> = <span style="color: #2aa198;">[]</span>
    add_text<span style="color: #2aa198;">(</span>text<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">add_text</span><span style="color: #2aa198;">(</span>text<span style="color: #2aa198;">)</span>
    words = text.split
    words.each <span style="color: #2aa198;">{</span>|word| add_word<span style="color: #b58900;">(</span>word<span style="color: #b58900;">)</span><span style="color: #2aa198;">}</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">add_word</span><span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span>
    i = unique_index_of<span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span> || add_unique_word<span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@index</span> &lt;&lt; i
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">unique_index_of</span><span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@unique</span>.index<span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">add_unique_word</span><span style="color: #2aa198;">(</span>word<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@unique</span> &lt;&lt; word
    unique.size  - 1
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>这个版本才是真正的ruby的写法, initialize清晰,每个函数都很简短.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2">Composing Methods for Humans</h3>
<div class="outline-text-3" id="text-10-2">
<ul class="org-ul">
<li>我们上面对TextCompressor类的改编在学术上叫做"Composed method"技法,其核心是
将函数分解成满足如下三个条件的函数:
<ul class="org-ul">
<li>每个函数只做一件事情,这样既易于书写,又易于理解
</li>
<li>每个函数只处理一个level的概念
</li>
<li>每个函数短到它的名字就可以概括它的作用
</li>
</ul>
</li>
<li>书写简短,名字非常容易理解的函数的意义,不是为了computer着想,而是为了你.为了
你能更好的处理细节
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3">Composing Ruby Methods</h3>
<div class="outline-text-3" id="text-10-3">
<ul class="org-ul">
<li>ruby创建method的代价很小,而且小的函数为你提供了更多的"插口",也更容易的书写
测试用例
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-4" class="outline-3">
<h3 id="sec-10-4">One Way Out?</h3>
<div class="outline-text-3" id="text-10-4">
<ul class="org-ul">
<li>Ruby设计了一种最后一行不用说就是返回值的做法,这不是偶然的. 先看一个新手的ruby
代码例子
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">prose_rating</span>
    <span style="color: #859900; font-weight: bold;">if</span> pretentious_density &gt; 0.3
      <span style="color: #859900; font-weight: bold;">if</span> informal_density &lt; 0.2
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">:really_pretentious</span>
      <span style="color: #859900; font-weight: bold;">else</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">:somewhat_pretentious</span>
      <span style="color: #859900; font-weight: bold;">end</span>
    <span style="color: #859900; font-weight: bold;">elsif</span> pretentious_density &lt; 0.1
      <span style="color: #859900; font-weight: bold;">if</span> informal_density &gt; 0.3
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">:really_informal</span>
      <span style="color: #859900; font-weight: bold;">end</span>
      <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">:somewhat_informal</span>
    <span style="color: #859900; font-weight: bold;">else</span>
      <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">:about_right</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">pretentious_density</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">informal_density</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>这是在其他语言里面最常见不过的代码,但是ruby不喜欢这样.ruby非常喜欢的就是"一
行代码"的函数! 这一行也就是返回值.这就是为什么ruby要设计成最后一行默认是返
回值. 我们来看看"一行代码"的函数的魅力
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">prose_rating</span>
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">:really_pretentious</span> <span style="color: #859900; font-weight: bold;">if</span> really_pretentious?
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">:somewhat_pretentious</span> <span style="color: #859900; font-weight: bold;">if</span> somewhat_pretentious?
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">:really_informal</span> <span style="color: #859900; font-weight: bold;">if</span> really_informal?
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">:somewhat_informal</span> <span style="color: #859900; font-weight: bold;">if</span> somewhat_informal?
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">:about_right</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">really_pretentious?</span>
  pretentious_density &gt; 0.3 &amp;&amp; informal_density &lt; 0.2
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">somewhat_pretentious?</span>
  pretentious_density &gt; 0.3 &amp;&amp; informal_density &gt;= 0.2
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">really_informal?</span>
  pretentious_density &lt; 0.1 &amp;&amp; informal_density &gt; 0.3
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">somewhat_informal?</span>
  pretentious_density &lt; 0.1 &amp;&amp; informal_density &lt;= 0.3
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">pretentious_density</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">informal_density</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-5" class="outline-3">
<h3 id="sec-10-5">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-10-5">
<ul class="org-ul">
<li>我们前面将了太多将函数设计的极简成一行的办法,但是你要了解虽然我们要求简单,
但是也得要有意义.函数虽然设计成一行了,但是啥都没干,也没意义.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-6" class="outline-3">
<h3 id="sec-10-6">In the Wild</h3>
<div class="outline-text-3" id="text-10-6">
<ul class="org-ul">
<li>在"简短而有意义"的ruby函数设计的实践中,rails一定是做的最好的.比如rails会把
下面的代码变得非常有意义
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Employee</span> &lt; <span style="color: #b58900;">ActiveRecord</span>::<span style="color: #b58900;">Base</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>我们来看看base.rb里面是如何实现ActiveRecord::Base的
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">find</span><span style="color: #2aa198;">(</span>*args<span style="color: #2aa198;">)</span>
  options = args.extract_options!
  validate_find_options<span style="color: #2aa198;">(</span>options<span style="color: #2aa198;">)</span>
  set_readonly_option!<span style="color: #2aa198;">(</span>options<span style="color: #2aa198;">)</span>

  <span style="color: #859900; font-weight: bold;">case</span> args.first
  <span style="color: #859900; font-weight: bold;">when</span> <span style="color: #268bd2; font-weight: bold;">:first</span> <span style="color: #859900; font-weight: bold;">then</span> find_initial<span style="color: #2aa198;">(</span>options<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">when</span> <span style="color: #268bd2; font-weight: bold;">:last</span> <span style="color: #859900; font-weight: bold;">then</span> find_last<span style="color: #2aa198;">(</span>options<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">when</span> <span style="color: #268bd2; font-weight: bold;">:all</span> <span style="color: #859900; font-weight: bold;">then</span> find_every<span style="color: #2aa198;">(</span>options<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">else</span> find_from_ids<span style="color: #2aa198;">(</span>args, options<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>虽然你不一定了解这些代码里面是干什么的,但是从rails生动的函数命名来说,你已经
了解了他们的功能.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">Chapter 11: Define Operators Respectfully</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li>重定义操作符在c++来到的时候,火了一把,但是后来又沉寂,这是因为其存在着优点以及
缺点, ruby选择了支持操作符重载,所以我们也必须知道如何避免它的缺点
</li>
</ul>
</div>
<div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1">Defining Operators in Ruby</h3>
<div class="outline-text-3" id="text-11-1">
<ul class="org-ul">
<li>ruby能够重定义操作符的原理是:ruby所有操作符的内部实现都是函数
<div class="org-src-container">

<pre class="src src-ruby">sum = first + second
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">is Actually</span>
sum = first.+<span style="color: #2aa198;">(</span>second<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2">A Sampling of Operators</h3>
<div class="outline-text-3" id="text-11-2">
<ul class="org-ul">
<li>除了+, ruby还允许你定义各种操作符-,/,*等等,但是最经常定义的一个操作符是&lt;&lt;,
其意义是"add another one". 数组就重定义了这个操作符
<div class="org-src-container">

<pre class="src src-ruby">names = <span style="color: #2aa198;">[]</span>
names &lt;&lt; <span style="color: #2aa198;">'Rob'</span>
names &lt;&lt; <span style="color: #2aa198;">'Denise'</span>

<span style="color: #657b83; font-weight: bold;">p</span> names

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">["Rob", "Denise"]                              #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>Ruby1.9开始,你甚至可以定义unary operator,比如!
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:content</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>content<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@content</span> = content
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">!</span>
    <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"It is not true: </span><span style="color: #268bd2;">#{content}</span><span style="color: #2aa198;">"</span><span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

favorite = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Chocolate is best'</span><span style="color: #2aa198;">)</span>

<span style="color: #657b83; font-weight: bold;">puts</span> favorite.content
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">(</span><span style="color: #b58900; font-weight: bold;">!</span>favorite<span style="color: #2aa198;">)</span>.content

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Chocolate is best                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">It is not true: Chocolate is best              #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>你也不是所有的操作符都能重定义,比如下面的就不行:
<ol class="org-ol">
<li>not
</li>
<li>and
</li>
<li>||
</li>
<li>&amp;&amp;
</li>
</ol>
</li>
<li>如果想把+当做unary来重定义,函数名是+@
</li>
<li>在Ruby里面[]也是一个操作符,其内部实现也是函数[],可以重定义.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3">Operating Across Classes</h3>
<div class="outline-text-3" id="text-11-3">
<ul class="org-ul">
<li>操作符重定义的一个问题就在于夸class,比如我们想让Document来和string进行相加
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">+</span><span style="color: #2aa198;">(</span>other<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">if</span> otehr.kind_of?<span style="color: #2aa198;">(</span><span style="color: #b58900;">String</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span>title, author, <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{content}</span><span style="color: #2aa198;"> </span><span style="color: #268bd2;">#{other}</span><span style="color: #2aa198;">"</span><span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span>title, author, <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{content}</span><span style="color: #2aa198;"> </span><span style="color: #268bd2;">#{other.content}</span><span style="color: #2aa198;">"</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>这样做的问题在于,如果我是String在前,Document在后,比如
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #2aa198;">'I say to you, '</span> + doc
</pre>
</div>
</li>
<li>就会出现错误
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #93a1a1;">#</span><span style="color: #93a1a1;">&lt;TypeError: can't convert Document into String&gt;</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11-4" class="outline-3">
<h3 id="sec-11-4">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-11-4">
<ul class="org-ul">
<li>从略
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11-5" class="outline-3">
<h3 id="sec-11-5">In the Wild</h3>
<div class="outline-text-3" id="text-11-5">
<ul class="org-ul">
<li>在ruby代码中,还是有一些地方重定义了操作符的,比如,在时间里面
<div class="org-src-container">

<pre class="src src-ruby">now = <span style="color: #b58900;">Time</span>.now
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">one_minute_from_now = now + 60</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Bang! Will break</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">one_minute_from_now = 60 + now</span>

<span style="color: #657b83; font-weight: bold;">puts</span> now
<span style="color: #657b83; font-weight: bold;">puts</span> one_minute_from_now

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2014-06-05 20:47:26 +0800                      #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">2014-06-05 20:48:26 +0800                      #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>

<li>ruby典型的#{variable}也是重定义了操作符
</li>
<li>还有格式化输出
<div class="org-src-container">

<pre class="src src-ruby">day = 4
month = 7
year = 1776

file_name = <span style="color: #2aa198;">'file_%02d%02d%d'</span> % <span style="color: #2aa198;">[</span> day, month, year<span style="color: #2aa198;">]</span>

<span style="color: #657b83; font-weight: bold;">puts</span> file_name

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">file_04071776                                  #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">Chapter 12: Create Classes That Understand Equality</h2>
<div class="outline-text-2" id="text-12">
</div><div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1">An Identifier for Your Documents</h3>
<div class="outline-text-3" id="text-12-1">
<ul class="org-ul">
<li>Document类设计的非常出色,你为了能够快速的定位一个Document,设计了一个Document
的Id类
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DocumentIdentifier</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:folder</span>, <span style="color: #268bd2; font-weight: bold;">:name</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>folder, name<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@folder</span> = folder
    <span style="color: #268bd2;">@name</span> = name
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>然后你发现你的设计并不足够好,同事们认为这个class无法快速比较两个Document的
内容是否完全一致.你需要增加这个设计
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2">An Embarrassment of Equality</h3>
<div class="outline-text-3" id="text-12-2">
<ul class="org-ul">
<li>说到"相等性"(equality),在标榜简洁的Ruby里面,有多达四种的表示"相等"这个概念
的操作符:
<ul class="org-ul">
<li>eql? : 比较Hash的key
</li>
<li>equal?: 比较object(的哈希值)
</li>
<li>==: 比较内容
</li>
<li>===: 比较正则表达式
</li>
</ul>
</li>
<li>好消息是equal?首先可以不用考虑,因为它是指的两个object是否指的是同一个(hash
值相同,类似于Java中的==)
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Return true if x and y are both references to identically same objects</span>
x.equal?<span style="color: #2aa198;">(</span>y<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>equal?的设计其实就是比对内部的hash,这个在Object类里面已经实现好了,无需多次实现.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-3" class="outline-3">
<h3 id="sec-12-3">Double Equals for Everyday Use</h3>
<div class="outline-text-3" id="text-12-3">
<ul class="org-ul">
<li>在Object里面, ==operator的实现和equal?是一样的.而实际上, ==operator才是真正
的比较"内容",而非heap里面的object
</li>
<li>所以,我们要在class里面如下实现==operator
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DocumentIdentifier</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:folder</span>, <span style="color: #268bd2; font-weight: bold;">:name</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>folder, name<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@folder</span> = folder
    <span style="color: #268bd2;">@name</span> = name
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">==</span><span style="color: #2aa198;">(</span>other<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span> <span style="color: #859900; font-weight: bold;">unless</span> other.instance_of?<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.class<span style="color: #2aa198;">)</span>
    folder == other.folder &amp;&amp; name == other.name
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>实现的原理也非常简单:
<ul class="org-ul">
<li>首先测试other是不是一个self.class也就是DocumentIdentifier类型的instance,
需要注意的是nil不需要进行专门测试(像在java中那样), 因为nil本身也是一个类,
会再instance_of?的时候返回false
</li>
<li>其次我们再判断name和folder是否都一致
</li>
</ul>
</li>
<li>一个合理的优化,就是测试other是否就是自己本身(这在其他语言中也很常见,比如c++)
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">==</span><span style="color: #2aa198;">(</span>other<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span> <span style="color: #859900; font-weight: bold;">if</span> other.equal?<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span> <span style="color: #859900; font-weight: bold;">unless</span> other.instance_of?<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.class<span style="color: #2aa198;">)</span>
  folder == other.folder &amp;&amp; name == other.name
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-4" class="outline-3">
<h3 id="sec-12-4">Broadening the Appeal of the == Method</h3>
<div class="outline-text-3" id="text-12-4">
<ul class="org-ul">
<li>前面一个例子的坏处是它只能让==成功匹配完全相同类型的(也就是DocumentIdentifier)
的instance,其实在OO设计中. subclass"也是"一种baseclass.所以,我们使用kind_of?
来替代instance_of?
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DocumentIdentifier</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">==</span><span style="color: #2aa198;">(</span>other<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span> <span style="color: #859900; font-weight: bold;">if</span> other.equal?<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span> <span style="color: #859900; font-weight: bold;">unless</span> other.kind_of?<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.class<span style="color: #2aa198;">)</span>
    folder == other.folder &amp;&amp; name == other.name
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">ContractIdentifer</span> &lt; <span style="color: #b58900;">DocumentIdentifier</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>这样的做法看起来很"不ruby", 因为dedicated的类继承,只有Java才做. Ruby再OO上
是更加务实的态度.Ruby也不像继承的过深, 这种情况下(需要另外一个类和当前类"有
关系", 却不是继承的关系), Ruby会倾向于创建一个内容有部分相似的类,但"绝不"踏
上继承的贼船
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DocumentIdentifier</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:folder</span>, <span style="color: #268bd2; font-weight: bold;">:name</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>folder, name<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@folder</span> = folder
    <span style="color: #268bd2;">@name</span> = name
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">==</span><span style="color: #2aa198;">(</span>other<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span> <span style="color: #859900; font-weight: bold;">unless</span> other.instance_of?<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.class<span style="color: #2aa198;">)</span>
    folder == other.folder &amp;&amp; name == other.name
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DocumentPointer</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:folder</span>, <span style="color: #268bd2; font-weight: bold;">:name</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>folder, name<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@folder</span> = folder
    <span style="color: #268bd2;">@name</span> = name
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">==</span><span style="color: #2aa198;">(</span>other<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span> <span style="color: #859900; font-weight: bold;">unless</span> other.respond_to?<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">:folder</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span> <span style="color: #859900; font-weight: bold;">unless</span> other.respond_to?<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">:name</span><span style="color: #2aa198;">)</span>
    folder == other.folder &amp;&amp; name == other.name
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

doc_id = <span style="color: #b58900;">DocumentIdentifier</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'secret/area51'</span>, <span style="color: #2aa198;">'phone list'</span><span style="color: #2aa198;">)</span>
pointer= <span style="color: #b58900;">DocumentPointer</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'secret/area51'</span>, <span style="color: #2aa198;">'phone list'</span><span style="color: #2aa198;">)</span>

<span style="color: #657b83; font-weight: bold;">puts</span> pointer == doc_id

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">true                                           #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>我们可以看到ruby使用了respond_to?这个函数来寻找other是否有"某个名字的函数",
这再次印证了Ruby duck type的特征:"只要有相应的功能(函数), 我们就认为是同一
种类"
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-5" class="outline-3">
<h3 id="sec-12-5">Well-Behaved Equality</h3>
<div class="outline-text-3" id="text-12-5">
<ul class="org-ul">
<li>无论是使用kind_of?还是respond_to?一个无法弥补的问题是,我们的==operator做不
到真正的==operator的"互换性",比如上面的例子,如果我们把doc_id放在前面,肯定做
不到相等.像这样
<div class="org-src-container">

<pre class="src src-ruby">doc_id == pointer
</pre>
</div>
</li>
<li>尽管有一些方法可以规避这种问题,但其实大多数情况下,你并不需要一个==operator,
一个名字非常友好的函数就解决了你的问题,而且非常"Ruby"
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">is_same_document?</span><span style="color: #2aa198;">(</span>other<span style="color: #2aa198;">)</span>
  other.folder == folder &amp;&amp; other.name == name
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-6" class="outline-3">
<h3 id="sec-12-6">Triple Equals for Case Statements</h3>
<div class="outline-text-3" id="text-12-6">
<ul class="org-ul">
<li>===operator是ruby特有的,主要用在case statement里面. 之所以要设计===其实是为
了一种扩展性: ===operator的作用:
<ul class="org-ul">
<li>如果case后面是常规的操作数,那么===operator(在case里面)就等同于==operator
</li>
<li>如果case后面是正则表达式, when后面是字符串,那么===operator(在case里面)就
等同于=~operator
</li>
<li>如果case后面是一个instance, when后面是Class, 那么===operator(再case里面)
就等同于kind_of?
</li>
<li>以后,Ruby还可以从容的再加上其他的扩展
</li>
</ul>
</li>
<li>所以,绝大多数情况下,不用改写==operator,除非你要写什么奇怪的case语句
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-7" class="outline-3">
<h3 id="sec-12-7">Hash Tables and the eql? Method</h3>
<div class="outline-text-3" id="text-12-7">
<ul class="org-ul">
<li>就像===是为了case statement而单独创作的一样, eql?是单独为了比较Hash的Key而
创作的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-8" class="outline-3">
<h3 id="sec-12-8">Building a Well-Behaved Hash Key</h3>
<div class="outline-text-3" id="text-12-8">
<ul class="org-ul">
<li>eql? 默认的行为也是再Object里面定义的.默认的hash会以key的object_id作为key,所以
下面的例子中, second_id虽然内容和first_id一致,但是object_id却不一致,最后会
导致取不到值,因为first_id.eql?(second_id)为false
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DocumentIdentifier</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:folder</span>, <span style="color: #268bd2; font-weight: bold;">:name</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initializ</span><span style="color: #2aa198;">(</span>folder, name<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@folder</span> = folder
    <span style="color: #268bd2;">@name</span> = name
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

hash = <span style="color: #2aa198;">{}</span>
document = <span style="color: #b58900;">Document</span>.new
first_id = <span style="color: #b58900;">DocumentIdentifier</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'public'</span>, <span style="color: #2aa198;">'CoverStory'</span><span style="color: #2aa198;">)</span>

hash<span style="color: #2aa198;">[</span>first_id<span style="color: #2aa198;">]</span> = document
second_id = <span style="color: #b58900;">DocumentIdentifier</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'public'</span>, <span style="color: #2aa198;">'CoverStory'</span><span style="color: #2aa198;">)</span>

<span style="color: #657b83; font-weight: bold;">p</span> hash<span style="color: #2aa198;">[</span>second_id<span style="color: #2aa198;">]</span>
<span style="color: #657b83; font-weight: bold;">p</span> hash<span style="color: #2aa198;">[</span>first_id<span style="color: #2aa198;">]</span>

<span style="color: #657b83; font-weight: bold;">p</span> first_id.eql?<span style="color: #2aa198;">(</span>second_id<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">nil                                            #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">#&lt;Document:0x007fccc097db98&gt;                   #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">false                                          #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>所以,如果你创建了一个class,并且很有可能作为hash的key(显然DocumentIdentifier
是要做key的).那么,你一定要:
<ol class="org-ol">
<li>实现hash函数. a.hash == b.hash
</li>
<li>实现一下eql? a.eql?(b)
</li>
</ol>
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DocumentIdentifier</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Code omitted...</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">hash</span>
    folder.hash ^ name.hash
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">eql?</span><span style="color: #2aa198;">(</span>other<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span> <span style="color: #859900; font-weight: bold;">unless</span> other.instance_of?<span style="color: #2aa198;">(</span>slef.clas<span style="color: #2aa198;">)</span>
    folder == other.folder &amp;&amp; name == other.name
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>我们可以看到hash函数使用了操作符^,这是一种非常经济实惠的创建hash值的方法
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-9" class="outline-3">
<h3 id="sec-12-9">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-12-9">
<ul class="org-ul">
<li>让equality可以正常工作是非常痛苦的.你能做的只是"减少痛苦":其实你可以直接忽
略equality的书写&#x2013;直到你遇到问题,直到你的代码崩溃,你再去看看equality的问题.
因为大部分的class,一辈子也不会去做==操作,或者作为Hash的key
</li>
<li>对于equality的完成还可以把工作"交给别人来做", 比如你的class主要是包裹了array
一层,那么你的equality主要在内部调用array的equality就可以了
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DisArray</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:my_array</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span>
    <span style="color: #268bd2;">@my_array</span> = <span style="color: #2aa198;">[]</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">==</span><span style="color: #2aa198;">(</span>other<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span> <span style="color: #859900; font-weight: bold;">unless</span> other.kind_of?<span style="color: #2aa198;">(</span><span style="color: #b58900;">DisArray</span><span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@my_array</span> == other.my_array
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">eql?</span><span style="color: #2aa198;">(</span>other<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span> <span style="color: #859900; font-weight: bold;">unless</span> other.kind_of?<span style="color: #2aa198;">(</span><span style="color: #b58900;">DisArray</span><span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@my_array</span>.eql?<span style="color: #2aa198;">(</span>other.my_array<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">hash</span>
    <span style="color: #268bd2;">@my_array</span>.hash
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-12-9-1" class="outline-4">
<h4 id="sec-12-9-1">In the Wild</h4>
<div class="outline-text-4" id="text-12-9-1">
<ul class="org-ul">
<li>抛开我们设计的比较复杂的类而言,对于数学界的数字,Ruby当然有不同的处理.
</li>
<li>比如下面的例子中, Ruby会把integer先转化成float,然后去对比
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">puts</span> 1 == 1.0

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">true                                          #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>而且,像数学里面的数字,他们直接是有顺序的. 1肯定小于2,大于0. 这种有序的类,
可以再引入一个操作符&lt;=&gt;: 如果小于返回-1, 等于返回0, 大于返回1
</li>
<li>Ruby有一种机制叫做Module,能够"注入代码". &lt;=&gt;operator由于非常常用,所以引入
了Comparable Module, 这个Comparable Module里面会给你写&lt;,&lt;=,&gt;=, &gt; 都基于你
的&lt;=&gt;operator
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">RomanNumerals</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Comparable</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Actual guts of the class omitted...</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">&lt;=&gt;</span><span style="color: #2aa198;">(</span>other<span style="color: #2aa198;">)</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Return -1, 0, or 1</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>前面我们说过case后面跟instance,而when后面为Class的时候,===operator其实就是
kind_of?
<div class="org-src-container">

<pre class="src src-ruby">the_object = 3.14159

<span style="color: #859900; font-weight: bold;">case</span> the_object
<span style="color: #859900; font-weight: bold;">when</span> <span style="color: #b58900;">String</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"It's a string"</span>
<span style="color: #859900; font-weight: bold;">when</span> <span style="color: #b58900;">Float</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"It's a float"</span>
<span style="color: #859900; font-weight: bold;">when</span> <span style="color: #b58900;">Fixnum</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"It's a fixnum"</span>
<span style="color: #859900; font-weight: bold;">else</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Dunno!"</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">It's a float                                   #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">Chapter 13: Get the Behavior You Nedd with Singleton and Class Methods</h2>
<div class="outline-text-2" id="text-13">
<ul class="org-ul">
<li>OO编程的核心思想其实就是建模世界.但是很多时候处心积虑创建出来的class可能不一
定"百分之百的"符合某个instance的要求.比如我们创建一个叫做American的类,其中有
两个函数eat_hamburgers和watch_football. 一个美国人可能确实是喜欢吃汉堡包,但
是他不喜欢看足球啊!
</li>
<li>Ruby对待这种情况的办法是singleton函数
</li>
</ul>
</div>
<div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1">A Stubby Puzzle</h3>
<div class="outline-text-3" id="text-13-1">
<ul class="org-ul">
<li>所谓singleton method,就是某个instance特有的函数(不是java里面的instance函数
哦,那个的意思是所有instance都有,而不是某个类有).
</li>
<li>除了numeric class或者symbol,其他的class或者新创建的class都支持singleton method
</li>
<li>创建singleton method的方法如下,其和普通method没有任何区别&#x2013;除了它只属于某个instance
<div class="org-src-container">

<pre class="src src-ruby">hand_built_stub_printer = <span style="color: #b58900;">Object</span>.new

<span style="color: #859900; font-weight: bold;">def</span> hand_built_stub_printer.<span style="color: #268bd2;">available?</span>
  <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">def</span> hand_built_stub_printer.<span style="color: #268bd2;">render</span><span style="color: #2aa198;">(</span>content<span style="color: #2aa198;">)</span>
  <span style="color: #268bd2; font-weight: bold;">nil</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">p</span> hand_built_stub_printer.available?
<span style="color: #657b83; font-weight: bold;">p</span> hand_built_stub_printer.render<span style="color: #2aa198;">(</span>0<span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">true                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">nil                                            #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>singleton method会override所有的常规的,或者class-defined的method,比如
<div class="org-src-container">

<pre class="src src-ruby">uncooperative = <span style="color: #2aa198;">"Don't ask my class"</span>

<span style="color: #859900; font-weight: bold;">def</span> uncooperative.<span style="color: #268bd2;">class</span>
  <span style="color: #2aa198;">"I'm not telling"</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">puts</span> uncooperative.class

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">I'm not telling                                #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>每次都把instance写出来,然后定义singleton函数的方法看起来有点傻,如果定义很多
singleton函数的话,可以试试下面的方法
<div class="org-src-container">

<pre class="src src-ruby">hand_built_stub_printer = <span style="color: #b58900;">Object</span>.new

<span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; hand_built_stub_printer
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">available?</span>                <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">A singleton method</span>
    <span style="color: #268bd2; font-weight: bold;">true</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">render</span>                    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Another one</span>
    <span style="color: #268bd2; font-weight: bold;">nil</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-13-2" class="outline-3">
<h3 id="sec-13-2">A Hidden, but Real Class</h3>
<div class="outline-text-3" id="text-13-2">
<ul class="org-ul">
<li>singleton函数能够实现的原因是再object和其class之间,Ruby"偷偷的"为你创建了
Singleton函数
<pre class="example">
+-----------+
|  Object   |
|           |
+-----^-----+
      |
      +-----------+
                  |
            +-----------+
            | Singleton |
            |  Class    |
            +-----+-----+
                  |
      +-----------+
      |
+-----------+
|stub_print |
|instance   |
+-----------+
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-13-3" class="outline-3">
<h3 id="sec-13-3">Class Methods: Singletons in Plain Sight</h3>
<div class="outline-text-3" id="text-13-3">
<ul class="org-ul">
<li>我们费尽非常大的力气实现了singleton method,看起来用处不多,但其实一个背后的
目的是:他是为了实现Ruby的重要feature, class method. 换句话说,我们每天都在使
用的class method其实是一个singleton method,让我们慢慢道来
</li>
<li>下面是一个常规的class函数用法.my_object的self表示他是一个叫做#&lt;Document:0x007fccc08840e8&gt;
的instance, 它的是由class Document创建来的
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
<span style="color: #859900; font-weight: bold;">end</span>

my_object = <span style="color: #b58900;">Document</span>.new

<span style="color: #859900; font-weight: bold;">def</span> my_object.<span style="color: #268bd2;">explain</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"self is </span><span style="color: #268bd2;">#{self}</span><span style="color: #2aa198;">"</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"and its class is </span><span style="color: #268bd2;">#{self.class}</span><span style="color: #2aa198;">"</span>
<span style="color: #859900; font-weight: bold;">end</span>

my_object.explain

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">self is #&lt;Document:0x007fccc08840e8&gt;           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">and its class is Document                      #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>我们把Document的new去掉再来看看,输出变得大不同
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
<span style="color: #859900; font-weight: bold;">end</span>

my_object = <span style="color: #b58900;">Document</span>

<span style="color: #859900; font-weight: bold;">def</span> my_object.<span style="color: #268bd2;">explain</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"self is </span><span style="color: #268bd2;">#{self}</span><span style="color: #2aa198;">"</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"and its class is </span><span style="color: #268bd2;">#{self.class}</span><span style="color: #2aa198;">"</span>
<span style="color: #859900; font-weight: bold;">end</span>

my_object.explain

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">self is Document                               #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">and its class is Class                         #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>输出变成了:
<ul class="org-ul">
<li>my_object是一个叫做Document的instance
</li>
<li>这个instance是由class Class创建来的!
</li>
</ul>
</li>
<li>这就像我们解释了:
<ul class="org-ul">
<li>所有的class(比如Document,或者Fixnum, 或者String)都是对象!
</li>
<li>它们是由Class实例化来的
</li>
<li>class是这些对象的singleton method,所以我们可以这样
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #b58900;">Document</span>.<span style="color: #268bd2;">explain</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"self is </span><span style="color: #268bd2;">#{self}</span><span style="color: #2aa198;">"</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"and its class is </span><span style="color: #268bd2;">#{self.class}</span><span style="color: #2aa198;">"</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #b58900;">Document</span>.explain

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">self is Document                               #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">and its class is Class                         #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</li>
<li>一旦知道了class是类Class一个singleton函数, 而所有的class都是Class的instance
那么下面代码就容易理解了,其实就是定义instance Document的singleton method
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">previously, we have this</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">class &lt;&lt; hand_built_stub_printer</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">here the self is actually the same meaning with hand_built_stub_printer</span>
  <span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; <span style="color: #859900; font-weight: bold;">self</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">find_by_name</span><span style="color: #2aa198;">(</span>name<span style="color: #2aa198;">)</span>
      <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Find a document by name</span>
    <span style="color: #859900; font-weight: bold;">end</span>

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">fidn_by_id</span><span style="color: #2aa198;">(</span>doc_id<span style="color: #2aa198;">)</span>
      <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Find a document by id</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-13-4" class="outline-3">
<h3 id="sec-13-4">In the Wild</h3>
<div class="outline-text-3" id="text-13-4">
<ul class="org-ul">
<li>其实除了上面说到的class method, singleton class的用处并不多(Rspec可能会用到很多)
</li>
<li>大多数情况下,类函数显得更加"合适".而不是把类看成是Class的instance,然后定义instance method
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-13-5" class="outline-3">
<h3 id="sec-13-5">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-13-5">
<ul class="org-ul">
<li>singleton method最大的问题是和class method容易混淆.使用的时候:
<ul class="org-ul">
<li>class method是: 类名.函数名
</li>
<li>singleton method是: instance名.函数名
</li>
</ul>
</li>
<li>class method使用的时候,self的意义会变化!我们来看看一个常见的class method的
创建方法. 我们可以看到,在class method里面self转换成了一个Class类型的instance
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Parent</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">who_am_i</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"The value of self is </span><span style="color: #268bd2;">#{self}</span><span style="color: #2aa198;">"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Child</span> &lt; <span style="color: #b58900;">Parent</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #b58900;">Parent</span>.who_am_i
<span style="color: #b58900;">Child</span>.who_am_i

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The value of self is Parent                    #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The value of self is Child                     #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>如果是普通的方法的话,就会导致如下结果. 我们可以看到, 在普通的method里面,self
就是当前class的一个instance.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Parent</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">who_am_i</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"The value of self is </span><span style="color: #268bd2;">#{self}</span><span style="color: #2aa198;">"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Child</span> &lt; <span style="color: #b58900;">Parent</span>
<span style="color: #859900; font-weight: bold;">end</span>

parent = <span style="color: #b58900;">Parent</span>.new
child = <span style="color: #b58900;">Child</span>.new

parent.who_am_i
child.who_am_i

<span style="color: #93a1a1;">###################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;  #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The value of self is #&lt;Parent:0x007fccc1070298&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The value of self is #&lt;Child:0x007fccc1070270&gt;  #</span>
<span style="color: #93a1a1;">###################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">Chapter 14: Use Class Instance Variables</h2>
<div class="outline-text-2" id="text-14">
<ul class="org-ul">
<li>Ruby中使用@@表示class variable, 经验告诉我们,class variable通常不是一个好主
意,所以要使用class instance variable来替代class variable.
</li>
<li>注意!是class instance variable而不是instance variable.
</li>
<li>class instance variable是一个"中间状态":
<ul class="org-ul">
<li>它和instance variable长得很像都是一个@,但是它不在某个method里面
</li>
<li>它和class variable一样,再class里面,但是在所有的method的外面.
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1">A Quick Review of Class Variables</h3>
<div class="outline-text-3" id="text-14-1">
<ul class="org-ul">
<li>我们想给Document增加尺寸这个属性,先看看把它加成class variable的版本的效果
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #268bd2;">@@default_paper_size</span> = <span style="color: #268bd2; font-weight: bold;">:a4</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">default_paper_size</span>
    <span style="color: #268bd2;">@@default_paper_size</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">default_paper_size=</span><span style="color: #2aa198;">(</span>new_size<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@@default_paper_size</span> = new_size
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:title</span>, <span style="color: #268bd2; font-weight: bold;">:author</span>, <span style="color: #268bd2; font-weight: bold;">:content</span>
  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:paper_size</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>title, author, content<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@title</span> = title
    <span style="color: #268bd2;">@author</span> = author
    <span style="color: #268bd2;">@content</span> = content
    <span style="color: #268bd2;">@paper_size</span> = <span style="color: #268bd2;">@@default_paper_size</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Rest of the class omitted...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>看似完美的解决方法其实不堪一击,后面章节会进行解释
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-14-2" class="outline-3">
<h3 id="sec-14-2">Wandering Variables</h3>
<div class="outline-text-3" id="text-14-2">
<ul class="org-ul">
<li>先来了解一下编译器如何解析, 在Document class一进去看到@@default_paper_size
     的时候,编译器第一反应是找它第一次出现的位置,所以会"追根溯源"的找:
<ul class="org-ul">
<li>要么在某个base class里面找到了那个@@default_paper_size
</li>
<li>要么没有找到,就再当前的class里面设置一个new class variable
</li>
</ul>
</li>
<li>Resume是一种文档,所以继承了Document, 增加了一个class variable叫做default_font
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Resume</span> &lt; <span style="color: #b58900;">Document</span>
  <span style="color: #268bd2;">@@default_font</span> = <span style="color: #268bd2; font-weight: bold;">:arial</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">default_font</span> = <span style="color: #2aa198;">(</span>font<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@@default_font</span> = font
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">default_font</span>
    <span style="color: #268bd2;">@@default_font</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:font</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span>
    <span style="color: #268bd2;">@font</span> = <span style="color: #268bd2;">@@default_font</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Rest of the class omitted...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>Presentation也是一种文档,也继承了Document, 也增加了一个叫做default_font的
     class variable
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Presentation</span> &lt; <span style="color: #b58900;">Document</span>
  <span style="color: #268bd2;">@@default_font</span> = <span style="color: #268bd2; font-weight: bold;">:nimbus</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">default_font</span> = <span style="color: #2aa198;">(</span>font<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@@default_font</span> = font
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">default_font</span>
    <span style="color: #268bd2;">@@default_font</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:font</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span>
    <span style="color: #268bd2;">@font</span> = <span style="color: #268bd2;">@@default_font</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>有一天你不知道哪根筋错了,竟然给Document,也就是Resume和Presentation的父类也
定义了一个名字相同的class variable. 然后,一切都毁灭了
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #268bd2;">@@dafault_font</span> = <span style="color: #268bd2; font-weight: bold;">:times</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>我们用一个简单的例子来描绘一下"毁灭"的现场
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Base</span>
  <span style="color: #268bd2;">@@cv</span> = <span style="color: #268bd2; font-weight: bold;">:hello</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:out</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span>
    <span style="color: #268bd2;">@out</span> = <span style="color: #268bd2;">@@cv</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
b1 = <span style="color: #b58900;">Base</span>.new
<span style="color: #657b83; font-weight: bold;">p</span> b1.out

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Derived</span> &lt; <span style="color: #b58900;">Base</span>
  <span style="color: #268bd2;">@@cv</span> = <span style="color: #268bd2; font-weight: bold;">:world</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:out</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span>
    <span style="color: #268bd2;">@out</span> = <span style="color: #268bd2;">@@cv</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

b2 = <span style="color: #b58900;">Base</span>.new
d = <span style="color: #b58900;">Derived</span>.new

<span style="color: #657b83; font-weight: bold;">p</span> b2.out
<span style="color: #657b83; font-weight: bold;">p</span> d.out

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">:hello                                         #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">:world                                         #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">:world                                         #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>也就是说如果我们Document系列代码有如下调用的话, 因为有Document再中间"牵线搭
桥", 会出现,所有的Document系列的字体都称了:arial
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'document'</span>
<span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'resume'</span>                <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Load Resume first</span>
<span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'presentation'</span>          <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">then Presentation</span>
</pre>
</div>
</li>
<li>出现上面这种问题的原因,是class variable的封装性不够,class variable其实和原
来面向过程编程中的全局变量很像. class variable和某个specific的class联系的不
够紧密,反而是和整个继承序列所有的class都有关系,被David Black称作"vertical
global variables" (非常生动哈)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-14-3" class="outline-3">
<h3 id="sec-14-3">Getting Control of the Data in Your Class</h3>
<div class="outline-text-3" id="text-14-3">
<ul class="org-ul">
<li>解决方法也很简单,"去掉一个@", 我们使用class instance variable. 少了一个@后,
整个default_font就是和某个class紧密结合了.而且不出意外的再initialize的时候
给每个instance都赋好了值
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #268bd2;">@default_font</span> = <span style="color: #268bd2; font-weight: bold;">:times</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">default_font=</span><span style="color: #2aa198;">(</span>font<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@default_font</span> = font
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">default_font</span>
    <span style="color: #268bd2;">@default_font</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>由于我们实现了default_font=函数,所以我们可以做到如下:
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #b58900;">Document</span>.default_font = <span style="color: #268bd2; font-weight: bold;">:arial</span>
</pre>
</div>
</li>
<li>由于我们实现了default_font函数,所以我们可以直接在其他method,比如initialize
里面直接调用它
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>title, author<span style="color: #2aa198;">)</span>
  <span style="color: #268bd2;">@title</span> = title
  <span style="color: #268bd2;">@author</span> = author
  <span style="color: #268bd2;">@font</span> = <span style="color: #b58900;">Document</span>.default_font
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-14-4" class="outline-3">
<h3 id="sec-14-4">Class Instance Variable and Subclasses</h3>
<div class="outline-text-3" id="text-14-4">
<ul class="org-ul">
<li>我们刚才发现class variable的问题是通过subclass,所以我们还是要看看class
instance variable在subclass存在时候的表现
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Base</span>
  <span style="color: #268bd2;">@civ</span> = <span style="color: #268bd2; font-weight: bold;">:hello</span>
  <span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; <span style="color: #859900; font-weight: bold;">self</span>
    <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:civ</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:out</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span>
    <span style="color: #268bd2;">@out</span> = <span style="color: #b58900;">Base</span>.civ
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Derived</span> &lt; <span style="color: #b58900;">Base</span>
  <span style="color: #268bd2;">@civ</span> = <span style="color: #268bd2; font-weight: bold;">:world</span>

  <span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; <span style="color: #859900; font-weight: bold;">self</span>
    <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:civ</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:out</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span>
    <span style="color: #268bd2;">@out</span> = <span style="color: #b58900;">Derived</span>.civ
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

b2 = <span style="color: #b58900;">Base</span>.new
d = <span style="color: #b58900;">Derived</span>.new

<span style="color: #657b83; font-weight: bold;">p</span> b2.out
<span style="color: #657b83; font-weight: bold;">p</span> d.out

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">:hello                                         #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">:world                                         #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>表现不错,没有出现class variable的错误.其原因自然是因为class instance variable
是和某个specific的class紧密联系,而不和其他class分享的.而且我们上面非常巧妙
的使用了Singleton variable来减少代码量
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-14-5" class="outline-3">
<h3 id="sec-14-5">Adding Some Convenience to Your Class Instance</h3>
<div class="outline-text-3" id="text-14-5">
<ul class="org-ul">
<li>前面说过了我们替代class variable的选择是class instance variable, 他本质上是
instance variable(因为只有一个@),只是碰巧不小心再class里面,在method外面.
</li>
<li>我们第一个例子介绍class instance variable的时候,给他写了setter getter函数,
第二个例子就用了Ruby的attr_accessor来减少代码,还用了singleton method. 否则
instance是无法调动它们的
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #268bd2;">@default_font</span> = <span style="color: #268bd2; font-weight: bold;">:times</span>
  <span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; <span style="color: #859900; font-weight: bold;">self</span>
    <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:default_font</span>
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>这样一设置.Document有了好几个singleton method可以调用.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-14-6" class="outline-3">
<h3 id="sec-14-6">In the Wild</h3>
<div class="outline-text-3" id="text-14-6">
<ul class="org-ul">
<li>Rails的ActiveRecord使用了很多的class instance variable.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-14-7" class="outline-3">
<h3 id="sec-14-7">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-14-7">
<ul class="org-ul">
<li>使用class variable的情况极其少见,要非常小心,推荐使用class instance variable
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15">Chapter 15: Use Modules as Name Spaces</h2>
<div class="outline-text-2" id="text-15">
</div><div id="outline-container-sec-15-1" class="outline-3">
<h3 id="sec-15-1">A Place for Your Stuff, with a Name</h3>
<div class="outline-text-3" id="text-15-1">
<ul class="org-ul">
<li>Ruby的class第一是一个创建object的工厂, 第二是一个把method和variable装在一起
的container
</li>
<li>而Ruby的Module,则只是一个container,它不能创建object. Module包罗万象,可以包
括:
<ul class="org-ul">
<li>method
</li>
<li>constant
</li>
<li>class
</li>
<li>other module
</li>
</ul>
</li>
<li>先看下面的一个module的例子,其中包括两个class, 其最明显的作用体现出来了:能把
相关联的class聚集在一起. 更重要的优点是,你在Rendering的module里面定义了Font
等于给Font了一层namespace,即便再其他Module里面也定义了Font,也不用害怕了.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">Rendering</span>
  <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Font</span>
    <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:name</span>, <span style="color: #268bd2; font-weight: bold;">:weight</span>, <span style="color: #268bd2; font-weight: bold;">:size</span>

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>name, weight=<span style="color: #268bd2; font-weight: bold;">:normal</span>, size=10<span style="color: #2aa198;">)</span>
      <span style="color: #268bd2;">@name</span> = name
      <span style="color: #268bd2;">@weight</span> = weight
      <span style="color: #268bd2;">@wize</span> = size
    <span style="color: #859900; font-weight: bold;">end</span>

    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">PaperSize</span>
    <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:name</span>, <span style="color: #268bd2; font-weight: bold;">:width</span>, <span style="color: #268bd2; font-weight: bold;">:height</span>

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>name=<span style="color: #2aa198;">'US Let'</span>, width=8.5, height=11.0<span style="color: #2aa198;">)</span>
      <span style="color: #268bd2;">@name</span> = name
      <span style="color: #268bd2;">@width</span> = width
      <span style="color: #268bd2;">@height</span> = height
    <span style="color: #859900; font-weight: bold;">end</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>Module还可也用来"存放"const(其实class name也是一种const,所以放const没有什么
奇怪的)
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">Rendering</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Font and PaperSize classes omitted...</span>

  <span style="color: #b58900;">DEFAULT_FONT</span> = <span style="color: #b58900;">Font</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'default'</span><span style="color: #2aa198;">)</span>
  <span style="color: #b58900;">DEFAULT_PAPER_SIZE</span> = <span style="color: #b58900;">PaperSize</span>.new
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>使用方法是加::, 比如Render::DEFAULT_PAPER_SIZE
</li>
<li>Module还是相互间可以嵌套的
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">WordProcessor</span>
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">Rndering</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-15-2" class="outline-3">
<h3 id="sec-15-2">A Home for Those Utility Methods</h3>
<div class="outline-text-3" id="text-15-2">
<ul class="org-ul">
<li>Module是一切helper函数(不知道放到哪里合适的函数)的理想的放置场所.比如我们的
文字处理的module里面可能会有一些设计进制转换的helper函数
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">WordProcessor</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">points_to_inches</span><span style="color: #2aa198;">(</span>points<span style="color: #2aa198;">)</span>
    points / 72.0
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">inches_to_points</span><span style="color: #2aa198;">(</span>inches<span style="color: #2aa198;">)</span>
    inches * 72.0
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>调用module的常量,使用::, 函数的话也可以使用::, 但是更多的人喜欢使用"."
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-15-3" class="outline-3">
<h3 id="sec-15-3">Building Modules a Little at a Time</h3>
<div class="outline-text-3" id="text-15-3">
<ul class="org-ul">
<li>Module暴露自己是namespace的地方在于使用方法:
<ul class="org-ul">
<li>我们在font.rb里面写下如下代码
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">Rendering</span>
  <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Font</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Bulk of class omitted...</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>我们在paper_size.rb里面定义了下面的代码
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">Rendering</span>
  <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">PaperSize</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Bulk of class omitted...</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #b58900;">DEFAULT_PAPER_SIZE</span> = <span style="color: #b58900;">PaperSize</span>.new
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</li>
<li>我们的module被写在了两个地方.然后使用的时候一块require就可以了
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'font'</span>
<span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'paper_size'</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-15-4" class="outline-3">
<h3 id="sec-15-4">Treat Modules Like the Objects That They Are</h3>
<div class="outline-text-3" id="text-15-4">
<ul class="org-ul">
<li>Ruby中一切都是对象,Module也是.所以下面的代码可行:
<div class="org-src-container">

<pre class="src src-ruby">the_module = <span style="color: #b58900;">Rendering</span>

times_new_roman_font = the_module::<span style="color: #b58900;">Font</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'times-new-roman'</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>Module既是namespace,又是object的特性,可以用来在running time替换底层的实际起
作用的代码,比如我们有两种打印机,所以我们把它们分别放到两个module里面:
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">TonsOToner</span>
  <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">PrintQueue</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Administration</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">OceansOfInk</span>
  <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">PrintQueue</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Administration</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>在使用的时候,就可以根据不同的情况,替换底层的代码
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">if</span> use_laser_printer
  print_module = <span style="color: #b58900;">TonsOToner</span>
<span style="color: #859900; font-weight: bold;">else</span>
  print_module = <span style="color: #b58900;">OceansOfInk</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Later...</span>
admin = print_module::<span style="color: #b58900;">Administration</span>.new
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-15-5" class="outline-3">
<h3 id="sec-15-5">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-15-5">
<ul class="org-ul">
<li>判断是否需要给class增加一个Module的方法,是看class名字是不是很多都有相同的前
缀.如果有很多HelloWorld_XXX,那么就干脆创建一个HelloWorld的Module
</li>
<li>Module和Module不要嵌套的太深,我们需要简洁的代码
</li>
<li>要理解两种Module里面"直接"嵌套的method的不同:
<ul class="org-ul">
<li>如果你像mix into其他代码,那么这么写
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">WordProcessor</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">points_to_inches</span><span style="color: #2aa198;">(</span>points<span style="color: #2aa198;">)</span>
    points / 72.0
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>如果是要做helper函数,那么这么写
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">WordProcessor</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">points_to_inches</span><span style="color: #2aa198;">(</span>points<span style="color: #2aa198;">)</span>
    points / 72.0
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-15-6" class="outline-3">
<h3 id="sec-15-6">In the Wild</h3>
<div class="outline-text-3" id="text-15-6">
<ul class="org-ul">
<li>DataMapper是一个运用Module非常好的例子
</li>
<li>RubyGems也是一个14000行的module的代码.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16">Chapter 16: Use Modules as Mixins</h2>
<div class="outline-text-2" id="text-16">
<ul class="org-ul">
<li>上一节我们讲到ruby class(其实也是所有OO语言中的class)的两个作用:
<ul class="org-ul">
<li>instance的factory
</li>
<li>method和variable的container
</li>
<li>其实还有第三个,就是作为一个super class. 设计类第一步就是要选择是否继承,和
到底继承谁.继承了某个class,也就继承了一大笔财富(或者负担)
</li>
</ul>
</li>
<li>Ruby和其他语言不一样的地方.是它不单单可以通过"继承"来获取一些函数或者变量,还
可以通过mix in的方法来获取(在module的帮助下)
</li>
</ul>
</div>
<div id="outline-container-sec-16-1" class="outline-3">
<h3 id="sec-16-1">Better Books with Modules</h3>
<div class="outline-text-3" id="text-16-1">
<ul class="org-ul">
<li>我们经常会使用一些"陈词滥调", 我们设计了一段代码来统计content里面,有多少"陈
词滥调"
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:content</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>content<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@content</span> = content
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #b58900;">CLICHES</span> = <span style="color: #2aa198;">[</span> <span style="color: #2aa198;">/play fast and loose/</span>,
              <span style="color: #2aa198;">/make no mistake/</span>,
              <span style="color: #2aa198;">/does the trick/</span>,
              <span style="color: #2aa198;">/off and running/</span>,
              <span style="color: #2aa198;">/my way or the highway/</span><span style="color: #2aa198;">]</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">number_of_cliches</span>
    <span style="color: #b58900;">CLICHES</span>.inject<span style="color: #2aa198;">(</span>0<span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span> |count, pharse|
      count += 1 <span style="color: #859900; font-weight: bold;">if</span> pharse =~ content
      count
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

doc = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"off and running, make mistake,hello world, my way or the \</span>
<span style="color: #2aa198;">highway does the trick"</span><span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">puts</span> doc.number_of_cliches

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">3                                              #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>我可以看到上面代码中,再次使用了inject.
</li>
<li>这段代码经历了时间的考验,得到了很多人的认同,所以想不加更改的加入到一个新的
和原来完全没有关系的class(叫做ElectronicBook)里面.
</li>
<li>在其他语言里面,我们可能会把这段代码提交到一个公共的base class,比如叫做Tome,
把number_of_cliches放入Tome,然后让ElectronicBook和Document都去继承Tome.这种
做法评价起来也就是将将能用.如果公用的代码很多,也不方便重构到共同的base class里面
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-16-2" class="outline-3">
<h3 id="sec-16-2">Mixin Modules to the Rescue</h3>
<div class="outline-text-3" id="text-16-2">
<ul class="org-ul">
<li>Ruby当然有更好的解决方案啦.那就是使用Module进行mixin. 首先把number_of_cliche
     放入一个module里面
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">WritingQuality</span>
  <span style="color: #b58900;">CLICHES</span> =<span style="color: #2aa198;">[</span> <span style="color: #2aa198;">/play fast and loose/</span>,
             <span style="color: #2aa198;">/make no mistake/</span>,
             <span style="color: #2aa198;">/does the trick/</span>,
             <span style="color: #2aa198;">/off and running/</span>,
             <span style="color: #2aa198;">/my way or the highway/</span>
           <span style="color: #2aa198;">]</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">number_of_cliches</span>
    <span style="color: #b58900;">CLICHES</span>.inject<span style="color: #2aa198;">(</span>0<span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span> |count, phrae|
      count += 1 <span style="color: #859900; font-weight: bold;">if</span> pharse =~content
      count
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>注意, number_of_cliches在这里是一个instance method in the module(没有self),
而有self的叫做model-level method
</li>
<li>然后我们在两个class里面都include 这个module
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">WritingQuality</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Lots of stuff omitted...</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">ElectronicBook</span> &lt; <span style="color: #b58900;">ElectronicText</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">WritingQuality</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Lots of stuff omitted...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>Module的魅力,还在于能够在一个代码里面include多个module,这更减小了代码量,提
高了代码质量,非常灵活
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">ElectronicBook</span> &lt; <span style="color: #b58900;">ElectronicText</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">WritingQuality</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">ProjectManagement</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">AuthorAccountTracking</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Lots of stuff omitted</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-16-3" class="outline-3">
<h3 id="sec-16-3">Extending a Module</h3>
<div class="outline-text-3" id="text-16-3">
<ul class="org-ul">
<li>上面的做法,是把某个module里面的代码引入到某个class里面,成为其"instance method",
如果我想让module里面的代码变成"class method",那么就应该这样
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">Finders</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">find_by_name</span><span style="color: #2aa198;">(</span>name<span style="color: #2aa198;">)</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Find a doc by name</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">find_by_id</span><span style="color: #2aa198;">(</span>doc_id<span style="color: #2aa198;">)</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Find a doc by id</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Most of the class omitted</span>
  <span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; <span style="color: #859900; font-weight: bold;">self</span>
    <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Finders</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>这实在是一招"语法糖"了,需要细细解释:
<ul class="org-ul">
<li>首先,我们的method在Module里面都是普通的instance method
</li>
<li>其次,我们使用了class &lt;&lt; self, 这里的self指的是类Class的instance(Document),
引入了Finder的话,那么就让instance Document有了两个singleton method.
</li>
<li>instance Document的singleton method,其实也就是class Document的class method
从使用方法就看出来了.都是调用Document(而不是其instance,比如doc)
<div class="org-src-container">

<pre class="src src-ruby">war_and_peace = <span style="color: #b58900;">Document</span>.find_by_name<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'War And Peace'</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>把module中的method作为singleton method引入Class的instance的做法,一是太难以
为新手所理解,二来使用频繁.所以Ruby直接发明了一个关键字extend
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">Finders</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Most of the class omitted</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>这样一写,你的Document也就可以使用Document.find_by_name和Document.find_by_id
     了
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-16-4" class="outline-3">
<h3 id="sec-16-4">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-16-4">
<ul class="org-ul">
<li>Module插入的这种方法,和singleton插入的方法很类似,都是编译器默默的为你生成一
个"中间的状态".
<pre class="example">
+-----------+
|  Object   |
|           |
+-----^-----+
      |
      +-----------+
                  |
            +--------------+
            |WritingQuality|
            |              |
            +-----+--------+
                  |
      +-----------+
      |
+-----------+
|  Document |
|           |
+-----------+
</pre>
</li>
<li>但是你在使用class 函数的时候(mix in了),是发现不了中间状态的.但是你使用
Instance_Name.kind_of?(ModuleName)是可以发现你是否include或者extend了这个
module的. 注意一定要使用instance来调用kind_of?
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M1</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M2</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Foo</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">M1</span>
  <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">M2</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #b58900;">Foo</span>.class
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"---Foo.new is a instance---"</span>
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #b58900;">Foo</span>.new.kind_of?<span style="color: #2aa198;">(</span><span style="color: #b58900;">M1</span><span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #b58900;">Foo</span>.kind_of?<span style="color: #2aa198;">(</span><span style="color: #b58900;">M1</span><span style="color: #2aa198;">)</span>

<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"---Foo is a class Class's instance---"</span>
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #b58900;">Foo</span>.kind_of?<span style="color: #2aa198;">(</span><span style="color: #b58900;">M2</span><span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #b58900;">Foo</span>.new.kind_of?<span style="color: #2aa198;">(</span><span style="color: #b58900;">M2</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Class                                          #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">---Foo.new is a instance---                    #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">true                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">false                                          #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">---Foo is a class Class's instance---          #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">true                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">false                                          #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>ancestors函数可以返回完整的"继承上的先驱", 但是只有include的,没有extend的
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M1</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">M2</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Foo</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">M1</span>
  <span style="color: #657b83; font-weight: bold;">extend</span> <span style="color: #b58900;">M2</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">p</span> <span style="color: #b58900;">Foo</span>.ancestors

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[Foo, M1, Object, Kernel, BasicObject]         #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>因为从原理上来讲,其实Module是创建了一个"隐藏的superclass",所以module引入的这
些函数都是从"superclass"来的"遗产". 所以当继承序列后面的class不想使用这些method
的时候,它们可以选择override这些函数(重新写一个函数,来掩盖原来的函数)
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  incldue <span style="color: #b58900;">WritingQuality</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">For Political Book, cliche's number is None</span>
<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">PoliticalBook</span> &lt; <span style="color: #b58900;">Document</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">number_of_cliches</span>
    0
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>由于include一次module就会引入一个"隐藏的superclass", 多次include以后,多个
superclass排列的顺序是,先来的最root,后来的最接近当前的class,所以如果在多个被
include的module里面有同名的函数的话,最后include的module里面的函数会最终获得
胜利(当然,如果当前class也实现了一份,它是最最会获得胜利的)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-16-5" class="outline-3">
<h3 id="sec-16-5">In the Wild</h3>
<div class="outline-text-3" id="text-16-5">
<ul class="org-ul">
<li>Rails代码里面使用Module定义了无数的help function
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">ActionView</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Huge amouts of code and helpful documentation omitted...</span>
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">Helpers</span>
    <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">FormHelper</span>
      <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">label</span><span style="color: #2aa198;">(</span>object_name, method, text = <span style="color: #268bd2; font-weight: bold;">nil</span>, options = <span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>
        <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
      <span style="color: #859900; font-weight: bold;">end</span>

      <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">radio_button</span><span style="color: #2aa198;">(</span>ojbect_name, method, tag_value, options=<span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>
      <span style="color: #859900; font-weight: bold;">end</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>Module的另一大用处"放常量", 被sqlite3 gem使用的恰到好处
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900;">ErrorCode</span>
  <span style="color: #b58900;">OK</span>          = 0     <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Successful result</span>
  <span style="color: #b58900;">ERROR</span>       = 1     <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">SQL error or missing database</span>
  <span style="color: #b58900;">INTERNAL</span>    = 2     <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">An internal logic error in SQLite</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>前面说过常量要这样使用ErrorCode::OK, 但是你include了以后,肯定是可以直接使用的
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">SomeSQLiteApplication</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">ErrorCode</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">print_status_message</span><span style="color: #2aa198;">(</span>status<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">if</span> status == <span style="color: #b58900;">ERROR</span>
      <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"It failed!"</span>
    <span style="color: #859900; font-weight: bold;">elsif</span> status == <span style="color: #b58900;">OK</span>
      <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"It worked!"</span>
    <span style="color: #859900; font-weight: bold;">else</span>
      <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Status was </span><span style="color: #268bd2;">#{status}</span><span style="color: #2aa198;">"</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17">Chapter 17: Use Blocks to Iterate</h2>
<div class="outline-text-2" id="text-17">
<ul class="org-ul">
<li>code block是Ruby的瑞士军刀,基本上到处都会有code block的影子
</li>
</ul>
</div>
<div id="outline-container-sec-17-1" class="outline-3">
<h3 id="sec-17-1">A Quick Review of Code Blocks</h3>
<div class="outline-text-3" id="text-17-1">
<ul class="org-ul">
<li>在Ruby中,你可以把code block放到一个函数的后面,像如下一样使用
<div class="org-src-container">

<pre class="src src-ruby">do_domething <span style="color: #859900; font-weight: bold;">do</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Hello from inside the block"</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>或者使用一个{}来替代do/end
<div class="org-src-container">

<pre class="src src-ruby">do_something <span style="color: #2aa198;">{</span><span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Hello from inside the block"</span><span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>其原理简单点说,就是每当你把一个code block "附着"在某个函数的后面的时候,其实
Ruby解释器内部是把这个code block包裹成一个"秘密参数", 然后把"秘密参数"发送
给这个函数.
</li>
<li>这个秘密参数也可以再函数内部,通过block_gen?来判断
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">do_something</span>
  <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">block_given?</span>
<span style="color: #859900; font-weight: bold;">end</span>

do_something <span style="color: #2aa198;">{</span><span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"testing"</span><span style="color: #2aa198;">}</span>
<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"-----------------------&gt;"</span>
do_something

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">testing                                        #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">-----------------------&gt;                       #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>code block和函数之间是可以相互交流数据的:
<ul class="org-ul">
<li>从函数到code block这个方向的交流方式是"参数":函数可以再yield后面加一个参
数,然后这个参数就可以在code block里面使用了
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">do_something_with_an_arg</span>
  <span style="color: #859900; font-weight: bold;">yield</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Hello World"</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">block_given?</span>
<span style="color: #859900; font-weight: bold;">end</span>

do_something_with_an_arg <span style="color: #859900; font-weight: bold;">do</span> |message|
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"The message is </span><span style="color: #268bd2;">#{message}</span><span style="color: #2aa198;">"</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The message is Hello World                     #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>从code block到函数这个方向的交流方式是"返回值":code block的最后一行(或者
return的数据)会作为yield函数的返回值在method里面有所体现
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">print_the_value_returned_by_the_block</span>
  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">block_given?</span>
    value = <span style="color: #859900; font-weight: bold;">yield</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"The block returned </span><span style="color: #268bd2;">#{value}</span><span style="color: #2aa198;">"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

print_the_value_returned_by_the_block <span style="color: #2aa198;">{</span>3.14159 / 4.0<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">0.7853975                                      #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</li>
<li>从code block和函数的相互交流方式来看. yield就是code block的代表:
<ul class="org-ul">
<li>yield函数的参数,会作为code block的变量
</li>
<li>code block的返回值,会作为yield函数的返回值
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-2" class="outline-3">
<h3 id="sec-17-2">One Word after Another</h3>
<div class="outline-text-3" id="text-17-2">
<ul class="org-ul">
<li>我们可以试着给自己的Document类添加一个遍历的函数each_word, 其也是把每一个元
素都作为yield的参数,yield的参数也就是code block的变量啦
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:content</span>, <span style="color: #268bd2; font-weight: bold;">:words</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>content<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@content</span> = content
    <span style="color: #268bd2;">@words</span> = content.split
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">each_word</span>
    word_array = words
    index = 0
    <span style="color: #859900; font-weight: bold;">while</span> index &lt; words.size
      <span style="color: #859900; font-weight: bold;">yield</span><span style="color: #2aa198;">(</span>word_array<span style="color: #b58900;">[</span>index<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
      index += 1
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

d = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Life is like a box of ...'</span><span style="color: #2aa198;">)</span>
d.each_word <span style="color: #2aa198;">{</span>|word| <span style="color: #657b83; font-weight: bold;">puts</span> word<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Life                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">is                                             #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">like                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">a                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">box                                            #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">of                                             #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">...                                            #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>当然了,我们真正实现each_word的方法是依赖已经存在的Array#each函数
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">each_word</span>
  words.each <span style="color: #2aa198;">{</span>|word| <span style="color: #859900; font-weight: bold;">yield</span><span style="color: #b58900;">(</span>word<span style="color: #b58900;">)</span><span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-3" class="outline-3">
<h3 id="sec-17-3">As Many Iterators as You Like</h3>
<div class="outline-text-3" id="text-17-3">
<ul class="org-ul">
<li>除了each_word,我们还可以有很多很多的iterator, 因为这种函数总是很受欢迎,但是
命名规则一定是each_xxx
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-4" class="outline-3">
<h3 id="sec-17-4">Iterating over the Ethereal</h3>
<div class="outline-text-3" id="text-17-4">
<ul class="org-ul">
<li>Ruby的iterator甚至可以在"不创建collection"的情况下,就打印出"某个臆想的
collection"所有的数据
<div class="org-src-container">

<pre class="src src-ruby">12.times <span style="color: #2aa198;">{</span>|x| <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"The number is </span><span style="color: #268bd2;">#{x}</span><span style="color: #2aa198;">"</span><span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The number is 0                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The number is 1                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The number is 2                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The number is 3                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The number is 4                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The number is 5                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The number is 6                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The number is 7                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The number is 8                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The number is 9                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The number is 10                               #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The number is 11                               #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>我们也可以通过code block来创建这种"虚拟的collection",比如Document中,我们想
把所有的单词"两两"结合的打印出来.于是就有了下面的代码.可是我们从来没有创建
过这种"两个"单词为一组的,长度为4的array
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>content<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@content</span> = content
    <span style="color: #268bd2;">@words</span> = content.split
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">each_word_pair</span>
    word_array = words
    index = 0
    <span style="color: #859900; font-weight: bold;">while</span> index &lt; <span style="color: #2aa198;">(</span>word_array.size-1<span style="color: #2aa198;">)</span>
      <span style="color: #859900; font-weight: bold;">yield</span> word_array<span style="color: #2aa198;">[</span>index<span style="color: #2aa198;">]</span>, word_array<span style="color: #2aa198;">[</span>index+1<span style="color: #2aa198;">]</span>
      index += 1
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

doc = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'I love donuts mmmm donuts'</span><span style="color: #2aa198;">)</span>
doc.each_word_pair<span style="color: #2aa198;">{</span>|first, second| <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"</span><span style="color: #268bd2;">#{first}</span><span style="color: #2aa198;"> </span><span style="color: #268bd2;">#{second}</span><span style="color: #2aa198;">"</span><span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">I love                                         #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">love donuts                                    #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">donuts mmmm                                    #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">mmmm donuts                                    #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-5" class="outline-3">
<h3 id="sec-17-5">Enumerable: Your Iterator on Steroids</h3>
<div class="outline-text-3" id="text-17-5">
<ul class="org-ul">
<li>前面说过,你的iterator最好是以each_xx命名,而最重要的那个iterator,一定要以each
来命名,这是有原因的:因为Ruby有一个很好用的Module Enumerable, 它可以mix in到
一个class起作用,前提是:这个class的iterator的名字是each!(因为each已经写死在
Enumerable的代码里面了)
</li>
<li>Enumerable的功能代码非常的多,比如, each实现之后,再加include Enumerable就能
使用Enumerable提供的helper函数
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Enumerable</span>

  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:words</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>content<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@content</span> = content
    <span style="color: #268bd2;">@words</span> = content.split
  <span style="color: #859900; font-weight: bold;">end</span>


  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">each</span>
    words.each <span style="color: #2aa198;">{</span>|word| <span style="color: #859900; font-weight: bold;">yield</span><span style="color: #b58900;">(</span>word<span style="color: #b58900;">)</span><span style="color: #2aa198;">}</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

doc = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Go ahead make my day'</span><span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">puts</span> doc.include?<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"make"</span><span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">puts</span> doc.include?<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Punk"</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">true                                           #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">false                                          #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>Enumerable还提供了each_cons, 也就是会把相邻的n个参数组成数组,并返回
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Enumerable</span>

  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:words</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>content<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@content</span> = content
    <span style="color: #268bd2;">@words</span> = content.split
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">each</span>
    words.each <span style="color: #2aa198;">{</span>|word| <span style="color: #859900; font-weight: bold;">yield</span><span style="color: #b58900;">(</span>word<span style="color: #b58900;">)</span><span style="color: #2aa198;">}</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

doc = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Go ahead make my day'</span><span style="color: #2aa198;">)</span>
doc.each_cons<span style="color: #2aa198;">(</span>2<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>|array| <span style="color: #657b83; font-weight: bold;">p</span> array<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">["Go", "ahead"]                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">["ahead", "make"]                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">["make", "my"]                                 #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">["my", "day"]                                  #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>如果你提供了&lt;=&gt;操作函数的话(也就是你的instance可以比较大小),那么你还可以使
用sort函数
</li>
<li>Array其实也include Enumerable,所以上面的这些method,它都有.
</li>
<li>除了提供函数, Enumerable还在内部实现了Enumerator class
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">include</span> <span style="color: #b58900;">Enumerable</span>

  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:words</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>content<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@content</span> = content
    <span style="color: #268bd2;">@words</span> = content.split
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">each</span>
    words.each <span style="color: #2aa198;">{</span>|word| <span style="color: #859900; font-weight: bold;">yield</span> word<span style="color: #2aa198;">}</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">each_characters</span>
    index = 0
    <span style="color: #859900; font-weight: bold;">while</span> index &lt; <span style="color: #268bd2;">@content</span>.size
      <span style="color: #859900; font-weight: bold;">yield</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">@content</span><span style="color: #b58900;">[</span>index<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
      index += 1
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

doc = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'hello world, american'</span><span style="color: #2aa198;">)</span>
enum = <span style="color: #b58900;">Enumerator</span>.new<span style="color: #2aa198;">(</span>doc, <span style="color: #268bd2; font-weight: bold;">:each</span><span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">p</span> enum.sort
enum = <span style="color: #b58900;">Enumerator</span>.new<span style="color: #2aa198;">(</span>doc, <span style="color: #268bd2; font-weight: bold;">:each_characters</span><span style="color: #2aa198;">)</span>
<span style="color: #657b83; font-weight: bold;">p</span> enum.sort

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">["american", "hello", "world,"]                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[" ", " ", ",", "a", "a", "c", "d", "e", "e",  #</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">"h", "i", "l", "l", "l", "m", "n", "o", "o",  #</span>
<span style="color: #93a1a1;">#  </span><span style="color: #93a1a1;">"r", "r", "w"]                                #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>我们可以从上面的例子看到Enumerator class的初始化方法是提供两个参数:
<ol class="org-ol">
<li>collection: 把我们的Document的实例化成员doc看成是一个我们自己customize的
collection.
</li>
<li>遍历方法: 提供了collection,我们还可以提供默认的遍历方法: each_xx
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-6" class="outline-3">
<h3 id="sec-17-6">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-17-6">
<ul class="org-ul">
<li>自己书写的iterator是为code block服务的,但是code block很可能是其他人的code,
如何保证你的代码不会被别人中断(比如通过exception). 下面的例子就是这种情况,
我们再iterator申请了某个资源,但是code block使用的时候就直接exception了(去了
其他不知道哪里的代码流程)
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">iterator code in one place</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">each_name</span>
  name_server = open_name_server <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Get some expensive resource</span>
  <span style="color: #859900; font-weight: bold;">while</span> name_server.has_more?
    <span style="color: #859900; font-weight: bold;">yield</span> name_server.read_name
  <span style="color: #859900; font-weight: bold;">end</span>
  name_server.close             <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">may never closed</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">code bloc code in somewhere else</span>
doc.each_word <span style="color: #859900; font-weight: bold;">do</span> |word|
  <span style="color: #657b83; font-weight: bold;">raise</span> <span style="color: #2aa198;">'boom'</span> <span style="color: #859900; font-weight: bold;">if</span> word == <span style="color: #2aa198;">'now'</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>解决的办法当然有: ensure
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">each_name</span>
  name_server = open_name_server <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Get some expensive resouce</span>
  <span style="color: #859900; font-weight: bold;">begin</span>
    <span style="color: #859900; font-weight: bold;">while</span> name_server.has_more?
      <span style="color: #859900; font-weight: bold;">yield</span> name_server.read_name
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">ensure</span>
    name_server.close           <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Close the expensive resource</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>不止exception, break 和显式的return都会触发ensure.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-7" class="outline-3">
<h3 id="sec-17-7">In the Wild</h3>
<div class="outline-text-3" id="text-17-7">
<ul class="org-ul">
<li>Array和Hash有each不奇怪,奇怪的是Dir也有each函数
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Contents of /etc directory:"</span>
etc_dir = <span style="color: #b58900;">Dir</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"/Users/hfeng/tmp"</span><span style="color: #2aa198;">)</span>
etc_dir.each <span style="color: #2aa198;">{</span>|entry| <span style="color: #657b83; font-weight: bold;">puts</span> entry<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Contents of /etc directory:                    #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">.                                              #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">..                                             #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">passwd.txt                                     #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">sel-intro.txt                                  #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>还有一个非常有趣的函数, Resolv#each_address:能够找出某个域名的所有的ip地址
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #657b83; font-weight: bold;">require</span> <span style="color: #2aa198;">'resolv'</span>
<span style="color: #b58900;">Resolv</span>.each_address<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"www.google.com"</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>|x| <span style="color: #657b83; font-weight: bold;">puts</span> x<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">173.194.127.179                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">173.194.127.180                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">173.194.127.176                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">173.194.127.177                                #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">173.194.127.178                                #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18">Chapter 18: Execute Around with a Block</h2>
<div class="outline-text-2" id="text-18">
</div><div id="outline-container-sec-18-1" class="outline-3">
<h3 id="sec-18-1">Add a Little Logging</h3>
<div class="outline-text-3" id="text-18-1">
<ul class="org-ul">
<li>Logging是非常好的debug方式, 所以我们在创建下面的应用的时候,非常希望创建一个
log来记录异常
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">SomeApplication</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>logger<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@logger</span> = logger
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">do_something</span>
    <span style="color: #859900; font-weight: bold;">begin</span>
      <span style="color: #268bd2;">@logger</span>.debug<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Starging Document load'</span><span style="color: #2aa198;">)</span>
      doc = <span style="color: #b58900;">Document</span>.load<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'resume.txt'</span><span style="color: #2aa198;">)</span>
      <span style="color: #268bd2;">@logger</span>.debug<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Completed Document load'</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">rescue</span>
      <span style="color: #268bd2;">@logger</span>.error<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Load failed!'</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">end</span>

    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Do something interesting with the document</span>
    <span style="color: #859900; font-weight: bold;">begin</span>
      <span style="color: #268bd2;">@logger</span>.debug<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Starting Document save'</span><span style="color: #2aa198;">)</span>
      doc.save
      <span style="color: #268bd2;">@logger</span>.debug<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Completed Document save'</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">rescue</span>
      <span style="color: #268bd2;">@logger</span>.error<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Save failed!'</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-2" class="outline-3">
<h3 id="sec-18-2">Carring the Answers Back</h3>
<div class="outline-text-3" id="text-18-2">
<ul class="org-ul">
<li>上面做法的缺点是看起来很不清晰,而且,大部分是重复的代码:在操作之前怎样怎样,
在操作之后,怎样怎样. 我们可以使用code block大幅减少代码
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">SomeApplication</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">do_something</span>
    with_logging<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'load'</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span><span style="color: #268bd2;">@doc</span> = <span style="color: #b58900;">Document</span>.load<span style="color: #b58900;">(</span><span style="color: #2aa198;">'resume.txt'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">}</span>

    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Do something with the document</span>
    with_logging<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'save'</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span><span style="color: #268bd2;">@doc</span>.save<span style="color: #2aa198;">}</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Rest of the class omitted...</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">with_logging</span><span style="color: #2aa198;">(</span>description<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">begin</span>
      <span style="color: #268bd2;">@logger</span>.debug<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Staring #{description}'</span><span style="color: #2aa198;">)</span>
      <span style="color: #859900; font-weight: bold;">yield</span>
      <span style="color: #268bd2;">@logger</span>.debug<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Completed #{description}'</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">rescue</span>
      <span style="color: #268bd2;">@logger</span>.error<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'#{description} failed'</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>with_logging的代码非常通用,我们可以用来处理各种函数.其原理就是在某个操作的
"前后"进行log记录
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-3" class="outline-3">
<h3 id="sec-18-3">When It Absolutely Must Happen</h3>
<div class="outline-text-3" id="text-18-3">
<ul class="org-ul">
<li>其实code block非常自由,你也可以选择在"前"或者"后"记录log
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">log_before</span><span style="color: #2aa198;">(</span>description<span style="color: #2aa198;">)</span>
  <span style="color: #268bd2;">@logger</span>.debug<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Starting #{description}'</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">log_after</span><span style="color: #2aa198;">(</span>description<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">yield</span>
  <span style="color: #268bd2;">@logger</span>.debug<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Done #{description}'</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-4" class="outline-3">
<h3 id="sec-18-4">Setting Up Objects with an Initialization Block</h3>
<div class="outline-text-3" id="text-18-4">
<ul class="org-ul">
<li>你甚至可以使用code block来初始化initialize函数
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #657b83; font-weight: bold;">attr_accessor</span> <span style="color: #268bd2; font-weight: bold;">:title</span>, <span style="color: #268bd2; font-weight: bold;">:author</span>, <span style="color: #268bd2; font-weight: bold;">:content</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>title, author, content= <span style="color: #2aa198;">''</span><span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@title</span> = title
    <span style="color: #268bd2;">@author</span> = author
    <span style="color: #268bd2;">@content</span> = content
    <span style="color: #859900; font-weight: bold;">yield</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #657b83; font-weight: bold;">block_given?</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

new_doc = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'US Constitution'</span>, <span style="color: #2aa198;">'Madison'</span>, <span style="color: #2aa198;">''</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span> |d|
  d.content &lt;&lt; <span style="color: #2aa198;">'We the people'</span>
  d.content &lt;&lt; <span style="color: #2aa198;">'In order to form a more perfect union'</span>
  d.content &lt;&lt; <span style="color: #2aa198;">'provide for the common defense'</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">puts</span> new_doc.content

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">We the peopleIn order to form a more perfect   #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">unionprovide for the common defense            #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-5" class="outline-3">
<h3 id="sec-18-5">Dragging Your Scope along with the Block</h3>
<div class="outline-text-3" id="text-18-5">
<ul class="org-ul">
<li>书写这种"around method"的关键,是要了解输入是什么,输出是什么
</li>
<li>同样的,在函数中产生对象,然后传入到code block中,也是正确的写法,比如我们要打
开一个数据库,然后把数据库"句柄"放入到code block中去
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">with_database_connection</span><span style="color: #2aa198;">(</span>connection_info<span style="color: #2aa198;">)</span>
  connection = <span style="color: #b58900;">Database</span>.new<span style="color: #2aa198;">(</span>connection_info<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">begin</span>
    <span style="color: #859900; font-weight: bold;">yield</span><span style="color: #2aa198;">(</span>connection<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">ensure</span>
    connection.close
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-6" class="outline-3">
<h3 id="sec-18-6">Carrying the Answers Back</h3>
<div class="outline-text-3" id="text-18-6">
<ul class="org-ul">
<li>"有来就有往", 有时候我们也希望code block能够返回一些代码回来.我们前面讲过
yield函数的返回值就是code block的返回值. 但是"around method"后面可能会加入
一些代, 所以yield可能不是最后一句代码, 所以我们要手动设计一个变量,然后返回
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">do_something_silly</span>
  with_logging<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Compute miles in a light year'</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span>
    186000 * 60 * 60 * 24 * 365
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">with_logging</span><span style="color: #2aa198;">(</span>description<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">begin</span>
    <span style="color: #268bd2;">@logger</span>.debug<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Starting #{description}'</span><span style="color: #2aa198;">)</span>
    return_value = <span style="color: #859900; font-weight: bold;">yield</span>
    <span style="color: #268bd2;">@logger</span>.debug<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Completed #{description}'</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> return_value
  <span style="color: #859900; font-weight: bold;">rescue</span>
    <span style="color: #268bd2;">@logger</span>.error<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'#{description} failed!'</span><span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-7" class="outline-3">
<h3 id="sec-18-7">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-18-7">
<ul class="org-ul">
<li>要把with_logging这种"around method"看做是像while或者if这种常用的高度,才能足
够的"抽象",取出"with_logging"这种名字,而不是"execute_between_logging_statement"
这种名字
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-8" class="outline-3">
<h3 id="sec-18-8">In the Wild</h3>
<div class="outline-text-3" id="text-18-8">
<ul class="org-ul">
<li>在ruby代码中有很多使用code block,来完成"around method"的例子
</li>
<li>打开数据库,然后把"句柄"给code block,然后自己负责释放的例子,其实在Ruby代码中,
<a href=":open就是这么实现的">:open就是这么实现的</a>.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">No open file here</span>

<span style="color: #b58900;">File</span>.open<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'/etc/passwd'</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span> |f|
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">File open here!</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Begin cracking the passwords on Russ' computer...</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">The password file is guaranteed to be closed here</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19">Chapter 19: Save Blocks to Execute Later</h2>
<div class="outline-text-2" id="text-19">
<ul class="org-ul">
<li>前面两章,我们讲了code block的两个作用:
<ul class="org-ul">
<li>做循环
</li>
<li>做around method
</li>
</ul>
</li>
<li>这一章讲如何把你的代码暂时保存,一会过来执行
</li>
</ul>
</div>
<div id="outline-container-sec-19-1" class="outline-3">
<h3 id="sec-19-1">Explicit Blocks</h3>
<div class="outline-text-3" id="text-19-1">
<ul class="org-ul">
<li>前面我们的函数体里面,是没有明确写出code block的: code block是作为一个implict
的参数传入的. 然后根据block_given?的值来判断是否提供,除了这种方法以外,我们还
可以使用"explicit"的把code block作为函数的一个参数
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">run_the_block</span><span style="color: #2aa198;">(</span>&amp;that_block<span style="color: #2aa198;">)</span>
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"About to run the block"</span>
  that_block.call <span style="color: #859900; font-weight: bold;">if</span> that_block
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Done running the block"</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-19-2" class="outline-3">
<h3 id="sec-19-2">The Call Back Problem</h3>
<div class="outline-text-3" id="text-19-2">
<ul class="org-ul">
<li>假设你现在碰到了一个问题,一个文本编辑器想要使用你的Document class. 它想在你
在"载入"和"保存"的时候,得到提醒.
</li>
<li>常规的做法是为这两个行为设计两个listener class
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DocumentSaveListener</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">on_save</span><span style="color: #2aa198;">(</span>doc, path<span style="color: #2aa198;">)</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">" Hey, I've been saved!"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DocumentLoadListener</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">on_load</span><span style="color: #2aa198;">(</span>doc, path<span style="color: #2aa198;">)</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">" Hey, I've been loaded!"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>然后再Document里面注入这些listener
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  attr_accesor <span style="color: #268bd2; font-weight: bold;">:load_listener</span>
  attr_accesor <span style="color: #268bd2; font-weight: bold;">:save_listener</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">load</span><span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@content</span> = <span style="color: #b58900;">File</span>.read<span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    load_listener.on_load<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, path<span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">if</span> load_listener
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">save</span><span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    <span style="color: #b58900;">File</span>.open<span style="color: #2aa198;">(</span>path, <span style="color: #2aa198;">'w'</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span> |f| f.print<span style="color: #b58900;">(</span><span style="color: #268bd2;">@content</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">}</span>
    save_listener.on_save<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, path<span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">if</span> save_listener
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-19-3" class="outline-3">
<h3 id="sec-19-3">Banking Blocks</h3>
<div class="outline-text-3" id="text-19-3">
<ul class="org-ul">
<li>不说传统的好坏吧,反正我们是为了引出Ruby是如何做listener的
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>content<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@content</span> = content
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">on_save</span><span style="color: #2aa198;">(</span>&amp;block<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@save_listener</span> = block
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">on_load</span><span style="color: #2aa198;">(</span>&amp;block<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@load_listener</span> = block
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">load</span><span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">@content = File.read(path)</span>
    <span style="color: #268bd2;">@load_listener</span>.call <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">@load_listener</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">save</span><span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">File.open(path, 'w') {|f| f.print(@content)}</span>
    <span style="color: #268bd2;">@save_listener</span>.call <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">@save_listener</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

my_doc = <span style="color: #b58900;">Document</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Block Based Example'</span><span style="color: #2aa198;">)</span>

my_doc.on_load <span style="color: #859900; font-weight: bold;">do</span> |doc|
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Hey, I've been loaded! </span><span style="color: #268bd2;">#{doc}</span><span style="color: #2aa198;">"</span>
<span style="color: #859900; font-weight: bold;">end</span>

my_doc.on_save <span style="color: #859900; font-weight: bold;">do</span> |doc|
  <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Hey, I've been saved! </span><span style="color: #268bd2;">#{doc}</span><span style="color: #2aa198;">"</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"----------------------&gt;"</span>
my_doc.load<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #2aa198;">)</span>
my_doc.save<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">nil</span><span style="color: #2aa198;">)</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">----------------------&gt;                        #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Hey, I've been loaded!                         #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Hey, I've been saved!                          #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>初始化的时候就给了on_save函数的code block(也就是puts saved什么的), 但是不会
马上执行,一定要打调用Document#save或者Document#load的时候才会调用,所以叫做
bank么
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-19-4" class="outline-3">
<h3 id="sec-19-4">Saving Code Blocks for Lazy Initialization</h3>
<div class="outline-text-3" id="text-19-4">
<ul class="org-ul">
<li>假设我们有新的需求,再读取存档的文档的时候,我们倾向于只读取题目和作者,只有在
个别需要的时候才读取内容,所以我们立马有了如下的代码
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">ArchivalDocument</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:title</span>, <span style="color: #268bd2; font-weight: bold;">:author</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>title, author, path<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@title</span> = title
    <span style="color: #268bd2;">@author</span> = author
    <span style="color: #268bd2;">@path</span> = path
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">content</span>
    <span style="color: #268bd2;">@content</span> ||= <span style="color: #b58900;">File</span>.read<span style="color: #2aa198;">(</span><span style="color: #268bd2;">@path</span><span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>第一个例子的肯定能做到lazy initialization,因为直到用到content的时候才会用path
去读取相应内容. 但是,这种方法有一定的局限性:你只能使用path来打开文件.如果文
件是以其他形式,比如HTTP或者FTP的方式来打开的话,那么就只能望洋兴叹了.幸好, code
block能够解决这个问题
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">BlockBasedArchivalDocument</span>
  <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:title</span>, <span style="color: #268bd2; font-weight: bold;">:author</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>title, author, &amp;block<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@title</span> = title
    <span style="color: #268bd2;">@author</span> = author
    <span style="color: #268bd2;">@initializer_block</span> = block
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">content</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">@initializer_block</span>
      <span style="color: #268bd2;">@content</span> = <span style="color: #268bd2;">@initializer_block</span>.call
      <span style="color: #268bd2;">@initializer_block</span> = <span style="color: #268bd2; font-weight: bold;">nil</span>
    <span style="color: #859900; font-weight: bold;">end</span>
    <span style="color: #268bd2;">@content</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">You can use all kind of resource</span>
file_doc = <span style="color: #b58900;">BlockBasedArchivalDocument</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'file'</span>, <span style="color: #2aa198;">'russ'</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span>
  <span style="color: #b58900;">File</span>.read<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'some_text.txt'</span><span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">end</span>

google_doc = <span style="color: #b58900;">BlockBasedArchivalDocument</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'http'</span>, <span style="color: #2aa198;">'russ'</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span>
  <span style="color: #b58900;">Net</span>::<span style="color: #b58900;">HTTP</span>.get_response<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'www.google.com'</span>, <span style="color: #2aa198;">'/index.html'</span><span style="color: #2aa198;">)</span>.body
<span style="color: #859900; font-weight: bold;">end</span>

boring_doc = <span style="color: #b58900;">BlockBasedArchivalDocument</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'sily'</span>, <span style="color: #2aa198;">'russ'</span><span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">do</span>
  <span style="color: #2aa198;">'Ya'</span> * 100
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>上面的代码中,"有且只有"当你调用content函数的时候才会真正的调用类似File.read
这样的代码.否则这些代码都是不会调用的.真正的做到了lazy initialization
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-19-5" class="outline-3">
<h3 id="sec-19-5">Instant Block objects</h3>
<div class="outline-text-3" id="text-19-5">
<ul class="org-ul">
<li>code block其实只是Proc这个类的instance
</li>
<li>如果你像创造一个code block(Proc的instance), 但是却不像让某个method 和它有联
系(而是保留自己的名分,以后给自己喜欢的method使用).你可以使用lambda
</li>
<li>lambda函数的输入为code block,输出为Proc object
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Document</span>
  <span style="color: #b58900;">DEFAULT_LOAD_LISTENER</span> = <span style="color: #657b83; font-weight: bold;">lambda</span> <span style="color: #859900; font-weight: bold;">do</span> |doc, path|
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Loaded: </span><span style="color: #268bd2;">#{path}</span><span style="color: #2aa198;">"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-19-6" class="outline-3">
<h3 id="sec-19-6">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-19-6">
<ul class="org-ul">
<li>还有一种最原始的创建的Proc objec他方法是Proc.new
<div class="org-src-container">

<pre class="src src-ruby">from_proc_new = <span style="color: #b58900;">Proc</span>.new <span style="color: #2aa198;">{</span><span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"hello from a block"</span><span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>lambda的效果和Proc.new的效果是一样, 除了两个方面:
<ul class="org-ul">
<li>Proc.new object不会去检查其call 函数的参数个数. lambda创建的Proc object在
调用call的时候,会细心检查传入的参数个数
</li>
<li>Proc.new object 的code block里面如果有return的话, 代码会尝试从code block和
调用这个code block的函数"两个地方同时return". lambda创建的code block里面有
return的话,就只会从code block里面退出.
</li>
</ul>
</li>
<li>code block有一个不为人知的特性,它会把它创建的所在的local域里面的所有的local
variable都记着(都放在内存里面).所以下面的代码(使用了非常大的数组, 又在附近
创建code block),就会导致这些数组和code block会一直存在内存里面.非常浪费
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">some_method</span><span style="color: #2aa198;">(</span>doc<span style="color: #2aa198;">)</span>
  big_array = <span style="color: #b58900;">Array</span>.new<span style="color: #2aa198;">(</span>100000000<span style="color: #2aa198;">)</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Do something with big_array</span>

  doc.on_load <span style="color: #859900; font-weight: bold;">do</span> |d|
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Hey, I've been loaded!"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
<li>应对的办法很简单, 把big_array用完后,设置为nil
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">some_method</span><span style="color: #2aa198;">(</span>doc<span style="color: #2aa198;">)</span>
  big_array = <span style="color: #b58900;">Array</span>.new<span style="color: #2aa198;">(</span>100000000<span style="color: #2aa198;">)</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Do something with big_array</span>

  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">And now get rid of it!</span>
  big_array = <span style="color: #268bd2; font-weight: bold;">nil</span>

  doc.on_load <span style="color: #859900; font-weight: bold;">do</span> |d|
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Hey, I've been loaded!"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-19-7" class="outline-3">
<h3 id="sec-19-7">In the Wild</h3>
<div class="outline-text-3" id="text-19-7">
<ul class="org-ul">
<li>#TODO#
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20">Chapter 20: Use Hooks to Keep Your Program Informed</h2>
<div class="outline-text-2" id="text-20">
<ul class="org-ul">
<li>对于ruby来说,元编程没有那么深奥,其展示给我们的表象就是使用less code来让你获
得计算结果
</li>
<li>如果你能更近一步呢,你甚至可以让你的ruby代码会在如下的n种情况下被通知:
<ul class="org-ul">
<li>新的class的诞生
</li>
<li>某个method被调用
</li>
<li>application要退出的时候.
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-20-1" class="outline-3">
<h3 id="sec-20-1">Waking Up to a New Subclass</h3>
<div class="outline-text-3" id="text-20-1">
<ul class="org-ul">
<li>所谓hook,在哪里都是一个意义:一个事情(要发生)或者已经发生了.那么一段代码(叫做
hook)就会被通知.
</li>
<li>下面是一个简单的例子, inherited函数会在当前class被继承的第一瞬间,调用puts语
句.
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">SimpleBaseClass</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">inherited</span><span style="color: #2aa198;">(</span>new_subclass<span style="color: #2aa198;">)</span>
    <span style="color: #657b83; font-weight: bold;">puts</span> <span style="color: #2aa198;">"Hey </span><span style="color: #268bd2;">#{new_subclass}</span><span style="color: #2aa198;"> is now a subclass of </span><span style="color: #268bd2;">#{self}</span><span style="color: #2aa198;">"</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">ChildClassOne</span> &lt; <span style="color: #b58900;">SimpleBaseClass</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #93a1a1;">##########################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;         #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Hey ChildClassOne is now a subclass of SimpleBaseClass #</span>
<span style="color: #93a1a1;">##########################################################</span>
</pre>
</div>
</li>
<li>d
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">YAMLReader</span> &lt; <span style="color: #b58900;">DocumentReader</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">can_read?</span><span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    <span style="color: #2aa198;">/.*\.yaml/</span> =~ path
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@path</span> = path
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">read</span><span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Lots of simple YAML stuff omitted</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">XMLReader</span> &lt; <span style="color: #b58900;">DocumentReader</span>
  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">can_read?</span><span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    <span style="color: #2aa198;">/.*\.xml/</span> =~ path
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">initialize</span><span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    <span style="color: #268bd2;">@path</span> = path
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">read</span><span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Lots of simple XML stuff omitted</span>
  <span style="color: #859900; font-weight: bold;">end</span>
<span style="color: #859900; font-weight: bold;">end</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DocumentReader</span>

  <span style="color: #859900; font-weight: bold;">class</span> &lt;&lt; <span style="color: #859900; font-weight: bold;">self</span>
    <span style="color: #657b83; font-weight: bold;">attr_reader</span> <span style="color: #268bd2; font-weight: bold;">:reader_classes</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #268bd2;">@reader_classes</span> = <span style="color: #2aa198;">[]</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">read</span><span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    reader = reader_for<span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">nil</span> <span style="color: #859900; font-weight: bold;">unless</span> reader
    reader.read<span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">reader_for</span><span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    reader_class = <span style="color: #b58900;">DocumentReader</span>.reader_classes.find <span style="color: #859900; font-weight: bold;">do</span> |klass|
      klass.can_read?<span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">end</span>
    <span style="color: #859900; font-weight: bold;">return</span> reader_class.new<span style="color: #2aa198;">(</span>path<span style="color: #2aa198;">)</span> <span style="color: #859900; font-weight: bold;">if</span> reader_class
    <span style="color: #268bd2; font-weight: bold;">nil</span>
  <span style="color: #859900; font-weight: bold;">end</span>

  <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #859900; font-weight: bold;">self</span>.<span style="color: #268bd2;">inherited</span><span style="color: #2aa198;">(</span>subclass<span style="color: #2aa198;">)</span>
    <span style="color: #b58900;">DocumentReader</span>.reader_classes &lt;&lt; subclass
  <span style="color: #859900; font-weight: bold;">end</span>
  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">One critical bit omitted, but stay tuned...</span>
<span style="color: #859900; font-weight: bold;">end</span>

yam = <span style="color: #b58900;">YAMLReader</span>.new<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'cc.yaml'</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
