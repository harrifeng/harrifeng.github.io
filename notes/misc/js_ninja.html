<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>js_ninja</title>
<!-- 2017-05-02 Tue 10:45 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">js_ninja</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 01: Enter the ninja</a>
<ul>
<li><a href="#sec-1-1">The JavaScript libraries we'll be tapping</a></li>
<li><a href="#sec-1-2">Understanding the JavaScript language</a></li>
<li><a href="#sec-1-3">Cross-browser considerations</a></li>
<li><a href="#sec-1-4">Current best practices</a>
<ul>
<li><a href="#sec-1-4-1">Currrent best practice: testing</a></li>
<li><a href="#sec-1-4-2">Current best practice: performance analysis</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">Chapter 02: Arming with testing and debugging</a>
<ul>
<li><a href="#sec-2-1">Debugging code</a></li>
<li><a href="#sec-2-2">Test generation</a></li>
<li><a href="#sec-2-3">Testing frameworks</a></li>
<li><a href="#sec-2-4">The fundamentals of a test suite</a>
<ul>
<li><a href="#sec-2-4-1">The assertion</a></li>
<li><a href="#sec-2-4-2">Test groups</a></li>
<li><a href="#sec-2-4-3">Asynchronous testing</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">Chapter 03: Functions are fundamental</a>
<ul>
<li><a href="#sec-3-1">What's with the functional difference?</a>
<ul>
<li><a href="#sec-3-1-1">Why is JavaScript's functional nature important?</a></li>
<li><a href="#sec-3-1-2">Sorting with a comparator</a></li>
</ul>
</li>
<li><a href="#sec-3-2">Declarations</a>
<ul>
<li><a href="#sec-3-2-1">Scoping and functions</a></li>
</ul>
</li>
<li><a href="#sec-3-3">Invocations</a>
<ul>
<li><a href="#sec-3-3-1">From arguments to function parameters</a></li>
<li><a href="#sec-3-3-2">Invocation as a function</a></li>
<li><a href="#sec-3-3-3">Invocation as a method</a></li>
<li><a href="#sec-3-3-4">Invocation as a constructor</a></li>
<li><a href="#sec-3-3-5">Invocation with the apply() and call() methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">Chatper 04: Wielding functions</a>
<ul>
<li><a href="#sec-4-1">Anonymous functions</a></li>
<li><a href="#sec-4-2">Recursion</a>
<ul>
<li><a href="#sec-4-2-1">Recursion in named functions</a></li>
<li><a href="#sec-4-2-2">Recursion with methods</a></li>
<li><a href="#sec-4-2-3">The pilfered reference problem</a></li>
<li><a href="#sec-4-2-4">Inline named functions</a></li>
<li><a href="#sec-4-2-5">The callee property</a></li>
</ul>
</li>
<li><a href="#sec-4-3">Fun with function as objects</a>
<ul>
<li><a href="#sec-4-3-1">Storing functions</a></li>
<li><a href="#sec-4-3-2">Self-memoizing functions</a></li>
<li><a href="#sec-4-3-3">Faking array methods</a></li>
</ul>
</li>
<li><a href="#sec-4-4">Variable-length argument lists</a>
<ul>
<li><a href="#sec-4-4-1">Using apply() to supply variable arguments</a></li>
<li><a href="#sec-4-4-2">Function overloading</a></li>
</ul>
</li>
<li><a href="#sec-4-5">Checking for functions</a></li>
</ul>
</li>
<li><a href="#sec-5">Chapter 05: Closing in on closures</a>
<ul>
<li><a href="#sec-5-1">How closuers work</a></li>
<li><a href="#sec-5-2">Putting closures to work</a>
<ul>
<li><a href="#sec-5-2-1">Private variables</a></li>
<li><a href="#sec-5-2-2">Callbacks and timers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">Chapter 06: Object-orientation with prototypes</a>
<ul>
<li><a href="#sec-6-1">Instantiation and prototypes</a>
<ul>
<li><a href="#sec-6-1-1">Object instantiation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 01: Enter the ninja</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>为了能够写出简洁高效，并且跨浏览器的代码.js的开发人员倾向于创造js库
</li>
<li>所以如果能够理解这些优秀的库是如何运行的,对于我们有很多益处.本书就是教给大家
读懂这些诡异的代码的
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">The JavaScript libraries we'll be tapping</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>本书主要涉及的库有:
<ul class="org-ul">
<li>jQuery
</li>
<li>Prototype
</li>
<li>Yahoo UI
</li>
<li>base2
</li>
</ul>
</li>
<li>JS库的优点主要有三个方面:
<ul class="org-ul">
<li>对于js新feature的使用
</li>
<li>对跨浏览器的支持
</li>
<li>使用了best practice,能够把其他的代码联系起来.
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Understanding the JavaScript language</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>Javascript语言里面如下三个概念联系的非常紧密:
<ul class="org-ul">
<li>Objects
</li>
<li>Closures
</li>
<li>Functions
</li>
</ul>
</li>
<li>从传统语言过来的程序员往往只能对Object有所理解,对其他两个概念则给予的重视不
够.
</li>
<li>除了这三个概念,js里面还有两个feature被广泛的错误理解:
<ul class="org-ul">
<li>timers: 正确理解可以让长期运行的计算相关代码和动画更流畅
</li>
<li>regular expressions: 正确理解可以让很多文本相关工作变得简单
</li>
</ul>
</li>
<li>我们最后还会介绍如下两个高级的同时也是争议最大的两个概念:
<ul class="org-ul">
<li>with
</li>
<li>eval
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Cross-browser considerations</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>加强我们JS的能力是非常重要的,因为js如今已经从前端走向了后端(nodejs),但是js
主要的战场还是在前端.只要在前端一天,那么浏览器之间的差异就是我们不得不面对的问题.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Current best practices</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>掌握js语言的特性以及熟悉不同浏览器的特点是成为高级web开发者的要素,但是要素
不仅仅局限于这两个方面,你还需要知道能够提高代码质量的best practice:
<ul class="org-ul">
<li>Testing
</li>
<li>Performance analysis
</li>
<li>Debugging skills
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">Currrent best practice: testing</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li>这里说的测试并不是单元测试,而是类似于nodejs里面conole.log的方式,只不过是在
前端.具体的方法是使用如下的assert函数(assert函数并不是js内置的,需要我们自
己实现)
<div class="org-src-container">

<pre class="src src-javascript">assert<span style="color: #2aa198;">(</span>a == 1, <span style="color: #2aa198;">"Disaster! a is not 1!"</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">Current best practice: performance analysis</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>我们可以使用如下的代码来测试performance
<div class="org-src-container">

<pre class="src src-javascript">start = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Date</span><span style="color: #2aa198;">()</span>.getTime<span style="color: #2aa198;">()</span>;
<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">n</span> = 0; n &lt; maxCount; n++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">perform the operation to be measured */</span>
<span style="color: #2aa198;">}</span>

elapsed = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Date</span><span style="color: #2aa198;">()</span>.getTime<span style="color: #2aa198;">()</span> - start;
assert<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">true</span>, <span style="color: #2aa198;">"Measured time: "</span> + elapsed<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 02: Arming with testing and debugging</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Debugging code</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>前面我们说过我们自己实现的alert(),除此之外,每个浏览器都会有自己的Developer
tools
</li>
<li>还有两种非常重要的debug方法:
<ul class="org-ul">
<li>logging:log的方法比alert()好的地方在于,它不会打断程序的进行
</li>
<li>breakpoints:能够使得代码运行停止,让我们慢慢去研究问题.当然这得
依靠浏览器的支持.
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Test generation</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>Good test make good code.
</li>
<li>而good test往往拥有如下的特点:
<ul class="org-ul">
<li>可重复性,每次测试结果唯一
</li>
<li>简单:每个测试侧重于一个方面
</li>
<li>独立:我们的测试独立于其他测试
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Testing frameworks</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>引入test framework的好处是:
<ul class="org-ul">
<li>能够模拟浏览器行为
</li>
<li>更容易的暂停测试
</li>
<li>处理异步测试
</li>
<li>仅仅跑测试一部分测试
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">The fundamentals of a test suite</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>test suite 是指把你一部分的测试联合起来,做一次resource的setup和tear down
</li>
</ul>
</div>
<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1">The assertion</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li>unit-testing framework的核心其实就是一个assertion method,一般都叫做
assert(), 我们这里也实现一个简单的assert()
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">html</span>&gt;
    &lt;<span style="color: #268bd2;">head</span>&gt;
        &lt;<span style="color: #268bd2;">title</span>&gt;<span style="font-weight: bold;">Test Suite</span>&lt;/<span style="color: #268bd2;">title</span>&gt;
        &lt;<span style="color: #268bd2;">script</span>&gt;
         function assert(value, desc) {
             var li = document.createElement(<span style="color: #2aa198;">"li"</span>);
             li.className = value ? <span style="color: #2aa198;">"pass"</span> : <span style="color: #2aa198;">"fail"</span>;
             li.appendChild(document.createTextNode(desc));
             document.getElementById(<span style="color: #2aa198;">"results"</span>).appendChild(li);
         };

         window.onload = function() {
             assert(true, <span style="color: #2aa198;">"The test suite is running"</span>);
             assert(false, <span style="color: #2aa198;">"Fail!"</span>);
         };
        &lt;/<span style="color: #268bd2;">script</span>&gt;

        &lt;<span style="color: #268bd2;">style</span>&gt;
         #results li.pass { color: green; }
         #results li.fail { color: red; }
        &lt;/<span style="color: #268bd2;">style</span>&gt;
    &lt;/<span style="color: #268bd2;">head</span>&gt;

    &lt;<span style="color: #268bd2;">body</span>&gt;
        &lt;<span style="color: #268bd2;">ul</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"results"</span>&gt;&lt;/<span style="color: #268bd2;">ul</span>&gt;
        &lt;<span style="color: #268bd2;">h1</span>&gt;<span style="font-weight: bold;">Hello</span>&lt;/<span style="color: #268bd2;">h1</span>&gt;
    &lt;/<span style="color: #268bd2;">body</span>&gt;
&lt;/<span style="color: #268bd2;">html</span>&gt;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2">Test groups</h4>
<div class="outline-text-4" id="text-2-4-2">
<ul class="org-ul">
<li>有时候,一个assert的成功没有意义,要一组都成功,才能算成功,这个时候,我们就会
把这几个有关系的test组合起来,组成一个叫做test group的测试.一个test group
里面所有的test都通过,才叫成功
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">html</span>&gt;
    &lt;<span style="color: #268bd2;">head</span>&gt;
        &lt;<span style="color: #268bd2;">title</span>&gt;<span style="font-weight: bold;">Test Suite</span>&lt;/<span style="color: #268bd2;">title</span>&gt;
        &lt;<span style="color: #268bd2;">script</span>&gt;
         (function(){
             var results;
             this.assert = function assert(value, desc) {
                 var li = document.createElement(<span style="color: #2aa198;">"li"</span>);
                 li.className = value ? <span style="color: #2aa198;">"pass"</span> : <span style="color: #2aa198;">"fail"</span>;
                 li.appendChild(document.createTextNode(desc));
                 results.appendChild(li);
                 if (!value) {
                     li.parentNode.parentNode.className = <span style="color: #2aa198;">"fail"</span>;
                 }
                 return li;
             };
             this.test = function test(name, fn) {
                 results = document.getElementById(<span style="color: #2aa198;">"results"</span>);
                 results = assert(true, name).appendChild(
                     document.createElement(<span style="color: #2aa198;">"ul"</span>));
                 fn();
             };
         })();

         window.onload = function() {
             test(<span style="color: #2aa198;">"A test."</span>, function() {
                 assert(true, <span style="color: #2aa198;">"First assertion completed"</span>);
                 assert(true, <span style="color: #2aa198;">"Second assertion completed"</span>);
                 assert(true, <span style="color: #2aa198;">"Third asserttion completed"</span>);
             });
             test(<span style="color: #2aa198;">"Another test."</span>, function() {
                 assert(true, <span style="color: #2aa198;">"First test completed"</span>);
                 assert(false, <span style="color: #2aa198;">"Second test failed"</span>);
                 assert(true, <span style="color: #2aa198;">"Third assertion completed"</span>);
             });
             test(<span style="color: #2aa198;">"A third test."</span>, function() {
                 assert(null, <span style="color: #2aa198;">"fail"</span>);
                 assert(5, <span style="color: #2aa198;">"pass"</span>)
             });
         };
        &lt;/<span style="color: #268bd2;">script</span>&gt;
        &lt;<span style="color: #268bd2;">style</span>&gt;
            #results li.pass { color: green; }
            #results li.fail { color: red; }
        &lt;/<span style="color: #268bd2;">style</span>&gt;
    &lt;/<span style="color: #268bd2;">head</span>&gt;
    &lt;<span style="color: #268bd2;">body</span>&gt;
        &lt;<span style="color: #268bd2;">ul</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"results"</span>&gt;&lt;/<span style="color: #268bd2;">ul</span>&gt;
    &lt;/<span style="color: #268bd2;">body</span>&gt;
&lt;/<span style="color: #268bd2;">html</span>&gt;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3">Asynchronous testing</h4>
<div class="outline-text-4" id="text-2-4-3">
<ul class="org-ul">
<li>有些测试是测试"不固定时间之后来临的event",我们通常需要使用test framework来
处理此类测试
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 03: Functions are fundamental</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>对于很多不了解js的人来说,第一章不介绍object,而介绍function是一件非常奇怪的事
情.之所以这样设计,是因为
<pre class="example">
js是一个functional language
</pre>
</li>
<li>在javascript里面,function被称之为"first-class object", 也就是说,他们能像普通
object一样工作(比如当做变量,literal声明,作为参数),同时function还有object所没
有的附加功能&#x2014;被调用!
</li>
<li>function成为first-class object的优点在于,我们可以写出更加简洁的代码:
<ul class="org-ul">
<li>Java实现排序的代码如下
<div class="org-src-container">

<pre class="src src-java">Arrays.sort<span style="color: #2aa198;">(</span>values, <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Comparator</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">Integer</span><span style="color: #b58900;">&gt;(){</span>
        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">compare</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">Integer</span> <span style="color: #268bd2;">value1</span>, <span style="color: #b58900;">Integer</span> <span style="color: #268bd2;">value2</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            <span style="color: #859900; font-weight: bold;">return</span> value2 - value1;
        <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>Javascript的实现方法如下:
<div class="org-src-container">

<pre class="src src-js">values.sort<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">value1</span>,<span style="color: #268bd2;">value2</span><span style="color: #b58900;">){</span> <span style="color: #859900; font-weight: bold;">return</span> value2 - value1; <span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">What's with the functional difference?</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>很多人都声称痛恨javascript,其原因十有八九是因为他们把javascript当成了另外的
语言(比如java).
</li>
<li>javascript取名字取得跟java很像,明显是想借东风,但是希望本书读者理解,javascript
跟java根本不像,反而把javascript看成是java是一个"补充(补充java没有的功能)"更
好. 这么一来javascript反而不是和java一样,而是"恰恰相反"
</li>
</ul>
</div>
<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">Why is JavaScript's functional nature important?</h4>
<div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li>Js中function和function concept很重要的原因在于function是js中"执行的最主要
模块"(document.write()这种inline script除外)
</li>
<li>我们先来看看一个object在js里面拥有的能力:
<ul class="org-ul">
<li>可以通过literal创建
</li>
<li>可以被赋值给variable, array entries, 或者是其他object的property
</li>
<li>可以被当做参数传递给function
</li>
<li>可以被function作为返回值返回
</li>
<li>可以拥有property, 这个property是可以动态创建的,动态赋值的
</li>
</ul>
</li>
<li>Function作为first-class object拥有object的所有能力,另外:
<ul class="org-ul">
<li>function还可以被调用(invoked)!
</li>
</ul>
</li>
<li>常规的GUI桌面应用有如下的书写方法:
<ul class="org-ul">
<li>建立一个user interface
</li>
<li>进入loop,等待event发生
</li>
<li>对特定的event,调用对应的handler
</li>
</ul>
</li>
<li>对于JS来说,浏览器负责为我们来处理上面的流程,我们只需要为我们感兴趣的Event
提供handler就可以了.所有的event(不管我们感兴趣与否)都会在诞生的那一刻被放
在一个event queue里面(是一个FIFO list), 如果我们为这个event写了handler,
那么浏览器会在从FIFO里面取出event的时候,自动调用我们的handler
</li>
<li>因为这些event都是在unpredictable time以unpredictable order发生的,所以浏览
器处理这些handler的方式是"异步的"asynchronous
</li>
<li>一些常见的event类型如下:
<ul class="org-ul">
<li>Browser events: 比如当一个page完成loading或者它将被unload的时候
</li>
<li>Network events: 比如对Ajax 发起的request得到了response
</li>
<li>User events: 比如鼠标click事件, 鼠标移动事件,或者键盘按键
</li>
<li>Timer events: 当一个时钟timeout的时候
</li>
</ul>
</li>
<li>下面的例子中,我们就为一种browser event(页面加载完毕)建立了handler.而这个
handler会在页面加载完毕的时候执行
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">startup</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">do something wonderful</span>
<span style="color: #2aa198;">}</span>
window.onload = startup
</pre>
</div>
</li>
<li>很明显strarup函数只会被onload的时候用,所以在不需要代码复用的情况下,我们可以
简单的把上面代码改写成
<div class="org-src-container">

<pre class="src src-js">window.onload = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">do something wonder ful */</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>使用windows.onload来建立handler的方法是值得鼓励的,其对立面(也就是不被鼓励)
的做法,是在&lt;body&gt; tag的onload里面设置handler.
</li>
<li>之所以这样做是被值得鼓励的,是因为这样把script和document markup分开了!(就像
css把style和document markup分开一样,是good practice)
</li>
<li>这样做了以后,我们的page就有三个部分:
<ul class="org-ul">
<li>structure: 在document markup里面定义
</li>
<li>style: 在&lt;style&gt;里面(或者external 文件)定义
</li>
<li>behavior: 在&lt;script&gt;里面(或者external 文件)定义
</li>
</ul>
</li>
<li>brower event loop是个single-threaded程序, 所有event都是严格按照FIFO的顺序
被执行的.而一个event被处理的时候,其他event都是在等待的.
</li>
<li>从下图中我们可以看到code是提前准备好的,为了能够在后面运行(注意,除了inline
setup code). 我们大部分的代码都会伴随着某一event(后面会说到)而被执行.

<div class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/org_dot/master/notes/js/ninja_event_loop.png" alt="ninja_event_loop.png" />
</p>
<p><span class="figure-number">Figure 1:</span> ninja_event_loop.png</p>
</div>
</li>
<li>需要注意的是,我们前面说的event loop的单线程模型,指的仅仅是处理loop里面event
的进程是单线程. 但是,发现event发生,并把event放入queue的可以是另外的一个进程
(process), 它不算在event loop model里面
</li>
<li>event handler是比较学术的叫法,在js里面,他们有自己的名字,叫做callback function
</li>
<li>callback 函数从字面上的理解,就是先设置了,但是:
<ul class="org-ul">
<li>不马上调用
</li>
<li>不是自己调用
</li>
<li>而是在某些情况满足之后,由其他代码调用
</li>
</ul>
</li>
<li>我们可以看一个非常简单的callback函数例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">useless</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">callback</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> callback<span style="color: #b58900;">()</span>; <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">text</span> = <span style="color: #2aa198;">'Demo arigato!'</span>;
assert<span style="color: #2aa198;">(</span>useless<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(){</span> <span style="color: #859900; font-weight: bold;">return</span> text; <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span> === text,
       <span style="color: #2aa198;">"The useless function works!"</span> + text<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2">Sorting with a comparator</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li>常见的java排序的代码如下:
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">Integer</span><span style="color: #2aa198;">[]</span> <span style="color: #268bd2;">values</span> = <span style="color: #2aa198;">{</span> 213, 16, 2058, 54, 10, 1965, 57, 9 <span style="color: #2aa198;">}</span>;
Arrays.sort<span style="color: #2aa198;">(</span>values<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>而js的版本如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">values</span> = <span style="color: #2aa198;">[</span>213, 16, 2058, 54, 10, 1965, 57, 9<span style="color: #2aa198;">]</span>;
values.sort<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>这两个版本其实都非常的容易理解,js的优势在于当我们的需求"变化"的时候,比如,
这里我们不想要"升序", 而要"降序",这个时候js的优势显示出来了.我们先看看java
的版本:
<div class="org-src-container">

<pre class="src src-java">Arrays.sort<span style="color: #2aa198;">(</span>values, <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Comparator</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">Integer</span><span style="color: #b58900;">&gt;()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">compare</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">Integer</span> <span style="color: #268bd2;">value1</span>, <span style="color: #b58900;">Integer</span> <span style="color: #268bd2;">value2</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            <span style="color: #859900; font-weight: bold;">return</span> value2 - value1;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>js的版本则简洁的多:
<div class="org-src-container">

<pre class="src src-js">values.sort<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">value1</span>, <span style="color: #268bd2;">value2</span><span style="color: #b58900;">){</span> <span style="color: #859900; font-weight: bold;">return</span> value2 - value1; <span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>到处可以创建function,是js能够写出简洁代码的不二法宝,合理利用可以得到非常大的益处
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Declarations</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>function一般由四个部分组成:
<ul class="org-ul">
<li>function keyword
</li>
<li>(可选的)name, 如果有名字,那么必须是"合法的"
</li>
<li>在小括号里面,由逗号分隔的参数
</li>
<li>在大括号里面的函数体
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">Scoping and functions</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>在大多数语言里面scope是通过{}定义的,而在js里面,竟然是function定义scope!
</li>
<li>看下面这个例子,在大多数语言里面,大家一定会得到如下的结论: 因为x的scope在if
后面的'}'之后结束,所以alert(x)会报undefined错
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>window<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">x</span> = 213;
<span style="color: #2aa198;">}</span>
alert<span style="color: #2aa198;">(</span>x<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>当然,js里面这段代码是可以运行的啦,因为scope是function定义的
</li>
<li>看起来简单的规则,其实还是有很多"小坑":
<ul class="org-ul">
<li>变量的scope是从var开始,到"最近的"包含它的function结束
</li>
<li>named function的scope是从"最近的"包含它的function开始,到包含它的function
结束
</li>
<li>global context就像一个big function一样(包括了页面上的所有code)
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Invocations</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>对于function的调用方法,其实细分起来有四种:
<ul class="org-ul">
<li>单纯的作为function被调用
</li>
<li>做为method调用(既然叫做method了,那么就是把这个function赋给了一个object,使
用oo的样式来调用)
</li>
<li>作为constructor来调用,会产生一个新的object
</li>
<li>使用apply()或者call()函数来调用
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">From arguments to function parameters</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>js作为动态语言对于实参和行参的个数,并没有"严格的要求数目完全一样":
<ul class="org-ul">
<li>如果调用的时候参数比实际需要的参数多,那么多余的参数直接就是不起作用
</li>
<li>如果调用的时候参数比实际需要的参数少,那么没得到赋值的参数会被设置为
undefined
</li>
</ul>
</li>
<li>除了这些"明面"的参数以外,每个function还会被"暗中"传递两个参数:
<ul class="org-ul">
<li>argument: 是一个"类似数组"的object,里面是function得到的所有的参数,比如
argument代表第三个参数
</li>
<li>this: this代表了和这个function"紧密联系"的object,注意!这里的"紧密联系"的
意思是因为function有四种不同的调用关系:只有function作为method的时候,this
才指代调用它的object,其他情况下都不是(后面会详细介绍)
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2">Invocation as a function</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>这是function被调用的"最普通"的形式,就是(),而且前面没有object
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">ninja</span><span style="color: #2aa198;">(){}</span>;
ninja<span style="color: #2aa198;">()</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">samurai</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(){}</span>
samurai<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>当如此调用的时候,function context是global context:就是在window
object里面&#x2013;所以从另一个角度上来讲,也就是windows.method的用法
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3">Invocation as a method</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>method是需要object的,调用方法如下:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">o</span> = <span style="color: #2aa198;">{}</span>
o.whatever = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(){}</span>
o.whatever<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>这种用法的优势,是js终于和主流语言"接近"了, 使用object调用function的时候,this
就直接指向了调用的object
</li>
<li>虽说这种方法是有了object的样子,但是其使用起来还是有些"不同寻常",具体表现在
this所指代的object是"调用"这个method的object. 这和传统的oo语言一样,不一样
的地方是,这个函数竟然还可以"借用object的,而且效果和自己写的一样":
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">assert</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">value</span>, <span style="color: #268bd2;">desc</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">li</span> = document.createElement<span style="color: #b58900;">(</span><span style="color: #2aa198;">"li"</span><span style="color: #b58900;">)</span>;
    li.className = value ? <span style="color: #2aa198;">"pass"</span> : <span style="color: #2aa198;">"fail"</span>;
    li.appendChild<span style="color: #b58900;">(</span>document.createTextNode<span style="color: #268bd2;">(</span>desc<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;
    document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">"results"</span><span style="color: #b58900;">)</span>.appendChild<span style="color: #b58900;">(</span>li<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>;
<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">starter</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">creep</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>

    assert<span style="color: #b58900;">(</span>creep<span style="color: #268bd2;">()</span> === window, <span style="color: #2aa198;">"Creeping in the window"</span><span style="color: #b58900;">)</span>;

    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">sneak</span> = creep;
    assert<span style="color: #b58900;">(</span>sneak<span style="color: #268bd2;">()</span> === window, <span style="color: #2aa198;">"Sneaking in the window"</span><span style="color: #b58900;">)</span>;

    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #b58900;">{</span>
        skulk: creep
    <span style="color: #b58900;">}</span>;
    assert<span style="color: #b58900;">(</span>ninja1.skulk<span style="color: #268bd2;">()</span> === ninja1,
           <span style="color: #2aa198;">"The 1st ninja is skulking"</span><span style="color: #b58900;">)</span>;

    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #b58900;">{</span>
        skulk: creep
    <span style="color: #b58900;">}</span>;
    assert<span style="color: #b58900;">(</span>ninja2.skulk<span style="color: #268bd2;">()</span> === ninja2,
           <span style="color: #2aa198;">"The 2nd ninja is skulking"</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

window.onload = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    starter<span style="color: #b58900;">()</span>;
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>上述例子中, creep这个函数还可以被ninja1赋值为自己的一个property赋值为一个
method的reference. 调用的时候,这个reference非常好用,还是正确的返回了指向
ninja1的obj.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-4" class="outline-4">
<h4 id="sec-3-3-4">Invocation as a constructor</h4>
<div class="outline-text-4" id="text-3-3-4">
<ul class="org-ul">
<li>作为constructor的话, 就是调用的时候前面加个new
</li>
<li>看起来没什么特点的操作,其实意味着非常多的事情会发生:
<ul class="org-ul">
<li>一个empty object被创建
</li>
<li>这个empty object马上成为constructor function的this参数.
</li>
<li>不需要任何"return",这个object(可能在某些构建之后)作为返回值返回给调用ctor
的调用者
</li>
</ul>
</li>
<li>一个简单的new例子如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.skulk = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>; <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;

assert<span style="color: #2aa198;">(</span>ninja1.skulk<span style="color: #b58900;">()</span> === ninja1,
       <span style="color: #2aa198;">"The 1st ninja is skulking"</span><span style="color: #2aa198;">)</span>;
assert<span style="color: #2aa198;">(</span>ninja2.skulk<span style="color: #b58900;">()</span> === ninja2,
       <span style="color: #2aa198;">"The 2nd ninja is skulking"</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>需要注意的是new的一大特性是"首先创建了一个empty object",所以如下代码是起不
到new的作用的,因为它会产生一个window object返回
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">whatever</span> = Ninja<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>因为ctor也是函数,所以为了区分普通函数和ctor函数,我们在js的命名上面有如下规
定:
<ul class="org-ul">
<li>小写字母开头的动词都是普通的函数,比如skulk(), creep()
</li>
<li>大写字母开头的名词都是ctor函数,比如Ninja(), Samurai()
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-5" class="outline-4">
<h4 id="sec-3-3-5">Invocation with the apply() and call() methods</h4>
<div class="outline-text-4" id="text-3-3-5">
<ul class="org-ul">
<li>总结一下前面三种function的使用方法,其实区别在于this的作用:
<ul class="org-ul">
<li>常规的function调用,this是指代的window
</li>
<li>method的function调用,this指代的是调用method的object
</li>
<li>对于ctor来说,this指代的是新创建的empty object instance.
</li>
</ul>
</li>
<li>上面这三种的用法,都有其严格的绑定,比如method调用的时候,this总是指的"method"
被绑定的object(比如ninja1就是后来绑定了skulk为creep), 如果我们想制定this就是
包含creep()的window呢? apply就是为这个需求服务的,其有两个参数:
<ul class="org-ul">
<li>参数1:是我们想绑定的object
</li>
<li>参数2:是函数调用列表组成的一个数组(call(),和apply的区别就在于第二个参数
不是数组,而是一系列参数)
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chatper 04: Wielding functions</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Anonymous functions</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>匿名函数的出现,主要是因为有很多时候,函数的名字并不重要,比如如下:
<ul class="org-ul">
<li>为一个event设置一个handler, 相当于直接赋值给"变量"
<div class="org-src-container">

<pre class="src src-js">window.onload =
    <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(){</span> assert<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">true</span>, <span style="color: #2aa198;">'power!'</span><span style="color: #b58900;">)</span>; <span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>把一个函数直接赋给"变量的property,也就是method(注意,object的函数才叫
method呢)", 还需要注意的是这里的shout是object的property,匿名函数并没有获
得这个名字
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2;">shout</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">[</span>
        assert<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">true</span>, <span style="color: #2aa198;">"Ninja"</span><span style="color: #268bd2;">)</span>;
    <span style="color: #657b83; background-color: #fdf6e3;">}</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>把一个函数直接作为参数传递给调用的函数
<div class="org-src-container">

<pre class="src src-js">setTimeout<span style="color: #2aa198;">(</span>
    <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(){</span> assert<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">true</span>, <span style="color: #2aa198;">'Forever!'</span><span style="color: #268bd2;">)</span> <span style="color: #b58900;">}</span>,
    500<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</li>
<li>javascript喜欢使用匿名函数是来源于functional programming的特质:使用
side-effect-free的函数,作为自己的building block.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Recursion</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>递归函数在处理非常多的运算的时候,非常有作用.但不仅仅于此,web开发中也有很多
要用到递归函数的地方(比如pop up)
</li>
</ul>
</div>
<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">Recursion in named functions</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>判断字符串是不是palindrome,是使用递归的非常好的一个例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">isPalindrome</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">text</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>text.length &lt;= 1<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>text.charAt<span style="color: #268bd2;">(</span>0<span style="color: #268bd2;">)</span> != text.charAt<span style="color: #268bd2;">(</span>text.length - 1<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
    <span style="color: #859900; font-weight: bold;">return</span> isPalindrome<span style="color: #b58900;">(</span>text.substr<span style="color: #268bd2;">(</span>1, text.length - 2<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2">Recursion with methods</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>使用named function的递归是非常容易理解的,因为和常规的其他语言并没有什么不
同, 而在js中,除了named function还有anonymous function.我们下面的例子就是把
一个anonymous function赋给object的property,然后使用object method调用的方式
来实现递归
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2;">chirp</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">n</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> n &gt; 1 ? ninja.chirp<span style="color: #268bd2;">(</span>n-1<span style="color: #268bd2;">)</span> + <span style="color: #2aa198;">"-chirp"</span> : <span style="color: #2aa198;">"chirp"</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-3" class="outline-4">
<h4 id="sec-4-2-3">The pilfered reference problem</h4>
<div class="outline-text-4" id="text-4-2-3">
<ul class="org-ul">
<li>使用匿名函数赋给object property的方法是很常见的,但是如果这个匿名函数还是递
归函数,有些情况下会引起问题,比如下面
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2;">chirp</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">n</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> n &gt; 1 ? ninja.chirp<span style="color: #268bd2;">(</span>n-1<span style="color: #268bd2;">)</span> + <span style="color: #2aa198;">"-chirp"</span> : <span style="color: #2aa198;">"chirp"</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">samurai</span> = <span style="color: #2aa198;">{</span> chirp: ninja.chirp <span style="color: #2aa198;">}</span>;
ninja = <span style="color: #2aa198;">{}</span>;
<span style="color: #859900; font-weight: bold;">try</span> <span style="color: #2aa198;">{</span>
    assert<span style="color: #b58900;">(</span>samurai.chirp<span style="color: #268bd2;">(</span>3<span style="color: #268bd2;">)</span> == <span style="color: #2aa198;">"chirp-chirp-chirp"</span>,
           <span style="color: #2aa198;">"Is this going to work?"</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-4" class="outline-4">
<h4 id="sec-4-2-4">Inline named functions</h4>
<div class="outline-text-4" id="text-4-2-4">
<ul class="org-ul">
<li>解决上面困境的方法很简单,就是设置top named function,但是我们其实还想简洁一
点:那就是在anonymous function的基础上给它设置个"名字",但是这个名字只是在函
数体内部有用(也就是我们说的作用域的范围也就适合递归一下), 我们把这种函数叫
做: inline named function
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2;">chirp</span>: <span style="color: #859900; font-weight: bold;">function</span> signal<span style="color: #b58900;">(</span><span style="color: #268bd2;">n</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> n &gt; 1 ? signal<span style="color: #268bd2;">(</span>n-1<span style="color: #268bd2;">)</span> + <span style="color: #2aa198;">"-chirp"</span> : <span style="color: #2aa198;">"chirp"</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

assert<span style="color: #2aa198;">(</span>ninja.chirp<span style="color: #b58900;">(</span>3<span style="color: #b58900;">)</span> == <span style="color: #2aa198;">"chirp=chirp-chirp"</span>,
       <span style="color: #2aa198;">"Works as we would expect it to!"</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">samurai</span> = <span style="color: #2aa198;">{</span> chirp: ninja.chirp <span style="color: #2aa198;">}</span>;
ninja = <span style="color: #2aa198;">{}</span>;
assert<span style="color: #2aa198;">(</span>samurai.chirp<span style="color: #b58900;">(</span>3<span style="color: #b58900;">)</span> == <span style="color: #2aa198;">"chirp-chirp=chirp"</span>,
       <span style="color: #2aa198;">"The method correctly calls itself."</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-5" class="outline-4">
<h4 id="sec-4-2-5">The callee property</h4>
<div class="outline-text-4" id="text-4-2-5">
<ul class="org-ul">
<li>注意,这种调用方式以后将会废除,了解是为了理解已有代码
</li>
<li>我们知道,每个function都会被传递一个argument(这是一个object,不是array), 这
个argument 有个callee的method用来指代当前运行的函数
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2;">chirp</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">n</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> n &gt; 1 ? <span style="color: #268bd2; font-weight: bold;">arguments</span>.callee<span style="color: #268bd2;">(</span>n - 1<span style="color: #268bd2;">)</span> + <span style="color: #2aa198;">"-chirp"</span> : <span style="color: #2aa198;">"chirp"</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Fun with function as objects</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>我们前面已经说过了,function是超级object,其拥有普通object的所有能力.而且还能
被调用!
</li>
<li>下面我们总结一下function的这些和普通object一样拥有的能力:
<ul class="org-ul">
<li>把function赋值给variable:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">objj</span> = <span style="color: #2aa198;">{}</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">fn</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>;
assert<span style="color: #2aa198;">(</span>obj &amp;&amp; fun, <span style="color: #2aa198;">"Both the object and function exist."</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>把function和property联系起来:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">obj</span> = <span style="color: #2aa198;">{}</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">fn</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(){}</span>;
obj.prop = <span style="color: #2aa198;">"hitsuke (distraction)"</span>;
fn.prop = <span style="color: #2aa198;">"tanuki (climbing)"</span>;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1">Storing functions</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>有些情况下,我们有如下的需求:我们要保持一系列有关系的function,但是我们不希
望重复存储(类似hashset), 实现方法如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">store</span> = <span style="color: #2aa198;">{</span>
    nextId: 1,
    cache: <span style="color: #b58900;">{}</span>,
    <span style="color: #268bd2;">add</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">fn</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>!fn.id<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            fn.id = store.nextId++;
            <span style="color: #859900; font-weight: bold;">return</span> !!<span style="color: #6c71c4;">(</span>store.cache<span style="color: #859900;">[</span>fn.id<span style="color: #859900;">]</span> = fn<span style="color: #6c71c4;">)</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">ninja</span><span style="color: #2aa198;">(){}</span>

assert<span style="color: #2aa198;">(</span>store.add<span style="color: #b58900;">(</span>ninja<span style="color: #b58900;">)</span>,
       <span style="color: #2aa198;">"Function was safely added."</span><span style="color: #2aa198;">)</span>;
assert<span style="color: #2aa198;">(</span>store.add<span style="color: #b58900;">(</span>ninja<span style="color: #b58900;">)</span>,
       <span style="color: #2aa198;">"But it was only added once."</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>其实就是利用类似cache这个hashmap来实现hashset, 不过为function添加一个id这
种能力还真是只有javascript有.
</li>
<li>注意,这里的`!!`不整体是一个operator,它只不过是`!`了两次,把任意一个类型转换
为boolean类型而已.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2">Self-memoizing functions</h4>
<div class="outline-text-4" id="text-4-3-2">
<ul class="org-ul">
<li>javascript 的hashmap作为cache用,还有其他各种妙用,比如下面的记录计算过的值
从而直接返回cache的例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">isPrime</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">value</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>!isPrime.answers<span style="color: #b58900;">)</span> isPrime.answers = <span style="color: #b58900;">{}</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>isPrime.answers<span style="color: #268bd2;">[</span>value<span style="color: #268bd2;">]</span> != <span style="color: #268bd2; font-weight: bold;">null</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> isPrime.answers<span style="color: #268bd2;">[</span>value<span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">prime</span> = value != 1;
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">i</span> = 2; i &lt; value; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>value % i == 0<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            prime = <span style="color: #268bd2; font-weight: bold;">false</span>;
            <span style="color: #859900; font-weight: bold;">break</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> isPrime.answers<span style="color: #b58900;">[</span>value<span style="color: #b58900;">]</span> = prime;
<span style="color: #2aa198;">}</span>

assert<span style="color: #2aa198;">(</span>isPrime<span style="color: #b58900;">(</span>5<span style="color: #b58900;">)</span>, <span style="color: #2aa198;">"5 is prime!"</span><span style="color: #2aa198;">)</span>;
assert<span style="color: #2aa198;">(</span>isPrime.answers<span style="color: #b58900;">[</span>5<span style="color: #b58900;">]</span>, <span style="color: #2aa198;">"The anser was cached!"</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-3" class="outline-4">
<h4 id="sec-4-3-3">Faking array methods</h4>
<div class="outline-text-4" id="text-4-3-3">
<ul class="org-ul">
<li>js能模拟很多特殊的要求,比如js中存在数组,可以去存储一些"其他的"内容,这个时
候,我们就要自己改造数组
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">elems</span> = <span style="color: #2aa198;">{</span>
    length: 0,

    <span style="color: #268bd2;">add</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">elem</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        Arrays.<span style="color: #268bd2; font-weight: bold;">prototype</span>.push.call<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>, elem<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>,

    <span style="color: #268bd2;">gather</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">id</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #268bd2; font-weight: bold;">this</span>.add<span style="color: #268bd2;">(</span>document.getElementById<span style="color: #6c71c4;">(</span>id<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

elems.gather<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"first"</span><span style="color: #2aa198;">)</span>;
assert<span style="color: #2aa198;">(</span>elems.length == 1 &amp;&amp; elems<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span>.nodeType,
       <span style="color: #2aa198;">"Verify that we have an element in our stash"</span><span style="color: #2aa198;">)</span>;

elems.gather<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"second"</span><span style="color: #2aa198;">)</span>;
assert<span style="color: #2aa198;">(</span>elems.length == 2 &amp;&amp; elems<span style="color: #b58900;">[</span>1<span style="color: #b58900;">]</span>.nodeType,
       <span style="color: #2aa198;">"Verify the other insertion"</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Variable-length argument lists</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>js的灵活性还在于可以接受任意数量的argument,这就给了我们对于function更多的控
制,也就诞生了一些特殊的用法:
<ul class="org-ul">
<li>如何给于一个"能够接受任意参数的function"以多个argument
</li>
<li>如何使用变长参数来实现function overloading
</li>
<li>如何使用argument list的length property
</li>
</ul>
</li>
<li>因为js没有overloading的特性,所以argument list的灵活性就是我们"hack" overloading
的法宝了
</li>
</ul>
</div>
<div id="outline-container-sec-4-4-1" class="outline-4">
<h4 id="sec-4-4-1">Using apply() to supply variable arguments</h4>
<div class="outline-text-4" id="text-4-4-1">
<ul class="org-ul">
<li>js中实现从一个数组中寻找最大数,最小数是非常常见的一个需求.如果不是太懂变长
参数,可能会使用如下的代码来计算
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">largest</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">arr</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>arr.lenght == 0<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">NaN</span>;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">maxV</span> = arr<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span>;
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">i</span> = 1; i &lt; arr.length; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>maxV &lt; arr<span style="color: #6c71c4;">[</span>i<span style="color: #6c71c4;">]</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            maxV = arr<span style="color: #6c71c4;">[</span>i<span style="color: #6c71c4;">]</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> maxV;
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">array</span> = <span style="color: #2aa198;">[</span>1, 2, 3, 9, 5, 7, 8<span style="color: #2aa198;">]</span>;
console.log<span style="color: #2aa198;">(</span>largest<span style="color: #b58900;">(</span>array<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>但是如果你了解js,知道js里面有一个叫做apply()的函数,这个函数和call()的不同
在于call是后面跟了一系列参数,而apply第二个参数就是一个数组是所有参数的集合
</li>
<li>我们可以利用apply()的这个特性,把对参数进行排序的max, min函数进行apply调用:
<ul class="org-ul">
<li>max,min函数的用法一般是这样的
<div class="org-src-container">

<pre class="src src-js">console.log<span style="color: #2aa198;">(</span>Math.min<span style="color: #b58900;">(</span>1, 2, 3, 9, 8, 8<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>Math.max<span style="color: #b58900;">(</span>1, 2, 3, 9, 8, 8<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>我们利用apply()之后的用法是这样的
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">largest</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">arr</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> Math.max.apply<span style="color: #b58900;">(</span>Math, arr<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">array</span> = <span style="color: #2aa198;">[</span>1, 2, 3, 9, 5, 7, 8<span style="color: #2aa198;">]</span>;
console.log<span style="color: #2aa198;">(</span>largest<span style="color: #b58900;">(</span>array<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4-2" class="outline-4">
<h4 id="sec-4-4-2">Function overloading</h4>
<div class="outline-text-4" id="text-4-4-2">
<ul class="org-ul">
<li>前面我们介绍过arguments 参数,现在我们就认真的看一下这个参数的几种常见用法
</li>
<li>第一个例子是把多个object的property合并到一个object里面, 这里"多个"object,
那么也就是说函数的参数个数不一定,既然不一定,那么传统的语言我们就必须设计一个
变参(或者最后一个参数为数组),对于js来说,则完全不需要,因为
<pre class="example">
javascript完全不care传入的参数是几个,和形参个数不一样都没事,
多了就"不赋值"给形参而已,但还是会存在arguments里面,少了那就
是剩下的形参为undefined
</pre>
</li>
<li>好了,我们的例子代码如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">merge</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">root</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">i</span> = 1; i &lt; <span style="color: #268bd2; font-weight: bold;">arguments</span>.length; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">key</span> <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #6c71c4;">[</span>i<span style="color: #6c71c4;">]</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            root<span style="color: #6c71c4;">[</span>key<span style="color: #6c71c4;">]</span> = <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #6c71c4;">[</span>i<span style="color: #6c71c4;">][</span>key<span style="color: #6c71c4;">]</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> root;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">merged</span> = merge<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    name: <span style="color: #2aa198;">"Batou"</span>
<span style="color: #b58900;">}</span>, <span style="color: #b58900;">{</span>
    city: <span style="color: #2aa198;">"Niihama"</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>merged<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ name: 'Batou', city: 'Niihama' }             //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>从上面代码里面,我们可以看到如下有趣的现象:
<ul class="org-ul">
<li>我们只有一个形参root, 但是没关系,我可以传入两个实参name,city,只不过
arguments有自己的名字root,而argumetns没有自己的名字而已.
</li>
<li>我们的递归从1开始,因为我们会把从第二个开始的所有的object的property都放到
的一个object里面.
</li>
<li>我们可以传递任意个数的参数给merge函数,甚至是none个
</li>
<li>arguments不是一个数组,只不过有length property而已
</li>
<li>key in [Object]的用法对于任意object都可以使用, 每个参数都是一个object,所
以可以这么使用
</li>
</ul>
</li>
<li>从上面的例子我们可以看到,'可以遍历并使用arguments'这个特性是我们创建复杂并
且智能的method的"源动力"
</li>
<li>第二个例子是把"参数的第一个数字和后面参数里面最大的数字相乘",这个看起来很
绕,其实就是看我们怎么灵活应用arguments,因为arguments竟然不是数组,所以无法
利用数组的各种便利函数,比如slice,会报如下错误
<div class="org-src-container">

<pre class="src src-sh">TypeError: arguments.slice is not a <span style="color: #859900; font-weight: bold;">function</span>
</pre>
</div>
</li>
<li>我们当然可以把arguments读取一遍,然后放到一个数组里面然后使用这个数组,如果
是这样的话我们就不能叫ninja了,对不对.肯定有更屌的办法那就是Array.prototype
这个东西使用起来有点像duck type的意思"当看到一只鸟走起来像鸭子,游泳起来像鸭子,
叫起来像鸭子,那么这只鸟就可以被称之为鸭子"
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">my_object</span> = <span style="color: #2aa198;">{</span>
    <span style="color: #2aa198;">'0'</span>: <span style="color: #2aa198;">'zero'</span>,
    <span style="color: #2aa198;">'1'</span>: <span style="color: #2aa198;">'one'</span>,
    <span style="color: #2aa198;">'2'</span>: <span style="color: #2aa198;">'two'</span>,
    <span style="color: #2aa198;">'3'</span>: <span style="color: #2aa198;">'three'</span>,
    <span style="color: #2aa198;">'4'</span>: <span style="color: #2aa198;">'four'</span>,
    length: 5
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">sliced</span> = Array.<span style="color: #268bd2; font-weight: bold;">prototype</span>.slice.call<span style="color: #2aa198;">(</span> my_object, 1 , 4<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>sliced<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 'one', 'two', 'three' ]                      //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>arguments也是"array type",因为他有length, 也有'0','1','2'等key
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">foo</span> = <span style="color: #859900; font-weight: bold;">function</span> <span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #b58900;">)</span>;
    console.log<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">arguments</span>.length<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>;

foo<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'zero'</span>, <span style="color: #2aa198;">'one'</span>, <span style="color: #2aa198;">'two'</span>, <span style="color: #2aa198;">'three'</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">///////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ '0': 'zero', '1': 'one', '2': 'two', '3': 'three' } //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4                                                     //</span>
<span style="color: #93a1a1;">///////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>所以我们的代码实现如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">multiMax</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">multi</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> multi * Math.max.apply<span style="color: #b58900;">(</span>Math,
        Array.<span style="color: #268bd2; font-weight: bold;">prototype</span>.slice.call<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">arguments</span>, 1<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

console.log<span style="color: #2aa198;">(</span>multiMax<span style="color: #b58900;">(</span>3, 1, 2, 3<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>好的,我们现在来看看overloading的定义:
<pre class="example">
The technique of defining a function that does different
things based upon what's passed to it.
定义一种函数,根据传入参数的不同来做不同的事情
</pre>
</li>
<li>从定义看来,因为js对于实参的"宽容程度",我们完全可以根据arguments的不同,使用
if-else来实现overloading, 但这只能实现于简单的情况
</li>
<li>复杂情况下,仅仅依靠if-else来判断arguments是非常麻烦的(比如多加了一个overloading
函数,那就必须继续添加if else)
</li>
<li>复杂情况下的overloading function实现,必须基于我们对function的一个叫做length
property的了解, 请不要把这个property和arguments的length相混淆.
<ul class="org-ul">
<li>一个function的length是指: 一个function所拥有的named parameter的个数
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">makeNinja</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">name</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{}</span>
<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">makeSamurai</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">name</span>, <span style="color: #268bd2;">rank</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{}</span>
console.log<span style="color: #2aa198;">(</span>makeNinja.length<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>makeSamurai.length<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>一个function的arguments.length是指:一个function实质被传入的参数的个数
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">makeNinja</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">name</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">arguments</span>.length<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
makeNinja<span style="color: #2aa198;">(</span>1, 2, 3<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</li>
<li>基本知识储备以后,我们来看看,我们在js里面的overloading functions by
argument count:就是根据arguments.length的不同来进行重载了:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2;">whatever</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">switch</span> <span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">arguments</span>.length<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">case</span> 0:
            <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">do something */</span>
            <span style="color: #859900; font-weight: bold;">break</span>;
        <span style="color: #859900; font-weight: bold;">case</span> 1:
            <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">do something */</span>
            <span style="color: #859900; font-weight: bold;">break</span>;
        <span style="color: #859900; font-weight: bold;">case</span> 2:
            <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">do something */</span>
            <span style="color: #859900; font-weight: bold;">break</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Checking for functions</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>我们来看看一个测试function type的例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">ninja</span><span style="color: #2aa198;">(){}</span>
console.log<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">typeof</span> ninja == <span style="color: #2aa198;">"function"</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>但是这中情况并不是一直能"准确判断"某种类型到底是不是function,因为我们存在不
同的浏览器, 它们有自己的想法:
<ul class="org-ul">
<li>firefox认为&lt;object&gt;是function
</li>
<li>IE认为某个是windows一部分的function,不是function
</li>
<li>Safari任务DOM NodeList是function
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 05: Closing in on closures</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">How closuers work</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>closure是一个scope,这个scope是function declare的时候定义的, 这个scope比
function自己的{}要大,使得function可以访问更大的一个区域.
</li>
<li>javascript可见域和传统的语言都不太一样,先看第一个例子. outFunction竟然可以
在自己函数体内部调用'似乎不在自己作用域的'变量outerValue
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">outerValue</span> = <span style="color: #2aa198;">'ninja'</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">outerFunction</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>outerValue<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

outerFunction<span style="color: #2aa198;">()</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninja                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>上面这个例子或许看起来"没有那么奇怪",因为outer value和outer function都定义
在global scope,而那个scope(也就是一个closure),我们再来看看下面这个足够复杂
的例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">outerValue</span> = <span style="color: #2aa198;">'ninja'</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">later</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">outerFunction</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">innerValue</span> = <span style="color: #2aa198;">'samurai'</span>;

    <span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">innerFunction</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span>outerValue<span style="color: #268bd2;">)</span>;
        console.log<span style="color: #268bd2;">(</span>innerValue<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
    later = innerFunction;
<span style="color: #2aa198;">}</span>

outerFunction<span style="color: #2aa198;">()</span>;
later<span style="color: #2aa198;">()</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninja                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">samurai                                        //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>打印出outerValue不奇怪,因为outerValue是global的, 但是innverValue已经不是global
的啦,那是如何打印出来的呢?那肯定就是closure的作用啦.
</li>
<li>我们来具体解释下这个closure:
<ul class="org-ul">
<li>当我们的innerFunction创建的时候,我们是把innerFunction声明在了outer function
里面,和这个function同时产生的还有一个closure, 这个closure包含如下两个部分:
<ol class="org-ol">
<li>刚刚声明的这个function
</li>
<li>function声明的时候所在的'那个scope里面',所有的变量
</li>
</ol>
</li>
<li>closure存在的意义在于,因为函数可以在任意的地方被调用,而当函数被调用的时候,
其scope可能已经非常的遥远了,closure的存在可以让function访问到自己"本来"可
以访问的数据
</li>
</ul>
</li>
<li>我们再来看一个函数带参数的例子, 让我们确信function parameter也是包括在了
function的closure里面:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">outerValue</span> = <span style="color: #2aa198;">'ninja'</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">later</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">outerFunction</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">innerValue</span> = <span style="color: #2aa198;">'samurai'</span>;

    <span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">innerFunction</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">paramValue</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span>outerValue<span style="color: #268bd2;">)</span>;
        console.log<span style="color: #268bd2;">(</span>innerValue<span style="color: #268bd2;">)</span>;
        console.log<span style="color: #268bd2;">(</span>paramValue<span style="color: #268bd2;">)</span>;
        console.log<span style="color: #268bd2;">(</span>tooLate<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
    later = innerFunction;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">tooLate</span> = <span style="color: #2aa198;">'ronin'</span>;

outerFunction<span style="color: #2aa198;">()</span>;
later<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'wakizashi'</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninja                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">samurai                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">wakizashi                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ronin                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Putting closures to work</h3>
<div class="outline-text-3" id="text-5-2">
</div><div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1">Private variables</h4>
<div class="outline-text-4" id="text-5-2-1">
<ul class="org-ul">
<li>closure的一个最常用技巧是把一些变量设计成"private variable", 对于传统语言
来说易如反掌的事情,让javascript做起来也是那么的&#x2026;.麻烦
</li>
<li>下例中的feints就是一个private variable,因为它被定义在function Ninja里面,所
以我们无法直接只用instances.variable的方法来访问它, 但是由于closure的存在,
我们的function却可以访问它
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">feints</span> = 0;

    <span style="color: #268bd2; font-weight: bold;">this</span>.getFeints = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> feints;
    <span style="color: #b58900;">}</span>;

    <span style="color: #268bd2; font-weight: bold;">this</span>.feint = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        feints++;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;

ninja.feint<span style="color: #2aa198;">()</span>;

console.log<span style="color: #2aa198;">(</span>ninja.getFeints<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja.feints<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined                                      //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2-2" class="outline-4">
<h4 id="sec-5-2-2">Callbacks and timers</h4>
<div class="outline-text-4" id="text-5-2-2">
<ul class="org-ul">
<li>closure的另一个用处就是callback或者是timer. (callback和timer有共同的特点:
就是:
<ul class="org-ul">
<li>function是在以后的一个unspecified 的时间点调用)
</li>
<li>function总是会调用scope之外的变量
</li>
</ul>
</li>
<li>TODO
</li>
</ul>
</div>
</div>
</div>
</div>



<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Chapter 06: Object-orientation with prototypes</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Instantiation and prototypes</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>所有的function都有一个prototype property, 这个property开始的时候是指向一个
empty object的, 这个property平时没有什么作用,直到这个function作为ctor的时候
也就是使用new调用的时候
</li>
</ul>
</div>
<div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1">Object instantiation</h4>
<div class="outline-text-4" id="text-6-1-1">
<ul class="org-ul">
<li>最简单的创建object的方法如下,这种是创建了一个empty的object(没有使用new), 然
后我们使用赋值语句来进行增减property
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">o</span> = <span style="color: #2aa198;">{}</span>;
o.name = <span style="color: #2aa198;">'Saito'</span>;
o.occupation = <span style="color: #2aa198;">'marksman'</span>;
o.cyberizationLevel = 20;
</pre>
</div>
</li>
<li>如果实例化一个对象,那么上述代码还凑合,如果实例化特别多,那么就麻烦去了.所以
javascript提供了new这个operator来实例化一个新的object,但是因为js里面并没有
class的概念,所以new的后面不是跟的class name,而是一个ctor函数
</li>
<li>前面讲到过, new了以后,除了创建一个空的object,还会把this指针赋值为新创建的
这个object,后面用this.property=xxx来设置新的object的属性就比较简单
</li>
<li>那原理是什么呢?原理就是new创建function的时候, function内部的prototype被
初始化成一个object,然后赋值给this, 然后等返回的时候,再把这个prototype返回
</li>
<li>TODO
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
