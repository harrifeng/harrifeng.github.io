<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Effective C++</title>
<!-- 2017-08-09 Wed 13:32 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Effective C++</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 1: Accustoming Yourself to C++</a>
<ul>
<li><a href="#sec-1-1">Item 1: View C++ as a federation of languages</a></li>
<li><a href="#sec-1-2">Item 2: Prefer const, enums and inlines to #defines</a></li>
<li><a href="#sec-1-3">Item 3: Use const whenever possible</a></li>
<li><a href="#sec-1-4">Item 4: Make sure that objects are initialized before they're used</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 2: 构造析构赋值运算</a>
<ul>
<li><a href="#sec-2-1">Item 05: 了解C++默默编写并调用哪些函数</a></li>
<li><a href="#sec-2-2">Item 06: 若不想使用编译器生成的函数,就该明确拒绝</a></li>
<li><a href="#sec-2-3">Item 07: 为多肽基类声明virtual析构函数</a></li>
<li><a href="#sec-2-4">Item 08: 别让异常逃离析构函数</a></li>
<li><a href="#sec-2-5">Item 09: 绝对不在构造和析构过程中调用virtual函数</a></li>
<li><a href="#sec-2-6">Item 10: 令operator=返回一个reference to *this</a></li>
<li><a href="#sec-2-7">Item 11: 在operator=中处理"自我赋值"</a></li>
<li><a href="#sec-2-8">Item 12: 复制对象时勿忘其每一个成分</a></li>
</ul>
</li>
<li><a href="#sec-3">Chapter 3: 资源管理</a>
<ul>
<li><a href="#sec-3-1">Item 13: 以对象管理资源:</a></li>
<li><a href="#sec-3-2">Item 14: 在资源管理类中小心coping行为</a></li>
<li><a href="#sec-3-3">Item 15: 在资源管理类中提供对原始资源的访问</a></li>
<li><a href="#sec-3-4">Item 16: 成对的使用new和delete时,要采用相同的形式</a></li>
<li><a href="#sec-3-5">Item 17: 以独立语句将newd对象置入智能指针</a></li>
</ul>
</li>
<li><a href="#sec-4">Chapter 4: 设计与声明</a>
<ul>
<li><a href="#sec-4-1">Item 18: 让接口容易被正确使用,不易被误用</a></li>
<li><a href="#sec-4-2">Item 19: 设计class犹如设计type</a></li>
<li><a href="#sec-4-3">Item 20: 宁以pass-by-reference-to-const替换pass-by-value</a></li>
<li><a href="#sec-4-4">Item 21: 必须返回对象时, 别妄想返回其reference</a></li>
<li><a href="#sec-4-5">Item 22: 讲成员变量声明为private</a></li>
<li><a href="#sec-4-6">Item 23: 宁以non-memeber, non-friend替换member函数</a></li>
<li><a href="#sec-4-7">Item 24: 若所有参数皆需类型转换,请为此采用non-member函数</a></li>
<li><a href="#sec-4-8">Item 25: 考虑写出一个不抛出异常的swap函数</a></li>
</ul>
</li>
<li><a href="#sec-5">Chapter 5: 实现</a>
<ul>
<li><a href="#sec-5-1">Item 26: 尽可能延后变量定义式出现时间</a></li>
<li><a href="#sec-5-2">Item 27: 尽量少做转型动作</a></li>
<li><a href="#sec-5-3">Item 28: 避免返回handles指向对象内部成分</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 1: Accustoming Yourself to C++</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Item 1: View C++ as a federation of languages</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>C++ 发展多年以后其实更像如下的几个部分的结合体:
<ol class="org-ol">
<li>C语言
</li>
<li>面向对象的C语言: 构造析构,继承,封装,多肽
</li>
<li>Template: 就是generic programming
</li>
<li>STL: generic programming库
</li>
</ol>
</li>
<li>我们要根据自己当前出的区域,来决定用什么技术更高效, 比如:
<ol class="org-ol">
<li>对于inline类型来说(c语言), build-in类型pass-by-value通常比pass-by-reference
高效, 但是在OOC里面, 由于有构造和析构的存在, 我们就更倾向于使用
pass-by-reference-const.
</li>
<li>在Template领域里面, 也是要传pass-by-reference-const
</li>
<li>但是在STL领域里面pass-by-value再次适用, 因为迭代器和函数对象都是在指针上面塑造
出来的, 那就必须传递指针(指针就是value, 引用才是reference)
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Item 2: Prefer const, enums and inlines to #defines</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>#define的缺点:
<ol class="org-ol">
<li>用define定义以后,由于有预编译的存在, ASPECT_RATIO根本就没进入符号表,那么
出了错误,你也就不知道在哪里去改
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">ASPECT_RATIO</span> 1.653
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Better Option</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">AspectRation</span> = 1.653
</pre>
</div>
</li>
<li>下面这个例子由于预编译的存在, STRING的内存被分配多次,如果用const替代的话,
只需要分配一次
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">STRING</span> <span style="color: #2aa198;">"abcdefg\n"</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">char</span> <span style="color: #268bd2;">string</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">"abcdefg"</span>;

printf<span style="color: #2aa198;">(</span>STRING<span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Allocate memory for STRING</span>

printf<span style="color: #2aa198;">(</span>string<span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Allocate memory for string, for the first and last time.</span>

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">....</span>
printf<span style="color: #2aa198;">(</span>STRING<span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Allocate memory for STRING again</span>
printf<span style="color: #2aa198;">(</span>string<span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">No allocate memory here</span>
</pre>
</div>
</li>
<li>#define并不重视作用域, 除非#undef, 否则她一直有效, 这对于封装来说是个灾
难(不存在private define这一说), const可以解决这个问题
</li>
<li>#define实现宏函数, 问题非常多, 有时候加再多的括号也没办法解决:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #268bd2;">#define</span> <span style="color: #268bd2;">CALL_WITH_MAX</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">a</span>, <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span> f<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>a<span style="color: #b58900;">)</span> &gt; <span style="color: #b58900;">(</span>b<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> ? <span style="color: #2aa198;">(</span>a<span style="color: #2aa198;">)</span> : <span style="color: #2aa198;">(</span>b<span style="color: #2aa198;">)</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">a</span> = 5, <span style="color: #268bd2;">b</span> = 0;

CALL_WITH_MAX<span style="color: #2aa198;">(</span>++a, b<span style="color: #2aa198;">)</span>;  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">a is incremented twice</span>
CALL_WITH_MAX<span style="color: #2aa198;">(</span>++a, b<span style="color: #2aa198;">)</span>;  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">a is incremented once</span>
</pre>
</div>
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Item 3: Use const whenever possible</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>const 指针是非常容易错的部分, 总结起来就是
<ul class="org-ul">
<li>const在*号左边,就是指针指向的东西const
</li>
<li>const在*号右边,就是指针本身const(不能指向其他地址)
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b58900;">char</span> <span style="color: #268bd2;">greeting</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">"Hello"</span>;
<span style="color: #b58900;">char</span> *<span style="color: #268bd2;">p</span> = greeting;              <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">non-const pointer, non-const data</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">p</span> = greeting;        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">non-const pointer, const data</span>
<span style="color: #b58900;">char</span> <span style="color: #859900; font-weight: bold;">const</span> *<span style="color: #268bd2;">p</span> = greeting;        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">same as above</span>

<span style="color: #b58900;">char</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p</span> = greeting;       <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">const pointer, non-const data</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">char</span> * <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p</span> = greeting; <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">const pointer, const data</span>
</pre>
</div>
</li>
<li>const在STL里面的应用如下:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">vec</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span>::<span style="color: #b58900;">iterator</span> <span style="color: #268bd2;">iter</span> = vec.begin<span style="color: #2aa198;">()</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">iter acts like a T* const</span>

<span style="color: #268bd2; font-weight: bold;">std</span>:<span style="color: #268bd2; font-weight: bold;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span>::<span style="color: #b58900;">const_iterator</span> <span style="color: #268bd2;">cIter</span> = vec.begin<span style="color: #2aa198;">()</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">cIter acts like a const T*</span>
</pre>
</div>
</li>
<li>如果一个成员变量被声明为const, 那么她就不能改变过其他成员变量, 下面例子中,
函数operator[]的返回值为const, 那么x[const成员变量]的结果就无法被赋值.
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">TextBlock</span>
<span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">public</span>:
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">char</span>&amp; <span style="color: #859900; font-weight: bold;">operator</span><span style="color: #b58900;">[]</span><span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">position</span><span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">{</span>  <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">operator[] for</span>
        <span style="color: #859900; font-weight: bold;">return</span> text<span style="color: #268bd2;">[</span>position<span style="color: #268bd2;">]</span>;                            <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">const object</span>
    <span style="color: #b58900;">}</span>

    <span style="color: #b58900;">char</span>&amp; <span style="color: #859900; font-weight: bold;">operator</span><span style="color: #b58900;">[]</span><span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">size_t</span> <span style="color: #268bd2;">position</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>              <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">operator[] for</span>
        <span style="color: #859900; font-weight: bold;">return</span> text<span style="color: #268bd2;">[</span>position<span style="color: #268bd2;">]</span>;                            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">non-const object</span>
    <span style="color: #b58900;">}</span>
<span style="color: #859900; font-weight: bold;">private</span>:
    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span> <span style="color: #268bd2;">text</span>;
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Item 4: Make sure that objects are initialized before they're used</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>如果是build-in类型的变量, 在定义的时候给一个初始化值, 因为不然的话, 其内容
是随机的
</li>
<li>对于其他非build-in类型来说, 要调用ctor来初始化, 当然也有注意事项:
<ul class="org-ul">
<li>每个构造函数将所有成员初始化
</li>
<li>初始化顺序和定义顺序相同
</li>
<li>用member initialization list来进行初始化, 原因有:
<ol class="org-ol">
<li>有些时候有些值是只能初始化,而无法赋值的
</li>
<li>调用成员初始化列表其实只是调用了一次copy ctor, 而default ctor在赋值的
话,等于除了default ctor又调用了一次operator=
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 2: 构造析构赋值运算</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Item 05: 了解C++默默编写并调用哪些函数</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>一个类,如果你没声明的话,编译器会默认给你创建三个函数:
<ul class="org-ul">
<li>default ctor
</li>
<li>copy ctor
</li>
<li>copy assignment
</li>
<li>dtor
</li>
</ul>
</li>
<li>所有这些函数都是public, inline的
</li>
<li>编译器产生的dtor是non-virtual的
</li>
<li>如果某个base的类把copy assignment声明为private,那么derived类是不会生成
一个copy assignment的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Item 06: 若不想使用编译器生成的函数,就该明确拒绝</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>为了不让编译器暗自提供某些功能,可以将相应的成员函数声明为private,并且不予
实现
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Item 07: 为多肽基类声明virtual析构函数</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>当derived 对象经由base 指针删除, 而base 带着一个non-virtual dtor, 那么其
结果未定义&#x2013;通常情况下是derived成分没有被销毁
</li>
<li>如果一个class里面哪怕只有一个virtual函数,那么它一定要有一个virtual的dtor,
如果一个virtual函数都没有,那么它没有想过继承这件事情,设置一个virtual dtor会
增大对象的大小
</li>
<li>说到多肽, 我们可以有这么一种继承方法:动物类-&gt;鸟类-&gt;鸵鸟类, 其中鸟类和鸵鸟类
都可以实例化,因为有这种动物, 而动物类就不应该实例化. 为了防止这种类被实例化
c++中给他们了一个类型叫做"抽象基类(abstract base class)", 想让一个类成为
抽象基类很简单, 只需要在这个类里面定义一个纯虚函数即可
</li>
<li>所谓纯虚函数,就是derived类里面必须要实现,而base类里面不需要实现的函数,其定义
语法比较不常见
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Base</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">virtual</span>  <span style="color: #b58900;">void</span> <span style="color: #268bd2;">pure_virtual_example</span><span style="color: #b58900;">()</span> = 0;
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>既然有一个纯虚函数就可以成为抽象基类可以了,而且既然是抽象基类肯定是要继承的
那么dtor肯定要是虚函数, 那么我们不妨"合二为一"把dtor设计成纯虚函数, 如下,
需要注意的是,纯虚dtor需要一个定义
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Base</span>
<span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">public</span>:
    <span style="color: #268bd2;">Base</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        cout &lt;&lt; <span style="color: #2aa198;">"Base Ctor"</span> &lt;&lt; endl;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">virtual</span> ~<span style="color: #268bd2;">Base</span><span style="color: #b58900;">()</span> = 0;
    <span style="color: #859900; font-weight: bold;">virtual</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">speak</span><span style="color: #b58900;">()</span> = 0;
<span style="color: #2aa198;">}</span>;
<span style="color: #268bd2; font-weight: bold;">Base</span>::~<span style="color: #268bd2;">Base</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    cout &lt;&lt; <span style="color: #2aa198;">"Pure Virtual Dtor Need One Difinition!"</span> &lt;&lt; endl;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">De</span> : <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Base</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">public</span>:
    <span style="color: #268bd2;">De</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        cout &lt;&lt; <span style="color: #2aa198;">"De Ctor"</span> &lt;&lt; endl;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">virtual</span> ~<span style="color: #268bd2;">De</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        cout &lt;&lt; <span style="color: #2aa198;">"De Dtor"</span> &lt;&lt; endl;
    <span style="color: #b58900;">}</span>
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">speak</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{}</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">De</span> *<span style="color: #268bd2;">dd</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">De</span><span style="color: #b58900;">()</span>;
    <span style="color: #859900; font-weight: bold;">delete</span> dd;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Item 08: 别让异常逃离析构函数</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>c++并不禁止析构函数突出异常,但是它并不鼓励你这么做
</li>
<li>如果客户需要堆某个操作函数运行期间抛出的异常做出反应,那么class应该提供一个
普通函数(而非在析构函数中)执行该操作
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Item 09: 绝对不在构造和析构过程中调用virtual函数</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>Base class构造期间, virtual函数不是virtual函数,只是base的一个函数, 其
绝对不可能到derived class阶层
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Item 10: 令operator=返回一个reference to *this</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>赋值是可以写成连锁形式的, 其赋值顺序是才用右结合:
<div class="org-src-container">

<pre class="src src-c++">x = y = z = 15;
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Following is the real order by default</span>
x = <span style="color: #2aa198;">(</span>y = <span style="color: #b58900;">(</span>z=15<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>为了实现赋值连锁, 赋值操作符函数必须返回一个reference指向操作符的左侧实参
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Widget</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">public</span>:
    <span style="color: #b58900;">Widget</span>&amp; <span style="color: #859900; font-weight: bold;">operator</span><span style="color: #268bd2;">=</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Widget</span>&amp; <span style="color: #268bd2;">rhs</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
        <span style="color: #859900; font-weight: bold;">return</span> *<span style="color: #859900; font-weight: bold;">this</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Item 11: 在operator=中处理"自我赋值"</h3>
<div class="outline-text-3" id="text-2-7">
<ul class="org-ul">
<li>"自我赋值"发生在对象给自己赋值的时候,如果在这个期间有指针的话,那么事情就有可
能出现问题:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Bitmap</span> <span style="color: #2aa198;">{</span>
<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">..</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Widget</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">private</span>:
    <span style="color: #b58900;">Bitmap</span>* <span style="color: #268bd2;">pb</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Wrong Version!! what about if rhs is this</span>
<span style="color: #b58900;">Widget</span>&amp; <span style="color: #268bd2; font-weight: bold;">Widget</span>::<span style="color: #859900; font-weight: bold;">operator</span><span style="color: #268bd2;">=</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Widget</span>&amp; <span style="color: #268bd2;">rhs</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">delete</span> pb;
    pb = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Bitmap</span><span style="color: #b58900;">(</span>*rhs.pb<span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> *<span style="color: #859900; font-weight: bold;">this</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>破解"自我赋值"难题的方法是"证同测试(identity test)"
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b58900;">Widget</span>&amp; <span style="color: #268bd2; font-weight: bold;">Widget</span>::<span style="color: #859900; font-weight: bold;">operator</span><span style="color: #268bd2;">=</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Widget</span>&amp; <span style="color: #268bd2;">rhs</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">this</span> == &amp;rhs<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">return</span> *<span style="color: #859900; font-weight: bold;">this</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">identity test</span>
    <span style="color: #859900; font-weight: bold;">delete</span> pb;
    pb = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Bitmap</span><span style="color: #b58900;">(</span>*rhs.pb<span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> *<span style="color: #859900; font-weight: bold;">this</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>上面这个版本依然有异常方面的麻烦, 如果new Bitmap出现了异常, 那么pb已经被
删除,现在是一个空指针.所以我们要调整前面的语句顺序: 先记录pb的地址,在new
Bitmap之后再删除这个指针
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Widget</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">Bitmap</span>* <span style="color: #268bd2;">pOrig</span> = pb; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">remember previous pb</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">if exception here, the next line delete pOrig will not execute</span>
    pb = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Bitmap</span><span style="color: #b58900;">(</span>*rhs.pb<span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">delete</span> pOrig;
    <span style="color: #859900; font-weight: bold;">return</span> *<span style="color: #859900; font-weight: bold;">this</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">Item 12: 复制对象时勿忘其每一个成分</h3>
<div class="outline-text-3" id="text-2-8">
<ul class="org-ul">
<li>OO编程会把内部都封装起来,而外界留下两个函数进行复制拷贝: copy ctor 和
copy assignment, 我们称之为copying函数
</li>
<li>copying函数应该确保赋值"对象内部所有的成员变量", 和 "所有base class成员"
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Customer</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">PriorityCustomer</span> : <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Customer</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">public</span>:
    <span style="color: #268bd2;">PriorityCustomer</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">PriorityCustomer</span>&amp; <span style="color: #268bd2;">rhs</span><span style="color: #b58900;">)</span>;
    <span style="color: #b58900;">PriorityCustomer</span>&amp; <span style="color: #859900; font-weight: bold;">operator</span><span style="color: #268bd2;">=</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">PriorityCustomer</span>&amp; <span style="color: #268bd2;">rhs</span><span style="color: #b58900;">)</span>;
<span style="color: #859900; font-weight: bold;">private</span>:
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">priority</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #268bd2; font-weight: bold;">PriorityCustomer</span>::<span style="color: #268bd2;">PriorityCustomer</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">PriorityCustomer</span>&amp; <span style="color: #268bd2;">rhs</span><span style="color: #2aa198;">)</span>
    : Customer<span style="color: #2aa198;">(</span>rhs<span style="color: #2aa198;">)</span>, priority<span style="color: #2aa198;">(</span>rhs.priority<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{}</span>
<span style="color: #b58900;">PriorityCustomer</span>&amp; <span style="color: #268bd2; font-weight: bold;">PriorityCustomer</span>::<span style="color: #859900; font-weight: bold;">operator</span><span style="color: #268bd2;">=</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">PriorityCustomer</span>&amp; <span style="color: #268bd2;">rhs</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">Customer</span>::<span style="color: #859900; font-weight: bold;">operator</span>=<span style="color: #b58900;">(</span>rhs<span style="color: #b58900;">)</span>;
    priority = rhs.priority;
    <span style="color: #859900; font-weight: bold;">return</span> *<span style="color: #859900; font-weight: bold;">this</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>不要尝试某个copying函数取实现另一个copying函数, 应该将共同机能部分放进第
三个函数中(通常叫做init),由两个copying函数共同调用
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 3: 资源管理</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Item 13: 以对象管理资源:</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>对c++来说,所谓资源就是申请了就要释放的资源,不仅仅是内存,包括文件描述符,互斥
锁(mutex lock)都要申请了还给系统
</li>
<li>假设我们有一个投资的类如下:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Investment</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>我们通过工厂模式来返回某个Investment对象
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#36820;&#22238;&#25351;&#38024;,&#25351;&#21521;&#21160;&#24577;&#20998;&#37197;&#30340;&#20869;&#23384;(&#23384;&#20648;Investment&#23545;&#35937;),</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#35843;&#29992;&#32773;&#26377;&#36131;&#20219;&#37322;&#25918;&#20182;&#20204;</span>
Investment* createInvestment<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>使用使用工厂模式返回的对象,我们可以用一下代码来释放它.
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b58900;">void</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">Investment</span>* <span style="color: #268bd2;">pInv</span> = createInvestment<span style="color: #b58900;">()</span>;
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
    <span style="color: #859900; font-weight: bold;">delete</span> pInv;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这看起来妥当的方法却很有可能无法正确删除createInvestment返回的对象,因为//&#x2026;
里面可能出现不正常的情况(无论如何,就是无法到达delete), 比如:
<ul class="org-ul">
<li>过早的return
</li>
<li>抛出了异常
</li>
</ul>
</li>
<li>为了应对这种情况,c++设计了auto_ptr来管理资源
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b58900;">void</span> <span style="color: #268bd2;">f</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">&#20250;&#22312;&#23545;&#35937;&#31163;&#24320;&#20316;&#29992;&#22495;&#30340;&#26102;&#20505;, &#33258;&#21160;&#35843;&#29992;&#26512;&#26500;&#20989;&#25968;&#20445;&#35777;&#36164;&#28304;&#37322;&#25918;</span>
    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">auto_ptr</span><span style="color: #b58900;">&lt;</span>Investment<span style="color: #b58900;">&gt;</span> <span style="color: #268bd2;">pInv</span><span style="color: #b58900;">(</span><span style="color: #b58900;">createInvestment</span><span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>;
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个简单的例子, 精确的演绎了"以对象管理资源"的两个关键想法:
<ul class="org-ul">
<li>获得资源后立刻放入"管理对象(managing object)"里面
</li>
<li>"管理对象(managing object)"来确保资源被释放
</li>
</ul>
</li>
<li>auto_ptr虽然实现了上面的两个关键想法,但是其为了防止"拷贝的时候,出现多个对象,
然后析构多次", 毅然而然的设计了一种特殊的"复制":一旦copy(或者copy assinment)
就把资源唯一的代理权给新的指针,自己变成null
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">pInv1&#25351;&#21521;createInvestment&#30340;&#36820;&#22238;&#20540;</span>
<span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">auto_ptr</span><span style="color: #2aa198;">&lt;</span>Investment<span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">pInv1</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">createInvestment</span><span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">&#29616;&#22312;pInv2&#25351;&#21521;&#23545;&#35937;, pInv1&#20026;null</span>
<span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">auto_ptr</span><span style="color: #2aa198;">&lt;</span>Investment<span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">pInv2</span><span style="color: #2aa198;">(</span>pInv1<span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">&#29616;&#22312;pInv1&#25351;&#21521;&#23545;&#35937;, pInv2&#20026;null</span>
pInv1 = pInv2
</pre>
</div>
</li>
<li>由于起诡异的复制行为,而STL容器要求其元素发挥"正常的"复制行为,因此,这些容器里面
不能包含auto_ptr成员
</li>
<li>一个复制行为正常的智能指针是tr1::shared_ptr, 它使用引用计数来持续追踪乖哦能用
多少对象指向某个资源.
</li>
<li>不过可惜的是,shared_ptr也有很多缺点:无法判别循环引用(两个其实已经没有使用的对
象相互指向, 因而好像感觉都还在"被使用")
</li>
<li>智能指针(包括auto_ptr和shared_ptr)还有一个特别大的缺点,他们的实现中,析构的时候
总是suppose用户使用的是单个成员,所以只用delete,而不是delete[],所以下面两个例子
都是错误的
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#39306;&#20027;&#24847;,&#20250;&#29992;&#38169;&#35823;&#30340;delete&#24418;&#24335;</span>
<span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">auto_ptr</span><span style="color: #2aa198;">&lt;</span><span style="color: #268bd2; font-weight: bold;">std</span>::string<span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">aps</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">new</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span><span style="color: #b58900;">[</span>10<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;
<span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">tr1</span>::<span style="color: #b58900;">shared_ptr</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">spi</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">int</span><span style="color: #b58900;">[</span>1024<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>最后的最后,请大家注意的是createInvestment返回"未加工指针(raw pointer)", 简直
就是对资源泄漏的死亡邀请,因为调用者极易忘记释放资源.所以我们会在item18里面修改
createInvestment的借口
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Item 14: 在资源管理类中小心coping行为</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>复制RAII(Resource Acquisition Is Initialization) 对象必须一并复制它所管理的
资源,所以资源的copying行为决定RAII对象的copying行为
</li>
<li>普遍而常见的RAII copying行为是:抑制copying,使用引用计数法
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Item 15: 在资源管理类中提供对原始资源的访问</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>条款13的例子中使用了智能指针来管理Investment, 但是由于改变了指针的类型(变成了智能
指针型), 所以需要一些转换,有两种方式:
<ul class="org-ul">
<li>显示转换, 智能指针提供的get函数
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">tr1</span>::<span style="color: #b58900;">shared_ptr</span><span style="color: #2aa198;">&lt;</span>Investment<span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">pInv</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">createInvestment</span><span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">declare</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">dayHeld</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Investment</span>* <span style="color: #268bd2;">pi</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">usage</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">days</span> = dayHeld<span style="color: #2aa198;">(</span>pInv.get<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>隐式转换
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Item 16: 成对的使用new和delete时,要采用相同的形式</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>游戏规则很简单,如果调用new的时候使用了[],那么在对应的delete的时候,也要加上[]
</li>
<li>如果typedef使用了的话, 那么delete的时候,要注意,不要被typedef的类型蒙蔽
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span> <span style="color: #b58900;">AddressLine</span><span style="color: #2aa198;">[</span>4<span style="color: #2aa198;">]</span>;
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">new Addressline&#36820;&#22238;&#19968;&#20010;new string[4]</span>
<span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span>* <span style="color: #268bd2;">pal</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">AddressLine</span>;

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">delete</span> pal; <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">Not defined</span>
<span style="color: #859900; font-weight: bold;">delete</span> <span style="color: #2aa198;">[]</span>pal; <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">Good</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Item 17: 以独立语句将newd对象置入智能指针</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>这里看似是讨论智能指针的问题,其实是讨论c++编译器"灵活性"的一种:参数执行顺序
的灵活性:一个函数的几个参数如果需要计算值作为参数,那么谁先谁后,是无法保证的
(java, c#可以保证)
</li>
<li>比如我们有个例子,函数processWidget的两个参数pw, priority, 而我们想把函数
priority()的返回值作为priority的值. 某个new Widget的临时指针作为pw的值:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">priority</span><span style="color: #2aa198;">()</span>;

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">declaration for the function</span>
<span style="color: #b58900;">void</span> <span style="color: #268bd2;">processWidget</span><span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">tr1</span>::<span style="color: #b58900;">shared_ptr</span><span style="color: #b58900;">&lt;</span>Widget<span style="color: #b58900;">&gt;</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">priority</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">usage fo the function</span>
processWidget<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Widget</span>, priority<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>上面的这种语法在编译的时候无法通过,因为tr1::shared_ptr的构造函数虽然是以
一个raw pointer为参数,但是这个构造函数被声明为explicit,所以是无法进行隐式
转换的, 显示转换然后调用的代码如下
<div class="org-src-container">

<pre class="src src-c++">processWidget<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">tr1</span>::shared_ptr<span style="color: #b58900;">&lt;</span>Widget<span style="color: #b58900;">&gt;(</span><span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Widget</span><span style="color: #b58900;">)</span>, priority<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>上面看似挺好的代码,却隐藏着资源泄漏的危险, 原因就是我们上面说的c++编译器在
以什么顺序计算参数方面,是没有定数的. processWidget的参数要完成下面三件事:
<ul class="org-ul">
<li>调用priority()
</li>
<li>执行new Widget, 生成一个临时的指针X
</li>
<li>把临时指针X作为参数,调用tr1::shared_ptr构造函数
</li>
</ul>
</li>
<li>上面调用shared_ptr构造函数一定要在生成临时指针之后,但是调用priority(),可以
出现在第一步,第二步,或者最后一步,假设最终是以下面的这个顺序执行的:
<ol class="org-ol">
<li>执行new Widget, 生成一个临时的指针X
</li>
<li>调用priority()
</li>
<li>把临时指针X作为参数,调用tr1::shared_ptr构造函数
</li>
</ol>
</li>
<li>如果在执行priority()的时候抛出了异常, 那么临时指针X就会遗失,因为它尚未放入到
我们自动管理资源的shared_ptr内部.也就不可能被释放了.
</li>
<li>解决的方法也很简单:使用分离的语句1,创建Widget. 2,讲Widget放入智能指针内部
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">tr1</span>::<span style="color: #b58900;">shared_ptr</span><span style="color: #2aa198;">&lt;</span>Widget<span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">pw</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Widget</span><span style="color: #2aa198;">)</span>;

processWidget<span style="color: #2aa198;">(</span>pw, priority<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 4: 设计与声明</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Item 18: 让接口容易被正确使用,不易被误用</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>"促进正确使用"的办法包括接口的一致性,以及与内置类型行为的兼容
</li>
<li>"阻止误用"的办法包括建立新类型, 限制类型操作, 束缚对象值, 以及消除客户的资
源管理责任
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Item 19: 设计class犹如设计type</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>在设计每个class的时候,回答以下问题:
<ul class="org-ul">
<li>新type对象应该如何创建和销毁
</li>
<li>对象的初始化和对象的赋值操作有什么差别
</li>
<li>新的type的对象如果被passed by value意味着什么 (copy构造函数用来定义一个
type的pass-by-value如何实现)
</li>
<li>什么是新type的"合法值"
</li>
<li>需要继承什么
</li>
<li>新type需要什么样的转换
</li>
<li>什么样的操作符和函数对次type而言是合理的
</li>
<li>什么样的标准函数应该被驳回(声明为private)
</li>
<li>函数该采用public,private还是protected
</li>
<li>什么是新type的"未声明接口"
</li>
<li>新的type有多一般化,如果一般化的够多,比如integer, string等都要一般化的化,
就要考虑generic编程了
</li>
<li>你真的需要一个新的type么
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Item 20: 宁以pass-by-reference-to-const替换pass-by-value</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>pass-by-reference-to-const效率高的多, 因为没有任何构造或者析构函数的调用(没
有新的对象被创建)
</li>
<li>pass-by-reference-to-const不仅仅是效率高,而且可以避免对象切割(slicing)问题:
当一个derived对象以by value的方式传递到一个并被视为base对象, 那么base class的
拷贝构造函数会被调用而"造成此对象的行为像个derived class对象"的那些特质化的性质
全被切割掉了
</li>
<li>不用pass-by-reference-to-const的唯一情况是1)内置类型2)STL的迭代器和函数对象
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Item 21: 必须返回对象时, 别妄想返回其reference</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>说到返回值,在c++中是可以返回一个对象的.方法入下,其实这就是最正常的写法
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">inline</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rational</span> <span style="color: #859900; font-weight: bold;">operator</span><span style="color: #268bd2;">*</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rational</span>&amp; <span style="color: #268bd2;">lhs</span>, <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rational</span>&amp; <span style="color: #268bd2;">rhs</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> Rational<span style="color: #b58900;">(</span>lhs.n * rhs.n, lhs.d * rhs.d<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>在Item20的影响下,可能会想到返回值"也用reference", 其实这是非常危险的, 因为reference
不是单独存在的,一个reference一定有一个"实体", 比如下面这个例子. 返回值reference其实
对应的是一个local的result对象, 一旦从函数返回,那么local的result就被销毁了.返回一个
已经销毁的,不存在的"实体"的reference是非常可怕的
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rational</span>&amp; <span style="color: #859900; font-weight: bold;">operator</span><span style="color: #268bd2;">*</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rational</span>&amp; <span style="color: #268bd2;">lhs</span>,
                           <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rational</span>&amp; <span style="color: #268bd2;">rhs</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">&#35686;&#21578;!&#31967;&#31957;&#30340;&#20195;&#30721;!!</span>
    <span style="color: #b58900;">Rational</span> <span style="color: #268bd2;">result</span><span style="color: #b58900;">(</span>lhs.n * rhs.n, lhs.d * rhs.d<span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> result;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们稍微改变一下,在heap里面创建一个对象,然后返回,例子如下.
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rational</span>&amp; <span style="color: #859900; font-weight: bold;">operator</span><span style="color: #268bd2;">*</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rational</span>&amp; <span style="color: #268bd2;">lhs</span>,
                           <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rational</span>&amp; <span style="color: #268bd2;">rhs</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">Rational</span>* <span style="color: #268bd2;">result</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Rational</span><span style="color: #b58900;">(</span>lhs.n * rhs.n, lhs.d * rhs.d*<span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> *result;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个例子其实也是不行的,因为释放内存的责任是调用者的,那就有可能会因为无法找到heapd的句柄,
无法释放内存,而发生内存泄漏. 比如下面, 调用了两次operator*, 那么就要释放两次内存,但是
却没有办法让operator* 使用者进行delete调用, 因为没有合理的办法让他们取得operator*返
回的references背后隐藏的那个指针.
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b58900;">Rational</span> <span style="color: #268bd2;">w</span>, <span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">y</span>, <span style="color: #268bd2;">z</span>;
w = x * y *z;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Item 22: 讲成员变量声明为private</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>切记将成员变量声明为private, 因为这样有很多好处:
<ul class="org-ul">
<li>可以实现更精确的访问控制:如果是public的话,谁都可以访问,但是private你却可以设置成:
只读,不准访问,读写访问,只写访问, 等等
</li>
<li>一个变量声明为public那就意味着永远不可改变, 声明为private给了class作者有了更大的
实现弹性
</li>
</ul>
</li>
<li>protected其实是历史一流, 和public一样,没有任何的封装性.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">Item 23: 宁以non-memeber, non-friend替换member函数</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li>class的member函数和friend函数在访问private数据方面的权利是一样的,所以具有一样的,
所以封装效果是一样的.这里比较的是non-member, non-friend函数和member函数. 我们的
原则是:如果一个member函数可以用non-member,non-friend函数来替代,那么就替代
</li>
<li>下面是一个webBroswerStuff的例子, 这个例子有三个member函数,其中clearBrowser其实
可以用一个non-member, non-friend函数代替,这样就是增加了class的封装性
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">WebBrowser</span><span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">clearCache</span><span style="color: #b58900;">()</span>;
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">clearHistory</span><span style="color: #b58900;">()</span>;
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">removeCookies</span><span style="color: #b58900;">()</span>;
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">clearBrowser</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        clearCache<span style="color: #268bd2;">()</span>;
        clearHistory<span style="color: #268bd2;">()</span>;
        removeCookies<span style="color: #268bd2;">()</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>用non-member, non-friend函数代替可以代替的member函数,并且使用一个namespace,是
c++常用的方法
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">WebBrowserStuff</span><span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">WebBrowser</span><span style="color: #b58900;">{</span>
        <span style="color: #b58900;">void</span> <span style="color: #268bd2;">clearCache</span><span style="color: #268bd2;">()</span>;
        <span style="color: #b58900;">void</span> <span style="color: #268bd2;">clearHistory</span><span style="color: #268bd2;">()</span>;
        <span style="color: #b58900;">void</span> <span style="color: #268bd2;">removeCookies</span><span style="color: #268bd2;">()</span>;
    <span style="color: #b58900;">}</span>;
    <span style="color: #b58900;">void</span>  <span style="color: #268bd2;">clearBrowser</span><span style="color: #b58900;">(</span><span style="color: #b58900;">WebBrowser</span>&amp; <span style="color: #268bd2;">wb</span><span style="color: #b58900;">){</span>
        wb.clearCache<span style="color: #268bd2;">()</span>;
        wb.clearHistory<span style="color: #268bd2;">()</span>;
        wb.removeCookies<span style="color: #268bd2;">()</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>话说,namespace是STL里面组织代码的主要方式,因为namespace可以跨越不同的文件
(class不行), std命名空间分布在数十个头文件(&lt;vector&gt;, &lt;algorithm&gt;, &lt;memory&gt;
里面等等), 用户想用某个就include某一个头文件. (class就不行,class无法分割)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7">Item 24: 若所有参数皆需类型转换,请为此采用non-member函数</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>这个item其实是讲如何在c++中把事情做对,而不是怎样做更好. 比如,一开始把operator*
实现成成员变量的化,碰到result = 2 * oneHalf, 必然会编译器报错,然后修改也不迟.
</li>
<li>错误的operator* 实现
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Rational</span> <span style="color: #2aa198;">{</span>
<span style="color: #268bd2; font-weight: bold;">pulic</span>:
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOT work for result = 2 * oneHalf</span>
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rational</span> <span style="color: #859900; font-weight: bold;">operator</span><span style="color: #268bd2;">*</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rational</span>&amp; <span style="color: #268bd2;">rhs</span><span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">const</span>;
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>正确的operator*是一个non-member, 借用numberator()和denominator()函数读取
private值,而不是设计成有元函数
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Rational</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rational</span> <span style="color: #859900; font-weight: bold;">operator</span><span style="color: #268bd2;">*</span><span style="color: #2aa198;">(</span>lhs.numberator<span style="color: #b58900;">()</span> * rhs.numberator<span style="color: #b58900;">()</span>,
                         lhs.denominator<span style="color: #b58900;">()</span> * rhs.denominator<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> Rational<span style="color: #b58900;">(</span>lhs.numberator<span style="color: #268bd2;">()</span> * rhs.numberator<span style="color: #268bd2;">()</span>,
                    lhs.denominator<span style="color: #268bd2;">()</span> * rhs.denominator<span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8">Item 25: 考虑写出一个不抛出异常的swap函数</h3>
<div class="outline-text-3" id="text-4-8">
<ul class="org-ul">
<li>当std::swap对你的类型效率不高的时候,提供一个swap成员函数, 并确定这个函数不
抛出异常
</li>
<li>如果你提供了一个member swap,也应该提供改一改non-member swap来调用前者,对于
classes(而不是templates), 也请特化std::swap
</li>
<li>对自己特例化的swap调用方式是先using, 再调用swap,而且没有直接写std::swap,这
源于编译器对namespace的名字查找时, 遵循的一系列规则
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Widget</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">public</span>:
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">swap</span><span style="color: #b58900;">(</span><span style="color: #b58900;">Widget</span>&amp; <span style="color: #268bd2;">other</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">swap</span>;
        swap<span style="color: #268bd2;">(</span>pImpl, other.pImpl<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>;
<span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">template</span><span style="color: #b58900;">&lt;&gt;</span>
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">swap</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">Widget</span><span style="color: #b58900;">&gt;(</span><span style="color: #b58900;">Widget</span>&amp; <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">Widget</span>&amp; <span style="color: #268bd2;">b</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        a.swap<span style="color: #268bd2;">(</span>b<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 5: 实现</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Item 26: 尽可能延后变量定义式出现时间</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>在老的c语言规范里面(C89/90)里面, 变量只能定义在block开始的地方.注意!!不是
function开始的地方, 即便是C89/90, 把所有变量都定义在函数开始的地方是非常
不明智的, 因为这样会导致逻辑不清晰, 变量作用域模糊的代码
</li>
<li>对于C++来说,变量"直到需要的时候"才定义,有更多的好处:
<ul class="org-ul">
<li>变量作用域更清晰, 下面的成本如下(但是方法B更清晰,作用域更准确):
<ol class="org-ol">
<li>方法A : 1个构造函数 + 1个析构函数 + n个赋值操作
</li>
<li>方法B : n个构造函数 + n个析构函数
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#26041;&#27861;A, &#23450;&#20041;&#20110;&#24490;&#29615;&#22806;</span>
<span style="color: #b58900;">Widget</span> <span style="color: #268bd2;">w</span>;

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; n; ++i<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    w = &#21462;&#20915;&#20110;i&#30340;&#26576;&#20010;&#20540;;
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#26041;&#27861;B, &#23450;&#20041;&#20110;&#24490;&#29615;&#20869;</span>
<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; n; ++i<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">Widget</span> <span style="color: #268bd2;">w</span><span style="color: #b58900;">(</span>&#21462;&#20915;&#20110;i&#30340;&#26576;&#20010;&#20540;<span style="color: #b58900;">)</span>;
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>防止"定义了不使用"(由于异常的存在,当然异常现在不推荐使用)
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span> <span style="color: #268bd2;">encryptPassword</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span>&amp; <span style="color: #268bd2;">password</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;
    <span style="color: #b58900;">string</span> <span style="color: #268bd2;">encrypted</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>password.length<span style="color: #268bd2;">()</span> &lt; MinimumPasswordLength<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">throw</span> logic_error<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Password is too short"</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
    <span style="color: #859900; font-weight: bold;">return</span> encrypted; <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">May NOT be used!</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>直到真正需要的时候,就意味着大多数情况下这个变量已经有了一个靠谱的初始化
值,那么就可以用"直接在构造的时候指定初始值", 这效率比起"通过default构造
函数构造出一个对象,然后对它复制"效果好
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span> <span style="color: #268bd2;">encryptPassword</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span>&amp; <span style="color: #268bd2;">password</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#26816;&#26597;&#38271;&#24230;</span>
    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span> <span style="color: #268bd2;">encrypted</span><span style="color: #b58900;">(</span>password<span style="color: #b58900;">)</span>;

    encrypt<span style="color: #b58900;">(</span>encrypted<span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> encrypted;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Item 27: 尽量少做转型动作</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>c语言风格的转型有以下两种(其实也只是小括号摆放位置不同而已),因此我们称之为"旧
式转型"(old-style casts)
<div class="org-src-container">

<pre class="src src-c"><span style="color: #2aa198;">(</span><span style="color: #b58900;">T</span><span style="color: #2aa198;">)</span><span style="color: #b58900;">expression</span>   <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">&#23558;expression &#36716;&#22411;&#20026;T</span>
<span style="color: #268bd2;">T</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">expression</span><span style="color: #2aa198;">)</span>   <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">&#23558;expression &#36716;&#22411;&#20026;T</span>
</pre>
</div>
</li>
<li>c++有四种新型的转型:
<ul class="org-ul">
<li>const_cast 将对象的常量性去除(cast away the constness)
</li>
<li>dynamic_cast 执行"安全向下转型" (safe downcasting), 也就是用来决定某对象
是否归属继承体系中的某个类型. 换句话说就是,你想在一个你认定了肯定是derived
class 对象身上执行derived class操作函数, 但是你手上却只有一个"指向base"
的pointer或者reference,你只能依靠他们来处理,所以你想到了把它dynamic_cast
到"你认为的类型"
</li>
<li>reinterpret_cast意图执行低级转型, 由于取决于编译器,也即表示它不可移植
</li>
<li>static_cast用来强迫隐式转换(implicit conversions).比如将non-const对象
转换为const对象, 或者将int转换为double. 但是无法将const转换为non-const,
只有const_cast才能做到
</li>
</ul>
</li>
<li>c++规则设计目的之一就是, 保证"类型错误"绝对不可能发生.理论上如果你"很干净"的
通过编译,就表示它并不企图在任何对象身上执行任何不安全,无意义的操作. 这是一个
极具价值的保证,不要轻率的放弃.
</li>
<li>c++的新型转型语法更受欢迎, 因为:
<ul class="org-ul">
<li>很容易在代码中被辨识出来(相比较老的类型转换就一个括号), 也就容易查找到问题
</li>
<li>新型类型转换分成了四种,每种功能都限定在一个比较小的范围内,便于让编译器找到
问题
</li>
</ul>
</li>
<li>虽然c++的转型非常的好,但是有时候我们还是会使用"旧式转型",比如调用一个explicit
构造函数,把一个对象传递给一个函数的时候.很多时候这也是c++里面推荐的,唯一使用"旧
式转型"的情况(其实也可以使用新式转型):
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Widget</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">public</span>:
    <span style="color: #859900; font-weight: bold;">explicit</span> <span style="color: #268bd2;">Widget</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">size</span><span style="color: #b58900;">)</span>;
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">doSomeWork</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Widget</span>&amp; <span style="color: #268bd2;">w</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#20197;&#19968;&#20010;int&#21152;&#19978;"&#26087;&#24335;&#20989;&#25968;&#39118;&#26684;"&#30340;&#36716;&#22411;&#21160;&#20316;&#21019;&#24314;&#20102;&#19968;&#20010;Widget</span>
doSomeWork<span style="color: #2aa198;">(</span>Widget<span style="color: #b58900;">(</span>15<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#20197;&#19968;&#20010;int&#21152;&#19978;"&#26032;&#24335;C++&#39118;&#26684;"&#30340;&#36716;&#22411;&#21160;&#20316;&#21019;&#24314;&#20102;&#19968;&#20010;Widget</span>
doSomeWork<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">static_cast</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">Widget</span><span style="color: #b58900;">&gt;(</span>15<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>转型不是简单的告诉编译器把某种类型视为另一种类型, 它往往会零编译器编译出"运行期间
执行的代码",比如下面的例子,由于底层机制的不同,把int转换成double,几乎肯定会产生一
些代码
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">y</span>;
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #b58900;">double</span> <span style="color: #268bd2;">d</span> = <span style="color: #859900; font-weight: bold;">static_cast</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">double</span><span style="color: #2aa198;">&gt;(</span>x<span style="color: #2aa198;">)</span> / y;
</pre>
</div>
</li>
<li>在继承体系中使用cast,也会产生"运行时代码", 因为c++支持多重继承,所以一个derived
对象可能拥有两个地址(Base1指向时候的地址,或者Base2指向时候的地址). 当然,有些实现
中单继承一会出现一个Derived的对象拥有两个地址的奇怪景象!
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">B1</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">B2</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">D</span> : <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">B1</span>, <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">B2</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">D</span> <span style="color: #268bd2;">aD</span>;
    <span style="color: #b58900;">B1</span>* <span style="color: #268bd2;">pb1</span> = &amp;aD;
    <span style="color: #b58900;">B2</span>* <span style="color: #268bd2;">pb2</span> = &amp;aD;

    cout &lt;&lt; &amp;aD &lt;&lt; endl;
    <span style="color: #93a1a1;">//////////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">There's no possible way for the B1 sub-object to //</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">have the same address as the B2 sub-object.      //</span>
    <span style="color: #93a1a1;">//////////////////////////////////////////////////////</span>
    cout &lt;&lt; pb1 &lt;&lt; endl;
    cout &lt;&lt; pb2 &lt;&lt; endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">///////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;==========running the test.out=========&gt; //</span>
<span style="color: #93a1a1;">//                                           </span><span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0x28fecc                                  //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0x28fecc                                  //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0x28fed0                                  //</span>
<span style="color: #93a1a1;">//                                           </span><span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;==========test.out ends here===========&gt; //</span>
<span style="color: #93a1a1;">///////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Item 28: 避免返回handles指向对象内部成分</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>假设我们要有一个"矩形"类, 其成员是两个点, 左上和右下.那么我们就有如下的类的
基础代码:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Point</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">public</span>:
    <span style="color: #268bd2;">Point</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">x</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">y</span><span style="color: #b58900;">)</span>;
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">setX</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">newVal</span><span style="color: #b58900;">)</span>;
    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">setY</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">newVal</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">RectData</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">Point</span> <span style="color: #268bd2;">ulhc</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ulhc = "upper left-hand corner"</span>
    <span style="color: #b58900;">Point</span> <span style="color: #268bd2;">lrhc</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">lrhc = "lower right-hand corner"</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Rectangle</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">private</span>:
    <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">tr1</span>::<span style="color: #b58900;">shared_ptr</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">RectData</span><span style="color: #b58900;">&gt;</span> <span style="color: #268bd2;">pData</span>;
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>函数需要对外公开"左上"和"右下"的数值, 所以有下面两个函数.
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Rectangle</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">public</span>:
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
    <span style="color: #b58900;">Point</span>&amp; <span style="color: #268bd2;">upperLeft</span><span style="color: #b58900;">()</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> pData-&gt;ulhc;
    <span style="color: #b58900;">}</span>
    <span style="color: #b58900;">Point</span>&amp; <span style="color: #268bd2;">lowerRight</span><span style="color: #b58900;">()</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> pData-&gt;lrhc;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>这两个函数可以通过编译,确是两个个错的函数,因为他们破坏了封装性!不是声明为了
const了么, 只有const对象可以调用这两个函数,为什么还破坏了封装性? 原因请看
下面的例子.虽然rec 是const的,不可更改,但是因为你返回了内部Point成员变量的
reference,可以利用这个reference来改动内部数据
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b58900;">Point</span> <span style="color: #268bd2;">coord1</span><span style="color: #2aa198;">(</span>0.0<span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">Point</span> <span style="color: #268bd2;">coord2</span><span style="color: #2aa198;">(</span>100, 100<span style="color: #2aa198;">)</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rectangle</span> <span style="color: #268bd2;">rec</span><span style="color: #2aa198;">(</span>coord1, coord2<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">rec is const, but rec.upperLeft() is Point&amp;, and</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">can be changed</span>
rec.upperLeft<span style="color: #2aa198;">()</span>.setX<span style="color: #2aa198;">(</span>50<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>上面的例子是返回了一个reference,其实指针或者迭代器和reference的效果是一样
的, 它们三个都叫做handles(号码牌,用来取得某个对象)
</li>
<li>上面的例子,稍加修改(返回const reference)就可以保证其封装性.
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Rectangle</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">public</span>:
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Point</span>&amp; <span style="color: #268bd2;">upperLeft</span><span style="color: #b58900;">()</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> pData-&gt;ulhc;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Point</span>&amp; <span style="color: #268bd2;">lowerRight</span><span style="color: #b58900;">()</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> pData-&gt;lrhc;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>上面这种实现方法, 虽然勉强可以使用(operator[]就是这么实现的.),但深究起来,
还是会有dangling handles(空悬号码牌的问题), 比如下面的例子,GUIObject作
为一个参数传入,求它的"左上右下"矩形数据.(boundingBox(*pgo))整个这一部分
会产生一个临时的Rectangle对象tmp, 随后upperLeft,作用于temp身上, 返回一
个指向temp内部成分的reference(也就是temp的Point).这个语句过后, temp
就会被销毁,间接导致temp的Point也会析构, 也就是说pUpperLeft一开始就指向
了一块已经析构了的内存地址!
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">GUIObject</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#20197; by value&#26041;&#24335;&#36820;&#22238;, &#19968;&#23450;&#35201;&#22768;&#26126;&#20026;const, &#21487;&#20197;&#38450;&#27490;&#19981;&#23567;&#24515;&#34987;'='&#36171;&#20540;</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Rectangle</span> <span style="color: #268bd2;">boundingBox</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">GUIObject</span>&amp; <span style="color: #268bd2;">obj</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&#29992;&#25143;&#21487;&#33021;&#20250;&#22914;&#19979;&#20351;&#29992;, &#22240;&#20026;&#20020;&#26102;&#23545;&#35937;&#30340;&#20135;&#29983;,&#25152;&#20197;&#20250;&#23548;&#33268;dangling handles</span>
<span style="color: #b58900;">GUIObject</span>* <span style="color: #268bd2;">pgo</span>;
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">Points</span>* <span style="color: #268bd2;">pUpperLeft</span> = &amp;<span style="color: #2aa198;">(</span>boundingBox<span style="color: #b58900;">(</span>*pgo<span style="color: #b58900;">)</span>.upperLeft<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
