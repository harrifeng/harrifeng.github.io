<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>cpp-primer-5th</title>
<!-- 2017-05-02 Tue 10:52 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">cpp-primer-5th</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 01: Getting Started</a>
<ul>
<li><a href="#sec-1-1">Writing a Simple C++ Program</a>
<ul>
<li><a href="#sec-1-1-1">Compiling and Executing Our Program</a></li>
</ul>
</li>
<li><a href="#sec-1-2">A First Look at Input/Output</a></li>
<li><a href="#sec-1-3">A Word about Comments</a></li>
<li><a href="#sec-1-4">Flow of Control</a></li>
<li><a href="#sec-1-5">Introducing Clases</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 02: Variables and basic types</a>
<ul>
<li><a href="#sec-2-1">Primitive Build-in Types</a>
<ul>
<li><a href="#sec-2-1-1">Arithmetic Types</a></li>
<li><a href="#sec-2-1-2">Type Conversions</a></li>
</ul>
</li>
<li><a href="#sec-2-2">Variables</a>
<ul>
<li><a href="#sec-2-2-1">Variable Definitions</a></li>
<li><a href="#sec-2-2-2">Variable Declarations and Definitions</a></li>
<li><a href="#sec-2-2-3">Identifiers</a></li>
<li><a href="#sec-2-2-4">Scope of a Name</a></li>
</ul>
</li>
<li><a href="#sec-2-3">Compound Types</a>
<ul>
<li><a href="#sec-2-3-1">References</a></li>
<li><a href="#sec-2-3-2">Pointers</a></li>
<li><a href="#sec-2-3-3">Understanding Compound Type Declarations</a></li>
</ul>
</li>
<li><a href="#sec-2-4">const Qualifier</a>
<ul>
<li><a href="#sec-2-4-1">References to const</a></li>
<li><a href="#sec-2-4-2">Pointers and Const</a></li>
<li><a href="#sec-2-4-3">Top-Level const</a></li>
<li><a href="#sec-2-4-4">constexpr and Constant Expressions</a></li>
</ul>
</li>
<li><a href="#sec-2-5">Dealing with Types</a>
<ul>
<li><a href="#sec-2-5-1">Type Aliases</a></li>
<li><a href="#sec-2-5-2">The auto Type Specifier</a></li>
<li><a href="#sec-2-5-3">The decltype Type Specifier</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">Chapter 03: Strings, Vectors, and Arrays</a>
<ul>
<li><a href="#sec-3-1">Namespace using Declarations</a></li>
<li><a href="#sec-3-2">Library string Type</a>
<ul>
<li><a href="#sec-3-2-1">Defining and Initializing strings</a></li>
<li><a href="#sec-3-2-2">Operations on strings</a></li>
<li><a href="#sec-3-2-3">Dealing with the Characters in a string</a></li>
</ul>
</li>
<li><a href="#sec-3-3">Library vector Type</a>
<ul>
<li><a href="#sec-3-3-1">Defining and Initializing vectors</a></li>
<li><a href="#sec-3-3-2">Adding Elements to a vector</a></li>
<li><a href="#sec-3-3-3">Other vector Operations</a></li>
</ul>
</li>
<li><a href="#sec-3-4">Introducing Iterators</a>
<ul>
<li><a href="#sec-3-4-1">Using Iterators</a></li>
<li><a href="#sec-3-4-2">Iterator Arithmetic</a></li>
</ul>
</li>
<li><a href="#sec-3-5">Arrays</a>
<ul>
<li><a href="#sec-3-5-1">Defining and Initializing Built-in Arrays</a></li>
<li><a href="#sec-3-5-2">Access the Element of Array</a></li>
<li><a href="#sec-3-5-3">Pointers and Arrays</a></li>
<li><a href="#sec-3-5-4">C-Style Character Strings</a></li>
<li><a href="#sec-3-5-5">Interfacing to Older Code</a></li>
</ul>
</li>
<li><a href="#sec-3-6">Multidimensional Arrays</a></li>
</ul>
</li>
<li><a href="#sec-4">Chapter 04: Expressions</a>
<ul>
<li><a href="#sec-4-1">Fundamentals</a>
<ul>
<li><a href="#sec-4-1-1">Basic Concepts</a></li>
<li><a href="#sec-4-1-2">Precedence and Associativity</a></li>
</ul>
</li>
<li><a href="#sec-4-2">The Member Access Operators</a></li>
</ul>
</li>
<li><a href="#sec-5">Chapter 05: Statements</a>
<ul>
<li><a href="#sec-5-1">Simple Statements</a>
<ul>
<li><a href="#sec-5-1-1">Null Statements</a></li>
<li><a href="#sec-5-1-2">Beware of Missing or Extraneous Semicolons</a></li>
<li><a href="#sec-5-1-3">Compound Statements(Blocks)</a></li>
</ul>
</li>
<li><a href="#sec-5-2">Statement Scope</a></li>
<li><a href="#sec-5-3">Conditional Statements</a>
<ul>
<li><a href="#sec-5-3-1">The if Statement</a></li>
<li><a href="#sec-5-3-2">The switch Statement</a></li>
</ul>
</li>
<li><a href="#sec-5-4">Iterative Statements</a>
<ul>
<li><a href="#sec-5-4-1">The while Statement</a></li>
<li><a href="#sec-5-4-2">Traditional for Statement</a></li>
<li><a href="#sec-5-4-3">Range for Statement</a></li>
<li><a href="#sec-5-4-4">The do while Statement</a></li>
</ul>
</li>
<li><a href="#sec-5-5">Jump Statements</a>
<ul>
<li><a href="#sec-5-5-1">The break Statement</a></li>
<li><a href="#sec-5-5-2">The continue Statement</a></li>
<li><a href="#sec-5-5-3">The goto Statment</a></li>
</ul>
</li>
<li><a href="#sec-5-6">try Blocks and Exception Handling</a>
<ul>
<li><a href="#sec-5-6-1">A throw Expression</a></li>
<li><a href="#sec-5-6-2">The try Block</a></li>
<li><a href="#sec-5-6-3">Standard Exceptions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 01: Getting Started</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Writing a Simple C++ Program</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>每个cpp程序都有一个或者多个function, 而且其中一个function的名字必须是main,下
面就是一个最简单的cpp程序,什么都不做就是返回零
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>在大多数系统中, 返回值为0意味着success, 而nonzero意味着失败
</li>
</ul>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Compiling and Executing Our Program</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>cpp文件可以使用如下的后缀:
<ul class="org-ul">
<li>cc
</li>
<li>cxx
</li>
<li>cpp
</li>
<li>cp
</li>
<li>C
</li>
</ul>
</li>
<li>在类Unix系统中,我们使用如下的一条命令来把"源代码"编译成"可执行程序"
<div class="org-src-container">

<pre class="src src-sh">CC prog1.cc
</pre>
</div>
</li>
<li>编译完成的程序,会默认使用a.out这个名字(在windows上面mingw系统编译成a.exe)
</li>
<li>运行就直接调用这个a.out就可以了.使用echo $?可以查看main函数的返回值
<pre class="example">
c:/code/cpp-in-action/primer5/ch01 &gt;&gt;&gt; CC 01.cc
c:/code/cpp-in-action/primer5/ch01 &gt;&gt;&gt; ./a.exe
c:/code/cpp-in-action/primer5/ch01 &gt;&gt;&gt; echo $?
0
</pre>
</li>
<li>Windows上面是查看ERRORLEVEL
<div class="org-src-container">

<pre class="src src-sh">&gt; echo %ERRORLEVEL%
0
</pre>
</div>
</li>
<li>如果你不想使用a.out或者a.exe,那么可以使用-o参数指定自己的"可执行程序"的名
字
<pre class="example">
c:/code/cpp-in-action/primer5/ch01 &gt;&gt;&gt; ls
01.cc
c:/code/cpp-in-action/primer5/ch01 &gt;&gt;&gt; g++ -o 01 01.cc
c:/code/cpp-in-action/primer5/ch01 &gt;&gt;&gt; ls
01.cc  01.exe
</pre>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">A First Look at Input/Output</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>cpp是通过一个叫做iostream的standard library来处理IO.所谓stream就是一系列的
从IO设备读入或输出的字符串
</li>
<li>处理IO的object主要有:
<ul class="org-ul">
<li>istream类型的object : cin处理输入
</li>
<li>ostream类型的object : cout处理输出
</li>
<li>ostream类型的object : cerr处理warning和error的输出
</li>
<li>ostream类型的object : clog处理总结信息等
</li>
</ul>
</li>
<li>我们下面看一个结合input和output的例子
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa198;">"Enter two numbers:"</span> &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">v1</span> = 0, <span style="color: #268bd2;">v2</span> = 0;
    <span style="color: #268bd2; font-weight: bold;">std</span>::cin &gt;&gt; v1 &gt;&gt; v2;
    <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa198;">"The sum of "</span> &lt;&lt; v1 &lt;&lt; <span style="color: #2aa198;">" and "</span> &lt;&lt; v2
              &lt;&lt; <span style="color: #2aa198;">" is "</span> &lt;&lt; v1 + v2 &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Enter two numbers:                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3 7                                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The sum of 3 and 7 is 10                       //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">A Word about Comments</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>c++ 兼容c的`/**/`注释方式
</li>
<li>同时提供了`//`的行注释方式
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Flow of Control</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>flow of control和其他的语言类似,有两种:
<ul class="org-ul">
<li>知道循环次数的时候,使用for
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sum</span> = 0, <span style="color: #268bd2;">val</span> = 1;
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">val</span> = 1; val &lt;= 10; ++val<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        sum += val;
        ++val;
    <span style="color: #b58900;">}</span>

    <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa198;">"Sum of 1 to 10 inclusive is "</span>
              &lt;&lt; sum &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Sum of 1 to 10 inclusive is 55                 //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>不知道具体循环次数的时候,使用while
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">currVal</span> = 0, <span style="color: #268bd2;">val</span> = 0;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">std</span>::cin &gt;&gt; currVal<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #b58900;">int</span> <span style="color: #268bd2;">cnt</span> = 1;
        <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">std</span>::cin &gt;&gt; val<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span>val == currVal<span style="color: #6c71c4;">){</span>
                ++cnt;
            <span style="color: #6c71c4;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #6c71c4;">{</span>
                <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; currVal &lt;&lt; <span style="color: #2aa198;">" occurs "</span>
                          &lt;&lt; cnt &lt;&lt; <span style="color: #2aa198;">" times"</span> &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;
                currVal = val;
                cnt = 1;
            <span style="color: #6c71c4;">}</span>
        <span style="color: #268bd2;">}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">while loop ends here</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">remember to print the count for the last value in the file</span>
        <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; currVal &lt;&lt; <span style="color: #2aa198;">" occurs "</span>
                  &lt;&lt; cnt &lt;&lt; <span style="color: #2aa198;">" times"</span> &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">42 42 42 42 42 55 55 62 100 100 100            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">42 occurs 5 times                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">55 occurs 2 times                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">62 occurs 1 times                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100 occurs 3 times                             //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Introducing Clases</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>在cpp中,我们可以定义自己的类型:通过关键字class. cpp的特点是,我们自己定义的
类型,和内置类型拥有几乎一样的"性质"
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 02: Variables and basic types</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Primitive Build-in Types</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>cpp定义的内置类型(primitive type)包括了:
<ul class="org-ul">
<li>算术类型(arithmetic type)
</li>
<li>特殊类型(void)
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">Arithmetic Types</h4>
<div class="outline-text-4" id="text-2-1-1">
<ul class="org-ul">
<li>算术类型在规范里面,只给了"最小"size, 因为机器字符宽度不同,所导致的最大长度
并不相同.下面是规范规定的最小size
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Meaning</th>
<th scope="col" class="left">Minimum Size</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">bool</td>
<td class="left">boolean</td>
<td class="left">8 bits</td>
</tr>

<tr>
<td class="left">char</td>
<td class="left">character</td>
<td class="left">16 bits</td>
</tr>

<tr>
<td class="left">wchar_t</td>
<td class="left">wide character</td>
<td class="left">16 bits</td>
</tr>

<tr>
<td class="left">char16_t</td>
<td class="left">Unicode character</td>
<td class="left">16 bits</td>
</tr>

<tr>
<td class="left">char32_t</td>
<td class="left">Unicode character</td>
<td class="left">32 bits</td>
</tr>

<tr>
<td class="left">short</td>
<td class="left">short integer</td>
<td class="left">16 bits</td>
</tr>

<tr>
<td class="left">int</td>
<td class="left">integer</td>
<td class="left">16 bits</td>
</tr>

<tr>
<td class="left">long</td>
<td class="left">long integer</td>
<td class="left">32 bits</td>
</tr>

<tr>
<td class="left">long long</td>
<td class="left">long integer</td>
<td class="left">64 bits</td>
</tr>

<tr>
<td class="left">float</td>
<td class="left">single-precision floating-point</td>
<td class="left">6 significant digits</td>
</tr>

<tr>
<td class="left">double</td>
<td class="left">double-precision floating-point</td>
<td class="left">10 significant digits</td>
</tr>

<tr>
<td class="left">long double</td>
<td class="left">extended-precision floating-point</td>
<td class="left">10 significant digits</td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2">Type Conversions</h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>type conversion在cpp中是非常容易发生的,比如
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">bool</span> <span style="color: #268bd2;">b</span> = 42;               <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">b is true</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = b;                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">i has value 1</span>
i = 3.14;                  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">i has value 3</span>
<span style="color: #b58900;">double</span> <span style="color: #268bd2;">pi</span> = i;             <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">pi has value 3.0</span>
<span style="color: #b58900;">unsigned</span> <span style="color: #b58900;">char</span> <span style="color: #268bd2;">c</span> = -1;      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">assuming 8-bit chars, c has value 255</span>
<span style="color: #b58900;">signed</span> <span style="color: #b58900;">char</span> <span style="color: #268bd2;">c2</span> = 256;      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">assuming chars, the value of c2 is undefined</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Variables</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">Variable Definitions</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>变量的定义很简单
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">sum</span> =0;
<span style="color: #b58900;">Sales_item</span> <span style="color: #268bd2;">item</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">item has type Sales_item</span>
</pre>
</div>
</li>
<li>如果一个变量在定义的时候还有有初始值,我们就说它被initialized了
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: price is defined and initialized before it is used to initialize discount</span>
<span style="color: #b58900;">double</span> <span style="color: #268bd2;">price</span> = 109.99;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: call applyDiscount and use the returen value to initialized salePrice</span>
<span style="color: #b58900;">double</span> <span style="color: #268bd2;">salePrice</span> = applyDiscount<span style="color: #2aa198;">(</span>price, discount<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>需要注意的是Initialization和assignment并不相同
<pre class="example">
Initialization happens when a variable is given a value when it is
created. Assignment obliterates an object's current value and replaces
that value with a new one.
</pre>
</li>
<li>initialization子所以复杂,是因为cpp定义了很多种"合理的"方法,比如,下面四种初
始化的方法都是合理的
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">units_sold</span> = 0;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">units_sold</span> = <span style="color: #2aa198;">{</span>0<span style="color: #2aa198;">}</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">units_sold</span><span style="color: #2aa198;">{</span>0<span style="color: #2aa198;">}</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">units_sold</span><span style="color: #2aa198;">(</span>0<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>{}来initialize的方式,是c++11才新近引入的, 名字叫做list initialization
</li>
<li>list initialization看似不常用,却有一个特殊的作用:编译器会检查初始化是否会
损失精度
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">long</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">ld</span> = 3.14159;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">a</span><span style="color: #b58900;">{</span>ld<span style="color: #b58900;">}</span>;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">b</span> = <span style="color: #b58900;">{</span>ld<span style="color: #b58900;">}</span>;
    <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; a &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;
    <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; b &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>


<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ g++ -std=c++11 01.cc                         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">01.cc: In function 'int main(int, char**)':    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">01.cc:6:13: warning: narrowing conversion of   //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">'ld' from 'long double' to 'int' inside { }    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[-Wnarrowing]                                  //</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">int a{ld};                                //</span>
<span style="color: #93a1a1;">//              </span><span style="color: #93a1a1;">^                                 //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">01.cc:7:16: warning: narrowing conversion of   //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">'ld' from 'long double' to 'int' inside { }    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[-Wnarrowing]                                  //</span>
<span style="color: #93a1a1;">//      </span><span style="color: #93a1a1;">int b = {ld};                             //</span>
<span style="color: #93a1a1;">//                 </span><span style="color: #93a1a1;">^                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ ./a.out                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>非list initialization通常是使用'='或者(), 都是可以通过编译并且没有warning的
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">long</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">ld</span> = 3.14159;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">c</span><span style="color: #b58900;">(</span>ld<span style="color: #b58900;">)</span>, <span style="color: #268bd2;">d</span> = ld;

    <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; c &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;
    <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; d &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;

    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ g++ -std=c++11 02.cc                         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ ./a.out                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>如果声明的时候没有给与一个initializer的话,那么会被给与一个default value:
<ul class="org-ul">
<li>如果是built-in类型的话:
<ol class="org-ol">
<li>定义在function body之外的,全部会被初始化为zero
</li>
<li>定义在function body之内的,会被设置为unitialized状态.local static
object(built-in type)是唯一一个特例(虽然在某个function里面,但是在
声明的时候,必定初始化为0了)
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">count_calls</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">count</span>;
    <span style="color: #859900; font-weight: bold;">return</span> ++count;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; 3; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; count_calls<span style="color: #268bd2;">()</span> &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ol>
</li>
<li>如果不是build-in类型的话:
<ol class="org-ol">
<li>如果class的定义允许我们不使用explicit initializer的话,当然可以直接定
义而不给initializer
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span> <span style="color: #268bd2;">empty</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">empty implicitly initialized to the empty string</span>
</pre>
</div>
</li>
<li>有些class需要explicitly initialized,所以必须给与initializer才可以.
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">Variable Declarations and Definitions</h4>
<div class="outline-text-4" id="text-2-2-2">
<ul class="org-ul">
<li>为了能够让不同的文件来写不同的逻辑部分.c++支持separate compilation.也就是把
一个大的程序,分成多个不同的文件进行编译.
</li>
<li>为了支持separate compilation, cpp区分了以下两个概念:
<ul class="org-ul">
<li>声明 (declaration) : 声明只会指出变量的名字和类型,不会分配内存. 可以简单
的理解为有extern而没有'='的语句.
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">extern</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span>;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">declares but does not define i</span>
</pre>
</div>
</li>
<li>定义 (definition) : 定义不仅仅会指出变量的名字和类型, 而且会分配内存, 甚
至给出初始值. 简单理解就是1只要有'='或者2只要没有extern的语句都是定义
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">has '=', definition, memory is ready, has default value of 1</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 1;
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">has '=', even extern shown, it is also a definition</span>
<span style="color: #859900; font-weight: bold;">extern</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">pi</span> = 3.1416;
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">no extern, definition. memory is ready, but no default value</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">j</span>;
</pre>
</div>
</li>
</ul>
</li>
<li>一个变量可以被声明很多次,但是只能被定义一次. 如果我们要在多个文件里面使用
同一个变量,那么我们要:
<ul class="org-ul">
<li>只在一个文件里面定义它(只一次)
</li>
<li>在其他的使用这个变量的文件中,声明它(多次)
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">Identifiers</h4>
<div class="outline-text-4" id="text-2-2-3">
<ul class="org-ul">
<li>变量标示的要求在cpp里面和其他的语言没什么不同,不能以数字开头(防止和数字混淆)
</li>
<li>关键字不能作为变量标示
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4">Scope of a Name</h4>
<div class="outline-text-4" id="text-2-2-4">
<ul class="org-ul">
<li>作用域scope在cpp里面,大部分情况下是靠{}来分割的
</li>
<li>相同的名字在不同的作用域里面可能代表不同的变量.名字从declare开始,可以被使用,
直到这个作用域(包含declare的scope)结束.
<pre class="example">
Names are visible from the point where they are declared until
the end of the scope in which the declaration appears
</pre>
</li>
<li>我们在cpp里面建议在第一次'使用'这个变量的时候,才去定义它, 因为这样容易找到
变量定义(而不是在程序开始的地方), 同时这样容易给变量一个有意义的初始值
</li>
<li>scope也可以包含其他scope的:
<ul class="org-ul">
<li>被包含的scope叫做inner scope
</li>
<li>包含其他scope的scope叫做outer scope
</li>
</ul>
</li>
<li>定义在outer scope的name可能会被inner scope里面的相同名字的变量所掩盖
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">reused</span> = 42;      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">resued has global scope</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">unique</span> = 0;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">unique has block scope</span>
    <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa198;">"use global reused "</span> &lt;&lt; reused &lt;&lt; <span style="color: #2aa198;">" unique is "</span> &lt;&lt; unique &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;

    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">reused</span> = 0;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">new, local object named reused hides global reused</span>
    <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa198;">"use local reused  "</span> &lt;&lt; reused &lt;&lt; <span style="color: #2aa198;">" unique is "</span> &lt;&lt; unique &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;

    <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #2aa198;">"explicityly request global reused "</span> &lt;&lt; ::reused &lt;&lt; <span style="color: #2aa198;">" unique is "</span> &lt;&lt; unique &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;

    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">//////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;   //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">use global reused 42 unique is 0                 //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">use local reused  0 unique is 0                  //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">explicityly request global reused 42 unique is 0 //</span>
<span style="color: #93a1a1;">//////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Compound Types</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>所谓compund type定义如下
<pre class="example">
A compound type is a type that is defined in terms of another type.
</pre>
</li>
<li>cpp中有一些compund type,其中最著名的两个:引用和指针.
</li>
</ul>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">References</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>首先要说明的是,一般来说reference就是指的lvalue reference, 虽然新出来一种rvalue reference
</li>
<li>然后我们来看看reference的本质:其本质就是为一个object寻找一个alternative name
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">ival</span> = 1024;
<span style="color: #b58900;">int</span> &amp;<span style="color: #268bd2;">refVal</span> = ival;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">refVal refers to (is another name for) ival</span>
</pre>
</div>
</li>
<li>我们来比较一下常规的definition和reference的definition之间的差距:
<ul class="org-ul">
<li>常规的definition : 我们定义的时候, 这个initializer的值就会被"拷贝"到我们
申请的内存(object)里面
</li>
<li>reference的definition: 我们定义的时候,是把reference给"bind"到initializer
(也就是ival).而且reference是一旦初始化,就无法再refer给其他的object.正是因
为无法rebind,所以reference必须在定义的时候赋予初始化值.也就是说下面这行
是不行的
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">Error!</span>
<span style="color: #b58900;">int</span> &amp;<span style="color: #268bd2;">refVal</span>;
</pre>
</div>
</li>
</ul>
</li>
<li>其实reference说来说去,只是给object起了一个新的名字而已!
<pre class="example">
A reference is not an object. Instead, a reference is just another
name for an already existing object.
</pre>
</li>
<li>正是由于reference不是一个object,所以我们不能定义reference to reference.
</li>
<li>在大多数情况下(两种特例是const和继承), ref自己的类型必须和initializer的类
型相同
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">double</span> <span style="color: #268bd2;">dval</span> = 3.14;
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Error; initializer must be an int object!</span>
<span style="color: #b58900;">int</span> &amp;<span style="color: #268bd2;">refVal5</span> = dval;
</pre>
</div>
</li>
<li>而且不能把reference"绑定"道非object的对象, 比如literal或者是general expression
的结果
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Error! initializer must be an object</span>
<span style="color: #b58900;">int</span> &amp;<span style="color: #268bd2;">refVal4</span> = 10;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Pointers</h4>
<div class="outline-text-4" id="text-2-3-2">
<ul class="org-ul">
<li>Pointer是C时代的产物, Reference是cpp为了改变Pointer的某些危险特性而设计的,
所以,两者有很多异同点:
<ul class="org-ul">
<li>相同点: 都是compunt type, 而且是用来indirect acces to other objects
</li>
<li>不同点: Pointer是一个object! 这就决定了很多point的"危险的"行为:
<ol class="org-ol">
<li>pointer是可以被赋值和拷贝的, 而且可以被赋值很多次
</li>
<li>pointer定义的时候,甚至可以没有初始化值(因为可以被多次赋值)
</li>
<li>如果pointer定义了以后,没有给与初始化值,那么这个pointer的值是undefined!
非常危险
</li>
</ol>
</li>
</ul>
</li>
<li>Pointer是用来"保存另外一个object的地址"的object.所以我们要用到取地址符(&amp;),
千万不要和reference前面的`&amp;`混淆:
<ul class="org-ul">
<li>reference前面的&amp;是为了区别'普通declarator'(比如ival) 和'reference declarator'
(比如refVal)而加的,是一个语法层面的标记
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">ival</span> = 1024;
<span style="color: #b58900;">int</span> &amp;<span style="color: #268bd2;">refVal</span> = ival;
</pre>
</div>
</li>
<li>pointer是指向某个object的地址的, 所以要在那个object前面加`&amp;`, 这个`&amp;`是一
个操作符,就和`^`一样,进行的是"取地址"操作. 当然了,为了区分'普通declarator'
(比如ival)和'pointer declarator'(比如p), 我们要在pointer 前面加个'*'
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">ival</span> = 42;
<span style="color: #b58900;">int</span> *<span style="color: #268bd2;">p</span> = &amp;ival;
</pre>
</div>
</li>
</ul>
</li>
<li>还是除了const和继承以外,pointer类型必须和initializer相同.
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">double</span> <span style="color: #268bd2;">dval</span>;
<span style="color: #b58900;">double</span> *<span style="color: #268bd2;">pd</span> = &amp;dval;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: initializer is the address of a double</span>
<span style="color: #b58900;">double</span> *<span style="color: #268bd2;">pd2</span> = pd;      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: initializer is a pointer to double</span>

<span style="color: #b58900;">int</span> *<span style="color: #268bd2;">pi</span> = pd;          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: types of pi and pd differ</span>
pi = &amp;dval;            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: assigning the address of a double to a pinter to int</span>
</pre>
</div>
</li>
<li>Pointer的值是存储的是address,这个地址值可以有如下四种可能:
<ul class="org-ul">
<li>这个地址可以是指向一个object
</li>
<li>这个地址可以指向一个object后面的位置
</li>
<li>这个地址可以为了null,表示pointer没有指向任何object
</li>
<li>这个地址可以是invalid的(比如定义没有给初始化的情况下), 这种情况是最危险的.
</li>
</ul>
</li>
<li>前面介绍了取地址操作符`&amp;`, 而把地址还原成object(dereference)的符号是`*` ,
需要注意的是我们一定要对valid的地址进行derefernce操作
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">ival</span> = 42;
    <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">p</span> = &amp;ival;
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">* yields the object to which p points</span>
    cout &lt;&lt; *p &lt;&lt; endl;

    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">* yields the object; we assign a new value to ival throught p</span>
    *p = 0;
    cout &lt;&lt; *p &lt;&lt; endl;
    cout &lt;&lt; ival &lt;&lt; endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">42                                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>如果一个指针不指向任何的object,我们把这个指针叫做null poiner.可以在定义的
时候通过如下方法来定义null pointer
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">cstdlib</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">//////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">use to include nullptr g++ --std=c++11 06.cc //</span>
    <span style="color: #93a1a1;">//////////////////////////////////////////////////</span>
    <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">p1</span> = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;
    <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">p2</span> = 0;
    <span style="color: #268bd2; font-weight: bold;">NULL</span> is include in cstdlib
    <span style="color: #93a1a1;">///////////////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Modern C++ programs generally should avoid using NULL //</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">and use nullptr instead                               //</span>
    <span style="color: #93a1a1;">///////////////////////////////////////////////////////////</span>
    <span style="color: #b58900;">int</span> *p3 = <span style="color: #268bd2; font-weight: bold;">NULL</span>;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>虽然NULL在预定义的时候,其值就是0, 但是pointer确不接受integer作为它的rvalue,
因为它会以为你是想要把'这个int的地址'赋予给这个pointer.所以上面三种才是给null
pointer 赋值(或初始化的方式)
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">cstdlib</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">p4</span> = <span style="color: #268bd2; font-weight: bold;">NULL</span>;

    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">zero</span> = 0;
    <span style="color: #93a1a1;">///////////////////////////////////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">07.cc:9:15: error: invalid conversion from 'int' to 'int*' [-fpermissive] //</span>
    <span style="color: #93a1a1;">//  </span><span style="color: #93a1a1;">int *p5 = zero;                                                          //</span>
    <span style="color: #93a1a1;">//            </span><span style="color: #93a1a1;">^                                                              //</span>
    <span style="color: #93a1a1;">///////////////////////////////////////////////////////////////////////////////</span>
    <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">p5</span> = zero;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>因为pointer是可以赋值的,所以任何NULL值的pointer都是false,否则都是true
</li>
<li>在范型还是不是很成熟的c时代,为了能够应对不同类型的pointer,发明了void* pointer
这种pointer可以指向任何的类型, 而且可以和其他pointer比较(因为都是地址么),
但是不可以对其进行dereference操作,进而控制响应object(因为不知道地址对应的
类型是什么,所以无法决断拿几个bytes的地址)
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">double</span> <span style="color: #268bd2;">obj</span> = 3.14, *<span style="color: #268bd2;">pd</span> = &amp;obj;

    <span style="color: #b58900;">void</span> *<span style="color: #268bd2;">pv</span> = &amp;obj;
    pv = pd;
    <span style="color: #93a1a1;">/////////////////////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">08.cc:10:14: error: 'void*' is not a pointer-to-object type //</span>
    <span style="color: #93a1a1;">//  </span><span style="color: #93a1a1;">cout &lt;&lt; *pv &lt;&lt; endl;                                       //</span>
    <span style="color: #93a1a1;">//           </span><span style="color: #93a1a1;">^                                                 //</span>
    <span style="color: #93a1a1;">/////////////////////////////////////////////////////////////////</span>
    cout &lt;&lt; *pv &lt;&lt; endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3">Understanding Compound Type Declarations</h4>
<div class="outline-text-4" id="text-2-3-3">
<ul class="org-ul">
<li>pointer和ref的定义方式非常令人困惑,是因为如下两种方式都是合理的
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> *<span style="color: #268bd2;">p1</span>;  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Way1: p1 is a pointer to int</span>
<span style="color: #b58900;">int</span>* <span style="color: #268bd2;">p2</span>;  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Way2: p2 is a pointer to int</span>
</pre>
</div>
</li>
<li>我们认为第二种定义(Way2)方式不好,因为它看起来好像definition的任务是定义了
一个int* 类型,其实不是的`*`是用来形容p2的, 这个definition的主体是一个int类
型.
</li>
<li>第二种定义方式在一次定义超过一个变量的时候会更加的难以区别
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span>* <span style="color: #268bd2;">p1</span>, <span style="color: #268bd2;">p2</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">p1 is a pinter to int; p2 is an int</span>
</pre>
</div>
</li>
<li>所以我们决定在后面都使用第一宠定义方式(Way1).
</li>
<li>因为pointer是一个object, 所以它自己也是有地址的,所以我们也可以让另外一个
pointer指向它, 也就是我们常说的pointer to pointer
</li>
<li>既然我们使用`*`来标示此变量为指针,那么我们也可以连续的使用多个`*`来标示"指针
的指针",甚至"指针的指针的指针"
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">ival</span> = 1024;
    <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">pi</span> = &amp;ival;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">pi points to an int</span>
    <span style="color: #b58900;">int</span> **<span style="color: #268bd2;">ppi</span> = &amp;pi;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ppi points to a pointer to an int</span>

    cout &lt;&lt; <span style="color: #2aa198;">"The value of ival\n"</span>
         &lt;&lt; <span style="color: #2aa198;">"direct value:   "</span> &lt;&lt; ival &lt;&lt; <span style="color: #2aa198;">"\n"</span>
         &lt;&lt; <span style="color: #2aa198;">"indirect value: "</span> &lt;&lt; *pi  &lt;&lt; <span style="color: #2aa198;">"\n"</span>
         &lt;&lt; <span style="color: #2aa198;">"doubly indirect value: "</span> &lt;&lt; **ppi
         &lt;&lt; endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The value of ival                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">direct value:   1024                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">indirect value: 1024                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">doubly indirect value: 1024                    //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>因为reference不是一个object,所以我们不能让pointer指向reference, 但是我们却
可以为pointer创建reference
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">const Qualifier</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>const的作用是防止变量被更改, 因为无法被更改,所以定义的时候,必须给与初始值
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = get_size<span style="color: #2aa198;">()</span>;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: initialized at run time</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">j</span> = 42;            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: initialized at compile time</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">k</span>;                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: k is uninitialized const</span>
</pre>
</div>
</li>
<li>const所赋予变量的"常量性"只在它被改变的那个时候,才起作用,平时const int变量
和int变量并没有什么不同, 比如,我们可以给int类型j赋值,initializer为一个const
int 类型
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 42;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">ci</span> = i;          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: the value in i is copied into ci</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">j</span> = ci;                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: the value in ci is copied into j</span>
</pre>
</div>
</li>
<li>鉴于const常量在定义的时候就必须赋予initializer值,那么单纯的"声明"一个常量就
不可能了, 所以在多个文件里面使用常量是不现实的,
</li>
<li>默认情况下, 常量是local to a file的. 所以在不同文件里面的const常量如果重名
了也没有关系,因为它们相当于file_name::const_name
</li>
<li>如果你想要在多个文件里面share常量,我们肯定要使用extern
</li>
<li>但是我们不光要在"declare"里面使用extern,在"definition"那里也必须使用extern!
否则编译器会把你的const变量直接替换成数值(比如下例中,所有bufSize都直接替换成
1001), 下面就是definition里面也使用extern const的例子
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">extern</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">bufSize</span> = 1001;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">getSize</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> bufSize + 1;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>"declare"里面当然也得使用extern了.
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">extern</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">bufSize</span>;
    cout &lt;&lt; bufSize &lt;&lt; endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ g++ -o a.out 11.cc 12.cc                     //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ ./a.out                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1001                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1">References to const</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li>const type的object也是object，我们当然可以给一个object绑定一个reference啦,
但是这个reference既然绑定的是const变量,那么它本身是const变量的"另外一个名字"
也就必然无法被赋值了
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">ci</span> = 1024;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> &amp;<span style="color: #268bd2;">r1</span> = ci;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">OK: both reference and underlying object are const</span>
r1 = 42;                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: r1 is a reference to const</span>
</pre>
</div>
</li>
<li>同样的,我们在初始化的时候,reference的类型也必须是const type的,否则无法初始
化成功
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">ci</span> = 1024;
<span style="color: #b58900;">int</span> &amp;<span style="color: #268bd2;">r2</span> = ci;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: non const reference to a const object!</span>
</pre>
</div>
</li>
<li>如果铭记reference不是object这个事实,我们就很容易理解, const是无法修饰reference
的.
</li>
<li>而reference无法改变初始化binding的对象这个特点,其实让reference本身具有了"const"
属性, 所以reference to什么类型只影响到我们能对reference做什么.而不影响reference
binding的这个过程.
</li>
<li>前面我们说过,有两种情况下,reference的类型和它要bind的类型可以不"完全match"
这里我们就遇到了第一种: reference to const X类型可以接受"所有能够converted to
X类型"的类型作为自己的initializer, 比如
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">double</span> <span style="color: #268bd2;">dval</span> = 3.14;
    <span style="color: #93a1a1;">////////////////////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">We can initialize a reference to const from any expression //</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">that can be converted to the type of reference             //</span>
    <span style="color: #93a1a1;">////////////////////////////////////////////////////////////////</span>
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> &amp;<span style="color: #268bd2;">ri</span> = dval;

    cout &lt;&lt; <span style="color: #2aa198;">"ri is "</span> &lt;&lt; ri &lt;&lt; endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ri is 3                                        //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>如果深究这个问题, 我们可以如下理解, 初始化一个refer to const, 如果类型不符
的话,编译器会做如下的转换,以使得reference to const int 确实bind了一个const
int类型
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">temp</span> = dval;      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">create a temporary const int from the double</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> &amp;<span style="color: #268bd2;">ri</span> = temp;       <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">bind ri to that temporary</span>
</pre>
</div>
</li>
<li>也就是说编译器创建了一个新的"临时变量". 然后让这个ref to const 来bind这个
临时变量. 这个临时变量是永远找不到了,但是我们有它的ref,也就相当于有它了.
</li>
<li>这种赋值,只有在reference to const的时候才有意义. 假设我们的ref不是const的,
那么我们的const ri bind了一个double的变量, 如果我们ri变成了4(本来是3), double
应该怎么变呢?变成4.14? 说不清楚,所以只有ref to const有这种便利.
</li>
<li>正是这种便利,让函数的参数更喜欢用const Type &amp;作为参数类型, 因为:
<ul class="org-ul">
<li>如果实参不需要转换成Type,那么正好减少一次对象复制. 而且这里还用到ref to const
的另外一个特性: ref to const 可以bind一个根本就不是const的对象. 实参不是
const的, 我参数也给它搞成ref to const. 这样可以保证不更改原来实参的值(同
时可以减少一次对象拷贝)!
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 42;
    <span style="color: #b58900;">int</span> &amp;<span style="color: #268bd2;">r1</span> = i;
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> &amp;<span style="color: #268bd2;">r2</span> = i;

    cout &lt;&lt; <span style="color: #2aa198;">"r1 is "</span> &lt;&lt; r1 &lt;&lt; <span style="color: #2aa198;">" and r2 is "</span> &lt;&lt; r2 &lt;&lt; endl;

    r1 = 0;
    cout &lt;&lt; <span style="color: #2aa198;">"r1 is "</span> &lt;&lt; r1 &lt;&lt; <span style="color: #2aa198;">" and r2 is "</span> &lt;&lt; r2 &lt;&lt; endl;

    <span style="color: #93a1a1;">///////////////////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">14.cc:15:8: error: assignment of read-only reference 'r2' //</span>
    <span style="color: #93a1a1;">//  </span><span style="color: #93a1a1;">r2 = 23;                                                 //</span>
    <span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">^                                                     //</span>
    <span style="color: #93a1a1;">///////////////////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">r2 = 23;</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">r1 is 42 and r2 is 42                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">r1 is 0 and r2 is 0                            //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>如果实参需要转换成Type, 那么就产生一个临时的const变量.
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2">Pointers and Const</h4>
<div class="outline-text-4" id="text-2-4-2">
<ul class="org-ul">
<li>就像reference一样,我们可以定义pointer to const来bind任意一个类型的变量(只要
可以convert).
</li>
<li>pointer (ref) to const绑定了某个变量后, 这个变量是可以变的.但是无法通过ref
或者pointer来改变. 也就是说,ref(pointer)'认为'自己绑定了const变量(虽然并不
一定是)
<pre class="example">
It may be helpful to think of pointers and references to const as
pointers or references "that *think* they point or refer to const"
</pre>
</li>
<li>pointer是object这个悲催的事实,让pointer自己也有可能是const的.(也就是说初始
化的时候绑定了什么变量,就不能再变了). 我们是通过把const放到*后面来强调pointer
本身的const性的(因为const离pointer更近了, 从右往左念就是"p是一个const pointer")
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">a1</span> = 0;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">a2</span> = 1;
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">p1</span> = &amp;a1;
    cout &lt;&lt; *p1 &lt;&lt; endl;
    p1 = &amp;a2;
    cout &lt;&lt; *p1 &lt;&lt; endl;

    <span style="color: #b58900;">int</span> *<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p2</span> = &amp;a1;
    cout &lt;&lt; *p2 &lt;&lt; endl;

    <span style="color: #93a1a1;">//////////////////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">15.cc:16:8: error: assignment of read-only variable 'p2' //</span>
    <span style="color: #93a1a1;">//  </span><span style="color: #93a1a1;">p2 = &amp;a2;                                               //</span>
    <span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">^                                                    //</span>
    <span style="color: #93a1a1;">//////////////////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">p2 = &amp;a2;</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3">Top-Level const</h4>
<div class="outline-text-4" id="text-2-4-3">
<ul class="org-ul">
<li>从一个更高的高度来审视const,我们会发现const其实是有两种:
<ul class="org-ul">
<li>top-level const: 表示object本身是const, 这种const可以对任何一种object有效
比如: int类型, string类型, class类型,都可以自身变成const
</li>
<li>low-level const: 表示compound type类型所指向的object是const的.既然是为compound
type类型所准备的,所以自然只能适用于reference和pointer
</li>
</ul>
</li>
<li>pointer是唯一一个可以同时拥有top-level和low-level const属性的类型
<ul class="org-ul">
<li>pointer自己是const的: top-level const
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0;
<span style="color: #b58900;">int</span> *<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p1</span> = &amp;i;
</pre>
</div>
</li>
<li>pointer指向的object是const的: low-level const
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">ci</span> = 42;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">p2</span> = &amp;ci;
</pre>
</div>
</li>
<li>同时具有top-level和low-level const
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">ci</span> = 42;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> *<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p3</span> = &amp;ci;
</pre>
</div>
</li>
</ul>
</li>
<li>区分top-level和low-level const的原因:是在于拷贝的时候:
<ul class="org-ul">
<li>当我们进行拷贝的时候, top-level const一直是被ignore的
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">ci</span> = 42;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = ci;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: copying the value of ci; top-level const in ci is ignored</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> *<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">p3</span> = &amp;ci;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">p2</span> = p3;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: pointed-to type matches; to-level const in p3 is ignored</span>
</pre>
</div>
</li>
<li>当我们进行拷贝的时候, low-level const是绝对不能忽视的!
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 11;
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">p1</span> = &amp;i;

    <span style="color: #93a1a1;">////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">16.cc:8:15: error: invalid conversion from //</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">'const int*' to 'int*' [-fpermissive]      //</span>
    <span style="color: #93a1a1;">//  </span><span style="color: #93a1a1;">int *p2 = p1;                             //</span>
    <span style="color: #93a1a1;">//            </span><span style="color: #93a1a1;">^                               //</span>
    <span style="color: #93a1a1;">////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">int *p2 = p1;</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-4" class="outline-4">
<h4 id="sec-2-4-4">constexpr and Constant Expressions</h4>
<div class="outline-text-4" id="text-2-4-4">
<ul class="org-ul">
<li>所谓constant expression就是value无法改变,而且在编译阶段就可以计算值的表达式
</li>
<li>literal肯定是constant expression
</li>
<li>一个object(或者expression)是不是const expression主要取决于两点:
<ul class="org-ul">
<li>object的类型:
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #93a1a1;">//////////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">alghough staff_size is initialized from a literal, it is not //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">a const because it is a plain int, not a const int           //</span>
<span style="color: #93a1a1;">//////////////////////////////////////////////////////////////////</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">staff_size</span> = 27;
</pre>
</div>
</li>
<li>initializer
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #93a1a1;">//////////////////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">even though sz is a const, the value of its initializer is not known //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">until run time, hence, sz is not a constant expression               //</span>
<span style="color: #93a1a1;">//////////////////////////////////////////////////////////////////////////</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sz</span> = get_size<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
</ul>
</li>
<li>新的时代,如果我们认为我们的initializer是一个const expression的话,我们可以
使用constexpr来代替const来修饰我们的类型
<pre class="example">
Variables declared as constexpr are implicitly const and must be
initialized by const expressions.
</pre>
</li>
<li>一般来说constexpr的initializer必须是const expression, 但是同时也可以是新规
范里面引入的constexpr function
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;
<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">constexpr function</span>
<span style="color: #859900; font-weight: bold;">constexpr</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">size</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> 15;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">constexpr</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">mf</span> = 50;
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">constexpr</span>
    <span style="color: #859900; font-weight: bold;">constexpr</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sz</span> = size<span style="color: #b58900;">()</span>;

    cout &lt;&lt; mf &lt;&lt; endl;
    cout &lt;&lt; sz &lt;&lt; endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">50                                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">15                                             //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>一般来说,能够组成constexpr的initializer的类型都很有限, 绝大多数情况下就是
能够产生literal value的类型, 所以我们把constexpr里面使用的类型(除了类型,当
然也可以直接使用数字)叫做literal type
<pre class="example">
The types we can use in a constexpr are known as "literal types"
because they are simple enough to have literal values.
</pre>
</li>
<li>我们目前了解的类型里面, 如下三种就是literal 类型
<ul class="org-ul">
<li>arithmetic
</li>
<li>reference
</li>
<li>pointer
</li>
</ul>
</li>
<li>如果我们想把一个pointer定义为一个constexpr的话,在语法方面是没有问题的,但是
要注意选对initializer:
<ul class="org-ul">
<li>0 或者 nullptr肯定是可以的
</li>
<li>定义在function内部的变量并不是存在于固定地址的, 所以其地址不可以作为constexpr的初始值
</li>
<li>定义在所有function之外的变量地址固定,所以可以使用
</li>
<li>还有第六章会介绍的variable that exist across calls to that function#TODO#
</li>
</ul>
</li>
<li>还有一个非常人格分裂的地方要解释,那就是 constexpr如果修饰一个指针的话,它给
与的是top-level的const(也就是相当于在*后面的const, 但是由于各种历史原因,
constexpr只能放倒最前面)
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">p</span> = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">p is a pointer to a const int</span>
<span style="color: #859900; font-weight: bold;">constexpr</span> <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">q</span> = <span style="color: #268bd2; font-weight: bold;">nullptr</span>;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">q is a const pointer to int</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Dealing with Types</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>c语言中有时候类型过于复杂,我们需要一些简化手段,让读代码的人更容易看清楚类型
</li>
</ul>
</div>
<div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1">Type Aliases</h4>
<div class="outline-text-4" id="text-2-5-1">
<ul class="org-ul">
<li>type alias是用来给与变量新名字的方法
</li>
<li>老的c语言使用了typedef
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #b58900;">double</span> <span style="color: #b58900;">wages</span>;   <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">wages is a synonym for double</span>
</pre>
</div>
</li>
<li>新的规范使用了using来进行alias declaration
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">using</span> <span style="color: #b58900;">SI</span> = Sales_item;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">SI is a synonym for Sales_item</span>
</pre>
</div>
</li>
<li>typedef是c语言引入的,typedef和compund type结合, 再加上const参与的话,会有很
多意想不到的结果
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">typedef</span> <span style="color: #b58900;">char</span> *<span style="color: #b58900;">pstring</span>;
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">pstring</span> <span style="color: #268bd2;">cstr</span> = 0; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">cstr is a constnt pointer to char!!</span>

    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOT equal with previous one</span>
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">cstr2</span> = 0;  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">cstr2 is a pointer to const char</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-5-2" class="outline-4">
<h4 id="sec-2-5-2">The auto Type Specifier</h4>
<div class="outline-text-4" id="text-2-5-2">
<ul class="org-ul">
<li>有时候,我们在程序中很难判断一个对象的真实类型,我们就会使用新规范引入的auto
关键字类让编译器帮助我们判断类型. 编译器判断的依据是initializer, 所以auto
修饰的变量必须得提供initializer
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">val1</span> = 3;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">val2</span> = 4;
    <span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">item</span> = val1 + val2;
    cout &lt;&lt; item &lt;&lt; endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">7                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>auto在同一行,只能代替一种类型.不能既修饰int又修饰double
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">sz</span> = 0, <span style="color: #268bd2;">pi</span> = 3.14;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: inconsistent types for sz and pi</span>
</pre>
</div>
</li>
<li>auto的行为和普通int没区别,也是会ignore top-level const, 除非你指定
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">ci</span> = i;
<span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">b</span> = ci;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">b is an int (top-leve const in ci is dropped)</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #859900; font-weight: bold;">auto</span> f = ci;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">deduced type of ci is int; f has type const int</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-5-3" class="outline-4">
<h4 id="sec-2-5-3">The decltype Type Specifier</h4>
<div class="outline-text-4" id="text-2-5-3">
<ul class="org-ul">
<li>decltype是用来让编译器判断类型的#TODO#
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 03: Strings, Vectors, and Arrays</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Namespace using Declarations</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>每次我们输入cout, endl这种函数或者变量的时候, 其实我们都是在std这个namespace
里面的. 所以我们可以使用using来默认使用某个namespace
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cin</span>;
</pre>
</div>
</li>
<li>如果我们只想使用std里面的某几个函数或者变量,我们可以分别指定,而不至于引入std
里面的所有的名字
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cin</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">count</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">endl</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">val1</span> = 3;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">val2</span> = 4;
    <span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">item</span> = val1 + val2;
    cout &lt;&lt; item &lt;&lt; endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">7                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>为了防止命名冲突, 在header里面不要使用using
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Library string Type</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>string是cpp里面的变长字符串,需要下面两行引入得以运行
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">string</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span>;
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">Defining and Initializing strings</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>string常见的初始化方式如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">string</span> <span style="color: #268bd2;">s1</span>;                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">default initialization; s1 is the empty string</span>
<span style="color: #b58900;">string</span> <span style="color: #268bd2;">s2</span> = s1;            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">s2 is a copy of s1</span>
<span style="color: #b58900;">string</span> <span style="color: #268bd2;">s3</span> = <span style="color: #2aa198;">"hiya"</span>;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">s3 is a copy of the string literal</span>
<span style="color: #b58900;">string</span> <span style="color: #268bd2;">s4</span><span style="color: #2aa198;">(</span>10, <span style="color: #2aa198;">'c'</span><span style="color: #2aa198;">)</span>;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">s4 is cccccccccc</span>
</pre>
</div>
</li>
<li>初始化方式其实是包含了两种:
<ul class="org-ul">
<li>copy initialization:
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">string</span> <span style="color: #268bd2;">s5</span> = <span style="color: #2aa198;">"hiya"</span>;
</pre>
</div>
</li>
<li>direct initialization:
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">string</span> <span style="color: #268bd2;">s6</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"hiya"</span><span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">string</span> <span style="color: #268bd2;">s7</span><span style="color: #2aa198;">(</span>10, <span style="color: #2aa198;">'c'</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">Operations on strings</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li>我们使用std::cin, std::cout来读取string
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span> <span style="color: #268bd2;">s</span>;
<span style="color: #268bd2; font-weight: bold;">std</span>::cin &gt;&gt; s;
<span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; s;
</pre>
</div>
</li>
<li>要读取不定数量的字符串使用while循环
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cin</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cout</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">endl</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">string</span> <span style="color: #268bd2;">word</span>;
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span>cin &gt;&gt; word<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        cout &lt;&lt; word &lt;&lt; endl;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt; ./a.out                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">123 456 789                                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">123                                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">456                                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">789                                            //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>上面方法的坏处是,遇到空格就认为是一次输入的结束,然后就会打印一行,我们有时候
还是希望留有输入的空格的,那么我们就要配合上getline
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cin</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cout</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">endl</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">string</span> <span style="color: #268bd2;">word</span>;
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span>getline<span style="color: #268bd2;">(</span>cin, word<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">////////////////////////////////////////////////////////////////</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The newline that cuses getline to return is discarded; the //</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">newline  is not stored in the string                       //</span>
        <span style="color: #93a1a1;">////////////////////////////////////////////////////////////////</span>
        cout &lt;&lt; word &lt;&lt; endl;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&gt; ./a.out                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">123 456 789                                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">123 456 789                                    //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>string的empty函数用来判断字符串是否为空, size来返回字符串的长度
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cin</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cout</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">endl</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">string</span> <span style="color: #268bd2;">word</span> = <span style="color: #2aa198;">"hello world"</span>;
    cout &lt;&lt; word.empty<span style="color: #b58900;">()</span> &lt;&lt; endl;
    cout &lt;&lt; word.size<span style="color: #b58900;">()</span> &lt;&lt; endl;

    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">11                                             //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>历史上string的size()返回的是string::size_type, 这是为了跨平台, 而且可以能够
容纳任意字符串的长度,其类型也是unsigned的
</li>
<li>新规范让我们可以使用auto来存储返回值(自动判断成为size_type)
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">len</span> = line.size<span style="color: #2aa198;">()</span>;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">len has type string::size_type</span>
</pre>
</div>
</li>
<li>因为size()返回值是unsigned的,而unsigned类型和signed类型混用的话,会有很多隐
含的问题,比如无符号和有符号数比较,总是小于.
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cin</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cout</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">endl</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">n</span> = -5;
    <span style="color: #b58900;">string</span> <span style="color: #268bd2;">word</span> = <span style="color: #2aa198;">"hello world"</span>;
    cout &lt;&lt; word.size<span style="color: #b58900;">()</span> &lt;&lt; endl;
    cout &lt;&lt; <span style="color: #b58900;">(</span>word.size<span style="color: #268bd2;">()</span> &gt; n ? <span style="color: #2aa198;">"size is bigger than -5 !"</span>: <span style="color: #2aa198;">"size is small than -5!"</span><span style="color: #b58900;">)</span>
         &lt;&lt; endl;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">11                                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">size is small than -5!                         //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>cpp中的字符串赋值, 是和java不一样的,赋值是一种内容的拷贝,而不是多个ref指向
一个object
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">string</span> <span style="color: #268bd2;">st1</span><span style="color: #2aa198;">(</span>10, <span style="color: #2aa198;">'c'</span><span style="color: #2aa198;">)</span>, <span style="color: #268bd2;">st2</span>;
<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">assignment : replace contents of st1 with a copy of st2</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">both st1 and st2 are now the empty string</span>
st1 = st2;
</pre>
</div>
</li>
<li>把两个string 对象加起来会形成一个新的string对象
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cin</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cout</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">endl</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">string</span> <span style="color: #268bd2;">s1</span> = <span style="color: #2aa198;">"hello"</span>, <span style="color: #268bd2;">s2</span> = <span style="color: #2aa198;">"world\n"</span>;
    <span style="color: #b58900;">string</span> <span style="color: #268bd2;">s3</span> = s1 + s2;
    cout &lt;&lt; s3;
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">helloworld                                     //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>这个道理看起来简单,但是由于历史原因(主要为了兼容c), string literals竟然"不
是" standard library strings!!, 所以在使用'+'号的时候,'+'左右两边必须有一
边不是string literal
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">string</span> <span style="color: #268bd2;">s4</span> = s1 + <span style="color: #2aa198;">", "</span>;       <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: adding a string and a literal</span>
<span style="color: #b58900;">string</span> <span style="color: #268bd2;">s5</span> = <span style="color: #2aa198;">"hello"</span> + <span style="color: #2aa198;">", "</span>;  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error! no string operand</span>
<span style="color: #b58900;">string</span> <span style="color: #268bd2;">s6</span> = s1 + <span style="color: #2aa198;">", "</span> + <span style="color: #2aa198;">"world"</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: each + has a string operand</span>
<span style="color: #b58900;">string</span> <span style="color: #268bd2;">s7</span> = <span style="color: #2aa198;">"hello"</span> + <span style="color: #2aa198;">", "</span> + s2; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error! can't add string literals</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3">Dealing with the Characters in a string</h4>
<div class="outline-text-4" id="text-3-2-3">
<ul class="org-ul">
<li>我们在处理字符串的时候,很经常的情况,就是处理字符串里面的每一个字符:
<ul class="org-ul">
<li>如果需要处理每一个字符的话,可以用'foreach'类型的for:
<ol class="org-ol">
<li>for的每一个成员都是普通auto类型
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">string</span> <span style="color: #268bd2;">str</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"some s"</span><span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">c</span>: str<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        cout &lt;&lt; c &lt;&lt; endl;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">s                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">o                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">m                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">e                                              //</span>
<span style="color: #93a1a1;">//                                                </span><span style="color: #93a1a1;">//</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">s                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>for的每一个成员都是auto refrence类型, 这样可以用来更改字符串!
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">string</span> <span style="color: #268bd2;">str</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"hello world"</span><span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">auto</span> &amp;<span style="color: #268bd2;">c</span>: str<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">c is a reference, the assignment changes the char in s</span>
        c = toupper<span style="color: #268bd2;">(</span>c<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
    cout &lt;&lt; str &lt;&lt; endl;

    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">HELLO WORLD                                    //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ol>
</li>
<li>如果不需要处理某个字符的话,可以使用operator[]
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">string</span> <span style="color: #268bd2;">str</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"hello world"</span><span style="color: #b58900;">)</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span><span style="color: #b58900; font-weight: bold;">!</span>str.empty<span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        str<span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span> = toupper<span style="color: #268bd2;">(</span>str<span style="color: #6c71c4;">[</span>0<span style="color: #6c71c4;">]</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    cout &lt;&lt; str &lt;&lt; endl;

    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hello world                                    //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Library vector Type</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>vector是一系列object的collection. 每个object的类型是一致的.这也就是我们常说
的container. 使用vector需要下面两个头文件
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">vector</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>;
</pre>
</div>
</li>
<li>c++中的template有两类:
<ul class="org-ul">
<li>class template: vector就是class template
</li>
<li>function template
</li>
</ul>
</li>
<li>template本身不是class或者function, 但是它们是一种"指导"编译器生产class或者
function的办法!而编译器生成class或者function的这个过程叫做instantiation.
</li>
<li>对于class template来说, 你可以通过在&lt;&gt;里面提供额外的信息来"指导"compiler针对
某个class来instantiate. 对于vector来说,就是在&lt;&gt;里面提供我们想要在里面存储的
类型
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">ivec</span>;                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ivec holds objects of type int</span>
<span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span>Sales_item<span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">Sales_vec</span>;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">holds Sales_items</span>
<span style="color: #93a1a1;">/////////////////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">old compiler may require old-style declaration for vector of vector //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">like -&gt; vector&lt;vector&lt;int&gt; &gt;                                        //</span>
<span style="color: #93a1a1;">/////////////////////////////////////////////////////////////////////////</span>
<span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">vector</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">string</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">file</span>;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">vector whose elements are vectors</span>
</pre>
</div>
</li>
<li>因为reference不是一种类型,所以无法定义保存reference的vector
</li>
</ul>
</div>
<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">Defining and Initializing vectors</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>最简单的是定义一个空的vector
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">svec</span>;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">default initialization; svec has no elements</span>
</pre>
</div>
</li>
<li>当然也可以使用operator=或者copy构造函数来初始化
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">ivec</span>;

<span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">ivec2</span><span style="color: #2aa198;">(</span>ivec<span style="color: #2aa198;">)</span>;
<span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">ivec3</span> = ivec;
</pre>
</div>
</li>
<li>新规范提供了list initialization,就是在{}里面提供多个初始化值
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">articles</span> = <span style="color: #2aa198;">{</span><span style="color: #2aa198;">"a"</span>, <span style="color: #2aa198;">"an"</span>, <span style="color: #2aa198;">"the"</span><span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>如果某个vector里面的值是一样的,我们可以使用如下方法定义
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">ivec</span><span style="color: #2aa198;">(</span>10, -1<span style="color: #2aa198;">)</span>;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ten int elements, each initialized to -1</span>
<span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">svec</span><span style="color: #2aa198;">(</span>10, <span style="color: #2aa198;">"hi!"</span><span style="color: #2aa198;">)</span>;  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ten strings; each element is "hi!"</span>
</pre>
</div>
</li>
<li>如果&lt;&gt;里面的类型允许"default value"的话,我们可以不提供初始化值,而只提供容器
大小
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">svec</span><span style="color: #2aa198;">(</span>10<span style="color: #2aa198;">)</span>;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ten elements, each an empty string</span>
</pre>
</div>
</li>
<li>在vector初始化的时候,使用{}还是()有很大的学问, 在不同类型中情况也不一样:
<ul class="org-ul">
<li>比如在int类型中:
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">v1</span><span style="color: #2aa198;">(</span>10<span style="color: #2aa198;">)</span>;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">v1 has then element with value 0</span>
<span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">v2</span><span style="color: #2aa198;">{</span>10<span style="color: #2aa198;">}</span>;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">v2 has one element with value 10</span>
<span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">v3</span><span style="color: #2aa198;">(</span>10, 1<span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">v3 has ten elements with value 1</span>
<span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">v4</span><span style="color: #2aa198;">{</span>10, 1<span style="color: #2aa198;">}</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">v4 has two elements with values 10 and 1</span>
</pre>
</div>
</li>
<li>如果你就此认为{}就会是list initialization的话,那就大错特错了. 比如类型是
string的话, {}在无法转换成list initialization的话, 也是可能会转换成()的
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">v5</span><span style="color: #2aa198;">{</span><span style="color: #2aa198;">"hi"</span><span style="color: #2aa198;">}</span>;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">list initialization</span>
<span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">v6</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"hi"</span><span style="color: #2aa198;">)</span>;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: can't construct a vector from astring literal</span>
<span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">v7</span><span style="color: #2aa198;">{</span>10<span style="color: #2aa198;">}</span>;      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">v7 has ten default-initialized elements</span>
<span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">string</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">v8</span><span style="color: #2aa198;">{</span>10, <span style="color: #2aa198;">"hi"</span><span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">v8 has ten elements with value "hi"</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2">Adding Elements to a vector</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>除了某些情况(比如所有vector的成员都是一个值),大多数情况下最有效率的增加vector
成员的方法就是先初始化一个空的vector,然后往里面加
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">v2</span>;

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0; i != 100; ++i<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    v2.push_back<span style="color: #b58900;">(</span>i<span style="color: #b58900;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">append sequential integers to v2</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>

<li>而在for的里面对vector 的size进行更改的做法通常都会引入问题#TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3">Other vector Operations</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>vector的每一个element就像string的每一个character一样可以访问, 比如下面的例
子就是更改vector的每个成员并打印
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">vector</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cout</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">endl</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">vector</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #b58900;">&gt;</span> <span style="color: #268bd2;">v</span><span style="color: #b58900;">{</span>1, 2, 3, 4, 5, 6, 7, 8, 9<span style="color: #b58900;">}</span>;
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">auto</span> &amp;<span style="color: #268bd2;">i</span> : v<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        i *= i;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">i</span> : v<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        cout &lt;&lt; i &lt;&lt; <span style="color: #2aa198;">" "</span>;
    <span style="color: #b58900;">}</span>
    cout &lt;&lt; endl;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1 4 9 16 25 36 49 64 81                        //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>vector也有empty和size, 而且特别要注意的是vector的返回值不是简单的size_type
      而是带有&lt;&gt;类型的size_type
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2; font-weight: bold;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span>::<span style="color: #b58900;">size_type</span> <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">ok</span>
<span style="color: #268bd2; font-weight: bold;">vector</span>::<span style="color: #268bd2;">size_type</span>      <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">error</span>
</pre>
</div>
</li>
<li>我们可以使用[]来取用"已有"的vector数据, 但是绝对不能依靠[]来增加数据,比如下
面的例子就是错误的ivec是空的,for内部应该使用push_back,而不是[]
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">ivec</span>;      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">empty vector</span>
<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">decltype</span><span style="color: #b58900;">(</span>ivec.size<span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span> <span style="color: #268bd2;">ix</span> = 0; ix != 10; ++ix<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    ivec<span style="color: #b58900;">[</span>ix<span style="color: #b58900;">]</span> = ix;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">disaster: ivec has no elements</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Introducing Iterators</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>虽然我们可以使用[]来遍历string或者vector, 但是我们可以使用更加"通用"的遍历
方法iterator.
</li>
<li>以后我们会发现,std实现了一系列的容器,所有的容器都支持iterator,但是只有个别
的容器支持[]
</li>
<li>iterator和pointer类似,给了我们indirect访问object的能力,也有valid和invalid之分
</li>
<li>string不算一种容器,但是string的iterator和容器的iterator相似,我们后面的讨论
也都适用于string
</li>
</ul>
</div>
<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1">Using Iterators</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>iterator不像pointer一样,使用取地址符来赋值,它使用一些容器的成员函数来赋值:
<ul class="org-ul">
<li>begin()返回:容器的第一个成员(如果存在的话)位置
</li>
<li>end()返回:容器的最后一个成员后面的位置
</li>
<li>如果一个容器是空的话begin()和end()返回同一个值"容器最后一个成员后面的位
置"
</li>
</ul>
</li>
<li>和指针一样, iterator也支持一些个比较操作符比如"=="和"!="
</li>
<li>和指针一样, iterator也支持"解引用"来获取指其所向位置的object. 当然我们的解
引用(dereference)也必须是valid的iterator
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">vector</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cout</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">endl</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">string</span> <span style="color: #268bd2;">s</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"some string"</span><span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>s.begin<span style="color: #268bd2;">()</span> != s.end<span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">it</span> = s.begin<span style="color: #268bd2;">()</span>;
        *it = toupper<span style="color: #268bd2;">(</span>*it<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
    cout &lt;&lt; s &lt;&lt; endl;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Some string                                    //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>移动一个iterator是依靠"++", 或者"&#x2013;"和pointer也类似
</li>
<li>但是特别要注意的是因为end()所返回的iterator并不指向某个object,所以对它进行
"++"或者"&#x2013;"都是逻辑不正确的.
</li>
<li>这也是为什么cpp的iterator循环,使用的是'!=' 而不是'&lt;'的原因: end()的位置"飘
忽"无法判断其大小. 另外的原因是某些iterator就没有支持operator&lt;
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">vector</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">cout</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">endl</span>;
<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">string</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">string</span> <span style="color: #268bd2;">s</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"some string"</span><span style="color: #b58900;">)</span>;
     <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">it</span> = s.begin<span style="color: #268bd2;">()</span>; it != s.end<span style="color: #268bd2;">()</span> &amp;&amp; <span style="color: #b58900; font-weight: bold;">!</span>isspace<span style="color: #268bd2;">(</span>*it<span style="color: #268bd2;">)</span>; ++it<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        *it = toupper<span style="color: #268bd2;">(</span>*it<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
    cout &lt;&lt; s &lt;&lt; endl;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">SOME string                                    //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>因为iterator也是object,所以它其实也是有const性的, 一个const的iterator是只
可以读不可以写的.就像const pointer一样:
<ul class="org-ul">
<li>如果一个容器是const的,那么'只能'使用const_iterator
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2; font-weight: bold;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span>::<span style="color: #b58900;">const_iterator</span> <span style="color: #268bd2;">it</span>;  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">const iterator</span>
</pre>
</div>
</li>
<li>如果一个容器不是const的,那么'既'使用const_iterator, '又'可以使用普通iterator
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2; font-weight: bold;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span>::<span style="color: #b58900;">iterator</span> <span style="color: #268bd2;">it</span>;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">common iterator</span>
</pre>
</div>
</li>
</ul>
</li>
<li>begin() end()也会根据自己容器的类型来返回不同类型的iterator
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">v</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">cv</span>;
<span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">it1</span> = v.begin<span style="color: #2aa198;">()</span>;          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">it1 has type vector&lt;int&gt;::iterator</span>
<span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">it2</span> = cv.begin<span style="color: #2aa198;">()</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">it2 has type vector&lt;int&gt;::const_iterator</span>
</pre>
</div>
</li>
<li>这种设计非常不人性,很容易用错. 遍历的时候,我们通知都会喜欢使用const iterator,
而无论容器是否const,都可以使用const iterator, 所以新规范设计了新的cbegin和cend
来"必定"返回const iterator
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">v</span>;
<span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">it3</span> = v.cbegin<span style="color: #2aa198;">()</span>;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">it3 has type vector&lt;int&gt;::const_iterator</span>
</pre>
</div>
</li>
<li>调用iterator指向的object的对象的函数有两种方法:
<ul class="org-ul">
<li>把iterator看成指针,可以使用*iterator来找到相应object,并调用.但是要记得加
括号
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #2aa198;">(</span>*it<span style="color: #2aa198;">)</span>.empty<span style="color: #2aa198;">()</span>
</pre>
</div>
</li>
<li>可以使用-&gt;来简化这个过程
<div class="org-src-container">

<pre class="src src-cpp">it-&gt;empty<span style="color: #2aa198;">()</span>
</pre>
</div>
</li>
</ul>
</li>
<li>我们前面说过,不要再for里面增加数据, 现在我们还要告诉大家,一旦增加vector的
size(比如通过push_back),所有的iterator都失效.所以,所有的loop一旦使用了iterator
那么就不要add element.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2">Iterator Arithmetic</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>和指针一样.iterator是可以进行加减法的.
</li>
<li>一个利用iterator来进行二分查找的例子
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">text must be sorted</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">beg and end will denote the range we're searching</span>
<span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">beg</span> = text.begin<span style="color: #2aa198;">()</span>, <span style="color: #268bd2;">end</span> = text.end<span style="color: #2aa198;">()</span>;
<span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">mid</span> = text.begin<span style="color: #2aa198;">()</span> + <span style="color: #2aa198;">(</span>end - beg<span style="color: #2aa198;">)</span> / 2;

<span style="color: #859900; font-weight: bold;">while</span> <span style="color: #2aa198;">(</span>mid != end &amp;&amp; *mid != sought<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>sought &lt; *mid<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        end = mid;
    <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
        beg = mid + 1;
    <span style="color: #b58900;">}</span>
    mid = beg + <span style="color: #b58900;">(</span>end - beg<span style="color: #b58900;">)</span> / 2;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Arrays</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>和vector不同的是, array是fix-sized, 因为array的size fix,所以性能会比较有优势
</li>
</ul>
</div>
<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1">Defining and Initializing Built-in Arrays</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>和reference以及pointer一样, 数组是一种compound type,形如a[d],其中d必须是
constant expression
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">unsigned</span> <span style="color: #268bd2;">cnt</span> = 42; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">not a constant expression</span>
<span style="color: #859900; font-weight: bold;">constexpr</span> <span style="color: #b58900;">unsigned</span> <span style="color: #268bd2;">sz</span> = 42; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">const expression</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">arr</span><span style="color: #2aa198;">[</span>10<span style="color: #2aa198;">]</span>;       <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">array of ten ints</span>
<span style="color: #b58900;">int</span> *<span style="color: #268bd2;">parr</span><span style="color: #2aa198;">[</span>sz<span style="color: #2aa198;">]</span>;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">array of 42 pointers to int</span>
<span style="color: #b58900;">string</span> <span style="color: #268bd2;">bad</span><span style="color: #2aa198;">[</span>cnt<span style="color: #2aa198;">]</span>;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: cnt is not a constant expression</span>
<span style="color: #b58900;">string</span> <span style="color: #268bd2;">strs</span><span style="color: #2aa198;">[</span>get_size<span style="color: #b58900;">()</span><span style="color: #2aa198;">]</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok if get_size is constexpr, error otherwise</span>
</pre>
</div>
</li>
<li>array里面的成员都是default initialized的,所以在function里面的定义的built-in
类型数组是非常危险的,因为
<pre class="example">
As with variables of built-in type, a default-initialized array of
built-in type that is defined inside a function will have undefined
values
</pre>
</li>
<li>array包含的必须是object,所以reference是没有数组的
</li>
<li>除了字符数组以外的数组初始化方式如下
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">unsigned</span> <span style="color: #268bd2;">sz</span> = 3;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">ial</span><span style="color: #2aa198;">[</span>sz<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">{</span>0, 1, 2<span style="color: #2aa198;">}</span>;      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">array of three ints with values 0, 1, 2</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">a2</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">{</span>0, 1, 2<span style="color: #2aa198;">}</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">anarray of dimension 3</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">a3</span><span style="color: #2aa198;">[</span>5<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">{</span>0, 1, 2<span style="color: #2aa198;">}</span>;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">equivalent to a3[] = {0, 1, 2, 0, 0}</span>
<span style="color: #b58900;">string</span> <span style="color: #268bd2;">a4</span><span style="color: #2aa198;">[</span>3<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">{</span><span style="color: #2aa198;">"hi"</span>, <span style="color: #2aa198;">"bye"</span><span style="color: #2aa198;">}</span>;  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">same as a4[] = {"hi", "bye", ""}</span>
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">a5</span><span style="color: #2aa198;">[</span>2<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">{</span>0, 1, 2<span style="color: #2aa198;">}</span>;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: too many initializers</span>
</pre>
</div>
</li>
<li>字符数组的初始化方式的一个特别之处是string literals会在最后加一个'\0'
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">char</span> <span style="color: #268bd2;">a3</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">"C++"</span>;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">null terminator added automatically</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">char</span> <span style="color: #268bd2;">a4</span><span style="color: #2aa198;">[</span>6<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">"Daniel"</span>;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error:no spaces for the null!</span>
</pre>
</div>
</li>
<li>字符串数组非string literals的话,和普通数组没啥区别
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">char</span> <span style="color: #268bd2;">a1</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">{</span><span style="color: #2aa198;">'c'</span>, <span style="color: #2aa198;">'+'</span>, <span style="color: #2aa198;">'+'</span><span style="color: #2aa198;">}</span>;
<span style="color: #b58900;">char</span> <span style="color: #268bd2;">a2</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">{</span><span style="color: #2aa198;">'c'</span>, <span style="color: #2aa198;">'+'</span>, <span style="color: #2aa198;">'+'</span>, <span style="color: #2aa198;">'\0'</span><span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>我们不能通过一个数组来初始化另外一个数组, 也不能数组间相互赋值
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">a</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">{</span>0, 1, 2<span style="color: #2aa198;">}</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">a2</span><span style="color: #2aa198;">[]</span> = a;          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: can not initialize one array with another</span>
a2 = a;                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: cannot assign one array to another</span>
</pre>
</div>
</li>
<li>数组的declaration是非常非常的多变和难以理解, 指针所谓的从右到左变得不再那
么好用. 数组是从'数组名'开始, 从里向外读取比较合适:
<ul class="org-ul">
<li>array of pointers
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> *<span style="color: #268bd2;">ptrs</span><span style="color: #2aa198;">[</span>10<span style="color: #2aa198;">]</span>;
</pre>
</div>
</li>
<li>NO array of references!
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error!!</span>
<span style="color: #b58900;">int</span> &amp;<span style="color: #268bd2;">refs</span><span style="color: #2aa198;">[</span>10<span style="color: #2aa198;">]</span> = <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">? */</span>
</pre>
</div>
</li>
<li>Parray pionts to an array of ten ints
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #2aa198;">(</span>*<span style="color: #268bd2;">Parray</span><span style="color: #2aa198;">)[</span>10<span style="color: #2aa198;">]</span> = &amp;arr;
</pre>
</div>
</li>
<li>arrRef refers to an array of ten ints
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #2aa198;">(</span>&amp;<span style="color: #268bd2;">arrRef</span><span style="color: #2aa198;">)[</span>10<span style="color: #2aa198;">]</span> = arr;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-2" class="outline-4">
<h4 id="sec-3-5-2">Access the Element of Array</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>cpp是不会去检查数组越界的,而这是很多错误的源泉.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-3" class="outline-4">
<h4 id="sec-3-5-3">Pointers and Arrays</h4>
<div class="outline-text-4" id="text-3-5-3">
<ul class="org-ul">
<li>在cpp中, 编译器通常是将array转换成pointer去操作, 比如下面的例子nums即是一个
数组名,同时也是一个指针名
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">string</span> <span style="color: #268bd2;">nums</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">{</span><span style="color: #2aa198;">"one"</span>, <span style="color: #2aa198;">"two"</span>, <span style="color: #2aa198;">"three"</span><span style="color: #2aa198;">}</span>;
<span style="color: #b58900;">string</span> *<span style="color: #268bd2;">p2</span> = nums;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">equivalent to p2 = &amp;nums[0]</span>
</pre>
</div>
</li>
<li>在c++11里面,下面的例子可以看出,编译器就是把数组转化成指针处理的
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">ia</span><span style="color: #2aa198;">[]</span> = <span style="color: #2aa198;">{</span>0, 1, 2, 3, 4<span style="color: #2aa198;">}</span>;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ia is an array of ten ints</span>
<span style="color: #859900; font-weight: bold;">auto</span> <span style="color: #268bd2;">ia2</span><span style="color: #2aa198;">(</span>ia<span style="color: #2aa198;">)</span>;                  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ia2 is an int* that points to the first element in ia</span>
ia2 = 42;                      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: ia2 is a pointer, and we can't assign an int to a pointer</span>
</pre>
</div>
</li>
<li>值得注意的是decltype是不会默认把数组转换成指针的
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">decltype</span><span style="color: #2aa198;">(</span>ia<span style="color: #2aa198;">)</span> <span style="color: #268bd2;">ia3</span> = <span style="color: #2aa198;">{</span>0, 1, 2, 3, 4<span style="color: #2aa198;">}</span>;
ia3 = p;       <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: can't assign an int* to an array</span>
ia3<span style="color: #2aa198;">[</span>4<span style="color: #2aa198;">]</span> = i;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ok: assign the value of i to an element in ia3</span>
</pre>
</div>
</li>
<li>指针至于数组就好像iterator至于vector
</li>
<li>新规范引入了std::begin和std::end来返回一个数组的begin pointer和end pointer(最后一个数组后一个位置)
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">arr</span><span style="color: #b58900;">[]</span> = <span style="color: #b58900;">{</span>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<span style="color: #b58900;">}</span>;
    <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">pbeg</span> = begin<span style="color: #b58900;">(</span>arr<span style="color: #b58900;">)</span>;
    <span style="color: #b58900;">int</span> *<span style="color: #268bd2;">pend</span> = end<span style="color: #b58900;">(</span>arr<span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span>pbeg != pend &amp;&amp; *pbeg &gt;=0<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        cout &lt;&lt; *pbeg &lt;&lt; <span style="color: #2aa198;">" "</span>;
        ++pbeg;
    <span style="color: #b58900;">}</span>
    cout &lt;&lt; endl;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ g++ --std=c++11 13.cc                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ ./a.out                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0 1 2 3 4 5 6 7 8 9                            //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>和vector以及string不同的是, 内置数组的index的类型不是unsigned type
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-4" class="outline-4">
<h4 id="sec-3-5-4">C-Style Character Strings</h4>
<div class="outline-text-4" id="text-3-5-4">
<ul class="org-ul">
<li>虽然c++支持c-style string,但是以后不应该再使用这些string, 因为它们基本就是
bug最多的来源.
</li>
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-5" class="outline-4">
<h4 id="sec-3-5-5">Interfacing to Older Code</h4>
<div class="outline-text-4" id="text-3-5-5">
<ul class="org-ul">
<li>我们是不可以通过一个array来初始化另外一个array, 但是我们可以使用一个array来
初始化一个vector, 而且在新规范引入了begin()和end()之后,变得更简单了
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">vector</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;

<span style="color: #b58900;">void</span> <span style="color: #268bd2;">display</span><span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #b58900;">vector</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #b58900;">&gt;</span> <span style="color: #268bd2;">someV</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">std</span>::<span style="color: #268bd2; font-weight: bold;">vector</span><span style="color: #268bd2;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #268bd2;">&gt;</span>::<span style="color: #b58900;">const_iterator</span> <span style="color: #268bd2;">ite</span> = someV.begin<span style="color: #268bd2;">()</span>; ite &lt; someV.cend<span style="color: #268bd2;">()</span>; ++ite<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; *ite &lt;&lt; <span style="color: #2aa198;">"  "</span>;
    <span style="color: #b58900;">}</span>
    <span style="color: #268bd2; font-weight: bold;">std</span>::cout &lt;&lt; <span style="color: #268bd2; font-weight: bold;">std</span>::endl;
<span style="color: #2aa198;">}</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">int_arr</span><span style="color: #b58900;">[]</span> = <span style="color: #b58900;">{</span>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<span style="color: #b58900;">}</span>;

    <span style="color: #b58900;">vector</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #b58900;">&gt;</span> <span style="color: #268bd2;">ivec</span><span style="color: #b58900;">(</span><span style="color: #b58900;">begin</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">int_arr</span><span style="color: #268bd2;">)</span>, <span style="color: #b58900;">end</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">int_arr</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;
    display<span style="color: #b58900;">(</span>ivec<span style="color: #b58900;">)</span>;

    <span style="color: #b58900;">vector</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #b58900;">&gt;</span> <span style="color: #268bd2;">subVec</span><span style="color: #b58900;">(</span>int_arr + 1, int_arr + 4<span style="color: #b58900;">)</span>;
    display<span style="color: #b58900;">(</span>subVec<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0  1  2  3  4  5  6  7  8  9                   //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1  2  3                                        //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>由于c-style string和指针是如此的容易出错,所以新代码推荐使用vector和strings
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">Multidimensional Arrays</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>其实在cpp中是不存在多维数组的, 多维数组的本质就是arrays of arrays
<pre class="example">
What are commonly referred to as multidimensional arrays are actually arrays of arrays
</pre>
</li>
<li>对于多维数组的理解,从第一dimension开始"读取"比较容易, 比如
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">ia</span><span style="color: #2aa198;">[</span>3<span style="color: #2aa198;">][</span>4<span style="color: #2aa198;">]</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">array of size 3; each element is an array of ints of size 4</span>
</pre>
</div>
</li>
<li>TODO
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 04: Expressions</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Fundamentals</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">Basic Concepts</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>操作符方面,cpp分为两种操作符:
<ul class="org-ul">
<li>unary operators: 操作一个数字
</li>
<li>binary operators: 操作两个数字
</li>
</ul>
</li>
<li>而expression在cpp中有两种分发:
<ul class="org-ul">
<li>lvalue: 可以放在assignment的左边的expression
</li>
<li>rvalue: 不可以放在assignment左边的expression
</li>
</ul>
</li>
<li>lvalue和rvalue的区分非常复杂,但是从直观上来说就是:
<ul class="org-ul">
<li>我们在把一个object当做lvalue来使用的时候, 我们使用的是它的identity(location in memory)
</li>
<li>我们在把一个object当做rvalue来使用的时候, 我们使用的是它的value (its content)
</li>
</ul>
</li>
<li>总体上来说lvalue"能力更强"
<pre class="example">
We can use an lvalue when an rvalue is rquired, but we cannot use
an lvalue in place of an rvalue.
</pre>
</li>
<li>lvalue作为rvalue使用的时候,其只需要把其内容"贡献"出来即可.
</li>
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2">Precedence and Associativity</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li>括号的优先级最大
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">The Member Access Operators</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>因为"解引用"符号的优先级是比dot低的,所以我们必须在"指针引用"外面加上括号,然
后再去使用, 比如下面的使用就是错误的.
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">run the size member of p, then dereference the result!</span>
*p.size<span style="color: #2aa198;">()</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: p is a pointer and has not member named size</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 05: Statements</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Simple Statements</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>大部分的c++ statement是以分号结尾的. 所谓的expression statement就是说一个
expression会被evaluated,然后它的结果被丢弃了:
<ul class="org-ul">
<li>如下的statement是没有意义的, 因为它的结果在被丢弃前没有保存
<div class="org-src-container">

<pre class="src src-cpp">ival + 5;
</pre>
</div>
</li>
<li>下面是一个在丢弃前保存的例子,不过保存的方式是打印
<div class="org-src-container">

<pre class="src src-cpp">cout &lt;&lt; ival;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1">Null Statements</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>如果需要什么都不做的语句,那么直接一个分号就好了,注意这种情况下要加上一些
comment
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">while</span> <span style="color: #2aa198;">(</span>cin &gt;&gt; s &amp;&amp; s != sought<span style="color: #2aa198;">)</span>
    ; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">null statment</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2">Beware of Missing or Extraneous Semicolons</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>多余的分号并不是总没有危害,比如在if或者while后面跟了分号的话,可能会导致无线
循环
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">while</span> <span style="color: #2aa198;">(</span>iter != save.end<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
    ++iter;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-1-3" class="outline-4">
<h4 id="sec-5-1-3">Compound Statements(Blocks)</h4>
<div class="outline-text-4" id="text-5-1-3">
<ul class="org-ul">
<li>复合语句(Compound Statement)是指的大括号括起来的语句, 也叫做块(block)
</li>
<li>复合语句自己本身就是一个作用域(scope), 也就是说,在这个block中引入的名字只
能在这个block(或其子block)中使用.
</li>
<li>复合语句说起来高冷,却是我们最常用的语法:对于while for等控制语句来说,后面本
来只能跟一行语句,如果需要多行语句的话,要把这个几个语句加入到一个block
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">while</span> <span style="color: #2aa198;">(</span>val &lt;= 10<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    sum += val;
    ++val;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Statement Scope</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>我们可以在while if等语句的control structure里面来定义变量.这样定义的变量在
只在while if的statement里面起作用.
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">while</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = get_num<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">i is created and initialized on each iteration</span>
    cout &lt;&lt; i &lt;&lt; endl;
i = 0;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: i is not accessible outside the loop</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Conditional Statements</h3>
<div class="outline-text-3" id="text-5-3">
</div><div id="outline-container-sec-5-3-1" class="outline-4">
<h4 id="sec-5-3-1">The if Statement</h4>
<div class="outline-text-4" id="text-5-3-1">
<ul class="org-ul">
<li>if 后面跟的condition必须是能够转化成bool类型的类型
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3-2" class="outline-4">
<h4 id="sec-5-3-2">The switch Statement</h4>
<div class="outline-text-4" id="text-5-3-2">
<ul class="org-ul">
<li>case label后面必须跟常量表达式
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">char</span> <span style="color: #268bd2;">ch</span> = getVal<span style="color: #2aa198;">()</span>;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">ival</span> = 42;

<span style="color: #859900; font-weight: bold;">switch</span><span style="color: #2aa198;">(</span>ch<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
<span style="color: #859900; font-weight: bold;">case</span> 3.14: <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: noninteger as case label</span>
<span style="color: #859900; font-weight: bold;">case</span> ival: <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">error: nonconstant as case label</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Iterative Statements</h3>
<div class="outline-text-3" id="text-5-4">
</div><div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">The while Statement</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>while是不停执行目标statement,只要condition还为true
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">while</span> <span style="color: #2aa198;">(</span>condition<span style="color: #2aa198;">)</span>
    statement
</pre>
</div>
</li>
<li>需要注意的是,我们在condition或者statement部分定义的变量,每次都会经历created
和destroyed的过程.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">Traditional for Statement</h4>
<div class="outline-text-4" id="text-5-4-2">
<ul class="org-ul">
<li>传统的for循环要求如下:
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span>initializer; condition; expression<span style="color: #2aa198;">)</span>
    statement
</pre>
</div>
</li>
<li>上述三个部分initializer, condition, expression都可以省略
</li>
<li>initializer里面的定义只运行一遍,但是如果变量定义于此的话,其作用域就是for语
句结束之前
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-3" class="outline-4">
<h4 id="sec-5-4-3">Range for Statement</h4>
<div class="outline-text-4" id="text-5-4-3">
<ul class="org-ul">
<li>c++11 引入了range for
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span>declaration : expression<span style="color: #2aa198;">)</span>
    statement
</pre>
</div>
</li>
<li>这种for的特点是:
<ul class="org-ul">
<li>declaration 会定义一个变量, 这个变量必须能转化为expression里面的容器的成
员变量的类型. 最简单的方法是使用auto让编译器为我们来判断.如果想更改容器里
面成员的值,那么declaration的这个变量必须是引用类型
</li>
<li>expression必须是一种列表,比如:
<ol class="org-ol">
<li>braced initializer list
</li>
<li>array
</li>
<li>能够支持返回iterator的begin和end的容器
</li>
</ol>
</li>
</ul>
</li>
<li>下面是一个使用range for来把成员变量大小翻倍的方法
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">vector</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">int</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">v</span> = <span style="color: #2aa198;">{</span>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<span style="color: #2aa198;">}</span>;
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">range variable must be a reference so we can write to the elements</span>
<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">auto</span> &amp;<span style="color: #268bd2;">r</span> : v<span style="color: #2aa198;">)</span>
    r *= 2
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-4" class="outline-4">
<h4 id="sec-5-4-4">The do while Statement</h4>
<div class="outline-text-4" id="text-5-4-4">
<ul class="org-ul">
<li>do while statement就是必须先执行一次的while循环,无论condition是否成立,需要
注意的是while后面要以分号结尾
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">do</span>
    statement;
<span style="color: #859900; font-weight: bold;">while</span> <span style="color: #2aa198;">(</span>condition<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Jump Statements</h3>
<div class="outline-text-3" id="text-5-5">
</div><div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1">The break Statement</h4>
<div class="outline-text-4" id="text-5-5-1">
<ul class="org-ul">
<li>break 会结束如下'最近'的一个语句:
<ul class="org-ul">
<li>while
</li>
<li>do while
</li>
<li>for
</li>
<li>switch
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-5-2" class="outline-4">
<h4 id="sec-5-5-2">The continue Statement</h4>
<div class="outline-text-4" id="text-5-5-2">
<ul class="org-ul">
<li>continue会结束循环的最近一次,进入下一次,所以只能出现在循环内部
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-5-3" class="outline-4">
<h4 id="sec-5-5-3">The goto Statment</h4>
<div class="outline-text-4" id="text-5-5-3">
<ul class="org-ul">
<li>随意跳转,最好不用.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6">try Blocks and Exception Handling</h3>
<div class="outline-text-3" id="text-5-6">
<ul class="org-ul">
<li>exception是运行期(runtime)出现的反常行为, 比如数据库连接丢失,或者是意外输入
(unexpected input)
</li>
<li>异常处理(exception handling)是指:
<ul class="org-ul">
<li>程序的一部分遇到了一个它无法解决的问题, 而且这个问题使得它无法继续运行
</li>
<li>遇到问题的这部分程序只需要把问题"声明"出来,不需要知道如何解决
</li>
<li>一旦"声明"出问题, 这部分程序就完成了使命.
</li>
</ul>
</li>
<li>异常的处理在cpp中包含如下几个部分:
<ul class="org-ul">
<li>detecting: 遇到问题的部分,会使用throw expression来"声明"自己遇到的问题
</li>
<li>handling: 解决问题的代码会使用try后面的block来"等待"block里面的代码"声明"
问题,然后在catach里面处理
</li>
<li>exception class: 用来在throw和catch里面"交流"问题的类型
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-5-6-1" class="outline-4">
<h4 id="sec-5-6-1">A throw Expression</h4>
<div class="outline-text-4" id="text-5-6-1">
<ul class="org-ul">
<li>遇到问题的部分使用的代码
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b58900;">Sales_item</span> <span style="color: #268bd2;">item1</span>, <span style="color: #268bd2;">item2</span>;

cin &gt;&gt; item1 &gt;&gt; item2;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">first check that item1 and item2 represent the same book</span>
<span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>item1.isbn<span style="color: #b58900;">()</span> != item2.isbn<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">throw</span> runtime_error<span style="color: #b58900;">(</span><span style="color: #2aa198;">"Data must refer to same ISBN"</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">if we're still here, the ISBN are the same</span>
cout &lt;&lt; item1 + item2 &lt;&lt; endl;
</pre>
</div>
</li>
<li>runtime_error是stdexcept header里面定义的standard library exception
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-6-2" class="outline-4">
<h4 id="sec-5-6-2">The try Block</h4>
<div class="outline-text-4" id="text-5-6-2">
<ul class="org-ul">
<li>try block是代码解决问题的部分, 其中
<ul class="org-ul">
<li>try后面跟的block里面是"可能出问题"的代码, 这些代码可能调用了函数,或者函
数里面调用了其他函数,只要是从这个block里面出去的,都可以被"捕捉"到
</li>
<li>catch是处理exception的部分, catch可以指定只处理某种类型的exception
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">iostream</span><span style="color: #2aa198;">&gt;</span>

<span style="color: #859900; font-weight: bold;">using</span> <span style="color: #859900; font-weight: bold;">namespace</span> <span style="color: #268bd2; font-weight: bold;">std</span>;

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">item1</span> = 0;
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">item2</span> = 0;

    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span>cin &gt;&gt; item1 &gt;&gt; item2<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">try</span> <span style="color: #268bd2;">{</span>
            <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span>item1 != item2<span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
                <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #b58900;">runtime_error</span><span style="color: #859900;">(</span><span style="color: #2aa198;">"Data must refer to same ISBN"</span><span style="color: #859900;">)</span>;
            <span style="color: #6c71c4;">}</span>

            cout &lt;&lt; <span style="color: #2aa198;">"The ISBNs are the same"</span> &lt;&lt; endl;
            <span style="color: #859900; font-weight: bold;">break</span>;
        <span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">catch</span> <span style="color: #268bd2;">(</span><span style="color: #b58900;">runtime_error</span> <span style="color: #268bd2;">err</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            cout &lt;&lt; err.what<span style="color: #6c71c4;">()</span>
                 &lt;&lt; <span style="color: #2aa198;">"\nTry Again? Entry y or n"</span> &lt;&lt; endl;
            <span style="color: #b58900;">char</span> <span style="color: #268bd2;">c</span>;
            cin &gt;&gt; c;
            <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span><span style="color: #b58900; font-weight: bold;">!</span>cin || c == <span style="color: #2aa198;">'n'</span><span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
                <span style="color: #859900; font-weight: bold;">break</span>;       <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">break ou of the while loop</span>
            <span style="color: #6c71c4;">}</span>
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> 0;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">$ ./a.out                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">111 222                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Data must refer to same ISBN                   //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Try Again? Entry y or n                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">y                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">333 333                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The ISBNs are the same                         //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-6-3" class="outline-4">
<h4 id="sec-5-6-3">Standard Exceptions</h4>
<div class="outline-text-4" id="text-5-6-3">
<ul class="org-ul">
<li>cpp在如下的头文件里面定义了一些exception类:
<ul class="org-ul">
<li>excepition header: 定义了名叫excepiton的异常
</li>
<li>stdexcept header: 定义了常用异常
</li>
<li>new header: 定义了bad_alloc 异常
</li>
<li>type_info header: 定义了bad_cast 异常
</li>
</ul>
</li>
<li>exception异常, bad_alloc异常和bad_cast异常是不需要字符串做为初始化参数的,除
此之外其他的异常都需要字符串初始化参数
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
