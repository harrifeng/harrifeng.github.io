<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>part2</title>
<!-- 2017-05-02 Tue 10:46 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">part2</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 3: First-class functions fro novice: definitions and arguments</a>
<ul>
<li><a href="#sec-1-1">What's with the functional difference?</a>
<ul>
<li><a href="#sec-1-1-1">Functions as first-class objects</a></li>
<li><a href="#sec-1-1-2">Callback functions</a>
<ul>
<li><a href="#sec-1-1-2-1">SORTING WITH A COMPARATOR</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-2">Fun with functions as objects</a>
<ul>
<li><a href="#sec-1-2-1">Storing functions</a></li>
<li><a href="#sec-1-2-2">Self-memoizing function</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Defining functions</a>
<ul>
<li><a href="#sec-1-3-1">Function declarations and function expressions:</a>
<ul>
<li><a href="#sec-1-3-1-1">IMMEDIATE FUNCTIONS</a></li>
</ul>
</li>
<li><a href="#sec-1-3-2">Arrow functions</a></li>
</ul>
</li>
<li><a href="#sec-1-4">Arguments and function parameters</a>
<ul>
<li><a href="#sec-1-4-1">Rest parameters</a></li>
<li><a href="#sec-1-4-2">Default parameters</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">Chapter 4: Functions for the journeyman: understanding function</a>
<ul>
<li><a href="#sec-2-1">Using implicit function parameters</a>
<ul>
<li><a href="#sec-2-1-1">The arguments paramter</a>
<ul>
<li><a href="#sec-2-1-1-1">ARGUMENTS OBJECT AS AN ALIAS TO FUNCTION PARAMETERS</a></li>
<li><a href="#sec-2-1-1-2">AVOIDING ALIASES</a></li>
</ul>
</li>
<li><a href="#sec-2-1-2">The this parameter: introducing the function context</a></li>
</ul>
</li>
<li><a href="#sec-2-2">Invoking functions</a>
<ul>
<li><a href="#sec-2-2-1">Invocation as a function</a></li>
<li><a href="#sec-2-2-2">Invocation as a method</a></li>
<li><a href="#sec-2-2-3">Invocation as a constructor</a>
<ul>
<li><a href="#sec-2-2-3-1">THE SUPERPOWERS OF CONSTRUCTORS</a></li>
<li><a href="#sec-2-2-3-2">CONSTRUCTOR RETURN VALUES</a></li>
<li><a href="#sec-2-2-3-3">CODING CONSIDERATIONS FOR CONSTRUCTORS</a></li>
</ul>
</li>
<li><a href="#sec-2-2-4">Invocation with the apply and call methods</a></li>
</ul>
</li>
<li><a href="#sec-2-3">Fixing the problem of function contexts</a>
<ul>
<li><a href="#sec-2-3-1">Using arrow functions to get around function contexts</a></li>
<li><a href="#sec-2-3-2">Using the bind method</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">Chapter 5: Functions for the master: closures and scopes</a>
<ul>
<li><a href="#sec-3-1">Understanding closures</a></li>
<li><a href="#sec-3-2">Putting closures to work</a>
<ul>
<li><a href="#sec-3-2-1">Mimicking private variables</a></li>
<li><a href="#sec-3-2-2">Using closures with callbacks</a></li>
</ul>
</li>
<li><a href="#sec-3-3">Tracking code execution with execution context</a></li>
<li><a href="#sec-3-4">Keep track of identifiers with lexical environments</a>
<ul>
<li><a href="#sec-3-4-1">Coding nesting</a></li>
<li><a href="#sec-3-4-2">Code nesting and lexical environments</a></li>
</ul>
</li>
<li><a href="#sec-3-5">Understanding types of JavaScript variables</a>
<ul>
<li><a href="#sec-3-5-1">Variable mutability</a></li>
<li><a href="#sec-3-5-2">Variable definition keywords and lexical environments</a></li>
<li><a href="#sec-3-5-3">Registering identifiers within lexical environments</a></li>
</ul>
</li>
<li><a href="#sec-3-6">Exploring how closures work</a>
<ul>
<li><a href="#sec-3-6-1">Revisiting mimicking private variables with closures</a></li>
<li><a href="#sec-3-6-2">Private variables caveat</a></li>
<li><a href="#sec-3-6-3">Revisiting the closures and callbacks example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">Chapter 6: Functions for the future: generators and promises</a>
<ul>
<li><a href="#sec-4-1">Makeing our async code elegant with generators and promises</a></li>
<li><a href="#sec-4-2">Working with generator functions</a>
<ul>
<li><a href="#sec-4-2-1">Controlling the generator throught the Iterator object</a></li>
<li><a href="#sec-4-2-2">Using generators</a></li>
<li><a href="#sec-4-2-3">Communicating with a generator</a></li>
<li><a href="#sec-4-2-4">Exploring generatos under the hood</a></li>
</ul>
</li>
<li><a href="#sec-4-3">Working with promises</a>
<ul>
<li><a href="#sec-4-3-1">Understanding the problems with simple callbacks</a></li>
<li><a href="#sec-4-3-2">Diving into promises</a></li>
<li><a href="#sec-4-3-3">Rejecting promises</a></li>
<li><a href="#sec-4-3-4">Creating our firs real-world promise</a></li>
<li><a href="#sec-4-3-5">Chaining promises</a></li>
<li><a href="#sec-4-3-6">Waiting for a number of promises</a></li>
</ul>
</li>
<li><a href="#sec-4-4">Combining generators and promises</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 3: First-class functions fro novice: definitions and arguments</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>不太了解js的人肯定有些诧异,我们最开始介绍的不是object,而是function. 懂得人其
实应该知道,因为javascript不是一个object-oriented language,而是一个functional
language !
</li>
<li>js里面的function被称之为first-class object是因为:
<ul class="org-ul">
<li>首先object可以做的(被variable refer, literal式的声明, pass as 函数参数)function
都可以做.
</li>
<li>其次function还有比object高明的地方:它可以被调用
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">What's with the functional difference?</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>functional的思想非常重要的原因在于function是JS里面执行的'主要的执行小单元':
所谓的'主要的执行小单元'是因为除了global的在page-building阶段就会被执行的代
码外,绝大部分的js代码都'以function的形式执行的'
</li>
<li>我们已经说了function是object的超集(object的能力,function都具备),下面就列举
一下js下面object的能力:
<ul class="org-ul">
<li>可以使用literal的方式创建
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">{}</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">an object</span>
</pre>
</div>
</li>
<li>可以被赋值给variable, array, 或者其他object的properties
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #2aa198;">{}</span>;
ninjaArray.push<span style="color: #2aa198;">(</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>;
ninja.data = <span style="color: #2aa198;">{}</span>;
</pre>
</div>
</li>
<li>可以作为参数传递给function
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">hide</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">ninja</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    ninja.visibility = <span style="color: #268bd2; font-weight: bold;">false</span>;
<span style="color: #2aa198;">}</span>
hide<span style="color: #2aa198;">(</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>可以被function返回
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">returnNinja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">{}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>object可以动态创建,然后'再'赋于它property
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #2aa198;">{}</span>;
ninja.name = <span style="color: #2aa198;">"Hanzo"</span>;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Functions as first-class objects</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>function拥有object前面所述的所有能力:
<ul class="org-ul">
<li>通过literal创建
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">ninjaFunction</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>
</pre>
</div>
</li>
<li>赋值给变量,加入数组,或者作为其他object的property
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninjaFunction</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>;
ninjaArray.push<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(){}</span><span style="color: #2aa198;">)</span>;
ninja.data = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(){}</span>;
</pre>
</div>
</li>
<li>作为其他function的参数
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">call</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">ninjaFunction</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    ninjaFunction<span style="color: #b58900;">()</span>;
<span style="color: #2aa198;">}</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">use it</span>
call<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(){}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>作为function的返回值
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">returnNewNinjaFunction</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(){}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>动态创建,'再'加property
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninjaFunction</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(){}</span>;
ninjaFunction.name = <span style="color: #2aa198;">"Hanzo"</span>;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">add a new property to a function</span>
</pre>
</div>
</li>
</ul>
</li>
<li>在这么多的特性中,有个特性更接近特殊,那就是我们可以把function作为参数传递给
另外一个function,而另外一个参数在自己内部调用'参数function',我们把这个叫做
callback function
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">Callback functions</h4>
<div class="outline-text-4" id="text-1-1-2">
<ul class="org-ul">
<li>每当我们设置一个function,然后这个function在一个later time被调用,那么我们就
把这种情况叫做callback
</li>
<li>我们前面为event设置listener, 然后浏览器自动为event帮我们调用event handler(其
实就是一个hans)的情形其实就是callback
</li>
<li>我们可以自己实践callback,就是把一个function作为参数传递给另外一个function
</li>
<li>我们先来看一个callback的例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">text</span> = <span style="color: #2aa198;">"Demo !"</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">useless</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">ninjaCallback</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span><span style="color: #2aa198;">"In useless function"</span><span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> ninjaCallback<span style="color: #b58900;">()</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">getText</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span><span style="color: #2aa198;">"In getText function"</span><span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> text;
<span style="color: #2aa198;">}</span>

console.log<span style="color: #2aa198;">(</span>useless<span style="color: #b58900;">(</span>getText<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">In useless function                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">In getText function                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Demo !                                         //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>这里的useless就是一个callback(当然了,有些人认为马上调用'传入function参数'
的做法不叫callback,我们这里只是以这个为例子),它在自己的内容调用了'传入的
function参数'作为返回值
</li>
<li>js最重要的一个feature就是能够在任何'expression可以出现的地方'创建一个function
这样做有两个好处:
<ul class="org-ul">
<li>让代码compact,而且易懂
</li>
<li>因为这个function只在这里使用,我们完全可以不用给这个function取名字,这样就
不会污染global namespace啦!
</li>
</ul>
</li>
<li>重写后代码如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">text</span> = <span style="color: #2aa198;">"Demo !"</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">useless</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">ninjaCallback</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span><span style="color: #2aa198;">"In useles function"</span><span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> ninjaCallback<span style="color: #b58900;">()</span>;
<span style="color: #2aa198;">}</span>

console.log<span style="color: #2aa198;">(</span>useless<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(){</span>
    console.log<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"In parameter"</span><span style="color: #6c71c4;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> text;
<span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">In useles function                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">In parameter                                   //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Demo !                                         //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>前面我们为event增加event listener的例子,也是一个callback的例子,在那个例子
中,我们的callback函数,也是匿名的
<div class="org-src-container">

<pre class="src src-js">document.body.addEventListener<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"mousemove"</span>, <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">second</span> = document.getElementById<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"second"</span><span style="color: #268bd2;">)</span>;
    addMessage<span style="color: #268bd2;">(</span>second, <span style="color: #2aa198;">"Event: mousemove"</span><span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-1-1-2-1" class="outline-5">
<h5 id="sec-1-1-2-1">SORTING WITH A COMPARATOR</h5>
<div class="outline-text-5" id="text-1-1-2-1">
<ul class="org-ul">
<li>说起使用function作为参数这件事情,在js里面有个特别好的例子,就是排序数组.我
们知道在java里面,你要给数组一个comparator来决定其顺序
</li>
<li>在js里面,我们只需要一个函数.这个函数设计也很新颖,参数是数组的两个成员:
<ul class="org-ul">
<li>两个参数比较,如果返回负数,说明他俩位置是对的.
</li>
<li>如果返回正数,说明位置要swap
</li>
<li>如果返回0,说明他俩相等
</li>
</ul>
</li>
<li>代码如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">values</span> = <span style="color: #2aa198;">[</span>0, 3, 2, 5, 7, 4, 8, 1<span style="color: #2aa198;">]</span>;

console.log<span style="color: #2aa198;">(</span>values.sort<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">value1</span>, <span style="color: #268bd2;">value2</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> value1 - value2;
<span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 0, 1, 2, 3, 4, 5, 7, 8 ]                     //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Fun with functions as objects</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>一个可能令人吃惊的事情是:我们完全可以给function赋予一个property,因为object
可以有property,那么function就必然可以有property
</li>
<li>这个特性,可以让js做下面的两种hack
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Storing functions</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>这个hack看起来很厉害,其实就是给function一个identification而已,防止重复加载
一个function到一个列表(collection)里面
</li>
<li>这个特性在维护event的call back列表的时候非常有用: 我们希望我们的event的call
back 函数礼包里面所有的函数只出现了一次.
</li>
<li>面对'唯一性'的问题,set(或者hash)是一个非常简单的思路.其实这里就是利用了function
可以多加一个域(property),把这个域作为set或者hash里面的key而已(同时下例中的
cache就是这个hash(set)
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">assert</span> = require<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'assert'</span><span style="color: #2aa198;">)</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">store</span> = <span style="color: #2aa198;">{</span>
    nextId: 1,
    cache: <span style="color: #b58900;">{}</span>,
    <span style="color: #268bd2;">add</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">fn</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>!fn.id<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            fn.id = <span style="color: #268bd2; font-weight: bold;">this</span>.nextId++;
            <span style="color: #268bd2; font-weight: bold;">this</span>.cache<span style="color: #6c71c4;">[</span>fn.id<span style="color: #6c71c4;">]</span> = fn;
            <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">ninja</span><span style="color: #2aa198;">(){}</span>

console.log<span style="color: #2aa198;">(</span>store.add<span style="color: #b58900;">(</span>ninja<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>store.add<span style="color: #b58900;">(</span>ninja<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined                                      //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Self-memoizing function</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>既然函数内部可以存储property,那么我们可以考虑在function内部记录已经计算过
的值,比如下面计算prime number的例子,每次计算完一个参数我们把值记录下来,下
次再有相同的计算我们之间返回就是了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">isPrime</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">value</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>!isPrime.answers<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        isPrime.answers = <span style="color: #268bd2;">{}</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>isPrime.answers<span style="color: #268bd2;">[</span>value<span style="color: #268bd2;">]</span> !== <span style="color: #268bd2; font-weight: bold;">undefined</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Cached value returned!"</span><span style="color: #268bd2;">)</span>;
        <span style="color: #859900; font-weight: bold;">return</span> isPrime.answers<span style="color: #268bd2;">[</span>value<span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">prime</span> = value !== 1; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1 is not a prime</span>

    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">i</span> = 2; i &lt; value / 2; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>value % i === 0<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            prime = <span style="color: #268bd2; font-weight: bold;">false</span>;
            <span style="color: #859900; font-weight: bold;">break</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> isPrime.answers<span style="color: #b58900;">[</span>value<span style="color: #b58900;">]</span> = prime;
<span style="color: #2aa198;">}</span>

console.log<span style="color: #2aa198;">(</span>isPrime<span style="color: #b58900;">(</span>5<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>isPrime<span style="color: #b58900;">(</span>5<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Cached value returned!                         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Defining functions</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>js提供了如下几种定义function的方法:
<ul class="org-ul">
<li>function declaration 和 function expression: 名字和长相很像,但确实是两种
不同的定义方法
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">myFun</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> 1;<span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">function declaration</span>
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">myFun2</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> 2; <span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">function expression</span>
</pre>
</div>
</li>
<li>arrow function: es6提供的新的函数定义方式
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">myFun3</span> = <span style="color: #2aa198;">(</span>x<span style="color: #2aa198;">)</span> =&gt; x + 1;
</pre>
</div>
</li>
<li>function constructor: 比较偏门的方法,我们不予讨论
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Function</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'a'</span>, <span style="color: #2aa198;">'b'</span>, <span style="color: #2aa198;">'return a + b'</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>generator function: 也是ES6新加的,和普通函数不同的是,它可以exited然后后面
reentered application execution,同时保存他们的variable
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">myGen</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">yield</span> 1; <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Function declarations and function expressions:</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>这两种的确很像,但是也有区别:
<ul class="org-ul">
<li>function declaration的名字是"必须要的", 因为否则你无法调用这个函数. 因为
function declaration必须自己是一个statement
</li>
<li>function expression的名字却"不是必须要的",因它是一个expression,是一个statement
的一部分,它总是会把:
<ol class="org-ol">
<li>自己放到一个变量里面.
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">doNothing</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>;
doNothing<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>或者赋予一个参数, 其实也是变相的赋值给参数:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">doSomething</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">action</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    action<span style="color: #b58900;">()</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-3-1-1" class="outline-5">
<h5 id="sec-1-3-1-1">IMMEDIATE FUNCTIONS</h5>
<div class="outline-text-5" id="text-1-3-1-1">
<ul class="org-ul">
<li>因为function expression嘛,它也可以是一个call statement的"调用者",如下
<div class="org-src-container">

<pre class="src src-js">console.log<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">x</span><span style="color: #268bd2;">){</span> <span style="color: #859900; font-weight: bold;">return</span> x *x; <span style="color: #268bd2;">}</span><span style="color: #b58900;">)(</span>6<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">36                                             //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>前面的例子在function expression的左右使用了'()'来告诉js engine,我们面对的
不是statement,而是expression.还有更难懂的方法,就是在前面使用一个unary operator
作用也是一样,告诉js engine,我们处理的是function expression,不是statement.
而unary operator处理的结果就被直接丢弃了,我们不需要了.在很多library里面都
有这种奇怪的用法
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Arrow functions</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>因为js里面function用到的地方太多,es6专门为function设计了一种新的格式,其格式为
<div class="org-src-container">

<pre class="src src-js">paramter =&gt; expression
</pre>
</div>
</li>
<li>expression的值会直接作为返回值返回,ruby用户会非常熟悉
<div class="org-src-container">

<pre class="src src-js">values.sort<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>value1, value2<span style="color: #b58900;">)</span> =&gt; value1 - value2<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>但是如果有多个statement的情况下,还是需要一个return的,而且这个时候要在=&gt; 后
面加上一个{}包裹这些statement. 如果忘记return的话,这个function返回值为undefined
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">greet</span> = name =&gt; <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">helloString</span> = <span style="color: #2aa198;">'Greetings '</span>;
    <span style="color: #859900; font-weight: bold;">return</span> helloString + name;
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Arguments and function parameters</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>当讨论function的时候,我们会讨论两个概念:
<ul class="org-ul">
<li>parameter: 是function 定义的时候概念
</li>
<li>argument: 是function调用的时候的概念
</li>
</ul>
</li>
<li>js中,argument和paramter的个数不要求对应(不会去检查):
<ul class="org-ul">
<li>如果argument的个数少于parameter,那么'从左到右'进行赋值.没有得到赋值的parameter
就会被设置为undefiend
</li>
<li>如果argument的个数多余parameter,剩下的依然可以使用关键字arguments访问TODO
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">Rest parameters</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li>rest parameter也是ES6新加入的特性
</li>
<li>rest parameter有点类似c语言里面的'参数个数不定'的情况(golang里面也有相似的
设置),就是有些情况下,我们肯定会有'至少一个参数',但是从第二个参数到最后一个
参数具体有多少个不定.而我们可以把这些(从2到最后)个参数设置成一个数组
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">multiMax</span> = <span style="color: #2aa198;">(</span>first, ...remaining<span style="color: #2aa198;">)</span> =&gt; first * remaining.sort<span style="color: #2aa198;">()[</span>2<span style="color: #2aa198;">]</span>;

console.log<span style="color: #2aa198;">(</span>multiMax<span style="color: #b58900;">(</span>3, 1, 2, 3<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">Default parameters</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>这就是其他语言早就有的特性了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">performAction</span> = <span style="color: #2aa198;">(</span>ninja, action=<span style="color: #2aa198;">"skulking"</span><span style="color: #2aa198;">)</span> =&gt;
    ninja + <span style="color: #2aa198;">" "</span> + action;

console.log<span style="color: #2aa198;">(</span>performAction<span style="color: #b58900;">(</span><span style="color: #2aa198;">"Fuma"</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Fuma skulking                                  //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 4: Functions for the journeyman: understanding function</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>本章我们主要讨论如下的两个implicit function parameter,说是implicit parameter
是因为:即便你在function调用的时候,没有传入这两个参数,它们依然可以被当做传入
了一样被使用:
<ul class="org-ul">
<li>this: 指代了当前function"所属"的object,是js一种特殊的靠近'面向对象编程'的特性
</li>
<li>arguments: 指代传入的所有参数的集合,是一种'类似'数组的东西
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Using implicit function parameters</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>implicit parameter是'默默'的传入,但是使用起来和explicit paramter 没有区别
</li>
</ul>
</div>
<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">The arguments paramter</h4>
<div class="outline-text-4" id="text-2-1-1">
<ul class="org-ul">
<li>arguments能够获取到传入的所有的argument(无论他们和paramter对应的好不好)
</li>
<li>在rest parameter引入了以后,arguments的作用就没那么大了,但是在处理legacy
code的时候还是会遇到,我们要了解它
</li>
<li>arguments在两个方面很像array:
<ul class="org-ul">
<li>它有一个property叫做length
</li>
<li>它可以使用operator[]来访问
</li>
</ul>
</li>
<li>但是我们极力避免把arguments叫做array, 因为它的确就不是array. 这一点容易被
人们忽略,我们要谨记不要把array的feature使用在arguments上面
</li>
<li>这也是为什么rest paramter更好的原因,因为rest parameter的最后一个参数的的确
确是array
</li>
</ul>
</div>
<div id="outline-container-sec-2-1-1-1" class="outline-5">
<h5 id="sec-2-1-1-1">ARGUMENTS OBJECT AS AN ALIAS TO FUNCTION PARAMETERS</h5>
<div class="outline-text-5" id="text-2-1-1-1">
<ul class="org-ul">
<li>换句话说就是, arguments和paramter是一种'硬链接'的关系:
<ul class="org-ul">
<li>一旦对argument进行更改, 第一个参数也会随之更改
</li>
<li>一旦对第n个参数更改, argument[n-1]也会随之更改
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-1-2" class="outline-5">
<h5 id="sec-2-1-1-2">AVOIDING ALIASES</h5>
<div class="outline-text-5" id="text-2-1-1-2">
<ul class="org-ul">
<li>arguments的这种alias关系是不好的.所以我们要禁止使用
</li>
<li>由于老的js中存在这很多这种不是特别好的特性,我们发明了一种禁止'一类js不好
的特性'的方法: strict mode
</li>
<li>strict mode很简单,只要在js代码最上面协商'strict mode'就可以了,这等于告诉
js engine:我们希望安装strict mode 来执行代码:
<ul class="org-ul">
<li>不使用strict mode
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">infiltrate</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">person</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>person<span style="color: #b58900;">)</span>;
    <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span> = <span style="color: #2aa198;">'ninja'</span>;
    console.log<span style="color: #b58900;">(</span>person<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

infiltrate<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"gradener"</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">gradener                                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninja                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>使用strict mode
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">"use strict"</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">infiltrate</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">person</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>person<span style="color: #b58900;">)</span>;
    <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span> = <span style="color: #2aa198;">'ninja'</span>;
    console.log<span style="color: #b58900;">(</span>person<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

infiltrate<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"gradener"</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">gradener                                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">gradener                                       //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2">The this parameter: introducing the function context</h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>this是一个很有意思的参数. 在objected-oriented语言中,一般都会有一个this来指
代当前的function是被那个object调用的.
</li>
<li>js并不是一个oo语言,function的创建也并不一定要在object里面. 但是js为了有oo
特性,特意发明了this参数.并且为oo做了一些'妥协':
<ul class="org-ul">
<li>如果我们的method有caller的话,那么this肯定就是指的caller object
</li>
<li>更多的情况下,我们并不会为一个function指定一个caller, 这种情况下又有两说:
<ol class="org-ol">
<li>老的js实现,也就是none-strict mode下面,我们的this会指向window,这是非常
不好的实现,因为我们调用function'没指定object',你却默认给我一个object,
这首先不合理.其实我们后面会看到,这种实现会'污染global namespace'
</li>
<li>新的js为了修正老的js实现,引入了strict mode(前面的arguments的alias我们
已经看到过strict mode修正过一次js的不良设计了), 在strict mode里面.如
果调用function不加object的话,this会指向undefined
</li>
</ol>
</li>
</ul>
</li>
<li>下面我们来介绍下function有哪些被调用的方法
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Invoking functions</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>在js里面有如下几种调用function的方式:
<ul class="org-ul">
<li>As a function: 这是最直接的调用function的方式,比如skulk()
</li>
<li>As a method: 这种方式会联系上一个object,为了oo设计而实现的, 比如ninja.skulk()
</li>
<li>As a constructor: 使用new来调用function,比如new Ninja(), 是一种类oo的object
创建方法
</li>
<li>通过apply或者call调用,这种是把object'当做参数'的调用方式: 比如skulk.call(ninja)
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">Invocation as a function</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>这么说的意思是function以最纯粹的方式调用:只使用operator()
</li>
<li>细细品味,有如下三种详细的调用方式:
<ul class="org-ul">
<li>function declaration, invoked as a function
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>;
ninja<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>function expression invoked as a function
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">samurai</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(){}</span>;
samurai<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>immediately invoked function expression, invoked as a function
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(){}</span><span style="color: #2aa198;">)()</span>
</pre>
</div>
</li>
</ul>
</li>
<li>以这种方式调用function,在function内部this会:
<ul class="org-ul">
<li>在strict mode下面指向undefined
</li>
<li>在none strict mode下面指向window object
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">Invocation as a method</h4>
<div class="outline-text-4" id="text-2-2-2">
<ul class="org-ul">
<li>当一个function被'设置'为一个object的property,然后当这个object调用这个function
的时候,我们就说function is invoked as a method of that object
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #2aa198;">{}</span>;
ninja.skulk = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(){}</span>;
ninja.skulk<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>这种情况下,this自然就指向了调用我们的object.这也是js极力模仿其他oo语言的地
方.
</li>
<li>这种情况下,function的this是不停变动的,根据调用method的object的不同,this会
会有各种不同
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">whatsMyContext</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">nodejs' [window] equivalent global variable [global]</span>
console.log<span style="color: #2aa198;">(</span>whatsMyContext<span style="color: #b58900;">()</span> === global<span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">getMyThis</span> = whatsMyContext;
console.log<span style="color: #2aa198;">(</span>getMyThis<span style="color: #b58900;">()</span> === global<span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #2aa198;">{</span>
    getMyThis: whatsMyContext
<span style="color: #2aa198;">}</span>;

console.log<span style="color: #2aa198;">(</span>ninja1.getMyThis<span style="color: #b58900;">()</span> === ninja1<span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #2aa198;">{</span>
    getMyThis: whatsMyContext
<span style="color: #2aa198;">}</span>;

console.log<span style="color: #2aa198;">(</span>ninja2.getMyThis<span style="color: #b58900;">()</span> === ninja2<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>虽然我们的ninja1和ninja2都共享了一个function实体,但是其内部this的值确是不
一样的.
</li>
<li>this的灵活指向,完成了js对oo语言的一种追求.但是这个例子中,这样实现ninja1和
ninja2其实是有点repeat代码的,也就是把两个object的getMyThis都指向whatsMyContext
</li>
<li>oo语言中是可以通过继承来减少这种repeated代码的,我们后面会介绍
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">Invocation as a constructor</h4>
<div class="outline-text-4" id="text-2-2-3">
<ul class="org-ul">
<li>总体上来说,任何一个function都可以作为一个constructor(可能arrow function有
些区别,后面会介绍),比如前面我们设置的whatsMyContext
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">whatsMyContext</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>; <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">whatsMyContext</span><span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>但是这样做却是没有什么意义的,因为constructor function要做些事情,但是这里却
完全没做.只是说这样做编译器不会报错而已,并没有实现constructor的核心价值.要
实现ctor的核心价值,就得让ctor function和普通函数有点不同才行
</li>
</ul>
</div>
<div id="outline-container-sec-2-2-3-1" class="outline-5">
<h5 id="sec-2-2-3-1">THE SUPERPOWERS OF CONSTRUCTORS</h5>
<div class="outline-text-5" id="text-2-2-3-1">
<ul class="org-ul">
<li>先看一个例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.skulk = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;

console.log<span style="color: #2aa198;">(</span>ninja1.skulk<span style="color: #b58900;">()</span> === ninja1<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja2.skulk<span style="color: #b58900;">()</span> === ninja2<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>根据这个例子我们可以列出使用operator new xx()的方法来调用function的一些特
殊的地方:
<ul class="org-ul">
<li>会首先创建一个empty object
</li>
<li>这个object会传递给ctor function,作为这个ctor function的this paramter,那
么也就成为了这cotr function的context
</li>
<li>这个ctor函数返回的时候,我们会把ctor function的this作为返回值返回,所以ctor
function的结果可以返回给某个变量
</li>
</ul>
</li>
<li>后面两点说明了为什么whatsMyContext不是一个好的ctor: 一个ctor是创建一个object,
然后再function内部对这个object进行配置,说白了就是对this进行配置,最终返回.
whatsContxt都没有对this做过什么,自然就没有ctor的灵魂了
</li>
<li>我们一个标准的ctor应该如Ninja()
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.skulk = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-3-2" class="outline-5">
<h5 id="sec-2-2-3-2">CONSTRUCTOR RETURN VALUES</h5>
<div class="outline-text-5" id="text-2-2-3-2">
<ul class="org-ul">
<li>其实ctor的设计,很明显是一种js这种functional语言"强行"适应面向对象编程语言
的一种妥协设计.所以最后出来了一种ctor function最后会返回'传递给它的新建的
object'的this指针的设计.
</li>
<li>所以问题来了,如果我们ctor function自己return了返回值怎么办?
</li>
<li>答案是, 看情况:
<ul class="org-ul">
<li>如果返回的是nonobject value,比如1, 那么没事,everything 都OK
</li>
<li>如果返回的是object value, 那么ctor function的返回值就不再是那个新建的this
了,而是这个明确return的object.正是这种情况的存在,让我们必须要小心,同时
也使用各种办法让ctor function看起来更加不一样一点
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-3-3" class="outline-5">
<h5 id="sec-2-2-3-3">CODING CONSIDERATIONS FOR CONSTRUCTORS</h5>
<div class="outline-text-5" id="text-2-2-3-3">
<ul class="org-ul">
<li>我们的ctor function的价值在于我们对new创建的新object进行配置,所以一个有意义
的ctor function内部肯定会着重处理this
</li>
<li>但是如果我们调用的时候不小心忘了加new,那么我们ctor function里面对this的操作
都会是对window的操作!这会极大的污染global namespace.(在strict mode这不会发
生)
<div class="org-src-container">

<pre class="src src-js"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">global equvivalent for window in nodejs</span>
console.log<span style="color: #2aa198;">(</span>Object.keys<span style="color: #b58900;">(</span>global<span style="color: #b58900;">)</span>.includes<span style="color: #b58900;">(</span><span style="color: #2aa198;">'skulk'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.skulk = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">whatever</span> = Ninja<span style="color: #2aa198;">()</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">forget new !</span>
console.log<span style="color: #2aa198;">(</span>Object.keys<span style="color: #b58900;">(</span>global<span style="color: #b58900;">)</span>.includes<span style="color: #b58900;">(</span><span style="color: #2aa198;">'skulk'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>在strict mode诞生之前,我们能做出的努力(让ctor function看起来不一样一点)就
是naming convention了:
<ul class="org-ul">
<li>普通函数的命名是首字母小写的驼峰模式,并且表述下自己做了什么,比如
<div class="org-src-container">

<pre class="src src-js">skulk, creep, sneak, doSomethingWonderful
</pre>
</div>
</li>
<li>ctor函数的命名是首字母大写的,一般是名词,比如
<div class="org-src-container">

<pre class="src src-js">Ninja, Samurai, Emperor, Ronin
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4">Invocation with the apply and call methods</h4>
<div class="outline-text-4" id="text-2-2-4">
<ul class="org-ul">
<li>到目前为止,我们看到的不同的function invocation类型的主要区别在于:implicit this
指向的function context是什么:
<ul class="org-ul">
<li>对于method来说,this指向了method的object
</li>
<li>对于top-level来说,this指向window或者undfined
</li>
<li>对于ctor来说,this指向new新创建的这个object
</li>
</ul>
</li>
<li>如果我们想随意指定一个object怎么办,比如top-level的function,我们不想使用window,
而想使用document来调用它们.
</li>
<li>为了解决这个问题,我们先来看一个'非常常见的'和event handling相关的bug.
</li>
<li>看这个bug之前,先来了解event handling的机制: 每当event handler被调用的时候,
function context是被设置为event绑定的object
<pre class="example">
When an event handler is called, the function context is set to
the object to which the event was bound.
</pre>
</li>
<li>我们的这个buggy的例子如下
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">button</span> id =<span style="color: #2aa198;">"test"</span>&gt; Click Me! &lt;/<span style="color: #268bd2;">button</span>&gt;
&lt;<span style="color: #268bd2;">script</span>&gt;
 function Button() {
     this.clicked = false;
     this.click = function() {
         this.clicked = true;
         assert(button.clicked, <span style="color: #2aa198;">"The button has been clicked"</span>); <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">false </span><span style="color: #93a1a1;">--&gt;</span>
     };
 }
 var button = new Button();
 var elem = document.getElementById(<span style="color: #2aa198;">"test"</span>);
 elem.addEventListener(<span style="color: #2aa198;">"click"</span>, button.click);
&lt;/<span style="color: #268bd2;">script</span>&gt;
</pre>
</div>
</li>
<li>这个例子的结果并不如人意, 每次调用都会显示'红色'的message,表示clicked的值是
false
</li>
<li>这个例子的问题在于button.click的调用,如果不和addEventListener掺和的话,那么
会把this默认为button object(这个是method的典型用法啊),而这里的问题是addEventListener
会把后面的callback的this改成elem(也就是addEventListener的调用者!),所以你对
this.clicked的操作,都会延续到elem上面!
</li>
<li>我们姑且还是认为这是js设计不合理的地方吧
</li>
<li>这个问题的根源在于我们没有'准确'函数的this object! 函数的this object如果能
够随心所欲的更改的话,那么我们就可以完成我们的工作了.
</li>
<li>幸运的是js确实是有这样的feature,那就是:
<ul class="org-ul">
<li>apply
</li>
<li>call
</li>
</ul>
</li>
<li>apply和call其实是一回事,只不过apply要求第二个参数是数组,call则是把这个数组展开
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">juggle</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">result</span> = 0;
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">n</span> = 0; n &lt; <span style="color: #268bd2; font-weight: bold;">arguments</span>.length; n++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        result += <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>n<span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">}</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.result = result;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #2aa198;">{}</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #2aa198;">{}</span>;

juggle.apply<span style="color: #2aa198;">(</span>ninja1, <span style="color: #b58900;">[</span>1,2, 3, 4<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;
juggle.call<span style="color: #2aa198;">(</span>ninja2, 5, 6, 7, 8<span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninja1.result<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja2.result<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10                                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">26                                             //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>好了,你信心满满的把代码改成如下,希望能够得到'绿色'的结果
<div class="org-src-container">

<pre class="src src-js">elem.addEventListener.call<span style="color: #2aa198;">(</span>button, <span style="color: #2aa198;">"click"</span>, button.click<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>结果浏览器却报错了,因为addEventListener是一个浏览器提供的API,它并不是一个真
正的js function
</li>
<li>要想真正的解决这个问题,我们要用到arrow function
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Fixing the problem of function contexts</h3>
<div class="outline-text-3" id="text-2-3">
</div><div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Using arrow functions to get around function contexts</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>除了写起来简单以外,arrow function还有一个特性和原来的function与众不同,而且
更容易把它作为一个callback: arrow function的this不再是一个动态的值,它是不
能再次改变的(可以被认为是一个const, 无论call, apply还是bind都不能改变它),
它的初始化值是'创建时期enclosing scope'的this值
<pre class="example">
Arrow functions don't have their own this value. Instead, they remember
the value of the this parameter at the time of their definition.
</pre>
</li>
<li>它的初始化值是'创建时期enclosing scope'的this值, 这句比较难以理解,我们可以
看看下面几个例子:
<ul class="org-ul">
<li>在global创建的function,其this始终是指向window(global)的
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">script</span>&gt;
    var o = {
        traditionalFunc: function() {
            assert(this === o, <span style="color: #2aa198;">"traditionalFunc this === o?"</span>); <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">true </span><span style="color: #93a1a1;">--&gt;</span>
        },
        arrowFunc: () =&gt; {
            assert(this === o, <span style="color: #2aa198;">"arrowFunc this === o?"</span>); <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">false </span><span style="color: #93a1a1;">--&gt;</span>
            assert(this === window, <span style="color: #2aa198;">"arrowFunc this === window?"</span>); <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">true </span><span style="color: #93a1a1;">--&gt;</span>
        }
    };

    o.traditionalFunc();
    o.arrowFunc();
&lt;/<span style="color: #268bd2;">script</span>&gt;
</pre>
</div>
</li>
<li>在ctor里面创建的,其this始终指向新创建的object,也就是我们后面的例子展现的.
</li>
</ul>
</li>
<li>这样一来,刚才的问题就迎刃而解了.下面的例子中,所有的this都是一个this,就是button object
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Button</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #268bd2; font-weight: bold;">this</span>.clicked = <span style="color: #268bd2; font-weight: bold;">false</span>;
  <span style="color: #268bd2; font-weight: bold;">this</span>.click = <span style="color: #b58900;">()</span> =&gt; <span style="color: #b58900;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.clicked = <span style="color: #268bd2; font-weight: bold;">true</span>;
    assert<span style="color: #268bd2;">(</span>button.clicked, <span style="color: #2aa198;">"The button has been clicked"</span><span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">button</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Button</span><span style="color: #2aa198;">()</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">elem</span> = document.getElementById<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"test"</span><span style="color: #2aa198;">)</span>;
elem.addEventListener<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"click"</span>, button.click<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Using the bind method</h4>
<div class="outline-text-4" id="text-2-3-2">
<ul class="org-ul">
<li>我们再来回顾下前面的event handler出问题的那句代码
<div class="org-src-container">

<pre class="src src-js">elem.addEventListener<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"click"</span>, button.click<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>前面说addEventListener不是真正的js function,那么我们可以从button.click上面
来做做文章,依照我们现有的知识,我们可以这么做
<div class="org-src-container">

<pre class="src src-js">elem.addEventListener<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"click"</span>, button.click.call<span style="color: #b58900;">(</span>button<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>这样做看起来可以,但是有一个问题:我们的apply或者call,是"调用一个函数",我们
的assert的确变成绿的了,但是只能绿一次,我们不能把这个function'再传递'给addEventListener
</li>
<li>所以我们很自然的想到,'再创建一个新的function,只不过this换掉的方案',那就是
bind了
</li>
<li>每个function都可以访问bind, bind会:
<ul class="org-ul">
<li>创建一个新的函数并且作为返回值返回
</li>
<li>而且这个函数的this函数变成了bind的第一个参数
</li>
<li>这种bind是强制的,不会受到'如何调用'的影响(如果还受到addEventListener的影
响,那就没完没了了)
</li>
</ul>
</li>
<li>下例中,我们使用bind来把button.click'绑定'在button上,然后返回就解决了这个问题
<div class="org-src-container">

<pre class="src src-html">var button = {
   clicked: false,
   click: function(){
     this.clicked = true;
     assert(button.clicked,<span style="color: #2aa198;">"The button has been clicked"</span>); <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">true </span><span style="color: #93a1a1;">--&gt;</span>
   }
 };
 var elem = document.getElementById(<span style="color: #2aa198;">"test"</span>);
 elem.addEventListener(<span style="color: #2aa198;">"click"</span>, button.click.bind(button));

 var boundFunction = button.click.bind(button);
 assert(boundFunction !== button.click,
        <span style="color: #2aa198;">"Calling bind creates a completyl new function"</span>); <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">true </span><span style="color: #93a1a1;">--&gt;</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 5: Functions for the master: closures and scopes</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>和我们前面讲的function一样,closure也是最重要的javascript特性.虽然很多js开发
者可以在完全不理解closure带来的好处的基础上写出代码.但是我们还是要说,closure
的引进,为js增添了如下的好处:
<ul class="org-ul">
<li>为一些高端的特性减少了代码的数量和复杂度: 和callback有关的代码,比如event
handling,如果没有closure,就会非常的麻烦
</li>
<li>让我们使用一些如果没有closure根本不能实现的特性:比如private object variable
</li>
</ul>
</li>
<li>closure其实是functional programming language的特性,了解它有助于理解复杂的js
代码
</li>
<li>closure其实是一种副作用(side effect),它是js scope工作原理的副作用
<pre class="example">
Closures are a side effect of how scopes work in JavaScript.
</pre>
</li>
</ul>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Understanding closures</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>closure的出现,让js的function可以'读写'不在function内部的variable,当然这些个
variable必须是在function定义的scope里面(也就是说是function定义所在的那个{})
</li>
<li>closure给function带来的好处,就是一个function可以在'以后任何的时间'被调用,甚
至是它定义的scope已经结束了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">outerValue</span> = <span style="color: #2aa198;">"samurai"</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">later</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">outerFunction</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">innerValue</span> = <span style="color: #2aa198;">"ninja"</span>;

    <span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">innerFunction</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">'outerValue is '</span> + outerValue<span style="color: #268bd2;">)</span>;
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">'innerValue is '</span> + innerValue<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    later = innerFunction;
<span style="color: #2aa198;">}</span>

outerFunction<span style="color: #2aa198;">()</span>;
later<span style="color: #2aa198;">()</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">outerValue is samurai                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">innerValue is ninja                            //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>我们使用later变量来保存innerFunction,然后再后面去调用它,否则我们无法获取它
的名字(因为innerFunction定义在outerFunction里面)
</li>
<li>later()调用的时候,outerFunction()已经运行完毕了,但是later()还是能看到outerVale
和innerValue,其中原因就是closure
</li>
<li>当我们在outer function里面定义innerFunction的时候,不知function declaration
定义了.同时一个closure也会被定义, 这个closure里面包括, function 定义时候的
所有的variable
<pre class="example">
+----------------------------------------------------+
|        +------------------------+                  |
|        | function outerFunction |                  |
|        +------------------------+                  |
|                                                    |
|   +-----------+                                    |
|   | var later |                                    |
|   +-----------+                                    |
|                                                    |
|            +--------------------------------+      |
|            | function innerFunction() {...} |      |
|            +--------------------------------+      |
|                                                    |
|             +----------------+                     |
|             | var innerValue |                     |
|             +----------------+                     |
|                                                    |
|        +----------------+                          |
|        | var outerValue |                          |
|        +----------------+       CLOSURE            |
|                                                    |
+----------------------------------------------------+
</pre>
</li>
<li>一旦closure创建起来了以后,function就有了它运行所有需要的一切(the function
has all it needs to execute), 好了,这里有一个问题了,为什么"仅仅"包括了function
定义时刻scope的内容,closure就肯定包括了function运行所需要的一切?难道function
不能使用'其他'内容么?
</li>
<li>答案是function'不一定'能使用'其他'内容,原因很简单:它看不到!function能看到的
变量有两种:
<ul class="org-ul">
<li>看到自己定义所在的scope里面的变量,所以它内部也仅仅可能使用这些变量
</li>
<li>global scope的内容(所有人都看得到)
</li>
</ul>
</li>
<li>每个function都带有一个closure,所以可以在无论什么时候进行运行,但是也是有代价
的: 每个function都要在内存里面维护这么一个closure,直到js engine它不会再被需
要,或者page unload的时候
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Putting closures to work</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>我们已经从概念上了解了closure,下面来看看closure如何在js代码中起作用的例子
</li>
</ul>
</div>
<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">Mimicking private variables</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>很多语言都有private variable这个概念,这是oo语言实现内聚的重要特性
</li>
<li>在js里面,我们通过closure来实现private variable,看下面的例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">feints</span> = 0;
    <span style="color: #268bd2; font-weight: bold;">this</span>.getFeints = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> feints;
    <span style="color: #b58900;">}</span>;
    <span style="color: #268bd2; font-weight: bold;">this</span>.feint = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        feints++;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
ninja1.feint<span style="color: #2aa198;">()</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">private data is inaccessible to us</span>
console.log<span style="color: #2aa198;">(</span>ninja1.feints<span style="color: #2aa198;">)</span>;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">We're able to access the internal feint count via getter</span>
console.log<span style="color: #2aa198;">(</span>ninja1.getFeints<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninja2 gets its own feints variable</span>
console.log<span style="color: #2aa198;">(</span>ninja2.getFeints<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>这个例子中,我们使用Ninja function作为一个ctor.这是一个常规操作
</li>
<li>不常规的操作在于我们在ctor里面定义了一个变量feints来hold state: 这个时候,
首先起作用的是javascript的scoping rule(不是closure是scope!!):这个变量只能
在constructor里面访问(within the ctor)
</li>
<li>好了,下面该closure出场了:为了让外面也能'访问'这个变量,我们设计了一个function
作为getter.这里体现了closure起作用的一大特点,在function里面定义function的
时候,往往意味着用到closure了!
<pre class="example">
Whenever you use function inside another function, a closure is used.
</pre>
</li>
<li>下面还是在function里面定义function:在Ninja()里面定义了一个setter: feint,这
里只是简单的增加1
</li>
<li>好了,我们的代码显示出,我们只能使用setter: feint来更改private variable,这跟
oo语言里面的封装是一个道理
</li>
<li>ninja2的例子还告诉我们,这个variable是每个instance都有一个的&#x2013;和private variable
一样
</li>
<li>使用closure(在scope和new的帮助下),ninja object的state只能通过特定的method
来访问
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">Using closures with callbacks</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li>closure另外经常出现的地方就是callbacks(when a function is called at an
unspecified later time)
</li>
<li>下面是一个callback使用closure的例子
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">body</span>&gt;
    &lt;<span style="color: #268bd2;">div</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"box1"</span>&gt;First Box&lt;/<span style="color: #268bd2;">div</span>&gt;
  &lt;<span style="color: #268bd2;">script</span>&gt;
    function animateIt(elementId) {
      var elem = document.getElementById(elementId);
      var tick = 0;
      var timer = setInterval(function(){
        if (tick &lt; 100) {
          elem.style.left = elem.style.top = tick + <span style="color: #2aa198;">"px"</span>;
          tick++;
        }
        else {
          clearInterval(timer);
          assert(tick === 100,
                 <span style="color: #2aa198;">"Tick accessed via a closure."</span>);
          assert(elem,
                 <span style="color: #2aa198;">"Element also accessed via a closure."</span>);
          assert(timer,
                 <span style="color: #2aa198;">"Timer reference also obtained via a closure."</span> );
        }
      }, 10);
    }
    animateIt(<span style="color: #2aa198;">"box1"</span>);
  &lt;/<span style="color: #268bd2;">script</span>&gt;
&lt;/<span style="color: #268bd2;">body</span>&gt;
</pre>
</div>
</li>
<li>这个例子的主体是其实就是对某个element(box1)调用一个函数animateIt, 而animateIt
的内部其主要作用的是setInterval这个函数
</li>
<li>setInterval函数的作用是'间隔性'的调用某个function(这个function肯定是callback
啦), 会返回一个timerId,这个timerId以后可以传递给clearInterval()来取消这个'间
歇性'的callback调用(这里是通过判断tick到没到100下来决定的)
</li>
<li>那重点又转移到了这个callback函数上面,这个callback函数其实就是根据tick来移
动elem,所以这个函数一共用到三个variable:
<ul class="org-ul">
<li>tick:调用了多少次callback
</li>
<li>elem:移动那个element
</li>
<li>timer: callback返回的timer,callback一定次数之后返回
</li>
</ul>
</li>
<li>我们发现这三个变量,其实是托closure的福才能访问的到,我们也发现我们的callback
函数正好是use function inside another function.
</li>
<li>那么我们有没有可能不使用closure呢?
</li>
<li>其实也可以,把三个变量都定义成全局变量就可以了,但是这会:
<ul class="org-ul">
<li>极大的污染全局变量.
</li>
<li>如果你有两个以上的animataion,那么会相互影响!
</li>
</ul>
</li>
<li>所以这是closure可以让我们做的better的一个特性(而不是像private variable那样
的没有就实现不了的特性)
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Tracking code execution with execution context</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>在js里面,最基本的单位就是function.为了完成某些功能,我们可以在一个function里
面调用另外的function,继续嵌套等等
</li>
<li>当一个function完成工作的时候,它必须退回到call 它时候的状态,学过c语言的都知
道这个是通过stack来完成的
</li>
<li>前面也说过了,我们有两种js code:
<ul class="org-ul">
<li>global code: 在所有的function之外的代码
</li>
<li>function code: 在function内部的代码
</li>
</ul>
</li>
<li>我们为这两种js code都准备了一种execution context:
<ul class="org-ul">
<li>global execution context: 全局只有一个
</li>
<li>function execution context: 每个function创建的时候都会创建一个
</li>
</ul>
</li>
<li>每次function调用的时候push一个context到stack里面,当function返回的时候,这个
context就会被pop而放弃
</li>
<li>除了保存运行的position以外,execution context还能够检查某个variable时候合法,
这是通过lexical environment来完成的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Keep track of identifiers with lexical environments</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>lexical environment是一个js engine内部的概念,所以说起来是这么的拗口,我们通
常把这个叫做scope.
</li>
<li>lexical是把identifier和内存值映射的这么一个机制,有点像编译里面的变量表
</li>
<li>在es6之前,scope只能有一种,那就是function,其他c-like语言里面的`{}`内部就是一
个scope的情况,在js里面没有实现,幸好es6实现了!
</li>
</ul>
</div>
<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1">Coding nesting</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>先看下面的一个例子
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">html</span>&gt;
    &lt;<span style="color: #268bd2;">script</span>&gt;
     var ninja = "Muneyoshi";
     function skulk() {
         var action = <span style="color: #2aa198;">"skulking"</span>;
         function report() {
             var reportNum = 3;

             for (var i = 0; i &lt; reportNum; i++) {
                 console.log(ninja + <span style="color: #2aa198;">" "</span> + action + <span style="color: #2aa198;">" "</span> + i);
             }
         }
         report();
     }
     skulk();
    &lt;/<span style="color: #268bd2;">script</span>&gt;
&lt;/<span style="color: #268bd2;">html</span>&gt;
</pre>
</div>
</li>
<li>这个例子中,我们看到了好多的nested:
<ul class="org-ul">
<li>for loop被nested在report function里面
</li>
<li>report()被nested在skulk()里面
</li>
<li>skulk()被nested在global code里面
</li>
</ul>
</li>
<li>在scope的语义里面,每次的"调用"都会获得一个新的lexical environment,就是一个
独立的scope,这个是和c-like语言保持一致的
<pre class="example">
In terms of scopes, each of these code structures gets an associated lexical
environment every time the code is evaluated.
</pre>
</li>
<li>还有一点需要强调的是,inner code'还必须可以'access to 定义在outer code的
variable,比如:
</li>
<li>for需要有能力去使用:
<ul class="org-ul">
<li>report()里面的变量
</li>
<li>skulk()里面的变量
</li>
<li>global里面的变量
</li>
</ul>
</li>
<li>report()需要能够访问:
<ul class="org-ul">
<li>skulk()里面的变量
</li>
<li>global里面的变量
</li>
</ul>
</li>
<li>skulk()只能访问:
<ul class="org-ul">
<li>global里面的变量
</li>
</ul>
</li>
<li>这些也是c-like语言里面常见的能力,但是在js里面,实现方法有所不同
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2">Code nesting and lexical environments</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>js里面的实现策略就是每一个lexical environment都会保存一个指向parent lexical
environment的"指针",这样当当前的environment找不到响应变量的时候,它可以顺着
指针向上寻找,直到global scope
</li>
<li>我们把function也可以看成是一种scope,但是这个scope更加的牛逼,它可以调用已经
运行完了的数据! 它实现起来也更加的麻烦:
</li>
<li>每当一个function被创建的时候,function都会有一个叫做\[\[ Environment\]\]的
property被创建,指向这个function`被创建时期`的scope. 这样保证了,我们的function
就算当做参数传递出去,也始终能通过\[\[ Environment\]\]来记住自己的'来历'
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Understanding types of JavaScript variables</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>java中,我们可以使用三种方法定义变量:
<ul class="org-ul">
<li>var
</li>
<li>let
</li>
<li>const
</li>
</ul>
</li>
<li>它们的区别在"是否可变"以及和lexical environment的关系不同
</li>
</ul>
</div>
<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1">Variable mutability</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>那就是分成:
<ul class="org-ul">
<li>const
</li>
<li>let或者var
</li>
</ul>
</li>
<li>const就是不可变'变量',es6代码的风格趋向于如果不确定,就把变量定义成const
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-2" class="outline-4">
<h4 id="sec-3-5-2">Variable definition keywords and lexical environments</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>var是上古时期的产物,它对于scope是不认识的,所以它只能定义在最近的function scope
或者是global scope
</li>
<li>const和let就会尊重scope啦
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-3" class="outline-4">
<h4 id="sec-3-5-3">Registering identifiers within lexical environments</h4>
<div class="outline-text-4" id="text-3-5-3">
<ul class="org-ul">
<li>js是一个script语言,但是script语言其实也不是从上到下一次运行的,它还是有点静
态语言的味道:因为它会先"大概过一下代码",了解定义了哪些function,所以,下面的
代码执行效果如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">firstRonin</span> = <span style="color: #2aa198;">"Kiyokawa"</span>;
check<span style="color: #2aa198;">(</span>firstRonin<span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">check</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">ronin</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>ronin<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Kiyokawa                                       //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>js engine往往会visit代码两遍:
<ul class="org-ul">
<li>第一遍不运行,只是把当前lexical environment的变量和function都注册一下
</li>
<li>第二遍才是正常的运行
</li>
</ul>
</li>
<li>我们详细来解释下,js engine把代码的执行分成了两个phase:
<ul class="org-ul">
<li>第一个phase被激发的条件,是new lexical environment被创建的时候,这个phase
不会执行代码,js engine会访问并注册当前lexical environment里面所有的declared
variable和function
</li>
<li>第二个phase,才是真正的execution
</li>
</ul>
</li>
<li>相比之下,第二个phase就是一行一行执行,比较容易理解. 而第一个phase却非常的复
杂,根据variable类型的不同,和environment的不同,都有不同的执行方法:
<ul class="org-ul">
<li>如果我们的lexical environment是function environment,那么就会创建arguments
当然了还要给这个arguments类数组赋值.只有function environment才会做这一步
</li>
<li>如果我们的lexical environment是global或者function environment,当前的代码
主体会被扫描并注册,同时还会为每个发现的function创建一个指向当前environment的指针
扫描并注册的时候,但是注意如下两点:
<ol class="org-ol">
<li>arrow function不会被注意到!
</li>
<li>function的body不会去检查,否则没完了
</li>
</ol>
</li>
<li>如果我们的lexical environment是global或者function environment, 我们还会
去扫描variable,所有定义在global scope和function scope的var变量以及const,
let变量,都会被找到.
</li>
<li>如果我们的lexical environment是block environment,那么变量方面,只有const和
let被找到
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">Exploring how closures work</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>我们这一章的开始是从介绍closure开始的,closure是一种能够让function在"运行的
时候"回忆起自己在"创建的时候scope"的变量的机制
</li>
<li>你还学到了使用closure可以模拟private object,或者是让代码和callback配合的更好
</li>
</ul>
</div>
<div id="outline-container-sec-3-6-1" class="outline-4">
<h4 id="sec-3-6-1">Revisiting mimicking private variables with closures</h4>
<div class="outline-text-4" id="text-3-6-1">
<ul class="org-ul">
<li>我们先来回顾下创建一个ninja1的代码
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">feints</span> = 0;
    <span style="color: #268bd2; font-weight: bold;">this</span>.getFeints = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> feints;
    <span style="color: #b58900;">}</span>;

    <span style="color: #268bd2; font-weight: bold;">this</span>.feint = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        feints++;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>js的ctor其实是调用function(只不过是使用了new来调用),那么每调用一次function
我们就有一个lexical environment(这个environment会保存对这个ctor创建时期可
见的variable),这是由scope的机制决定的
</li>
<li>js的evaulate一段scope(这里是调用一段function)会创建Environment,而同时js"创
建"一段function的时候,它会保持一个ref到它'创建时刻'的lexical environment(js
engine内部概念)
</li>
<li>理解上面的一段文字非常重要,它说明了两个问题:
<ul class="org-ul">
<li>js的调用,本质上是一个evaluate scope的过程(曾经function是唯一的一种scope
但是在es6之后,不再是唯一了,但也是scope的一种), 每次evaluate scope都会创建
一个Environment
</li>
<li>js的创建,会记录其创建时刻的Environment,在绝大多数情况下,function是会created
在global的scope,所以这个function会把global记录自己的\[\[Environment\]\].
而这个例子的情况"非常特殊",getter和setter是建立在ctor里面的,也就是说,它们
会把ctor的Environment设计成自己的\[\[Environment\]\].ctor每次的evaluate
scope都会创建一个Environment,而其中的function会记录这个Environment
</li>
</ul>
</li>
<li>getter和setter另外一个特殊的地方(一个是不是建立在global scope),是它们是赋予
给cotr所创建的this的,所以它们可以在ctor之外被访问(通过new赋值的变量),这样,
我们就创建了一个新的特殊的函数:
<ul class="org-ul">
<li>定义在另外一个函数里面,所以可以访问这个函数里面的变量
</li>
<li>可以在global scope使用
</li>
</ul>
</li>
<li>好了,我们继续使用下面的代码创建第二个object
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>那么我们Ninja()会再次调用,也就会生成新的Environment(every invocation都会产
生新的Environment), 那setter和getter也都会指向新的Environment,所以
<pre class="example">
ninja1.getFeints mehtod is different from the ninja2.getFeints method!!
</pre>
</li>
<li>好了,我们来总结下Environment和Closure的区别:
<ul class="org-ul">
<li>Environment可以看做是stack的一个js engine对应:记录当前可以访问的变量,在
历史上是使用stack的,所有在stack里面的(可能有好多层)变量都可以访问.但是
stack有一个致命的问题是,它可能会弹出,一旦弹出就没有存储了.对于js这种functional
语言来说是致命的(因为它要始终记得'自己创建时候'的变量可访问性),所以js engine
就设计了Environment,它内容等同于stack,但是却不会消失
</li>
<li>closure是使用一个指针\[\[Environment\]\]来记录function'必须使用的variable'
而已,占了Environment的便宜,closure只需要一指针就实现了
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-6-2" class="outline-4">
<h4 id="sec-3-6-2">Private variables caveat</h4>
<div class="outline-text-4" id="text-3-6-2">
<ul class="org-ul">
<li>我们需要注意的是,我们使用closure实现的private variable其实只是一种"尽可能好"
的模仿而已.我们依然可以通过把一个object的function赋给另外一个object,从
而丧失任何的private特性
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">feints</span> = 0;
    <span style="color: #268bd2; font-weight: bold;">this</span>.getFeints = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> feints;
    <span style="color: #b58900;">}</span>;
    <span style="color: #268bd2; font-weight: bold;">this</span>.feint = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        feints++;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
ninja1.feint<span style="color: #2aa198;">()</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">imposter</span> = <span style="color: #2aa198;">{}</span>;
imposter.getFeints = ninja1.getFeints;

console.log<span style="color: #2aa198;">(</span>imposter.getFeints<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>但是很多js开发者依然认为使用closure来模拟private variable的方法很有效!谁用
谁知道
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-6-3" class="outline-4">
<h4 id="sec-3-6-3">Revisiting the closures and callbacks example</h4>
<div class="outline-text-4" id="text-3-6-3">
<ul class="org-ul">
<li>我们再来看看上面的callback的例子,这次我们使用了两个object
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">div</span> id =<span style="color: #2aa198;">"box1"</span>&gt;First Box&lt;/<span style="color: #268bd2;">div</span>&gt;
&lt;<span style="color: #268bd2;">div</span> id =<span style="color: #2aa198;">"box2"</span>&gt;Second Box&lt;/<span style="color: #268bd2;">div</span>&gt;

&lt;<span style="color: #268bd2;">script</span>&gt;
 function animateIt(elementId) {
     var elem = document.getElementById(elementId);
     var tick = 0;
     var timer = setInterval(function() {
         if (tick &lt; 100) {
             elem.style.left = elem.style.top = tick + <span style="color: #2aa198;">"px"</span>;
             tick++;
         } else {
             clearInterval(timer);
             assert(tick === 100,
                    <span style="color: #2aa198;">"Tick accessed via a closure."</span>);
             assert(elem,
                    <span style="color: #2aa198;">"Element also accessed via a closure."</span>);
             assert(timer,
                    <span style="color: #2aa198;">"Timer reference also obtained via a closure."</span>);
         }
     }, 10);
 }
 animateIt(<span style="color: #2aa198;">"box1"</span>);
 animateIt(<span style="color: #2aa198;">"box2"</span>);
&lt;/<span style="color: #268bd2;">script</span>&gt;
</pre>
</div>
</li>
<li>每一次的function调用都会产生一个新的lexical environment,这里调用了两次animateIt
那么显然会有两个Environment产生,那么显然,每个Environment里面都会有各自的一
个elem和tick,所以两次调用也不会相互影响.这里我们就从理论上解释了为什么closure
能让callback函数更简单
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 6: Functions for the future: generators and promises</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Makeing our async code elegant with generators and promises</h3>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Working with generator functions</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>generator是一种完全崭新的function类型,它会generate一系列的值,但是并不是一次
返回,而是每次调用返回一次结果,知道没有结果返回了.
</li>
<li>什么时候没有结果了呢?我们新引入了一个关键字yield,你可以看做是return的特殊形
式,yield了几次,就可以返回几次.如果调用的次数超过yield的次数,那么就没有结果
返回了.generator会明确告诉调用者的,看例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">WeaponGenerator</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Katana"</span>,
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Wakizashi"</span>;
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Kusarigama"</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">weapon</span> = WeaponGenerator<span style="color: #2aa198;">()</span>;
console.log<span style="color: #2aa198;">(</span>weapon.next<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>weapon.next<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>weapon.next<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>weapon.next<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ value: 'Katana', done: false }               //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ value: 'Wakizashi', done: false }            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ value: 'Kusarigama', done: false }           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ value: undefined, done: true }               //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>这个例子引入了很多的新知识:
<ul class="org-ul">
<li>generator定义是使用function*来定义的
</li>
<li>yield相当于"不马上返回的"的return
</li>
<li>调用这个函数不会去执行,而是返回一个object,叫做iterator.这里的的weapon
object就是一个iterator,特点是自带一个函数叫做next(). 这其实就是实现了经典
的Iterator设计模式
<pre class="example">
         迭代器模式能够提高你的'遍历'的性能,从一个节点可以直接到下一个节点,遍历
         的时间复杂度是O(N).
         如果使用普通的遍历方法,每遍历一个节点就要使用get(idx)方法,会遍历半个列
         表去查找,所以整个遍历的复杂度是O(N^2)
</pre>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">Controlling the generator throught the Iterator object</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>对generator的调用,不会去执行function的内部代码,相反,调用会产生一个iterator
object: 整个是一个我们可以利用的,用来和iterator进行通信的利器
</li>
<li>iterator每次都会返回一个object,其解构我们都看到了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">{</span>
    value: <span style="color: #2aa198;">'xxx'</span>,
    done: <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们可以把iterator暴露出来的next()函数看成是它的interface,这个函数是我们唯
一可以依赖的,但是依赖的好,会有特别好的效果, 比如我们可以使用while来判断next()
返回的的done值是不是true
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">WeaponGenerator</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Katana"</span>,
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Wakizashi"</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">weaponsIterator</span> = WeaponGenerator<span style="color: #2aa198;">()</span>;

<span style="color: #859900; font-weight: bold;">while</span><span style="color: #2aa198;">(</span>!<span style="color: #b58900;">(</span>item = weaponsIterator.next<span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>.done<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>item.value<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Katana                                         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Wakizashi                                      //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>其实我们使用while的这种方法,用另外的语法糖的方法表示出来,就是for-of loop啦
for-of loop不再需要我们去直接调用next(), 自然也不再需要关注next()返回值的
结构
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">WeaponGenerator</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Katana"</span>,
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Wakizashi"</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">item</span> of WeaponGenerator<span style="color: #b58900;">()</span><span style="color: #2aa198;">){</span>
    console.log<span style="color: #b58900;">(</span>item<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Katana                                         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Wakizashi                                      //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>上面我们介绍的是最基本的generator的使用方法,其实还有一些高端的使用方法,比如
下面要介绍的把generator的execution代理给其他的generator,先看代码
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">WarriorGenerator</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Sun Tzu"</span>;
    <span style="color: #859900; font-weight: bold;">yield</span>* NinjaGenerator<span style="color: #b58900;">()</span>;
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Genhis Khan"</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">NinjaGenerator</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Hattori"</span>;
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Yoshi"</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">warrior</span> of WarriorGenerator<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>warrior<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Sun Tzu                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hattori                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Yoshi                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Genhis Khan                                    //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>注意,这里面的yield有一个是特殊的,是yield*,而不是单单的yield,使用了yield*之
后,我们的yield不再是直接返回后面的值了,而是返回后面值里面的yield.换句话说,
<pre class="example">
        就是把控制权交给了新的generator,让它去遍历,遍历完再把控制权还回来
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2">Using generators</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>生产sequences of item这件事情,看起来不起眼,但是在程序中却经常被用到,比如一
个特别常用的例子,就是生成unique的ID
</li>
<li>每当创建一个object的时候,我们都想给这个object一个不会重复的id,在没有generator
的帮助下,我们可以通过一个global counter来做到.但是这样太丑陋了,而且谁都有
权限去更改这个全局变量
</li>
<li>有了generator这种语言级别的特性,这个件事情做起来就非常容易了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> *<span style="color: #268bd2;">IdGenerator</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">id</span> = 0;
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">true</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">yield</span> ++id;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">idIterator</span> = IdGenerator<span style="color: #2aa198;">()</span>;

console.log<span style="color: #2aa198;">(</span>idIterator.next<span style="color: #b58900;">()</span>.value<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>idIterator.next<span style="color: #b58900;">()</span>.value<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>idIterator.next<span style="color: #b58900;">()</span>.value<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>例子中的id是generator自己的local variable,完全不会被外界干扰
</li>
<li>虽然我们使用了while(true)这种语法,看似会产生无限循环,但是由于yield这种可以
suspend的特性,我们也不必担心无限循环的问题.
</li>
<li>在来看一个遍历DOM的例子,在没有generator之前,代码如下
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #859900; font-weight: bold;">!DOCTYPE</span> html&gt;
&lt;<span style="color: #268bd2;">html</span>&gt;
    &lt;<span style="color: #268bd2;">head</span>&gt;
        &lt;<span style="color: #268bd2;">meta</span> <span style="color: #268bd2;">charset</span>=<span style="color: #2aa198;">"utf-8"</span>&gt;
        &lt;<span style="color: #268bd2;">title</span>&gt;<span style="font-weight: bold;">Recursive DOM traversal</span>&lt;/<span style="color: #268bd2;">title</span>&gt;
        &lt;<span style="color: #268bd2;">link</span> <span style="color: #268bd2;">rel</span>=<span style="color: #2aa198;">"stylesheet"</span> <span style="color: #268bd2;">href</span>=<span style="color: #2aa198;">"../assert.css"</span>&gt;
        &lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">src</span>=<span style="color: #2aa198;">"../assert.js"</span>&gt;&lt;/<span style="color: #268bd2;">script</span>&gt;
    &lt;/<span style="color: #268bd2;">head</span>&gt;
    &lt;<span style="color: #268bd2;">body</span>&gt;
        &lt;<span style="color: #268bd2;">div</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"subTree"</span>&gt;
            &lt;<span style="color: #268bd2;">form</span>&gt;
                &lt;<span style="color: #268bd2;">input</span> <span style="color: #268bd2;">type</span>=<span style="color: #2aa198;">"text"</span>/&gt;
            &lt;/<span style="color: #268bd2;">form</span>&gt;
            &lt;<span style="color: #268bd2;">p</span>&gt;Paragraph&lt;/<span style="color: #268bd2;">p</span>&gt;
            &lt;<span style="color: #268bd2;">span</span>&gt;Span&lt;/<span style="color: #268bd2;">span</span>&gt;
        &lt;/<span style="color: #268bd2;">div</span>&gt;
        &lt;<span style="color: #268bd2;">script</span>&gt;
         "use strict";

         function traverseDOM(element, callback) {
             callback(element);
             element = element.firstElementChild;
             while (element) {
                 traverseDOM(element, callback);
                 element = element.nextElementSibling;
             }
         }

         const subTree = document.getElementById(<span style="color: #2aa198;">"subTree"</span>);
         traverseDOM(subTree, function(element) {
             assert(element !== null, element.nodeName);
         });
        &lt;/<span style="color: #268bd2;">script</span>&gt;
    &lt;/<span style="color: #268bd2;">body</span>&gt;
&lt;/<span style="color: #268bd2;">html</span>&gt;
</pre>
</div>
</li>
<li>怎么说呢,这个例子在我看来,挺顺眼的!反倒是使用generator看起来还真是费劲,如下
<div class="org-src-container">

<pre class="src src-js">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=<span style="color: #2aa198;">"utf-8"</span>&gt;
        &lt;title&gt;Generator DOM traversal&lt;/title&gt;
        &lt;link rel=<span style="color: #2aa198;">"stylesheet"</span> href=<span style="color: #2aa198;">"../assert.css"</span>&gt;
        &lt;script src=<span style="color: #2aa198;">"../assert.js"</span>&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=<span style="color: #2aa198;">"subTree"</span>&gt;
            &lt;form&gt;
                &lt;input type=<span style="color: #2aa198;">"text"</span>/&gt;
            &lt;/form&gt;
            &lt;p&gt;Paragraph&lt;/p&gt;
            &lt;span&gt;Span&lt;/span&gt;
        &lt;/div&gt;

        &lt;script&gt;
         <span style="color: #2aa198;">"use strict"</span>;

         <span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">DomTraversal</span><span style="color: #2aa198;">(</span>element<span style="color: #2aa198;">){</span>
             <span style="color: #859900; font-weight: bold;">yield</span> element;
             element = element.firstElementChild;
             <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span>element<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                 <span style="color: #859900; font-weight: bold;">yield</span>* DomTraversal<span style="color: #268bd2;">(</span>element<span style="color: #268bd2;">)</span>;
                 element = element.nextElementSibling;
             <span style="color: #b58900;">}</span>
         <span style="color: #2aa198;">}</span>

         <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">subTree</span> = document.getElementById<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"subTree"</span><span style="color: #2aa198;">)</span>;
         <span style="color: #859900; font-weight: bold;">for</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">element</span> of DomTraversal<span style="color: #b58900;">(</span>subTree<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
             assert<span style="color: #b58900;">(</span>element !== <span style="color: #268bd2; font-weight: bold;">null</span>, element.nodeName<span style="color: #b58900;">)</span>;
         <span style="color: #2aa198;">}</span>
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-3" class="outline-4">
<h4 id="sec-4-2-3">Communicating with a generator</h4>
<div class="outline-text-4" id="text-4-2-3">
<ul class="org-ul">
<li>前面的例子,generator是一个纯的"输出"的对象,如果加上输入,那就是双向的,就能
称得上'交流'了
</li>
<li>我们和generator交流的方式有两种:
<ul class="org-ul">
<li>第一种比较简单,就是从function传入参数了, generator也是函数,自然可以读取
输入参数
</li>
<li>第二种就比较麻烦了,是从next()函数里面传入参数,这个传入的参数"赋值给了上次
next的调用".看清楚了,是上次next的调用,所以第一次使用next()就传参数都没地
方收, 但是第一次next()调用你可以使用generator function的参赛直接传入进去!
</li>
</ul>
</li>
<li>两种调用方式在下面的例子中均有体现
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">NinjaGenerator</span><span style="color: #2aa198;">(</span>action<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">imposter</span> = <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #b58900;">(</span><span style="color: #2aa198;">"Hattori "</span> + action<span style="color: #b58900;">)</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>imposter === <span style="color: #2aa198;">"Hanzo"</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"The generator has been infiltrated"</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">yield</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Yoshi ("</span> + imposter + <span style="color: #2aa198;">") "</span> + action<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjaIterator</span> = NinjaGenerator<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"skulk"</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninjaIterator.next<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjaIterator.next<span style="color: #b58900;">(</span><span style="color: #2aa198;">"Hanzo"</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ value: 'Hattori skulk', done: false }        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The generator has been infiltrated             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ value: 'Yoshi (Hanzo) skulk', done: false }  //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-4" class="outline-4">
<h4 id="sec-4-2-4">Exploring generatos under the hood</h4>
<div class="outline-text-4" id="text-4-2-4">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Working with promises</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>在js中,我们很依赖asynchronous计算,所谓asynchronous计算就是说,当前无法知道计
算的结果,但是later一定会知道结果.
</li>
<li>es6新进引入的promise就是来处理asynchronous task的object
</li>
<li>我们可以把promise看成是一种placeholder,用来存放我们当前还不知道结果的值,promise
保证我们最后会得到一个结果,因为最坏的结果也就是失败,或者是是一个我们为啥没
办法deliver的excuse
</li>
<li>一个最常见例子就是使用promise来从server获取data,我们保证能够从服务器获取数据,
当然server也可能出现问题,但是我们保证我们对调用者有个交代
</li>
<li>下面是一个promise的例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjaPromise</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Promise</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>resolve, reject<span style="color: #b58900;">)</span> =&gt; <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>Math.random<span style="color: #6c71c4;">()</span> &gt; 0.5<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
        resolve<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"Hattori"</span><span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #268bd2;">{</span>
        reject<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"An error happened"</span><span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

ninjaPromise.then<span style="color: #2aa198;">(</span>ninja =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span>ninja<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span>, err =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">///////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================possible OUTPUT 1===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hattori                                                   //</span>
<span style="color: #93a1a1;">///////////////////////////////////////////////////////////////</span>


<span style="color: #93a1a1;">///////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================possible OUTPUT 2===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">An error happened                                         //</span>
<span style="color: #93a1a1;">///////////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>为了创建一个promise,我们使用了内置的Promise constructor, 这个ctor要求传入一
个function作为参数(我们这里使用的是arrow function)
</li>
<li>这个传入的function参数叫做executor function, 有两个参数(其实也是两个函数):
<ul class="org-ul">
<li>resolve
</li>
<li>reject
</li>
</ul>
</li>
<li>这个executor function会在Promise object创建的那一刻'马上调用',这个function
一般都会根据"情势"来决定到底是调用resolve函数还是reject函数,通常是正常的情
况调用resolve,异常的情况调用reject
</li>
<li>好了,promise在创建了以后就返回了,object ref存在变量ninjaPromise里面,对这个
object的使用是调用这个object的函数then(),这个函数也是有两个callback作为参数:
<ul class="org-ul">
<li>success callback: resolve()调用的时候使用
</li>
<li>failure callback: reject()调用的时候使用
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1">Understanding the problems with simple callbacks</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>我们的js代码通常对响应性要求很高,所以当long-running task执行的时候,我们不
想block当前的application运行.当前的做法是把这个long-running task排挤出当前
运行的stack,然后为这个long-running task准备一个callback function,当这个task
运行完的时候,我们运行callback就好了
</li>
<li>比如,从服务器获取json file是一个典型的long-running task,为了不让我们获取json
的时候app变得unresponsive,我们必须为这个task配备一个callback
<div class="org-src-container">

<pre class="src src-js">getJSON<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"data/ninjas.json"</span>, <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Handle results */</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>但是问题在于,这个long-running task有可能是会发生错误的,但是我们不能使用try
catch来处理这个问题,如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">try</span> <span style="color: #2aa198;">{</span>
    getJSON<span style="color: #b58900;">(</span><span style="color: #2aa198;">"data/ninjas.json"</span>, <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Handle results</span>
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span> <span style="color: #859900; font-weight: bold;">catch</span><span style="color: #2aa198;">(</span>e<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Handle errors</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>不能使用try-catch的原因在于,如下两段代码并不在同一个event loop里面:
<ul class="org-ul">
<li>invoking callback的代码
</li>
<li>start the long-running task的代码
</li>
</ul>
</li>
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2">Diving into promises</h4>
<div class="outline-text-4" id="text-4-3-2">
<ul class="org-ul">
<li>看一个结合了delayjob和普通job的promise的例子
<div class="org-src-container">

<pre class="src src-js">console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"At code start---------&gt;"</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninjaDelayedPromise</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Promise</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>resolve, reject<span style="color: #b58900;">)</span> =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"ninjaDelayedPromise executor"</span><span style="color: #268bd2;">)</span>;
    setTimeout<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">()</span> =&gt; <span style="color: #6c71c4;">{</span>
        console.log<span style="color: #859900;">(</span><span style="color: #2aa198;">"Resolving ninjaDelayedPromise"</span><span style="color: #859900;">)</span>;
        resolve<span style="color: #859900;">(</span><span style="color: #2aa198;">"Hattori"</span><span style="color: #859900;">)</span>;
    <span style="color: #6c71c4;">}</span>, 500<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninjaDelayedPromise<span style="color: #2aa198;">)</span>;

ninjaDelayedPromise.then<span style="color: #2aa198;">(</span>ninja =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"ninjaDelayedPromise resolve handled with "</span> + ninja<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjaImmediatePromise</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Promise</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>resolve, reject<span style="color: #b58900;">)</span> =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"ninjaImmediatepromise executor"</span><span style="color: #268bd2;">)</span>;
    resolve<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Yoshi"</span><span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninjaImmediatePromise<span style="color: #2aa198;">)</span>;

ninjaImmediatePromise.then<span style="color: #2aa198;">(</span>ninja =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"ninjaImmediatepromise resolve handled with "</span> + ninja<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"At code end-----------&gt;"</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">//////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;   //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">At code start---------&gt;                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninjaDelayedPromise executor                     //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Promise { &lt;pending&gt; }                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninjaImmediatepromise executor                   //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Promise { 'Yoshi' }                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">At code end-----------&gt;                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninjaImmediatepromise resolve handled with Yoshi //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Resolving ninjaDelayedPromise                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninjaDelayedPromise resolve handled with Hattori //</span>
<span style="color: #93a1a1;">//////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>我们首先建立了ninjaDelayedPromise,这个ctor里面使用了setTimeout来在500毫秒
以后对我们的代码进行resolve."然后马上返回"
</li>
<li>注意,setTimer这种操作都是马上返回,放弃对cpu的控制的,然后在系统级别注册一个
中断,在500毫秒以后,中断会发送给浏览器,浏览器会把这个中断放入event queue,然
后最终终究会被执行
</li>
<li>当ninjaDelayedPromise被创建的时候,它是不知道自己的value的,所以这个时候,我们
打印出来就发现value为{ &lt;pending&gt; }
</li>
<li>然后我们来调用then函数,then函数里面也会注册"成功后"的callback,要注意,这个callback
无论如何都不会马上运行的,这是js engine的设计决定的,任何then函数都会在当前event
loop之后再运行
<pre class="example">
Promises are designed to deal with asynchronous actions, so the
JavaScript engine always resorts to asynchronous handling, to
make the promise behavior predictable.The engine does this by executing
the then callbacks after all the code in the current steop of
event loop is executed.
</pre>
</li>
<li>后面我们又创建了一个ninjaImmediatepromise, 这次我们的resolve是马上执行了,
所以我们的promise是立马有值的,也打印出来了.但是这并不能保证我们的then函数
马上实现, 它还是等到后面才实现,只不过比ninjaDelayedPromise的then函数早一点
罢了
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-3" class="outline-4">
<h4 id="sec-4-3-3">Rejecting promises</h4>
<div class="outline-text-4" id="text-4-3-3">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-4" class="outline-4">
<h4 id="sec-4-3-4">Creating our firs real-world promise</h4>
<div class="outline-text-4" id="text-4-3-4">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-5" class="outline-4">
<h4 id="sec-4-3-5">Chaining promises</h4>
<div class="outline-text-4" id="text-4-3-5">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-6" class="outline-4">
<h4 id="sec-4-3-6">Waiting for a number of promises</h4>
<div class="outline-text-4" id="text-4-3-6">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Combining generators and promises</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
