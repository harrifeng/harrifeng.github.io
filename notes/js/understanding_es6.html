<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>understanding_es6</title>
<!-- 2017-05-02 Tue 10:45 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">understanding_es6</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 1. Block Bindings</a>
<ul>
<li><a href="#sec-1-1">var Declarations and Hoisting</a></li>
<li><a href="#sec-1-2">Block-Level Declarations</a>
<ul>
<li><a href="#sec-1-2-1">let Declarations</a></li>
<li><a href="#sec-1-2-2">No Redeclaration</a></li>
<li><a href="#sec-1-2-3">const Declarations</a></li>
<li><a href="#sec-1-2-4">The Temporal Dead Zone</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Block Bindings in Loops</a>
<ul>
<li><a href="#sec-1-3-1">Functions in Loops</a></li>
<li><a href="#sec-1-3-2">const Declarations in Loops</a></li>
</ul>
</li>
<li><a href="#sec-1-4">Global Block Bindings</a></li>
<li><a href="#sec-1-5">Emerging Best Practices for Block Bindings</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 2. Strings and Regular Expressions</a>
<ul>
<li><a href="#sec-2-1">Better Unicode Support</a>
<ul>
<li><a href="#sec-2-1-1">UTF-16 Code Points</a></li>
<li><a href="#sec-2-1-2">The codePointAt() Method</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">Chapter 3. Functions</a>
<ul>
<li><a href="#sec-3-1">Functions with Default Parameter Values</a>
<ul>
<li><a href="#sec-3-1-1">Dimulating Default Paramter Values in ECMAScript5</a></li>
<li><a href="#sec-3-1-2">Default Parameter Values in ECMAScript</a></li>
<li><a href="#sec-3-1-3">How Default Parameter Values Affect the arguments Object</a></li>
<li><a href="#sec-3-1-4">Default Parameter Expressions</a></li>
<li><a href="#sec-3-1-5">Default Parameter TDZ</a></li>
</ul>
</li>
<li><a href="#sec-3-2">Working with Unnamed Parameters</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 1. Block Bindings</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>传统js中的variable 定义方法对于很多来自C-based语言的开发者来说是很tricky的,
因为:
<ul class="org-ul">
<li>在C-based语言中, varaible通常在declaration发生的时候创建
</li>
<li>而在JS里面variable会根据你declare的方式不同,而选择不同的创建时间
</li>
</ul>
</li>
<li>ES6为了修正原来的问题(主要是var引起的),引入了一些新的best practice
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">var Declarations and Hoisting</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>var定义变量的方式,会被看成是"永远定义在function(如果不在function那就是global
scope)最开始的地方", 而不管你的var是写在什么地方的.
</li>
<li>这种处理方式其实是js的一个feature,叫做hoisting.虽然这个feature迷惑了好多人,
下面就是一个例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">getValue</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">condition</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>condition<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">value</span> = <span style="color: #2aa198;">"blue"</span>;

        <span style="color: #859900; font-weight: bold;">return</span> value;
    <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">value exists here with a value of undefined</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">null</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">value exists here with a value of undefined</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>如果你对js不熟悉,你可能认为value会只在if成功的情况下创建,其实不然,无论怎样
的情况,value都会被创建,只不过在其他的case里面,value没有被赋过值罢了.js引擎
其实是把代码改写成如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">getValue</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">condition</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">value</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>condition<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        value = <span style="color: #2aa198;">"blue"</span>;
        <span style="color: #859900; font-weight: bold;">return</span> value;
    <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">null</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这种看起来像bug,其实是feature的问题,其实会诱导非常多的bug,因为大部分人还是C-based
语言转过来的.所以ES6决定引入一个block-level的变量定义方法
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Block-Level Declarations</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>block scope也叫作lexical scope,也就是和其他c-based的语言里面的scope是一个意
思了,换言之就是在下面两个地方都能创建一个scope:
<ul class="org-ul">
<li>在function内部
</li>
<li>在一个`{}`内部
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">let Declarations</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>block-level版本的var就是let,let的scope就是当前的block
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">getValue</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">condition</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>condition<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">value</span> = <span style="color: #2aa198;">"blue"</span>;
        <span style="color: #859900; font-weight: bold;">return</span> value;
    <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">value doesn't exist here</span>

        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">null</span>;
    <span style="color: #b58900;">}</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">value doesn't exist here</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">No Redeclaration</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>如果一个identifer已经被定义在一个scope里面,那么再在同一个scope里面使用let
来声明同一个identifer,那么就会抛出错误
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">count</span> = 30;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">throws an error</span>
<span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">count</span> = 40;
</pre>
</div>
</li>
<li>因为let不能redefine一个identifier,所以会抛出错误, let在containing scope里
面创建一个相同的identifier是可以的,这也是我们所理解的c-based的scope的概念
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">count</span> = 30;

<span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>condition<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">doesn't throw an error</span>
    <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">count</span> = 40;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">const Declarations</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>const也是从其他语言借鉴来,const必须在声明的时候初始化
<div class="org-src-container">

<pre class="src src-js"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">valid constant</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">maxItems</span> = 30;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">syntax error: missing initialization</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">name</span>;
</pre>
</div>
</li>
<li>const和let一样是block-level declaration,也就是说一个constant一旦离开它的scope
那么不能accessible
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>condition<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">maxItems</span> = 5;
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">more code</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">maxItems isn't accessible here</span>
</pre>
</div>
</li>
<li>const最重要的特性,当然是不能重复赋值
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">maxItems</span> = 5;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">throws an error</span>
maxItems = 6;
</pre>
</div>
</li>
<li>上面的const的特点应该是可以预料的,但是和其他语言不一样的地方就是:
<pre class="example">
        如果const hold是一个object,那么const是可以改变的!
</pre>
</li>
<li>原因是因为const'阻止'的并不是其内部value的改变,而是'阻止'的binding的改变,
比如
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">person</span> = <span style="color: #2aa198;">{</span>
    name: <span style="color: #2aa198;">"Nicholas"</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">works</span>
person.name = <span style="color: #2aa198;">"Greg"</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">throws an error</span>
person = <span style="color: #2aa198;">{</span>
    name: <span style="color: #2aa198;">"Greg"</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">The Temporal Dead Zone</h4>
<div class="outline-text-4" id="text-1-2-4">
<ul class="org-ul">
<li>原来使用var创建一个变量的时候,如果我们遇到了一个变量,我们不能确定它是不是
可能"在后面的代码中声明",所以,我们倾向于相信这个变量只是undefined
<div class="org-src-container">

<pre class="src src-js">console.log<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">typeof</span> value<span style="color: #2aa198;">)</span>;      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined</span>
</pre>
</div>
</li>
<li>我们创建了const和let,其行为必须和var有所区别,所以在新的const或者let声明的
代码,如果你使用这两个方法声明的话,在声明之前使用这些变量会抛出错误!!
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>condition<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">typeof</span> value<span style="color: #b58900;">)</span>;  <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">throw an error</span>
    <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">value</span> = <span style="color: #2aa198;">"blue"</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>所以这就出现了悖论:
<ul class="org-ul">
<li>你完全不去声明这个变量,反而可以使用(只不过值是undefined)
</li>
<li>你声明了,如果是使用了let或者const,那么在声明之前使用却会抛出错误!
</li>
</ul>
</li>
<li>一定是哪里动了手脚!对,所谓的手脚就是js的engine会把所有let和const所声明的变
量放到TDZ(temporal dead zone),如果你在声明前使用这个zone里面的变量,错误反
而会更大
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Block Bindings in Loops</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>之前var作为loop的内部变量的时候,会在loop之后还能访问,这显然不是普通程序开发
者需要的
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">i</span> = 0; i &lt; 10; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    process<span style="color: #b58900;">(</span>items<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">i is still accessible here</span>
console.log<span style="color: #2aa198;">(</span>i<span style="color: #2aa198;">)</span>;                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10</span>
</pre>
</div>
</li>
<li>而let就完美解决了这个问题
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">i</span> = 0; i &lt; 10; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    process<span style="color: #b58900;">(</span>items<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">i is not accessible here - thros an error</span>
console.log<span style="color: #2aa198;">(</span>i<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Functions in Loops</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>var的特性,让在loop里面创建function的行为非常的诡异,因为loop里面的variable
在外面还能访问,比如下面的代码,你肯定期望它能返回0到5,但是结果却是出乎意料,
返回了五个5
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">funcs</span> = <span style="color: #2aa198;">[]</span>;

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">i</span> = 0; i &lt; 5; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    funcs.push<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        console.log<span style="color: #6c71c4;">(</span>i<span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

funcs.forEach<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">func</span>, <span style="color: #268bd2;">index</span>, <span style="color: #268bd2;">array</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    func<span style="color: #268bd2;">()</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>问题出现的原因,在于我们var声明了i以后,这个i在整个程序的生命期里面都存在,在
后面forEach调用func()的时候,i总是会以5来替代我们想要的值
</li>
<li>聪明的你肯定想到了,使用let就可以将代码变成我们想要的样子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">funcs</span> = <span style="color: #2aa198;">[]</span>;

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">i</span> = 0; i &lt; 5; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    funcs.push<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        console.log<span style="color: #6c71c4;">(</span>i<span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

funcs.forEach<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">func</span>, <span style="color: #268bd2;">index</span>, <span style="color: #268bd2;">array</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    func<span style="color: #268bd2;">()</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>但是,需要注意的是,这种let的用法和上面的non-hoisting功能的let竟然不是一回事
<pre class="example">
It's important to understand that the behavior of let declaration
in loos is a specially defined behavior in the specification and is
not necessarily related to the non-hoisting characteristics of let.
In fat, early imlementations of let did not exhibit this behavior,
because it was added later in the process.
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">const Declarations in Loops</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>ES6没有明确的禁止const在loop里面应用,但是由于两种loop的特点,导致const的应
用有所不同:
<ul class="org-ul">
<li>在常规for loop里面,const是不能使用的,因为下一次的循环会尝试更改已经创建
的变量的值
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">funcst</span> = <span style="color: #2aa198;">[]</span>;
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">throws an error after on iteration</span>
<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">i</span> = 0; i &lt; 10; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>而对for-in loop,因为每次创建新的对象,所以这种情况反而可以使用const
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">funcs</span> = <span style="color: #2aa198;">[]</span>,
    object = <span style="color: #2aa198;">{</span>
        a: <span style="color: #268bd2; font-weight: bold;">true</span>,
        b: <span style="color: #268bd2; font-weight: bold;">true</span>,
        c: <span style="color: #268bd2; font-weight: bold;">true</span>
    <span style="color: #2aa198;">}</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">doesn't cause an error</span>
<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">key</span> <span style="color: #859900; font-weight: bold;">in</span> object<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    funcs.push<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        console.log<span style="color: #6c71c4;">(</span>key<span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

funcs.forEach<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">func</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    func<span style="color: #268bd2;">()</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Global Block Bindings</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>传统的var如果在global scope使用的话,会创建全局变量(global variable),而同时
全局变量还是global object(在浏览器里面就是window)的property
</li>
<li>全局变量的坏处,是可能会在任意一个scope里面不经意的更改它,从而影响到其他使用
这个全局变量的代码
</li>
<li>使用let在global scope的话,也是会创建全局变量,但是这个全局变量只是变量而已,
其不再会再给global object增加一个property
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">RegExp</span> = <span style="color: #2aa198;">"Hello!"</span>;
console.log<span style="color: #2aa198;">(</span>RegExp<span style="color: #2aa198;">)</span>;            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"Hello!"</span>
console.log<span style="color: #2aa198;">(</span>window.RegExp === RegExp<span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ncz</span> = <span style="color: #2aa198;">"Hi!"</span>;
console.log<span style="color: #2aa198;">(</span>ncz<span style="color: #2aa198;">)</span>;               <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"Hi!"</span>
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"ncz"</span> <span style="color: #859900; font-weight: bold;">in</span> window<span style="color: #2aa198;">)</span>;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Emerging Best Practices for Block Bindings</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>在ES6开发的时候,多数人都相信,以后ES6开展以后,绝大多数的情况下,需要使用let,
而在需要modification protection的变量上面使用const.
</li>
<li>但实际的情况是,大多数的开发者在转向ES6之后,默认使用const,只有在这个值确实可
能会改变的情况下,才会使用let
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 2. Strings and Regular Expressions</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>stirng是绝大多数编程语言的必备,而正则表达式则给了字符串开发以巨大的威力
</li>
</ul>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Better Unicode Support</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>在ES6之前,js的string都是由16bit的char组成的,使用16bit的char也是为数不多的从
java继承来的实现方法
</li>
<li>在ES6之前,所有的字符串肯定是16bit的,不存在某个字符串超过16bit的情况,这也就
是说,它实现了一个不完全的Unicode实现(Unicode要求最多有32bit长度的字符串)
</li>
</ul>
</div>
<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">UTF-16 Code Points</h4>
<div class="outline-text-4" id="text-2-1-1">
<ul class="org-ul">
<li>ES5的时候,我们还是使用16-bit code unit, 这种情况下如果出现了unicode大于16
bit的一些字符串,会遇到一些特殊的问题
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">text</span> = <span style="color: #2aa198;">"&#134071;"</span>;

console.log<span style="color: #2aa198;">(</span>text.length<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">/^.$/</span>.test<span style="color: #b58900;">(</span>text<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>text.charCodeAt<span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>text.charCodeAt<span style="color: #b58900;">(</span>1<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;


<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">55362                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">57271                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2">The codePointAt() Method</h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>ES6使用了UTF-16的支持,也就是说有时候会用两个16bit的空间来存储一个char
</li>
<li>老的charAt等接口自然是不能动的(es5的时候,超过16bit的会返回乱码),但可以引入
新的接口,es6就引入了codePointAt()
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">text</span> = <span style="color: #2aa198;">"&#134071;a"</span>;

console.log<span style="color: #2aa198;">(</span>text.charCodeAt<span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>text.charCodeAt<span style="color: #b58900;">(</span>1<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>text.charCodeAt<span style="color: #b58900;">(</span>2<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;


console.log<span style="color: #2aa198;">(</span>text.codePointAt<span style="color: #b58900;">(</span>0<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>text.codePointAt<span style="color: #b58900;">(</span>1<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>text.codePointAt<span style="color: #b58900;">(</span>2<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">55362                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">57271                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">97                                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">134071                                         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">57271                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">97                                             //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>我们可以看到,只要不涉及non-BMP(Basic Multilingual Plane) characters,那么charCodeAt
和codePointAt的结果是一样的,涉及了以后,codePointAt就能返回真的Unicode值了
</li>
<li>TODO
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 3. Functions</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>在ES6之前,js的function没有改动太多,而js原来的function设计并不好,会导致很多的
bug, es6在函数方面引入了非常大的改动,让js的function使用起来更不容易写错
</li>
</ul>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Functions with Default Parameter Values</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>js里面的function的一个特点就是调用的时候,你可以传入任意多的paramter,即便和
定义的时候的数目(类型就更不用说了,动态语言没类型检查)完全不同
</li>
</ul>
</div>
<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">Dimulating Default Paramter Values in ECMAScript5</h4>
<div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li>es5的时候,default paramter的使用方法如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">makeRequest</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">url</span>, <span style="color: #268bd2;">timeout</span>, <span style="color: #268bd2;">callback</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    timeout = timeout || 2000;
    callback = callback || <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{}</span>;

    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">the rest of the function</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>timeout和callback的optional来自于OR operator(||),但是OR operator并不是万能
的,因为有时候我们可能会传入参数0, 但是0也会被认为是false,所以timeout为0会
被认为timeout为2000
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2">Default Parameter Values in ECMAScript</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li>ES6像其他语言一样,提供了default parameter特性,从根本上解决了这个问题
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">makeRequest</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">url</span>, <span style="color: #268bd2;">timeout</span> = 2000, <span style="color: #268bd2;">callback</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">//</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>和其他语言不太一样的是,js允许default paramter不是最后一个,比如下面的例子,
我们的的default paramter timeout不是最后一个
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">makeRequest</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">url</span>, <span style="color: #268bd2;">timeout</span> = 2000, <span style="color: #268bd2;">callback</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">//</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>还要注意的是,undefined会被认为是没有设置这个值,如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">uses default timeout</span>
makeRequest<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"/foo"</span>, <span style="color: #268bd2; font-weight: bold;">undefined</span>, <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">body</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    doSomething<span style="color: #268bd2;">(</span>body<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>而null则被认为是一个合理的值
<div class="org-src-container">

<pre class="src src-js"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">doesn't use default timeout</span>
makeRequest<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"/foo"</span>, <span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">body</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    doSomething<span style="color: #268bd2;">(</span>body<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3">How Default Parameter Values Affect the arguments Object</h4>
<div class="outline-text-4" id="text-3-1-3">
<ul class="org-ul">
<li>在ECMAScript5的non-strict mode, arguments会严格的反应paramter的改动,比如下
面的例子中first, second都被赋予了新值,依然可以返回true
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">mixArgs</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">first</span>, <span style="color: #268bd2;">second</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>first === <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;
    console.log<span style="color: #b58900;">(</span>second === <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>1<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;

    first = <span style="color: #2aa198;">"c"</span>;
    second = <span style="color: #2aa198;">"d"</span>;
    console.log<span style="color: #b58900;">(</span>first === <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;
    console.log<span style="color: #b58900;">(</span>second === <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>1<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

mixArgs<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"a"</span>, <span style="color: #2aa198;">"b"</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>而strict mode下面,则不会去跟踪parameter的改动
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">mixArgs</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">first</span>, <span style="color: #268bd2;">second</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #2aa198;">"use strict"</span>;

    console.log<span style="color: #b58900;">(</span>first === <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;
    console.log<span style="color: #b58900;">(</span>second === <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>1<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;

    first = <span style="color: #2aa198;">"c"</span>;
    second = <span style="color: #2aa198;">"d"</span>;
    console.log<span style="color: #b58900;">(</span>first === <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;
    console.log<span style="color: #b58900;">(</span>second === <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>1<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

mixArgs<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"a"</span>, <span style="color: #2aa198;">"b"</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>在es6里面,行为和es5的一致,只不过arguments放弃了对named paramter的跟踪,所以
arguments的数目会减少
<div class="org-src-container">

<pre class="src src-js"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">not in strict mode</span>
<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">mixArgs</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">first</span>, <span style="color: #268bd2;">second</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">arguments</span>.length<span style="color: #b58900;">)</span>;
    console.log<span style="color: #b58900;">(</span>first === <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;
    console.log<span style="color: #b58900;">(</span>second === <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>1<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;

    first = <span style="color: #2aa198;">"c"</span>;
    second = <span style="color: #2aa198;">"d"</span>;
    console.log<span style="color: #b58900;">(</span>first === <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;
    console.log<span style="color: #b58900;">(</span>second === <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>1<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

mixArgs<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"a"</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-4" class="outline-4">
<h4 id="sec-3-1-4">Default Parameter Expressions</h4>
<div class="outline-text-4" id="text-3-1-4">
<ul class="org-ul">
<li>default parameter的参数不限于形式,可以是primitive value,当然也可以是object
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">getValue</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> 5;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">add</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">first</span>, <span style="color: #268bd2;">second</span> = <span style="color: #268bd2;">getValue</span><span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> first + second;
<span style="color: #2aa198;">}</span>

console.log<span style="color: #2aa198;">(</span>add<span style="color: #b58900;">(</span>1, 1<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2</span>
console.log<span style="color: #2aa198;">(</span>add<span style="color: #b58900;">(</span>1<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">6</span>
</pre>
</div>
</li>
<li>注意的是如果写成了second=getValue,那么
<pre class="example">
        你给second传入的是一个ref,而不是一个function
</pre>
</li>
<li>你甚至可以利用前面已经生产的参数
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">getValue</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">value</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> value + 5;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">add</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">first</span>, <span style="color: #268bd2;">second</span> = <span style="color: #268bd2;">getValue</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">first</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> first + second;
<span style="color: #2aa198;">}</span>

console.log<span style="color: #2aa198;">(</span>add<span style="color: #b58900;">(</span>1, 1<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2</span>
console.log<span style="color: #2aa198;">(</span>add<span style="color: #b58900;">(</span>1<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">7</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-5" class="outline-4">
<h4 id="sec-3-1-5">Default Parameter TDZ</h4>
<div class="outline-text-4" id="text-3-1-5">
<ul class="org-ul">
<li>我们可以认为function的paramter也是存在于一个自己的scope里面的,在函数声明的
时候,我们也把参数都放入了它们自己的TDZ,被调用的时候,就是给这些参数赋值!
</li>
<li>这也是为什么后面的参赛可以利用前面已经声明的参赛.而前面的参数不能利用后面的参数
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Working with Unnamed Parameters</h3>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
