<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>reactjs_up</title>
<!-- 2017-05-02 Tue 10:46 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">reactjs_up</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chaper 1. Hello World</a>
<ul>
<li><a href="#sec-1-1">Setup</a></li>
<li><a href="#sec-1-2">Hello React World</a></li>
<li><a href="#sec-1-3">What Just Happened?</a></li>
<li><a href="#sec-1-4">React.DOM.*</a></li>
<li><a href="#sec-1-5">Special DOM Attributes</a></li>
<li><a href="#sec-1-6">React DevTools Browser Extension</a></li>
<li><a href="#sec-1-7">Next: Custom Components</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 2. The Lif of a Component</a>
<ul>
<li><a href="#sec-2-1">Bare Minimum</a></li>
<li><a href="#sec-2-2">Properties</a></li>
<li><a href="#sec-2-3">propTypes</a>
<ul>
<li><a href="#sec-2-3-1">Default Property Values</a></li>
</ul>
</li>
<li><a href="#sec-2-4">State</a></li>
<li><a href="#sec-2-5">A Stateful Textarea Component</a></li>
<li><a href="#sec-2-6">A Note on DOM Events</a>
<ul>
<li><a href="#sec-2-6-1">Event Handling in the Olden Days</a></li>
<li><a href="#sec-2-6-2">Event Handling in React</a></li>
</ul>
</li>
<li><a href="#sec-2-7">Props Versus State</a></li>
<li><a href="#sec-2-8">Props in Initial State: An Anti-Pattern</a></li>
<li><a href="#sec-2-9">Accessing the Component from the Outside</a></li>
<li><a href="#sec-2-10">Changing Properties Mid-Flight</a></li>
<li><a href="#sec-2-11">Lifecycle Methods</a></li>
<li><a href="#sec-2-12">Lifecycle Example: Log It All</a></li>
<li><a href="#sec-2-13">Lifecycle Example: Use a Mixin</a></li>
<li><a href="#sec-2-14">Lifecycle Example: Using a Child Component</a></li>
<li><a href="#sec-2-15">Performance Win: Prevent Component Updates</a></li>
<li><a href="#sec-2-16">PureRenderMixin</a></li>
</ul>
</li>
<li><a href="#sec-3">Chapter 3. Excel: A Fancy Table Component</a>
<ul>
<li><a href="#sec-3-1">Data First</a></li>
<li><a href="#sec-3-2">Debugging the Console Warning</a></li>
<li><a href="#sec-3-3">Sorting</a></li>
<li><a href="#sec-3-4">Sorting UI Cues</a></li>
<li><a href="#sec-3-5">Editing Data</a>
<ul>
<li><a href="#sec-3-5-1">Editable Cell</a></li>
<li><a href="#sec-3-5-2">Input Field Cell</a></li>
<li><a href="#sec-3-5-3">Saving</a></li>
<li><a href="#sec-3-5-4">Conclusion and Virtual DOM diffs</a></li>
</ul>
</li>
<li><a href="#sec-3-6">Search</a>
<ul>
<li><a href="#sec-3-6-1">State and UI</a></li>
<li><a href="#sec-3-6-2">Filtering Content</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">Chapter 4. JSX</a>
<ul>
<li><a href="#sec-4-1">Hello JSX</a></li>
<li><a href="#sec-4-2">Transpiling JSX</a>
<ul>
<li><a href="#sec-4-2-1">Babel</a></li>
<li><a href="#sec-4-2-2">Client Side</a></li>
</ul>
</li>
<li><a href="#sec-4-3">Javascript in JSX</a></li>
<li><a href="#sec-4-4">Whitespce in JSX</a></li>
<li><a href="#sec-4-5">Comments in JSX</a></li>
<li><a href="#sec-4-6">HTML Entities</a>
<ul>
<li><a href="#sec-4-6-1">Anti-XSS</a></li>
</ul>
</li>
<li><a href="#sec-4-7">Spread Attributes</a>
<ul>
<li><a href="#sec-4-7-1">Parent-to-child Spread Attributes</a></li>
</ul>
</li>
<li><a href="#sec-4-8">Returning Multiple Nodes in JSX</a></li>
<li><a href="#sec-4-9">JSX Versus HTML Differences</a>
<ul>
<li><a href="#sec-4-9-1">No class, What for?</a></li>
<li><a href="#sec-4-9-2">Style Is an Object</a></li>
<li><a href="#sec-4-9-3">Closing Tags</a></li>
<li><a href="#sec-4-9-4">camelCase Attributes</a></li>
</ul>
</li>
<li><a href="#sec-4-10">JSX and Forms</a>
<ul>
<li><a href="#sec-4-10-1">onChange Handler</a></li>
<li><a href="#sec-4-10-2">value Versus defaultValue</a></li>
<li><a href="#sec-4-10-3">&lt;textarea&gt; Value</a></li>
<li><a href="#sec-4-10-4">&lt;select&gt; Value</a></li>
<li><a href="#sec-4-10-5">Excel Component in JSX</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">Chapter 5. Setting Up for App Development</a>
<ul>
<li><a href="#sec-5-1">Boilerplate App</a>
<ul>
<li><a href="#sec-5-1-1">Files and Folders</a></li>
<li><a href="#sec-5-1-2">index.html</a></li>
<li><a href="#sec-5-1-3">CSS</a></li>
<li><a href="#sec-5-1-4">Javascript</a></li>
<li><a href="#sec-5-1-5">Javascript: Modernized</a></li>
</ul>
</li>
<li><a href="#sec-5-2">Install Prerequisites</a>
<ul>
<li><a href="#sec-5-2-1">Node.js</a></li>
<li><a href="#sec-5-2-2">Browersify</a></li>
<li><a href="#sec-5-2-3">Babel</a></li>
<li><a href="#sec-5-2-4">React, etc.</a></li>
</ul>
</li>
<li><a href="#sec-5-3">Let's Build</a></li>
<li><a href="#sec-5-4">Deployment</a></li>
</ul>
</li>
<li><a href="#sec-6">Chapter 6. Building an App</a>
<ul>
<li><a href="#sec-6-1">Whinepad v.0.0.1</a></li>
<li><a href="#sec-6-2">The Components</a>
<ul>
<li><a href="#sec-6-2-1">Setup</a></li>
<li><a href="#sec-6-2-2">Discover</a></li>
<li><a href="#sec-6-2-3">Button Component</a></li>
<li><a href="#sec-6-2-4">Forms</a></li>
<li><a href="#sec-6-2-5">&lt;Suggest&gt;</a></li>
<li><a href="#sec-6-2-6">&lt;Rating&gt; Component</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7">Chapter 7. Lint, Flow, Test, Repeat</a>
<ul>
<li><a href="#sec-7-1">package.json</a>
<ul>
<li><a href="#sec-7-1-1">Configure Babel</a></li>
<li><a href="#sec-7-1-2">scripts</a></li>
</ul>
</li>
<li><a href="#sec-7-2">ESLint</a>
<ul>
<li><a href="#sec-7-2-1">Setup</a></li>
</ul>
</li>
<li><a href="#sec-7-3">Flow</a>
<ul>
<li><a href="#sec-7-3-1">Setup</a></li>
<li><a href="#sec-7-3-2">Running</a></li>
<li><a href="#sec-7-3-3">Signing Up for Typechecking</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-8">Chapter 8. Flux</a>
<ul>
<li><a href="#sec-8-1">The Big Idea</a></li>
<li><a href="#sec-8-2">Another Look at Whinepad</a></li>
<li><a href="#sec-8-3">The Store</a>
<ul>
<li><a href="#sec-8-3-1">Store Events</a></li>
<li><a href="#sec-8-3-2">Using the Store in &lt;Whinepad&gt;</a></li>
<li><a href="#sec-8-3-3">Using the Store in &lt;Excel&gt;</a></li>
<li><a href="#sec-8-3-4">Using the Store in &lt;Form&gt;</a></li>
</ul>
</li>
<li><a href="#sec-8-4">Actions</a>
<ul>
<li><a href="#sec-8-4-1">CRUD Actions</a></li>
<li><a href="#sec-8-4-2">Searching and Sorting</a></li>
<li><a href="#sec-8-4-3">Using the Actions in &lt;Whinepad&gt;</a></li>
</ul>
</li>
<li><a href="#sec-8-5">Flux Recap</a></li>
<li><a href="#sec-8-6">Immutable</a>
<ul>
<li><a href="#sec-8-6-1">Immutable Store Data</a></li>
<li><a href="#sec-8-6-2">Immutable Data Manipulation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chaper 1. Hello World</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Setup</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>react当然是可以使用npm来安装,或者是使用cdn的版本,这里我们使用的是把源代码下
载下来,因为本身react的代码量并不大,注意我们本书使用的是0.14.7版本(可以去
github下载历史版本).
</li>
<li>将下载下来的zip文件打包后,放入到我们project的react目录,我们会使用react目录
下面的build目录
<div class="org-src-container">

<pre class="src src-sh">$ tree react/build/
react/build/
|-- react-dom-server.js
|-- react-dom-server.min.js
|-- react-dom.js
|-- react-dom.min.js
|-- react-with-addons.js
|-- react-with-addons.min.js
|-- react.js
<span style="color: #6c71c4; font-weight: bold;">`-- react.min.js</span>

<span style="color: #6c71c4; font-weight: bold;">0 directories, 8 files</span>
</pre>
</div>
</li>
<li>值得注意的是react只不过是一个js,它并没有明确要求你一定要在哪个目录
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Hello React World</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>先看我们的第一个例子01_01_hello.html
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">html</span>&gt;
    &lt;<span style="color: #268bd2;">head</span>&gt;
        &lt;<span style="color: #268bd2;">title</span>&gt;<span style="font-weight: bold;"> Hello React</span>&lt;/<span style="color: #268bd2;">title</span>&gt;
        &lt;<span style="color: #268bd2;">meta</span> <span style="color: #268bd2;">charset</span>=<span style="color: #2aa198;">"utf-8"</span>&gt;
    &lt;/<span style="color: #268bd2;">head</span>&gt;
    &lt;<span style="color: #268bd2;">body</span>&gt;
        &lt;<span style="color: #268bd2;">div</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"app"</span>&gt;
            <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">my app renders here </span><span style="color: #93a1a1;">--&gt;</span>
        &lt;/<span style="color: #268bd2;">div</span>&gt;
        &lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">src</span>=<span style="color: #2aa198;">"react/build/react.js"</span>&gt;&lt;/<span style="color: #268bd2;">script</span>&gt;
        &lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">src</span>=<span style="color: #2aa198;">"react/build/react-dom.js"</span>&gt;&lt;/<span style="color: #268bd2;">script</span>&gt;
        &lt;<span style="color: #268bd2;">script</span>&gt;
         // my app's code
        &lt;/<span style="color: #268bd2;">script</span>&gt;
    &lt;/<span style="color: #268bd2;">body</span>&gt;
&lt;/<span style="color: #268bd2;">html</span>&gt;
</pre>
</div>
</li>
<li>这个例子只有两点需要注意:
<ol class="org-ol">
<li>你使用了&lt;script&gt;调用了两个js文件react.js和react-dom.js
</li>
<li>设置了一个id为"app"的div,以后应用会加载到这个位置
</li>
</ol>
</li>
<li>我们使用下面的代码替代`//my app's code`来看看最终的结果
<div class="org-src-container">

<pre class="src src-js">ReactDOM.render<span style="color: #2aa198;">(</span>
    React.DOM.h1<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">"Hello World!"</span><span style="color: #b58900;">)</span>,
    document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">"app"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>最终的结果就是大家会看到一个"Hello World"打印在页面上(在id为app的div里面),
从这个例子也可以看出'id为app的div'就是一个place holder
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">What Just Happened?</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>第一个例子如下几个地方与众不同:
<ul class="org-ul">
<li>我们使用了React object(好像只是通过script src调用),其method并不多
</li>
<li>我们使用了ReactDOM object,其method也不多,最著名的就是render(),原来这些
method都是在React object里面的,但是从0.14版本开始分开.因为render不仅仅是
DOM可以做,其他的Android, iOS也是可以做的
</li>
<li>我们遇到了component的概念,UI其实就是把不同的component结合起来.以后复杂的
项目中,你会创建自己的component.但是在这个例子里面,我们使用的是react为我们
封装好的component. React.DOM.h1():顾名思义,就是封装&lt;h1&gt;的一个component
</li>
<li>最后,你看到了document.getElementByIa("app")这段熟悉的代码,你其实是通过这
段代码,告诉react你的应用应该加载到哪里.
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">React.DOM.*</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>react其实为我们"封装了"所有的html element,把他们都放到了React.DOM.*里面,我们
可以使用ES6的最新feature来查看一个object所有的key
<div class="org-src-container">

<pre class="src src-js">&gt; <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">React</span> = require<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'react'</span><span style="color: #2aa198;">)</span>;
<span style="color: #268bd2; font-weight: bold;">undefined</span>
&gt; Object.keys<span style="color: #2aa198;">(</span>React.DOM<span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">[</span> <span style="color: #2aa198;">'a'</span>,
  <span style="color: #2aa198;">'abbr'</span>,
  <span style="color: #2aa198;">'address'</span>,
  <span style="color: #2aa198;">'area'</span>,
  <span style="color: #2aa198;">'article'</span>,
  <span style="color: #2aa198;">'aside'</span>,
  <span style="color: #2aa198;">'audio'</span>,
  <span style="color: #2aa198;">'b'</span>,
  <span style="color: #2aa198;">'form'</span>,
  <span style="color: #2aa198;">'h1'</span>,
  <span style="color: #2aa198;">'h2'</span>,
  <span style="color: #2aa198;">'h3'</span>,
  <span style="color: #2aa198;">'h4'</span>,
  <span style="color: #2aa198;">'h5'</span>,
  <span style="color: #2aa198;">'h6'</span>,
 <span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
<li>好了,我们回到我们的代码,我们的代码里面是如下这么一句
<div class="org-src-container">

<pre class="src src-js">React.DOM.h1<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">"Hello World!"</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>这一句如果在node repl里面看的话,其实就是生成一个object,这个object有一些key
<div class="org-src-container">

<pre class="src src-js">&gt; React.DOM.h1<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">'Hello World!'</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span> <span style="color: #2aa198;">'$$typeof'</span>: Symbol<span style="color: #b58900;">(</span>react.element<span style="color: #b58900;">)</span>,
  type: <span style="color: #2aa198;">'h1'</span>,
  key: <span style="color: #268bd2; font-weight: bold;">null</span>,
  ref: <span style="color: #268bd2; font-weight: bold;">null</span>,
  props: <span style="color: #b58900;">{</span> children: <span style="color: #2aa198;">'Hello World!'</span> <span style="color: #b58900;">}</span>,
  _owner: <span style="color: #268bd2; font-weight: bold;">null</span>,
  _store: <span style="color: #b58900;">{}</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>第一个参数null是说你希望自己的DOM有什么attribute(注意在这里因为不是真实的DOM,
所以设置是是props: virtual DOM里面的attribute的别称),我们可以自己设置一个
props如下
<div class="org-src-container">

<pre class="src src-js">&gt; React.DOM.h1<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>id: <span style="color: #2aa198;">"my-heading"</span><span style="color: #b58900;">}</span>, <span style="color: #2aa198;">'Hello World!'</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span> <span style="color: #2aa198;">'$$typeof'</span>: Symbol<span style="color: #b58900;">(</span>react.element<span style="color: #b58900;">)</span>,
  type: <span style="color: #2aa198;">'h1'</span>,
  key: <span style="color: #268bd2; font-weight: bold;">null</span>,
  ref: <span style="color: #268bd2; font-weight: bold;">null</span>,
  props: <span style="color: #b58900;">{</span> id: <span style="color: #2aa198;">'my-heading'</span>, children: <span style="color: #2aa198;">'Hello World!'</span> <span style="color: #b58900;">}</span>,
  _owner: <span style="color: #268bd2; font-weight: bold;">null</span>,
  _store: <span style="color: #b58900;">{}</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们把这句设置到代码里面以后,会得到如下的html结果
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">h1</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"my-heading"</span> <span style="color: #268bd2;">data-reactid</span>=<span style="color: #2aa198;">".0"</span>&gt;<span style="font-weight: bold;">Hello World!</span>&lt;/<span style="color: #268bd2;">h1</span>&gt;
</pre>
</div>
</li>
<li>render()的第二个参数是一个child componnet,最简单的情况就是一个text child,但
其实也是可以有object作为其child的
<div class="org-src-container">

<pre class="src src-js">&gt; React.DOM.h1<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>id: <span style="color: #2aa198;">"my-heading"</span><span style="color: #b58900;">}</span>, React.DOM.span<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">"Hello"</span><span style="color: #b58900;">)</span>, <span style="color: #2aa198;">" World!"</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span> <span style="color: #2aa198;">'$$typeof'</span>: Symbol<span style="color: #b58900;">(</span>react.element<span style="color: #b58900;">)</span>,
  type: <span style="color: #2aa198;">'h1'</span>,
  key: <span style="color: #268bd2; font-weight: bold;">null</span>,
  ref: <span style="color: #268bd2; font-weight: bold;">null</span>,
  props: <span style="color: #b58900;">{</span> id: <span style="color: #2aa198;">'my-heading'</span>, children: <span style="color: #268bd2;">[</span> <span style="color: #6c71c4;">[</span>Object<span style="color: #6c71c4;">]</span>, <span style="color: #2aa198;">' World!'</span> <span style="color: #268bd2;">]</span> <span style="color: #b58900;">}</span>,
  _owner: <span style="color: #268bd2; font-weight: bold;">null</span>,
  _store: <span style="color: #b58900;">{}</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>一个更加复杂的例子如下
<div class="org-src-container">

<pre class="src src-js">React.DOM.h1<span style="color: #2aa198;">(</span>
    <span style="color: #b58900;">{</span>id: <span style="color: #2aa198;">"my-heading"</span><span style="color: #b58900;">}</span>,
    React.DOM.span<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>,
                  React.DOM.em<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">"Hell"</span><span style="color: #268bd2;">)</span>,
                  <span style="color: #2aa198;">"o"</span><span style="color: #b58900;">)</span>,
    <span style="color: #2aa198;">" world!"</span>
<span style="color: #2aa198;">)</span>,
</pre>
</div>
</li>
<li>其得到的html文件如下
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">div</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"app"</span>&gt;
  &lt;<span style="color: #268bd2;">h1</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"my-heading"</span> <span style="color: #268bd2;">data-reactid</span>=<span style="color: #2aa198;">".0"</span>&gt;
    &lt;<span style="color: #268bd2;">span</span> <span style="color: #268bd2;">data-reactid</span>=<span style="color: #2aa198;">".0.0"</span>&gt;
      &lt;<span style="color: #268bd2;">em</span> <span style="color: #268bd2;">data-reactid</span>=<span style="color: #2aa198;">".0.0.0"</span>&gt;<span style="font-style: italic;">Hell</span>&lt;/<span style="color: #268bd2;">em</span>&gt;
      &lt;<span style="color: #268bd2;">span</span> <span style="color: #268bd2;">data-reactid</span>=<span style="color: #2aa198;">".0.0.1"</span>&gt;o&lt;/<span style="color: #268bd2;">span</span>&gt;
    &lt;/<span style="color: #268bd2;">span</span>&gt;
    &lt;<span style="color: #268bd2;">span</span> <span style="color: #268bd2;">data-reactid</span>=<span style="color: #2aa198;">".0.1"</span>&gt; world!
    &lt;/<span style="color: #268bd2;">span</span>&gt;
  &lt;/<span style="color: #268bd2;">h1</span>&gt;
&lt;/<span style="color: #268bd2;">div</span>&gt;
</pre>
</div>
</li>
<li>当然了,我们代码如果这样嵌套下去肯定是非常难看的,react为此为我们专门设计了jsx
格式,使用jsx是话,上面的代码就可以轻松的转换为如下非常易读的代码.(虽然易读,
但是不利于我们掌握原理, 再理解原理之后,再使用这种语法)
<div class="org-src-container">

<pre class="src src-jsx">ReactDOM.render(
    &lt;h1 id="my-heading"&gt;
    &lt;span&gt;&lt;em&gt;Hell&lt;/em&gt;o&lt;/span&gt; world!
    &lt;/h1&gt;,
    document.getElementById("app")
);
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Special DOM Attributes</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>我们上面的代码,使用{attrName: value}作为render的第一个参数,从而设置DOM的attribute
这里就存在一个问题:我们在使用js代码来设置html,而html里面有几个attribute在js
里面是关键字!所以我们要为这几个attribute设置别名:
<ul class="org-ul">
<li>class ==&gt; className
</li>
<li>for ==&gt; htmlFor
</li>
</ul>
</li>
<li>所以我们的代码应该是这样的
<div class="org-src-container">

<pre class="src src-js">React.DOM.h1<span style="color: #2aa198;">(</span>
    <span style="color: #b58900;">{</span>
        className: <span style="color: #2aa198;">"pretty"</span>,
        htmlFor: <span style="color: #2aa198;">"me"</span>,
    <span style="color: #b58900;">}</span>,
    <span style="color: #2aa198;">"Hello World!"</span>
<span style="color: #2aa198;">)</span>;


<span style="color: #93a1a1;">//////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">NOT work version         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">React.DOM.h1(            //</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">{                    //</span>
<span style="color: #93a1a1;">//         </span><span style="color: #93a1a1;">class: "pretty", //</span>
<span style="color: #93a1a1;">//         </span><span style="color: #93a1a1;">for: "me",       //</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">},                   //</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"Hello World!"       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">);                       //</span>
<span style="color: #93a1a1;">//////////////////////////////</span>
</pre>
</div>
</li>
<li>style倒不是js的关键字,但是我们也不能使用style:'xxx'的设置方法,因为这样会引
入cross-site scripting(XSS)攻击.react给出的解决方案是使用js object来设置,需
要注意的是,我们这里使用的是fontFamily(js用法),而不是font-family(css用法)
<div class="org-src-container">

<pre class="src src-js">React.DOM.h1<span style="color: #2aa198;">(</span>
    <span style="color: #b58900;">{</span>
        style: <span style="color: #268bd2;">{</span>
            background: <span style="color: #2aa198;">"black"</span>,
            color: <span style="color: #2aa198;">"white"</span>,
            fontFamily: <span style="color: #2aa198;">"Verdana"</span>,
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>,
    <span style="color: #2aa198;">"Hello World!"</span>
<span style="color: #2aa198;">)</span>;


<span style="color: #93a1a1;">////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">// CounterExample                                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">React.DOM.h1(                                                          //</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">{                                                                  //</span>
<span style="color: #93a1a1;">//         </span><span style="color: #93a1a1;">style: "background:black; color: white; font-family: Verdana", //</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">},                                                                 //</span>
<span style="color: #93a1a1;">//     </span><span style="color: #93a1a1;">"Hello World!"                                                     //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">);                                                                     //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">React DevTools Browser Extension</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>为chrome和firefox准备的react调试工具
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">Next: Custom Components</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>总结一下本章内容:
<ul class="org-ul">
<li>使用&lt;script&gt;来安装reactjs
</li>
<li>使用render函数来把component放到你想要的位置:ReactDOM.render(reactWhat, domWhere)
</li>
<li>reactWhat部分可以使用内置的常规DOM element: React.DOM.div(attributes, childrdn)
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 2. The Lif of a Component</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>上一章学习了ready-made DOM component,这一章学习自己创造的component
</li>
</ul>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Bare Minimum</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>创建一个新componet的API如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">MyComponent</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">spec */</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>其中的spec是一个JS object, 这个object必须内部含有一个叫做render()的函数,
大概的一个例子如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Component</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> React.DOM.span<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">"I'm so custom"</span><span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>大家也看到了,这个叫做render()的函数还必须返回一个React component(内置的),这
个看起来就有点java里面的interface的感觉了:所有的自定义component必须继承一个
interface,这个interface里面就一个函数render,其返回值是内置component
</li>
<li>自定义的component使用稍有不同,其不能只用内置的那种newClass的风格,而是使用React
createElement
<div class="org-src-container">

<pre class="src src-js">ReactDOM.render<span style="color: #2aa198;">(</span>
    React.createElement<span style="color: #b58900;">(</span>Component<span style="color: #b58900;">)</span>,
    document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">"app"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>值得注意的是createElement其实是创建React Object的唯一方式, React.DOM.xx其实
只不过是一种wraper,所以内置的component也可以使用如下的代码来创建.
<div class="org-src-container">

<pre class="src src-js">ReactDOM.render<span style="color: #2aa198;">(</span>
    React.createElement<span style="color: #b58900;">(</span><span style="color: #2aa198;">"span"</span>, <span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">"Hello"</span><span style="color: #b58900;">)</span>,
    document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">"app"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>我们可以看到不同:createElement接受的不再是一个js function,而是几个string作
为参数
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Properties</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>你的component可以从parent那里获得一些配置,获得的渠道就是this.props. 因为this.prop
可以在调用createElement的时候指定,也就是说可以在使用的时候"注入":
<ul class="org-ul">
<li>创建的方法
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Component</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(){</span>
        <span style="color: #859900; font-weight: bold;">return</span> React.DOM.span<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">"My name is "</span> + <span style="color: #268bd2; font-weight: bold;">this</span>.props.name<span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>'注入'的方法
<div class="org-src-container">

<pre class="src src-js">ReactDOM.render<span style="color: #2aa198;">(</span>
    React.createElement<span style="color: #b58900;">(</span>Component, <span style="color: #268bd2;">{</span>
        name: <span style="color: #2aa198;">"Bob"</span>,
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>,
    document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">"app"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</li>
<li>我们要把this.props看成是一个read-only的,在parent和child之间传递configuration
的变量.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">propTypes</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>我们前面已经做了两个铺垫:
<ul class="org-ul">
<li>自己定义的component object 必须有render函数,但是可以有其他的函数或者变量
</li>
<li>render函数里面可以使用this.props.xxx来获得parent给予的配置, 其实这个
props.xxx里面的xxx就是component object的变量
</li>
</ul>
</li>
<li>好了,我们的render的时候,使用了this.props.name是不是看起来有点突兀:万一parent
没有设置name,或者出现typo写成了nama怎么办?这个时候,页面上会出现如下text
<pre class="example">
My name is undefined
</pre>
</li>
<li>所以,除了render这个必须有的函数以外,如果我们render一定要用到某些configuration,
我们怎样才能提醒parent,让它记得总要设置这个configuration
</li>
<li>react给出的解决方案是设置'自定component'的proTypes variable,如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Component</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    propTypes: <span style="color: #268bd2;">{</span>
        name: React.PropTypes.string.isRequired,
    <span style="color: #268bd2;">}</span>,
    <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(){</span>
        <span style="color: #859900; font-weight: bold;">return</span> React.DOM.sapn<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">"My name is "</span> + <span style="color: #268bd2; font-weight: bold;">this</span>.props.name<span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>propType是为了更好的使用体验,所以它是optional的.其更好的体验体现在如下两个
方面:
<ul class="org-ul">
<li>在propType里面写出render到底需要哪些变量,这样,就不需要每次都去render()里
面查找到底要哪些properties
</li>
<li>react还可以对你"明确"表示需要的property value进行validation,比如我们render
里面的要求name,但是你并没有在createElement的时候,没有设置相应的property,
那么就会在chrome里面的console里面进行warning:
<ol class="org-ol">
<li>如果你没设置
<div class="org-src-container">

<pre class="src src-js">react.js:19368 Warning: Failed propType: Required prop <span style="color: #2aa198;">`name`</span>
was not specified <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #2aa198;">`Constructor`</span>.
</pre>
</div>
</li>
<li>如果你设置了name=123,integer而不是string
<div class="org-src-container">

<pre class="src src-js">react.js:19368 Warning: Failed propType: Invalid prop <span style="color: #2aa198;">`name`</span> of
type <span style="color: #2aa198;">`number`</span> supplied to <span style="color: #2aa198;">`Constructor`</span>, expected <span style="color: #2aa198;">`string`</span>.
</pre>
</div>
</li>
</ol>
</li>
</ul>
</li>
<li>propTypes是optional的,所以并不一定每一个property都需要设置.best practice就
是
<pre class="example">
       为重要的property设置propTypes,或者某个property有问题,在debug 的时候,
       为这个property设置propTypes
</pre>
</li>
<li>常见的propType类型有如下
<div class="org-src-container">

<pre class="src src-js">&gt; Object.keys<span style="color: #2aa198;">(</span>React.PropTypes<span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">[</span> <span style="color: #2aa198;">'array'</span>,
  <span style="color: #2aa198;">'bool'</span>,
  <span style="color: #2aa198;">'func'</span>,
  <span style="color: #2aa198;">'number'</span>,
  <span style="color: #2aa198;">'object'</span>,
  <span style="color: #2aa198;">'string'</span>,
  <span style="color: #2aa198;">'symbol'</span>,
  <span style="color: #2aa198;">'any'</span>,
  <span style="color: #2aa198;">'arrayOf'</span>,
  <span style="color: #2aa198;">'element'</span>,
  <span style="color: #2aa198;">'instanceOf'</span>,
  <span style="color: #2aa198;">'node'</span>,
  <span style="color: #2aa198;">'objectOf'</span>,
  <span style="color: #2aa198;">'oneOf'</span>,
  <span style="color: #2aa198;">'oneOfType'</span>,
  <span style="color: #2aa198;">'shape'</span> <span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Default Property Values</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>propType不是强制的,所以为了不让你的代码出现undefined,一个可行的办法是在你
的render里面设置如下的代码来保证,如果property没有设置的情况下怎么办
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">text</span> = <span style="color: #2aa198;">'text'</span> <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #268bd2; font-weight: bold;">this</span>.props ? <span style="color: #268bd2; font-weight: bold;">this</span>.props.text : <span style="color: #2aa198;">''</span>;
</pre>
</div>
</li>
<li>为了不写这种比较丑陋的逻辑代码,我们可以设置一个getDefaultProps()
函数来设置那些default value
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Component</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    propTypes: <span style="color: #268bd2;">{</span>
        firstName: React.PropTypes.string.isRequired,
        middleName: React.PropTypes.string,
        familyName: React.PropTypes.string.isRequired,
        address: React.PropTypes.string,
    <span style="color: #268bd2;">}</span>,

    <span style="color: #268bd2;">getDefaultProps</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">{</span>
            middleName: <span style="color: #2aa198;">''</span>,
            address: <span style="color: #2aa198;">'n/a'</span>,
        <span style="color: #6c71c4;">}</span>;
    <span style="color: #268bd2;">}</span>,
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">State</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>此前我们的例子大部分都是static的(比如props就是read-only的),换句话说就是
stateless的,其实对于React来说,其最强的特性,就是对待那些变动的,也就是stateful
的情况.
</li>
<li>React定义的state,其实就是你的Component的data,一旦你的data有变动,react会自动
的"找到"这些变动,并帮助你进行更新.所以你只需要关注如何更新data就可以了.
</li>
<li>在render函数里面,我们是通过this.props来获得props的,我们同样可以通过this.state
来获得state,但是需要注意的是,我们不要去"更改"this.state(这是React引擎做的事
情),我们要通过this.state的公开的API,也就是this.steState()来更新我的state
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">A Stateful Textarea Component</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>我们来看一个例子,我们创建一个新的component,这里面的textarea的char的数字是动
态更新的,我们希望能够动态的现实这个数字
</li>
<li>我们最外层的函数还是差不多的:把一个custom的Component(现在名字变了,叫做
TextAreaCounter)显示到id为app的dev上面去
<div class="org-src-container">

<pre class="src src-js">ReactDOM.render<span style="color: #2aa198;">(</span>
    React.createElement<span style="color: #b58900;">(</span>TextAreaCounter,<span style="color: #268bd2;">{</span>
        text: <span style="color: #2aa198;">"Bob"</span>,
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>,
    document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">"app"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>下面我们来实现我们新的component,为了便于理解,我们首先实现一个stateless的版
本:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">TextAreaCounter</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    propTypes: <span style="color: #268bd2;">{</span>
        text: React.PropTypes.string,
    <span style="color: #268bd2;">}</span>,

    <span style="color: #268bd2;">getDefaultProps</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">{</span>
            text: <span style="color: #2aa198;">''</span>,
        <span style="color: #6c71c4;">}</span>;
    <span style="color: #268bd2;">}</span>,

    <span style="color: #268bd2;">render</span>:<span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> React.DOM.div<span style="color: #6c71c4;">(</span>
            <span style="color: #268bd2; font-weight: bold;">null</span>,
            React.DOM.textarea<span style="color: #859900;">(</span><span style="color: #b58900;">{</span>
                defaultValue: <span style="color: #268bd2; font-weight: bold;">this</span>.props.text,
            <span style="color: #b58900;">}</span><span style="color: #859900;">)</span>,
            React.DOM.h3<span style="color: #859900;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #268bd2; font-weight: bold;">this</span>.props.text.length<span style="color: #859900;">)</span>
        <span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>下一步,我们要把这个stateless的变成stateful的版本.其核心思想是
<pre class="example">
让component维护一个data(state),并且使用这个data来render一个
"最开始的版本",每当data(state)改变的时候,React"自动"调用render
来更新UI
</pre>
</li>
<li>总的结果,就是使用state来替代props,分了几个步骤:
<ul class="org-ul">
<li>首先创建initial state: state就是data,而我们这个component只有一个data,那就
是text. 我们可以通过this.state.text来访问这个text.而下面的代码是我们通过
拷贝props.text来初始化自己
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">getInitialState</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">{</span>
        text: <span style="color: #268bd2; font-weight: bold;">this</span>.props.text,
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
<li>然后,当state变化的时候,我们需要触发一个function来进行更新,我们这里设置了
一个event listener,过一会我们会把它注册好.注意!我们要使用setState来进行
注册(里面的object会替代已有object),不要试图自己去动this.state!!
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">_textChange</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">ev</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #b58900;">(</span><span style="color: #268bd2;">{</span>
        text: ev.target.value,
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
<li>最后一步就是更新render(),让它使用this.state(而不再是this.props)来展示到最
终的页面上. 同时设置event listener
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> React.DOM.div<span style="color: #b58900;">(</span>
        <span style="color: #268bd2; font-weight: bold;">null</span>,
        React.DOM.textarea<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">{</span>
            value: <span style="color: #268bd2; font-weight: bold;">this</span>.state.text,
            onChange: <span style="color: #268bd2; font-weight: bold;">this</span>._textChange,
        <span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span>,
        React.DOM.h3<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #268bd2; font-weight: bold;">this</span>.state.text.length<span style="color: #268bd2;">)</span>
    <span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">A Note on DOM Events</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>我们的event listener起作用的代码如下,这是react优化过的使用方法,作为对比,我
们看看原来是如何工作的
<div class="org-src-container">

<pre class="src src-js">onChange: <span style="color: #268bd2; font-weight: bold;">this</span>._textChange
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-2-6-1" class="outline-4">
<h4 id="sec-2-6-1">Event Handling in the Olden Days</h4>
<div class="outline-text-4" id="text-2-6-1">
<ul class="org-ul">
<li>传统的DOM世界里面,设置event handler的设置如下
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">div</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"parent"</span>&gt;
    &lt;<span style="color: #268bd2;">button</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"ok"</span>&gt;OK&lt;/<span style="color: #268bd2;">button</span>&gt;
    &lt;<span style="color: #268bd2;">button</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"cancel"</span>&gt;Cancel&lt;/<span style="color: #268bd2;">button</span>&gt;
&lt;/<span style="color: #268bd2;">div</span>&gt;

&lt;<span style="color: #268bd2;">script</span>&gt;
 document.getElementById('parent').addEventListener('click', function(event) {
     var button = event.target;
     switch (button.id) {
         case 'ok':
             console.log('OK!');
             break;
         case 'cancel':
             console.log('Cancel');
             break;
         default:
             new Error('Unexpected button ID');

     };

 });
&lt;/<span style="color: #268bd2;">script</span>&gt;
</pre>
</div>
</li>
<li>但是老的设置有很多的缺点:
<ul class="org-ul">
<li>listener和UI之间距离太远
</li>
<li>使用switch,会有太多多余代码
</li>
<li>浏览器的兼容性会让代码比这个要多的多
</li>
</ul>
</li>
<li>原来处理浏览器兼容性的问题,通常会加入一个event library.但是我们的React提供
了自己非常好的event处理系统,就不需要加入其它什么library啦
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6-2" class="outline-4">
<h4 id="sec-2-6-2">Event Handling in React</h4>
<div class="outline-text-4" id="text-2-6-2">
<ul class="org-ul">
<li>React使用了synthetic events系统来统一处理event,等于消除了所有浏览器之间的
不兼容.换句话说,你永远可以assume event.target是存在的,可用的.
</li>
<li>这也意味着"取消"event的函数也是所有浏览器都支持的
</li>
<li>react的结构还会让UI和event listener设置在一起
</li>
<li>react的event handler的命名有些讲究,要使用驼峰命名法比如我们前面的handler就
取名叫做_textChange
</li>
<li>还有一件事情值得说,传统的DOM里面的onChange event是等你输入完,然后离开这个
输入区域以后,才开始运行handler的.这其实不是人们expected的behavior,但是react
的onChange是真的在输入的同时就触发handler
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Props Versus State</h3>
<div class="outline-text-3" id="text-2-7">
<ul class="org-ul">
<li>到现在为止,你知道了,你可以通过read this.props和this.state来获取你想要的显示
内容,并把他们放到render()函数体里面去.现在我们就来比较一下两者的不同:
<ul class="org-ul">
<li>props是让outside world(component的用户)来configure我们的component是一种
ctor一般的存在
</li>
<li>state则是内部的data,类似于OO编程里面的private data
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">Props in Initial State: An Anti-Pattern</h3>
<div class="outline-text-3" id="text-2-8">
<ul class="org-ul">
<li>我们前面的例子中取名取的不太好,把props直接取名叫做text:这不符合用户的预期,
因为用户其实是想把parent设置给component的默认值给state,所以我们来重命名一下
就解决问题
<div class="org-src-container">

<pre class="src src-js">propTypes: <span style="color: #2aa198;">{</span>
    defaultValue: React.PropTypes.string
<span style="color: #2aa198;">}</span>,

<span style="color: #268bd2;">getInitialState</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">{</span>
        text: <span style="color: #268bd2; font-weight: bold;">this</span>.props.defaultValue,
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">Accessing the Component from the Outside</h3>
<div class="outline-text-3" id="text-2-9">
<ul class="org-ul">
<li>react设计的初衷是要和所有已经存在的js代码和睦相处,在这种要求下面,我们必须能
够使用外部的代码来调用react
</li>
<li>最常见的和外界交流的办法,就是生成react的ref,然后让外部代码调用这个ref
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">myTextAreaCounter</span> = ReactDOM.render<span style="color: #2aa198;">(</span>
    React.createElement<span style="color: #b58900;">(</span>TextAreaCounter,<span style="color: #268bd2;">{</span>
        defaultValue: <span style="color: #2aa198;">"Bob"</span>,
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>,
    document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">"app"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>在render()函数中可以使用this访问的部分,就可以使用myTextAreaCounter来访问了:
<ul class="org-ul">
<li>比如可以改动state(注意,此种做法并不推荐,我们更希望react去查询而不是更改核
心state)
<div class="org-src-container">

<pre class="src src-js">myTextAreaCounter.setState<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>text: <span style="color: #2aa198;">"Hello outside world!"</span><span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>比如可以获得react活动的parent DOM node
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">reactAppNode</span> = ReactDOM.findDOMNode<span style="color: #2aa198;">(</span>myTextAreaCounter<span style="color: #2aa198;">)</span>;
reactAppNode.parentNode === document.getElementById<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'app'</span><span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
</pre>
</div>
</li>
<li>获取properties和state:
<div class="org-src-container">

<pre class="src src-js">myTextAreaCounter.props;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Object { defualtValue: "Bob" }</span>
myTextAreaCounter.state;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Object { text: "Hello outside world!" }</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">Changing Properties Mid-Flight</h3>
<div class="outline-text-3" id="text-2-10">
<ul class="org-ul">
<li>前面在讲props和state的区别的时候,我们说了,props更多的是一种"外部"给我们的
configuration,而state则是private data
</li>
<li>private data就该不被外部动,所以我们前面说使用如下方法在外部更改private data
的方法是不好的,会引发潜在bug的
<div class="org-src-container">

<pre class="src src-js">myTextAreaCounter.setState<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>text: <span style="color: #2aa198;">"Hello outside world!"</span><span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>所以,使用props来实现"外部"的configuration需求,是正当的.也是唯一的手段,但是
看看我们的代码,在render函数里面是没有涉及到Properties的,全部都是state
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> React.DOM.div<span style="color: #b58900;">(</span>
        <span style="color: #268bd2; font-weight: bold;">null</span>,
        React.DOM.textarea<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">{</span>
            value: <span style="color: #268bd2; font-weight: bold;">this</span>.state.text,
            onChange: <span style="color: #268bd2; font-weight: bold;">this</span>._textChange,
        <span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span>,
        React.DOM.h3<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #268bd2; font-weight: bold;">this</span>.state.text.length<span style="color: #268bd2;">)</span>
    <span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>存在如此的render(),我们就算是像如下一样更改props,在UI上也是不会有结果的
<div class="org-src-container">

<pre class="src src-js">myTextAreaCounter = ReactDOM.render<span style="color: #2aa198;">(</span>
    React.createElement<span style="color: #b58900;">(</span>
        TextAreaCounter,
        <span style="color: #268bd2;">{</span> defaultValue: <span style="color: #2aa198;">"Hello"</span>, <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">previously known as "Bob"</span>
        <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>,
    document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">"app"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>注意!!我们不能像传统的oo语言一样理解这里的代码,虽然我们使用了ReactDOM.render
重新创建了一次myTextAreaCounter,但是这并不是两个ref(传统oo语言这就意味着是
两个reference了,而且前一个被遮盖了),因为都是和id为app的div相关联,我们这里其
实两次都是对同一个组件进行的设置,react会自动寻找两次的diff进行升级.
</li>
<li>我们可以发现this.props改动了,但是UI却没有
<div class="org-src-container">

<pre class="src src-js">myTextAreaCounter.props;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Object { defaultValue="Hello" }</span>
</pre>
</div>
</li>
<li>react当然知道这种情况,为了能够"让外部的props注入同时改动state",你必须设置如
下的函数
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">componentWillReceiveProps</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">newProps</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #b58900;">(</span><span style="color: #268bd2;">{</span>
        text: newProps.defaultValue,
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-11" class="outline-3">
<h3 id="sec-2-11">Lifecycle Methods</h3>
<div class="outline-text-3" id="text-2-11">
<ul class="org-ul">
<li>前面的componentWillReceiveProps其实就是react提供的一种叫做lifecycle的函数:
你可以使用lifecycle函数来监听'你的component的改动'
</li>
<li>其他的lifecycle函数还有:
<ul class="org-ul">
<li>componentWillUpdte(): 每当你的render()被调用(通常有两种情况,state改动或者
props改动)'之前'的时候会执行,类似rails里面的before filter函数
</li>
<li>componentDidUpdate(): render()被调用之后, DOM被调用之前!类似rails里面的
after filter函数
</li>
<li>componentWillMount(): node被加入到DOM之前
</li>
<li>componentDidMount(): node被加入到DOM之后
</li>
<li>componentWillUnmount(): component被"移除"DOM之前
</li>
<li>shouldCompnentUpdate(newProps, newState):在componentWillUpdate()调用之前
你可以主动调用shouldCompnentUpdate(newProps, newState), 通过比较newProps和
this.prop, 比较newState和this.state,如果发现没有改变,可以直接返回false,阻
止这次update
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-12" class="outline-3">
<h3 id="sec-2-12">Lifecycle Example: Log It All</h3>
<div class="outline-text-3" id="text-2-12">
<ul class="org-ul">
<li>为了查看什么时候lifecycle函数会起作用,我们在component里面调用每个lifecycle
函数,并且每个函数里面都打上log,如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">TextAreaCounter</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>

    <span style="color: #268bd2;">_log</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">methodName</span>, <span style="color: #268bd2;">args</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
        console.log<span style="color: #6c71c4;">(</span>methodName, args<span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>,
    <span style="color: #268bd2;">componentWillUpdate</span>:  <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>._log<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">'componentWillUpdate'</span>,  <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #6c71c4;">)</span>;<span style="color: #268bd2;">}</span>,
    <span style="color: #268bd2;">componentDidUpdate</span>:   <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>._log<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">'componentDidUpdate'</span>,   <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #6c71c4;">)</span>;<span style="color: #268bd2;">}</span>,
    <span style="color: #268bd2;">componentWillMount</span>:   <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>._log<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">'componentWillMount'</span>,   <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #6c71c4;">)</span>;<span style="color: #268bd2;">}</span>,
    <span style="color: #268bd2;">componentDidMount</span>:    <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>._log<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">'componentDidMount'</span>,    <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #6c71c4;">)</span>;<span style="color: #268bd2;">}</span>,
    <span style="color: #268bd2;">componentWillUnmount</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>._log<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">'componentWillUnmount'</span>, <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #6c71c4;">)</span>;<span style="color: #268bd2;">}</span>,
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>好了,写入代码,刷新页面,我们会发现如下两个函数首先被调用了
<pre class="example">
componentWillMount
componentDidMount
</pre>
</li>
<li>而这两个以componentDidMount更为重要,因为在它内部,可以通过如下语句获得fresh
new的新创建DOM
<div class="org-src-container">

<pre class="src src-js">ReactDOM.findDOMNode<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">this</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>我们在textarea里面type一个s,这个时候被触发的是下面两个函数
<pre class="example">
componentWillUpdate
componentDidUpdate
</pre>
</li>
<li>先被调用的是componentWillUpdate,它有两个参数nextProps, nextState.比如nextProps
就是prop的future expected value.你可以看看这个是不是你想要的.然后决定是不是
进行一些操作
</li>
<li>更加有趣的是componentDidUpdate,这个相当于是一个"事后诸葛":比如我们要限制用
户输入的字符串的长度.我们在_textChange()里面当然可以设置,但是这个设置却不是
"完全保险"的,因为我们前面讲过,outside world获得了react object的ref以后,可以
使用componentDidUpdate,这里等于是每次"升级之后"检查"本次升级"是否是合格的,
不合格的话,我们可以退回(所以参数是oldValue)
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">componentDidUpdate</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">oldProps</span>, <span style="color: #268bd2;">oldState</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.state.text.length &gt; 3<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #268bd2; font-weight: bold;">this</span>.replaceState<span style="color: #268bd2;">(</span>oldState<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
<li>这里使用的是replaceState,我们可以把它想象成是http中的PUT(也就是所有属性都替
换),而原来的setState是http中的Patch(只更新需要的)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-13" class="outline-3">
<h3 id="sec-2-13">Lifecycle Example: Use a Mixin</h3>
<div class="outline-text-3" id="text-2-13">
<ul class="org-ul">
<li>mixin这个概念在ruby里面也有,就是一系列的method和properties都设置在一个mixin
里面,然后你一旦引入这个mixin就等于引入了所有的函数和属性.所以我们这里先设计
一个mixin
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">logMixin</span> = <span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">_log</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">methodName</span>, <span style="color: #268bd2;">args</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.name + <span style="color: #2aa198;">'::'</span> + methodName, args<span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>,
  <span style="color: #268bd2;">componentWillUpdate</span>:  <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>._log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">'componentWillUpdate'</span>,  <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">)</span>;<span style="color: #b58900;">}</span>,
  <span style="color: #268bd2;">componentDidUpdate</span>:   <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>._log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">'componentDidUpdate'</span>,   <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">)</span>;<span style="color: #b58900;">}</span>,
  <span style="color: #268bd2;">componentWillMount</span>:   <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>._log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">'componentWillMount'</span>,   <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">)</span>;<span style="color: #b58900;">}</span>,
  <span style="color: #268bd2;">componentDidMount</span>:    <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>._log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">'componentDidMount'</span>,    <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">)</span>;<span style="color: #b58900;">}</span>,
  <span style="color: #268bd2;">componentWillUnmount</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>._log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">'componentWillUnmount'</span>, <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">)</span>;<span style="color: #b58900;">}</span>,
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>当然了mixin在非react领域里面想使用,那就是放到一个for循环里面,把属性函数都加入到某个
object里面. react领域里面专门为mixin设计了一个快捷方法mixins,使用方法如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">MyComponent</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    mixins: <span style="color: #268bd2;">[</span>obj1, obj2, obj3<span style="color: #268bd2;">]</span>,
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">....</span>
<span style="color: #b58900;">}</span>;
</pre>
</div>
</li>
<li>我们的使用logMixin的代码如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">TextAreaCounter</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    name: <span style="color: #2aa198;">'TextAreaCounter'</span>,
    mixins: <span style="color: #268bd2;">[</span>logMixin<span style="color: #268bd2;">]</span>,
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-14" class="outline-3">
<h3 id="sec-2-14">Lifecycle Example: Using a Child Component</h3>
<div class="outline-text-3" id="text-2-14">
<ul class="org-ul">
<li>lifecycle里面的componentWillUnmount使用的范围,是当前component的child
component被移除DOM的时候才会被触发的.所以我们要先设计一个child component
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Counter</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    name: <span style="color: #2aa198;">'Counter'</span>,
    mixins: <span style="color: #268bd2;">[</span>logMixin<span style="color: #268bd2;">]</span>,
    propTypes: <span style="color: #268bd2;">{</span>
        count: React.PropTypes.number.isRequired,
    <span style="color: #268bd2;">}</span>,
    <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> React.DOM.span<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #268bd2; font-weight: bold;">this</span>.props.count<span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>这个component没有自己的state,只是负责显示一下当前textarea的字符个数
</li>
<li>我们的render()会去判断当前的字符长度,根据不同的长度来决定是否创建一个child
component来显示个数
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">counter</span> = <span style="color: #268bd2; font-weight: bold;">null</span>;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.state.text.length &gt; 0<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        counter = React.DOM.h3<span style="color: #268bd2;">(</span>
            <span style="color: #268bd2; font-weight: bold;">null</span>,
            React.createElement<span style="color: #6c71c4;">(</span>Counter, <span style="color: #859900;">{</span>
                count: <span style="color: #268bd2; font-weight: bold;">this</span>.state.text.length,
            <span style="color: #859900;">}</span><span style="color: #6c71c4;">)</span>
        <span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">return</span> React.DOM.div<span style="color: #b58900;">(</span>
        <span style="color: #268bd2; font-weight: bold;">null</span>,
        React.DOM.textarea<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">{</span>
            value: <span style="color: #268bd2; font-weight: bold;">this</span>.state.text,
            onChange: <span style="color: #268bd2; font-weight: bold;">this</span>._textChange,
        <span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span>,
        counter
    <span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>当我们的textarea里面的字符串长度变成0的时候,child component就消失了.react
diff以后,发现了某个component会unmount,就会触发这个component的child的函数
componentWillUnMount
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-15" class="outline-3">
<h3 id="sec-2-15">Performance Win: Prevent Component Updates</h3>
<div class="outline-text-3" id="text-2-15">
<ul class="org-ul">
<li>shouldComponentUpdate(nextProps, nextState)这个lifecycle的method是和性能有
关的.它会在componentWillUpdate()之前被invoke,然后给你一个机会让你决定是不是
真的要去调用
</li>
<li>有一类的component再render()里面只使用this.props和this.state,并且不需要额外
的function call.这一类的component叫做pure component.
</li>
<li>对于这类component,我们可以在shouldComponentUpdate里面比较下前后,如果没有什
么改动的话,就直接return false,减少后面调用的消耗(不再需要调用render())
</li>
<li>还有一类component,连props和state都不使用,那么shouldComponentUpdate就直接返
回false
</li>
<li>下面我们来做一个新的实验,首先移除logMixin,只需要去记录component什么时候调用
render
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Counter</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    name: <span style="color: #2aa198;">'Counter'</span>,
    propTypes: <span style="color: #268bd2;">{</span>
        count: React.PropTypes.number.isRequired,
    <span style="color: #268bd2;">}</span>,
    render<span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        console.log<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.name + <span style="color: #2aa198;">'::render()'</span><span style="color: #6c71c4;">)</span>;
        <span style="color: #859900; font-weight: bold;">return</span> React.DOM.span<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #268bd2; font-weight: bold;">this</span>.props.count<span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>TextAreaCounter也是一样的操作
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">TextAreaCouter</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    name: <span style="color: #2aa198;">'TextAreaCounter'</span>,
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">all other methods...</span>

    <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        console.log<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.name + <span style="color: #2aa198;">'::render()'</span><span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>这个时候,我们刷新页面,使用'LOL'来替代'BoB',然后我们会发现log如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">select all, paste the "LOL" string</span>
TextAreaCounter::render<span style="color: #2aa198;">()</span>
Counter::render<span style="color: #2aa198;">()</span>
</pre>
</div>
</li>
<li>也就是说,textarea的render首先被调用(这个是必须的,因为字符串换了么),然后
textarea的render又会在内部调用counter的render,所以会出现连个render都被调用
的情况
</li>
<li>但是静静分析以后发现,对counter的render()调用不是必须的:因为字符串长度没变嘛!
</li>
<li>这种情况下就是使用shouldComponentUpdate的情景啦,为counter设置这个函数,就也
保证parent的props.count不变的情况下,我们不需要更新(通过返回false,避免render()
的调用)
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">shouldComponentUpdate</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">nextProps</span>, <span style="color: #268bd2;">nextState</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> nextProps.count != <span style="color: #268bd2; font-weight: bold;">this</span>.props.count;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>结果就是如我们预期了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">paste the string "LOL"</span>
TextAreaCounter::render<span style="color: #2aa198;">()</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-16" class="outline-3">
<h3 id="sec-2-16">PureRenderMixin</h3>
<div class="outline-text-3" id="text-2-16">
<ul class="org-ul">
<li>上面这种逻辑:
<ul class="org-ul">
<li>某个component只负责展示
</li>
<li>如果这个component其data没有改变的话,那么就不调用render
</li>
</ul>
</li>
<li>这种'对比this.props和nextProps,同时对比this.state和nextState,发现没有改变就
不去更新render,直接在shouldComponentUpdate()里面返回false'的行为非常的常用
所以某些react addon把这个工作总结成了一个mixin叫做PureRenderMinxin,使用方法
如下,注意,这个不是react核心库里面的,需要引用react-with-addons.js
<div class="org-src-container">

<pre class="src src-js">&lt;script src=<span style="color: #2aa198;">"react/build/react-with-addons.js"</span>&gt;&lt;/script&gt;
&lt;script src=<span style="color: #2aa198;">"react/build/react-dom.js"</span>&gt;&lt;/script&gt;
&lt;script&gt;

  <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Counter</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    name: <span style="color: #2aa198;">'Counter'</span>,

    mixins: <span style="color: #268bd2;">[</span>React.addons.PureRenderMixin<span style="color: #268bd2;">]</span>,

    propTypes: <span style="color: #268bd2;">{</span>
      count: React.PropTypes.number.isRequired,
    <span style="color: #268bd2;">}</span>,

    <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
      console.log<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.name + <span style="color: #2aa198;">'::render()'</span><span style="color: #6c71c4;">)</span>;
      <span style="color: #859900; font-weight: bold;">return</span> React.DOM.span<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #268bd2; font-weight: bold;">this</span>.props.count<span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
  <span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 3. Excel: A Fancy Table Component</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>前面我们讲了如何创建自己的react component, 然后把自己的react component和
generic DOM component结合起来.
</li>
<li>然后就是如何设置properties, 如何管理state
</li>
<li>最后还讲了如何避免不必要的更新(调用render)操作
</li>
<li>这一章我们把我们的知识总结起来,创建一个更加有趣的component,一个微软Excel的v0.1
版本
</li>
</ul>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Data First</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>table就是对数据的管理,我们的fancy table就得先包括一个数组的数据(同时还得有
一个数组的header).所以我们就总结了历史最佳畅销书,放到两个数组里面
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">headers</span> = <span style="color: #2aa198;">[</span>
  <span style="color: #2aa198;">"Book"</span>, <span style="color: #2aa198;">"Author"</span>, <span style="color: #2aa198;">"Language"</span>, <span style="color: #2aa198;">"Published"</span>, <span style="color: #2aa198;">"Sales"</span>
<span style="color: #2aa198;">]</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">data</span> = <span style="color: #2aa198;">[</span>
  <span style="color: #b58900;">[</span><span style="color: #2aa198;">"The Lord of the Rings"</span>, <span style="color: #2aa198;">"J. R. R. Tolkien"</span>, <span style="color: #2aa198;">"English"</span>, <span style="color: #2aa198;">"1954-1955"</span>, <span style="color: #2aa198;">"150 million"</span><span style="color: #b58900;">]</span>,
  <span style="color: #b58900;">[</span><span style="color: #2aa198;">"Le Petit Prince (The Little Prince)"</span>, <span style="color: #2aa198;">"Antoine de Saint-Exup&#233;ry"</span>, <span style="color: #2aa198;">"French"</span>, <span style="color: #2aa198;">"1943"</span>, <span style="color: #2aa198;">"140 million"</span><span style="color: #b58900;">]</span>,
  <span style="color: #b58900;">[</span><span style="color: #2aa198;">"Harry Potter and the Philosopher's Stone"</span>, <span style="color: #2aa198;">"J. K. Rowling"</span>, <span style="color: #2aa198;">"English"</span>, <span style="color: #2aa198;">"1997"</span>, <span style="color: #2aa198;">"107 million"</span><span style="color: #b58900;">]</span>,
  <span style="color: #b58900;">[</span><span style="color: #2aa198;">"And Then There Were None"</span>, <span style="color: #2aa198;">"Agatha Christie"</span>, <span style="color: #2aa198;">"English"</span>, <span style="color: #2aa198;">"1939"</span>, <span style="color: #2aa198;">"100 million"</span><span style="color: #b58900;">]</span>,
  <span style="color: #b58900;">[</span><span style="color: #2aa198;">"Dream of the Red Chamber"</span>, <span style="color: #2aa198;">"Cao Xueqin"</span>, <span style="color: #2aa198;">"Chinese"</span>, <span style="color: #2aa198;">"1754-1791"</span>, <span style="color: #2aa198;">"100 million"</span><span style="color: #b58900;">]</span>,
  <span style="color: #b58900;">[</span><span style="color: #2aa198;">"The Hobbit"</span>, <span style="color: #2aa198;">"J. R. R. Tolkien"</span>, <span style="color: #2aa198;">"English"</span>, <span style="color: #2aa198;">"1937"</span>, <span style="color: #2aa198;">"100 million"</span><span style="color: #b58900;">]</span>,
  <span style="color: #b58900;">[</span><span style="color: #2aa198;">"She: A History of Adventure"</span>, <span style="color: #2aa198;">"H. Rider Haggard"</span>, <span style="color: #2aa198;">"English"</span>, <span style="color: #2aa198;">"1887"</span>, <span style="color: #2aa198;">"100 million"</span><span style="color: #b58900;">]</span>,
<span style="color: #2aa198;">]</span>;
</pre>
</div>
</li>
<li>我们先来实现一个只带header的table
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Excel</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">(</span>
            React.DOM.table<span style="color: #859900;">(</span>
                <span style="color: #268bd2; font-weight: bold;">null</span>,
                React.DOM.thead<span style="color: #b58900;">(</span>
                    <span style="color: #268bd2; font-weight: bold;">null</span>,
                    React.DOM.tr<span style="color: #268bd2;">(</span>
                        <span style="color: #268bd2; font-weight: bold;">null</span>,
                        <span style="color: #268bd2; font-weight: bold;">this</span>.props.headers.map<span style="color: #6c71c4;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #859900;">(</span><span style="color: #268bd2;">title</span><span style="color: #859900;">)</span> <span style="color: #859900;">{</span>
                            <span style="color: #859900; font-weight: bold;">return</span> React.DOM.th<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, title<span style="color: #2aa198;">)</span>;
                        <span style="color: #859900;">}</span><span style="color: #6c71c4;">)</span>
                    <span style="color: #268bd2;">)</span>
                <span style="color: #b58900;">)</span>
            <span style="color: #859900;">)</span>
        <span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>这段代码里面有一个map函数,这个函数是ruby里面map的感觉:就是对某个数组进行重
新的"计算"然后返回一个新的数组,我们用ruby来演示一下
<div class="org-src-container">

<pre class="src src-ruby">headers.map <span style="color: #2aa198;">{</span>|title| <span style="color: #b58900;">React</span>.<span style="color: #b58900;">DOM</span>.th<span style="color: #b58900;">(</span>title<span style="color: #b58900;">)</span> <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这种只用javascript的能力来构建UI的方法是react的魅力所在,我们不需要使用erb文
件了.
</li>
<li>这里需要说明一下, react里面允许你把最后一个参数作为数组传递,也可以分别传递
进去,这跟js的arguments有关,并不是要求的那么死. 如下两条完全相同
<div class="org-src-container">

<pre class="src src-js"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">separate arguments</span>
React.DOM.ul<span style="color: #2aa198;">(</span>
    <span style="color: #268bd2; font-weight: bold;">null</span>,
    React.DOM.li<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">'one'</span><span style="color: #b58900;">)</span>,
    React.DOM.li<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">'two'</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">array</span>
React.DOM.ul<span style="color: #2aa198;">(</span>
    <span style="color: #268bd2; font-weight: bold;">null</span>,
    <span style="color: #b58900;">[</span>
        React.DOM.li<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">'one'</span><span style="color: #268bd2;">)</span>,
        React.DOM.li<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>, <span style="color: #2aa198;">'two'</span><span style="color: #268bd2;">)</span>
    <span style="color: #b58900;">]</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>然后我们就可以把这个给展示出来了
<div class="org-src-container">

<pre class="src src-js">ReactDOM.render<span style="color: #2aa198;">(</span>
    React.createElement<span style="color: #b58900;">(</span>Excel, <span style="color: #268bd2;">{</span>
        headers: headers
        initialData: data,
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>,
    document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">"app"</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Debugging the Console Warning</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>上面的展示会在console里面有warning
<pre class="example">
react.js:18788 Warning: Each child in an array or iterator
should have a unique "key" prop. Check the render method of
`Constructor`.
</pre>
</li>
<li>首先看这个warnning的'Check the render method of `Constructor`',这个Constructor
其实是指的我们的Excel,但是由于我们没给它名字,所以react不知道如何给予说明,我
们可以通过增加一个displayName,来让我们的react认识Excel. 注意在JSX里面是不需
要定义displayName的
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Excel</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    displayName: <span style="color: #2aa198;">'Excel'</span>,
    <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span>;
</pre>
</div>
</li>
<li>然后warnning就变成了
<pre class="example">
react.js:18788 Warning: Each child in an array or iterator should
have a unique "key" prop. Check the render method of `Excel`.
</pre>
</li>
<li>然后我们再来看看,这个warning的意思,其实是说,我们在创建一个数组的component,
然后把这个数组都返回给react的ctor,react抱怨说,你给我的这个数组里面的每个
element我都需要track,所以请你给它们没人一个id,所以解决方案就是
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2; font-weight: bold;">this</span>.props.headers.map<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">title</span>, <span style="color: #268bd2;">idx</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> React.DOM.th<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">{</span>key: idx+10<span style="color: #6c71c4;">}</span>, title<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>这个就是react里面的超级map啦,用ruby来对比就是
<div class="org-src-container">

<pre class="src src-ruby">headers = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'one'</span>, <span style="color: #2aa198;">'two'</span>, <span style="color: #2aa198;">'three'</span><span style="color: #2aa198;">]</span>

<span style="color: #657b83; font-weight: bold;">p</span> headers.each_with_index.map<span style="color: #2aa198;">{</span>|header, idx| <span style="color: #b58900;">[</span>header, idx + 10<span style="color: #b58900;">]</span><span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">##################################################</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; #</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">[["one", 10], ["two", 11], ["three", 12]]      #</span>
<span style="color: #93a1a1;">##################################################</span>
</pre>
</div>
</li>
<li>我的warning就没有了,然后table的数组成员都有了id, 这个id只有在数组内部唯一就可以啦
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">tr</span> <span style="color: #268bd2;">data-reactid</span>=<span style="color: #2aa198;">".0.0.0"</span>&gt;
  &lt;<span style="color: #268bd2;">th</span> <span style="color: #268bd2;">data-reactid</span>=<span style="color: #2aa198;">".0.0.0.$10"</span>&gt;Book&lt;/<span style="color: #268bd2;">th</span>&gt;
  &lt;<span style="color: #268bd2;">th</span> <span style="color: #268bd2;">data-reactid</span>=<span style="color: #2aa198;">".0.0.0.$11"</span>&gt;Author&lt;/<span style="color: #268bd2;">th</span>&gt;
  &lt;<span style="color: #268bd2;">th</span> <span style="color: #268bd2;">data-reactid</span>=<span style="color: #2aa198;">".0.0.0.$12"</span>&gt;Language&lt;/<span style="color: #268bd2;">th</span>&gt;
  &lt;<span style="color: #268bd2;">th</span> <span style="color: #268bd2;">data-reactid</span>=<span style="color: #2aa198;">".0.0.0.$13"</span>&gt;Published&lt;/<span style="color: #268bd2;">th</span>&gt;
  &lt;<span style="color: #268bd2;">th</span> <span style="color: #268bd2;">data-reactid</span>=<span style="color: #2aa198;">".0.0.0.$14"</span>&gt;Sales&lt;/<span style="color: #268bd2;">th</span>&gt;
&lt;/<span style="color: #268bd2;">tr</span>&gt;
</pre>
</div>
</li>
<li>下面我们来初始化table的content,和table的title不一样的是,我们的content是可能
变动的.可能变动的部分就不能使用props了,而要使用data:
<ul class="org-ul">
<li>首先我们使用getInitialState来从props初始化data
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">getInitialState</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">{</span> data: <span style="color: #268bd2; font-weight: bold;">this</span>.props.initialData <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
<li>然后在原来的render function里面在thead平行的位置初始化tbody
<div class="org-src-container">

<pre class="src src-js">React.DOM.tbody<span style="color: #2aa198;">(</span>
    <span style="color: #268bd2; font-weight: bold;">null</span>,
    <span style="color: #268bd2; font-weight: bold;">this</span>.state.data.map<span style="color: #b58900;">(</span> <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">row</span>, <span style="color: #268bd2;">idx</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">(</span>
            React.DOM.tr<span style="color: #859900;">(</span><span style="color: #b58900;">{</span>key: idx<span style="color: #b58900;">}</span>,
                         row.map<span style="color: #b58900;">(</span> <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">cell</span>, <span style="color: #268bd2;">idx</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                             <span style="color: #859900; font-weight: bold;">return</span> React.DOM.td<span style="color: #6c71c4;">(</span><span style="color: #859900;">{</span>key: idx<span style="color: #859900;">}</span>, cell<span style="color: #6c71c4;">)</span>;
                         <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
            <span style="color: #859900;">)</span>
        <span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>最后,为了"document"和validate的需要,我们写上propTypes
<div class="org-src-container">

<pre class="src src-js">propTypes: <span style="color: #2aa198;">{</span>
    headers: React.PropTypes.arrayOf<span style="color: #b58900;">(</span>
        React.PropTypes.string
    <span style="color: #b58900;">)</span>,
    initialData: React.PropTypes.arryOf<span style="color: #b58900;">(</span>
        React.PropTypes.arrayOf<span style="color: #268bd2;">(</span>
            React.PropTypes.string
        <span style="color: #268bd2;">)</span>
    <span style="color: #b58900;">)</span>,
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Sorting</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>多少次你在网上看到table的时候,都想把它们按照某列排序,幸运的是,在react里面,
这是非常容易做到的.因为你只需要sort你的data就可以了.然后所有的UI都会随之改
动,因为react发现了data的变化.自动调用render
</li>
<li>我们的把触发的位置设置到thead
<div class="org-src-container">

<pre class="src src-js">React.DOM.table<span style="color: #2aa198;">(</span>
    <span style="color: #268bd2; font-weight: bold;">null</span>,
    React.DOM.thead<span style="color: #b58900;">(</span><span style="color: #268bd2;">{</span>onClick: <span style="color: #268bd2; font-weight: bold;">this</span>._sort<span style="color: #268bd2;">}</span>,
                    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
</pre>
</div>
</li>
<li>我们来实现我们的_sort:
<ul class="org-ul">
<li>首先要知道安装哪一行来排序, 通过event targe来获取其cellIndex
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">column</span> = e.target.cellIndex;
</pre>
</div>
</li>
<li>我们更新的方法,不能是直接sort data,因为我们要使用setState(),所以我们要先
复制一遍state
<div class="org-src-container">

<pre class="src src-js"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">copy the data</span>
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">data</span> = <span style="color: #268bd2; font-weight: bold;">this</span>.state.data.slice<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>下一步是js排序
<div class="org-src-container">

<pre class="src src-js">data.sort<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">a</span>, <span style="color: #268bd2;">b</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> a<span style="color: #268bd2;">[</span>column<span style="color: #268bd2;">]</span> &gt; b<span style="color: #268bd2;">[</span>column<span style="color: #268bd2;">]</span> ? 1 : -1;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>最后就是update啦
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    data: data,
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Sorting UI Cues</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>我们下面来改进下我们的代码:
<ul class="org-ul">
<li>显示出当前是按照哪一行进行的排序, 使用this.state.sortby
</li>
<li>可以按照逆序排序, 使用this.state.descending
</li>
</ul>
</li>
<li>我们的初始化代码更改如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">getInitialState</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">{</span>
        data: <span style="color: #268bd2; font-weight: bold;">this</span>.props.initialData,
        sortby: <span style="color: #268bd2; font-weight: bold;">null</span>,
        descending: <span style="color: #268bd2; font-weight: bold;">false</span>,
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
<li>设置descending 变量来确认是使用当前的column,并且原来没有逆序
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">descending</span> = <span style="color: #268bd2; font-weight: bold;">this</span>.state.sortby === column &amp;&amp; !<span style="color: #268bd2; font-weight: bold;">this</span>.state.descending;
</pre>
</div>
</li>
<li>sort函数要改变了
<div class="org-src-container">

<pre class="src src-js">data.sort<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">a</span>, <span style="color: #268bd2;">b</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> descending
        ? <span style="color: #268bd2;">(</span>a<span style="color: #6c71c4;">[</span>column<span style="color: #6c71c4;">]</span> &lt; b<span style="color: #6c71c4;">[</span>column<span style="color: #6c71c4;">]</span> ? 1 : -1<span style="color: #268bd2;">)</span>
    : <span style="color: #268bd2;">(</span>a<span style="color: #6c71c4;">[</span>column<span style="color: #6c71c4;">]</span> &gt; b<span style="color: #6c71c4;">[</span>column<span style="color: #6c71c4;">]</span> ? 1: -1<span style="color: #268bd2;">)</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>然后我们要在setState的时候,传入这些参数
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    data: data,
    sortby: column,
    descending: descending,
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>我们还要在我们的title里面加上一些提示,是上升还是下降的箭头来表示"排序安装当
前columen, 升还是降"
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2; font-weight: bold;">this</span>.props.headers.map<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">title</span>, <span style="color: #268bd2;">idex</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.state.sortby === idx<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
        title += <span style="color: #268bd2; font-weight: bold;">this</span>.state.descending? <span style="color: #2aa198;">'\u2191'</span> : <span style="color: #2aa198;">'\u2193'</span>
    <span style="color: #268bd2;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> React.DOM.th<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">{</span>key:idex<span style="color: #6c71c4;">}</span>, title<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span>, <span style="color: #268bd2; font-weight: bold;">this</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Editing Data</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>对Excel的下一步改造,就是让我们可以更改cell的content,可以:
<ul class="org-ul">
<li>双击某个cell,然后text就变成input field了
</li>
<li>编辑这个input field
</li>
<li>点击回车,input field就消失了,只剩下更新好的新的text
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1">Editable Cell</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>首先建立一个event handler,来应对double-click:
<ul class="org-ul">
<li>在tbody里面加上这个handler
<div class="org-src-container">

<pre class="src src-js">React.DOM.tbody<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>onDoubleClick: <span style="color: #268bd2; font-weight: bold;">this</span>._showEditor<span style="color: #b58900;">}</span>, ....<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>然后我们来看看_showEditor的实现
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">_showEditor</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">e</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #b58900;">(</span>
        <span style="color: #268bd2;">{</span>edit: <span style="color: #6c71c4;">{</span>
            row: parseInt<span style="color: #859900;">(</span>e.target.dataset.row, 10<span style="color: #859900;">)</span>,
            cell: e.target.cellIndex,
        <span style="color: #6c71c4;">}</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>我们的setState函数这次设置的是this.state的一个property: edit(注意这个不是
特殊property是需要我们自己设置的).
<ul class="org-ul">
<li>这个edit在没有改动的时候,值是null
</li>
<li>这个edit在有改动的时候,会记住被改动的value的row和index,比如你点击了最左
上角,它的值就会是{row: 0, cell: 0}
</li>
<li>获取cell,也就是column的办法是分析e.target中的cellIndex. e.target也就是我
们双击的&lt;td&gt;
</li>
<li>获取row就比较麻烦,因为不是html里面有的值,所以我们要使用data-attribute,注
意:这里的data-attribute也不是什么内置的神器,而是我们在初始化table的时候,
给每个cell都初始化的值
<div class="org-src-container">

<pre class="src src-js">React.DOM.tbody<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>onDoubleClick: <span style="color: #268bd2; font-weight: bold;">this</span>._showEditor<span style="color: #b58900;">}</span>,
                <span style="color: #268bd2; font-weight: bold;">this</span>.state.data.map<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">row</span>, <span style="color: #268bd2;">rowidx</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">(</span>
                        React.DOM.tr<span style="color: #859900;">(</span>
                            <span style="color: #b58900;">{</span>key: rowidx<span style="color: #b58900;">}</span>,
                            row.map<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">cell</span>, <span style="color: #268bd2;">idx</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
                                <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">content</span> = cell;
                                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">TODO turn content into a input if 'idx'</span>
                                <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">and 'rowidx' match the one being edited</span>

                                <span style="color: #859900; font-weight: bold;">return</span> React.DOM.td<span style="color: #6c71c4;">(</span><span style="color: #859900;">{</span>
                                    key: idx,
                                    <span style="color: #2aa198;">'data-row'</span>: rowidx
                                <span style="color: #859900;">}</span>, content<span style="color: #6c71c4;">)</span>;
                            <span style="color: #268bd2;">}</span>, <span style="color: #268bd2; font-weight: bold;">this</span><span style="color: #b58900;">)</span>
                        <span style="color: #859900;">)</span>
                    <span style="color: #6c71c4;">)</span>;
                <span style="color: #268bd2;">}</span>, <span style="color: #268bd2; font-weight: bold;">this</span><span style="color: #b58900;">)</span>
               <span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
</ul>
</li>
<li>edit这个property并不是关键字,是需要我们自己去设置的,在getInitialState里面
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">getInitialState</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">{</span>
        data: <span style="color: #268bd2; font-weight: bold;">this</span>.pros.initialData,
        sortby: <span style="color: #268bd2; font-weight: bold;">null</span>,
        descending: <span style="color: #268bd2; font-weight: bold;">false</span>,
        edit: <span style="color: #268bd2; font-weight: bold;">null</span>,
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-2" class="outline-4">
<h4 id="sec-3-5-2">Input Field Cell</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>前面介绍data-attribute,的时候,我们把cell变成input的设置为TODO,我们这里就来
实现一下:
<ul class="org-ul">
<li>首先获取parent的edit变量
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">edit</span> = <span style="color: #268bd2; font-weight: bold;">this</span>.state.edit;
</pre>
</div>
</li>
<li>check变量edit是否被设置,而且设置的是不是我们当前的cell
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>edit &amp;&amp; edit.row === rowidx &amp;&amp; edit.cell == idx<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>如果经过了check,那么我们就把当前的cell变成input. 初始值通过defaultValue
设置,然后存储的时候,使用_save()函数
<div class="org-src-container">

<pre class="src src-js">content = React.DOM.form<span style="color: #2aa198;">(</span>
    <span style="color: #b58900;">{</span>onSubmit: <span style="color: #268bd2; font-weight: bold;">this</span>._save<span style="color: #b58900;">}</span>,
    React.DOM.input<span style="color: #b58900;">(</span><span style="color: #268bd2;">{</span>
        type: <span style="color: #2aa198;">'text'</span>,
        defaultValue: content,
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-3" class="outline-4">
<h4 id="sec-3-5-3">Saving</h4>
<div class="outline-text-4" id="text-3-5-3">
<ul class="org-ul">
<li>我们来实现下上面的_save()函数,按下Enter Key以后,会触发这个存储.首先我们要
禁止默认的存储行为(默认的存储行为会刷新页面)
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">_save</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">e</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    e.preventDefault<span style="color: #b58900;">()</span>;
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">... do the save</span>
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
<li>之后,我们需要获取input field的ref
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">input</span> = e.target.firstChild;
</pre>
</div>
</li>
<li>拷贝里面的数据,我们要通过update,而非改动state的方式来更新数据
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">data</span> = <span style="color: #268bd2; font-weight: bold;">this</span>.state.data.slice<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>更新过程是首先把数据放到一个变量里面
<div class="org-src-container">

<pre class="src src-js">data<span style="color: #2aa198;">[</span><span style="color: #268bd2; font-weight: bold;">this</span>.state.edit.row<span style="color: #2aa198;">][</span><span style="color: #268bd2; font-weight: bold;">this</span>.state.edit.cell<span style="color: #2aa198;">]</span> = input.value;
</pre>
</div>
</li>
<li>使用setState更新
<div class="org-src-container">

<pre class="src src-ruby">this.setState<span style="color: #2aa198;">(</span>
  <span style="color: #b58900;">{</span>
    <span style="color: #268bd2; font-weight: bold;">edit:</span> null,                  <span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">done editing</span>
    <span style="color: #268bd2; font-weight: bold;">data:</span> data,
  <span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5-4" class="outline-4">
<h4 id="sec-3-5-4">Conclusion and Virtual DOM diffs</h4>
<div class="outline-text-4" id="text-3-5-4">
<ul class="org-ul">
<li>我们来总结下我们实现editing的过程:
<ul class="org-ul">
<li>通过this.state.edit来记录当前更新的是哪个cell
</li>
<li>如果发现当前cell的坐标和edit里面设置的一样,那么就render一个input field
</li>
<li>使用input field里面的值来更新table content
</li>
</ul>
</li>
<li>每当你使用setState()来设置新的data的时候, React都会自动调用component的render
函数, UI就会自动的更新!
</li>
<li>React的牛逼之处在于它并不是render整个table,它`只`update一个cell!
</li>
<li>React之所以可以做到这一点,是因为它创建了一种叫做virtual DOM的东西,每次render
函数被调用的时候, React会做一个virtual dom的diff.根据这个diff, React会计算
出更新所需要的最小的DOM opertion,然后把这个operation实施在真正的DOM上
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">Search</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>下面我们来添加对Excel component的搜索功能,可以让用户来filter table的内容:
<ul class="org-ul">
<li>首先要增加一个button来开启或者关闭搜索
</li>
<li>如果开启,那么搜索是以一个列为搜索单位的
</li>
<li>用户输入搜索字符串以后,只显示和这个搜索相关的内容
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-3-6-1" class="outline-4">
<h4 id="sec-3-6-1">State and UI</h4>
<div class="outline-text-4" id="text-3-6-1">
<ul class="org-ul">
<li>我们首先要把是否搜索开启设计成一个变量,存在getInitialState里面
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">getInitialtate</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">{</span>
        data: <span style="color: #268bd2; font-weight: bold;">this</span>.props.initialData,
        sortby: <span style="color: #268bd2; font-weight: bold;">null</span>,
        descending: <span style="color: #268bd2; font-weight: bold;">false</span>,
        edit: <span style="color: #268bd2; font-weight: bold;">null</span>,
        search: <span style="color: #268bd2; font-weight: bold;">false</span>,
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
<li>render()的过程不免就会复杂起来了,我们为了方便理解,把render()函数分成两个部
分: 一部分是render table,另一部分是render toolbar
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>
        React.DOM.div<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">null</span>,
                      <span style="color: #268bd2; font-weight: bold;">this</span>._renderToolbar<span style="color: #6c71c4;">()</span>,
                      <span style="color: #268bd2; font-weight: bold;">this</span>._renderTable<span style="color: #6c71c4;">()</span>
                     <span style="color: #268bd2;">)</span>
    <span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>,


<span style="color: #268bd2;">_renderToolbar</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">TODO</span>
<span style="color: #2aa198;">}</span>,

<span style="color: #268bd2;">_renderTable</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">TODO</span>
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
<li>也可以这么理解,新的render函数会返回两个&lt;div&gt; 一个是toolbar一个是table:
<ul class="org-ul">
<li>toolbar很简单,就是一个按钮
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">_renderToolbar</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> React.DOM.button<span style="color: #b58900;">(</span>
        <span style="color: #268bd2;">{</span>
            onClick: <span style="color: #268bd2; font-weight: bold;">this</span>._toggleSearch,
            className: <span style="color: #2aa198;">'toolbar'</span>,
        <span style="color: #268bd2;">}</span>,
        <span style="color: #2aa198;">'search'</span>
    <span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
<li>table不是那么简单,要考虑search功能是否开启,来决定table的样子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">_renderSearch</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>!<span style="color: #268bd2; font-weight: bold;">this</span>.state.search<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">null</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>
        React.DOM.tr<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">{</span>onChange: <span style="color: #268bd2; font-weight: bold;">this</span>._search<span style="color: #6c71c4;">}</span>,
                     <span style="color: #268bd2; font-weight: bold;">this</span>.props.headers.map<span style="color: #6c71c4;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #859900;">(</span><span style="color: #268bd2;">_ignore</span>, <span style="color: #268bd2;">idx</span><span style="color: #859900;">)</span> <span style="color: #859900;">{</span>
                         <span style="color: #859900; font-weight: bold;">return</span> React.DOM.td<span style="color: #b58900;">(</span> <span style="color: #268bd2;">{</span>key: idx<span style="color: #268bd2;">}</span>,
                                              React.DOM.input<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">{</span>
                                                  type: <span style="color: #2aa198;">'text'</span>,
                                                  <span style="color: #2aa198;">'data-idx'</span>: idx,
                     <span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span><span style="color: #657b83; background-color: #fdf6e3;">)</span>;
<span style="color: #657b83; background-color: #fdf6e3;">}</span>,
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-6-2" class="outline-4">
<h4 id="sec-3-6-2">Filtering Content</h4>
<div class="outline-text-4" id="text-3-6-2">
<ul class="org-ul">
<li>我们的search,其实就是利用js里面的Array.proptype.filter()来过滤关键字,只返
回我们需要的array
</li>
<li>你需要把数组的成员存储一下,否则你会丢失数据的.我们存储的数据还可以让用户在
清除input以后,获得原来完整的输入
</li>
<li>当我们点击search button的时候,我们会触发_toggleSearch()函数,这个函数要做下
面的几件事情:
<ul class="org-ul">
<li>设置this.state.search为true或者false
</li>
<li>当设置了search为true的时候,要"remembering" old data
</li>
<li>当设置了search为false的时候,要把old data revert
</li>
</ul>
</li>
<li>全部代码如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">_toggleSearch</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.state.search<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">{</span>
            data: <span style="color: #268bd2; font-weight: bold;">this</span>._preSearchData,
            search: <span style="color: #268bd2; font-weight: bold;">false</span>,
        <span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span>;
        <span style="color: #268bd2; font-weight: bold;">this</span>._preSearchDate = <span style="color: #268bd2; font-weight: bold;">null</span>;
    <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
        <span style="color: #268bd2; font-weight: bold;">this</span>._preSearchDate = <span style="color: #268bd2; font-weight: bold;">this</span>.state.date;
        <span style="color: #268bd2; font-weight: bold;">this</span>.setState <span style="color: #268bd2;">(</span><span style="color: #6c71c4;">{</span>
            search: <span style="color: #268bd2; font-weight: bold;">true</span>,
        <span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
<li>最后就是实现_search()函数了,这个函数会在每次搜索input有改动的时候被调用,代码如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2;">_search</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">e</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">needle</span> = e.target.value.toLowerCase<span style="color: #b58900;">()</span>;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>!needle<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">{</span>data: <span style="color: #268bd2; font-weight: bold;">this</span>._preSearchData<span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span>;
        <span style="color: #859900; font-weight: bold;">return</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">idx</span> = e.target.dataset.idx;
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">searchdta</span> = <span style="color: #268bd2; font-weight: bold;">this</span>._preSearchData.filter<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">row</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> row<span style="color: #6c71c4;">[</span>idx<span style="color: #6c71c4;">]</span>.toString<span style="color: #6c71c4;">()</span>.toLowerCase<span style="color: #6c71c4;">()</span>.indexOf<span style="color: #6c71c4;">(</span>needl<span style="color: #6c71c4;">)</span> &gt; -1;
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
    <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #b58900;">(</span><span style="color: #268bd2;">{</span>data: searchdata<span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
<li>TODO
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 4. JSX</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>目前为止,我们学的都是使用如下两种方法创建component:
<ul class="org-ul">
<li>React.DOM.*
</li>
<li>React.createElement()
</li>
</ul>
</li>
<li>上面两种使用function创建component的缺点是括号太多,不容易对齐,react对这个问题
给出的解决方案是jsx
</li>
</ul>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Hello JSX</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>我们来回顾下第一章的Hello World的例子,使用function的方法创建如下
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">src</span>=<span style="color: #2aa198;">"react/build/react.js"</span>&gt;&lt;/<span style="color: #268bd2;">script</span>&gt;
&lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">src</span>=<span style="color: #2aa198;">"react/build/react-dom.js"</span>&gt;&lt;/<span style="color: #268bd2;">script</span>&gt;
&lt;<span style="color: #268bd2;">script</span>&gt;
  ReactDOM.render(
    React.DOM.h1(
      {id: <span style="color: #2aa198;">"my-heading"</span>},
      React.DOM.span(null,
        React.DOM.em(null, <span style="color: #2aa198;">"Hell"</span>),
        <span style="color: #2aa198;">"o"</span>
      ),
      <span style="color: #2aa198;">" world!"</span>
    ),
    document.getElementById('app')
  );
&lt;/<span style="color: #268bd2;">script</span>&gt;
</pre>
</div>
</li>
<li>而使用JSX的样子如下,变得非常的简洁
<div class="org-src-container">

<pre class="src src-web">ReactDOM.render<span style="color: #2aa198;">(</span>
&lt;h1 id="myheading"&gt;
    &lt;span&gt;&lt;em&gt;Hell&lt;/em&gt;o&lt;/span&gt; world!
&lt;/h1&gt;,
document.getElementById<span style="color: #b58900;">(</span>'app'<span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>样子非常像html,所以很容易理解.但是问题在于jsx其实是一种wrapper,浏览器并不理
解这种格式,我们需要一种transform来把jsx转化成浏览器理解的pure js
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Transpiling JSX</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>所谓的transpilation就是把source code转换成如下的js代码,新的的js代码:
<ul class="org-ul">
<li>和老的js在效果上要保证完全一致
</li>
<li>必须要被老的浏览器都能理解,所以不能使用ES6等特性
</li>
</ul>
</li>
<li>这里我们要和polyfill区别一下,所谓polyfill是通过自己的努力让"某些"ES5
的特性能够工作在只支持ES3的浏览器里面,比如
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>!Array.<span style="color: #268bd2; font-weight: bold;">prototype</span>.map<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    Array.<span style="color: #268bd2; font-weight: bold;">prototype</span>.map = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">implement the method</span>
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">usage</span>
<span style="color: #859900; font-weight: bold;">typeof</span> <span style="color: #2aa198;">[]</span>.map === <span style="color: #2aa198;">'function'</span>;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
</pre>
</div>
</li>
<li>polyfill是一种纯的js解决方案(不会引入类似jsx这种新的技术),这个方案有其局限
性:只能向老的js里面增加函数,并不能做更多的事情:比如增加class关键字
</li>
<li>而transpiling则是另外一番景象,你可以放心的使用最新的规范(ES6),因为你知道最
后还会有一个代码翻译的过程,最终出来的代码是所有浏览器都可以理解的,最老规范
的版本
</li>
</ul>
</div>
<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">Babel</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>Babel是一个开源的js transpiler.支持把jsx转成老的浏览器都理解的js
</li>
<li>后面我们会介绍当下流行的build process,把React发布成可以使用的product级别的
代码,Babel在其中起了重要的作用
</li>
<li>我们当前先只把这个transpiler过程限定在client端,注意这只是为了理解代码,工业
级的代码并不这么写
</li>
<li>在0.14版本之前,react自带了一个transpiler的工具,但是现在已经默认使用Babel了
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2">Client Side</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>之前我们的代码中,都要include两个react js
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">src</span>=<span style="color: #2aa198;">"react/build/react.js"</span>&gt;&lt;/<span style="color: #268bd2;">script</span>&gt;
&lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">src</span>=<span style="color: #2aa198;">"react/build/react-dom.js"</span>&gt;&lt;/<span style="color: #268bd2;">script</span>&gt;
</pre>
</div>
</li>
<li>而你现在需要加上babel js的支持
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">src</span>=<span style="color: #2aa198;">"react/build/react.js"</span>&gt;&lt;/<span style="color: #268bd2;">script</span>&gt;
&lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">src</span>=<span style="color: #2aa198;">"react/build/react-dom.js"</span>&gt;&lt;/<span style="color: #268bd2;">script</span>&gt;
&lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">src</span>=<span style="color: #2aa198;">"babel/browser.js"</span>&gt;&lt;/<span style="color: #268bd2;">script</span>&gt;
</pre>
</div>
</li>
<li>为了让babel/browser.js能够找到jsx,你必须在script tag里面进行标注,这样
babel/brower.js才能找到需要自己的区域
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">type</span>=<span style="color: #2aa198;">"text/babel"</span>&gt;
  ReactDOM.render(/*...*/)
&lt;/<span style="color: #268bd2;">script</span>&gt;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Javascript in JSX</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>当我们创建UI的时候,总避免不了使用变量,循环,逻辑判断.一般来说,在rails里面,我
总是会在erb文件里面,使用ruby的语法来使用变量,循环,逻辑判断.
</li>
<li>react当然不能引入任何另外的script语言,它就只用js来做"变量,循环,逻辑判断",当
然了你需要在jsx文件里面,使用{}来包裹你的js代码,下面就是前面一章Excel Component
使用jsx语法后的代码.
</li>
<li>注意,是在html里面需要用"变量,循环,逻辑判断"才用{}, 外面的代码本身是js的就不
用{}了
<div class="org-src-container">

<pre class="src src-web">var Excel = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
displayName: 'Excel',


render: function<span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
var state = this.state;
return <span style="color: #6c71c4;">(</span>
&lt;table&gt;
    &lt;thead onClick=<span style="color: #859900;">{</span>this._sort<span style="color: #859900;">}</span>&gt;
        &lt;tr&gt;<span style="color: #859900;">{</span>
            this.props.headers.map<span style="color: #b58900;">(</span>function<span style="color: #268bd2;">(</span>title, idx<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            if <span style="color: #6c71c4;">(</span>state.sortby === idx<span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
            title += state.descending ? ' \u2191' : ' \u2193'
            <span style="color: #6c71c4;">}</span>
            return &lt;th key=<span style="color: #6c71c4;">{</span>idx<span style="color: #6c71c4;">}</span>&gt;<span style="color: #6c71c4;">{</span>title<span style="color: #6c71c4;">}</span>&lt;/th&gt;;
            <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
            <span style="color: #859900;">}</span>&lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        <span style="color: #859900;">{</span>
        this.state.data.map<span style="color: #b58900;">(</span>function<span style="color: #268bd2;">(</span>row, idx<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
        return <span style="color: #6c71c4;">(</span>
        &lt;tr key=<span style="color: #859900;">{</span>idx<span style="color: #859900;">}</span>&gt;<span style="color: #859900;">{</span>
            row.map<span style="color: #2aa198;">(</span>function<span style="color: #b58900;">(</span>cell, idx<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
            return &lt;td key=<span style="color: #268bd2;">{</span>idx<span style="color: #268bd2;">}</span>&gt;<span style="color: #268bd2;">{</span>cell<span style="color: #268bd2;">}</span>&lt;/td&gt;;
            <span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>
            <span style="color: #859900;">}</span>&lt;/tr&gt;
        <span style="color: #6c71c4;">)</span>;
        <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>
        <span style="color: #859900;">}</span>
    &lt;/tbody&gt;
&lt;/table&gt;
<span style="color: #6c71c4;">)</span>;<span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>一个典型的应用就是在th里面使用{}引入title
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">th</span> key={idx}&gt; {title} &lt;/<span style="color: #268bd2;">th</span>&gt;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Whitespce in JSX</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>在jsx里面,空格的转换有些特点:
<ul class="org-ul">
<li>和传统HTML一样的地方: 多个空格会被转换成一个空格
</li>
<li>但是回车会被"吞噬"掉
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Comments in JSX</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>不要使用single-line comment
</li>
<li>全部使用multiline comment,如下
<div class="org-src-container">

<pre class="src src-web">&lt;h1&gt;
  <span style="color: #2aa198;">{</span> /* multiline comment */ <span style="color: #2aa198;">}</span>
&lt;/h1&gt;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">HTML Entities</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li>你可以在JSX里面如下使用HTML entities. 这就和普通的HTML没有任何的区别
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">h2</span>&gt;
<span style="font-weight: bold; font-style: italic;">  More info </span><span style="color: #268bd2; font-weight: bold; font-style: italic;">&amp;raquo;</span>
&lt;/<span style="color: #268bd2;">h2</span>&gt;
</pre>
</div>
</li>
<li>你也可以通过加上{}把这段代码"解析成JS". 这就不是普通的HTML啦,字符串也不会解
析成特殊的格式. 如果你想解析成特殊格式,那么就请使用unocode.比如在这里就是使
用\u00bb来代替&amp;raquo;
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">h2</span>&gt;
<span style="font-weight: bold; font-style: italic;">  { </span><span style="color: #2aa198; font-weight: bold; font-style: italic;">"More info &amp;raquo;"</span><span style="font-weight: bold; font-style: italic;">}</span>
&lt;/<span style="color: #268bd2;">h2</span>&gt;
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-4-6-1" class="outline-4">
<h4 id="sec-4-6-1">Anti-XSS</h4>
<div class="outline-text-4" id="text-4-6-1">
<ul class="org-ul">
<li>为了防止XSS攻击,react会把所有的字符串转义,也就是说类似"&amp;raquo"这样的代码,
是无论如何都不会起到作用的,还是使用unicode的吧.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7">Spread Attributes</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>jsx反正要进行transpiler的,索性就借鉴了更多的最新js语法,比如ECMAScript6里面
的spread operator,这个特性对于定义properties非常有用
</li>
<li>比如你有一个js的attribute
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">attr</span> = <span style="color: #2aa198;">{</span>
    href: <span style="color: #2aa198;">'http://example.org'</span>,
    target: <span style="color: #2aa198;">'_blank'</span>,
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>你有两种方法来把这些attribute都赋值给一个&lt;a&gt; component:
<ul class="org-ul">
<li>原来老的办法,当然是一个一个的赋值,有很多多余的代码,attribute越多,多余代码越多
<div class="org-src-container">

<pre class="src src-web">return <span style="color: #2aa198;">(</span>
&lt;a
    href=<span style="color: #b58900;">{</span>attr.href<span style="color: #b58900;">}</span>
    target=<span style="color: #b58900;">{</span>attr.target<span style="color: #b58900;">}</span>&gt;
&lt;/a&gt;
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>spread attribute引入的办法,非常简洁
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">return</span> &lt;a <span style="color: #2aa198;">{</span>...attr<span style="color: #2aa198;">}</span> &gt; Hello &lt;/a&gt;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-4-7-1" class="outline-4">
<h4 id="sec-4-7-1">Parent-to-child Spread Attributes</h4>
<div class="outline-text-4" id="text-4-7-1">
<ul class="org-ul">
<li>spread attribute更重要的使用方法是从parent向child传递attribute:
<ul class="org-ul">
<li>比如你有一个FancyLink commponent, 这个component有很多&lt;a&gt;类似的attribute
下面是别人使用你的component的例子
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">FancyLink</span>
   <span style="color: #268bd2;">href</span>=<span style="color: #2aa198;">"http://example.org"</span>
   style={ { color: <span style="color: #2aa198;">"red"</span> }}
   <span style="color: #268bd2;">target</span>=<span style="color: #2aa198;">"_blank"</span>
   <span style="color: #268bd2;">size</span>=<span style="color: #2aa198;">"medium"</span>&gt;
  Hello
&lt;/<span style="color: #268bd2;">FancyLink</span>&gt;
</pre>
</div>
</li>
<li>你创建这个component的方法如下:this.props是从parent送来的attribute,我们要
一股脑的放到&lt;a&gt;里面
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">FancyLink</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
        <span style="color: #859900; font-weight: bold;">return</span> &lt;a <span style="color: #6c71c4;">{</span>...<span style="color: #268bd2; font-weight: bold;">this</span>.props<span style="color: #6c71c4;">}</span>&gt; <span style="color: #6c71c4;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>.props.children<span style="color: #6c71c4;">}</span>&lt;/a&gt;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</li>
<li>注意上面例子里面this.props.children的用法,"Hello"通过&lt;FancyLink&#x2026;&gt;Hello
&lt;/Francy&gt;的办法引入,被付给this.props.children, 而调用的时候直接使用就可以
了.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8">Returning Multiple Nodes in JSX</h3>
<div class="outline-text-3" id="text-4-8">
<ul class="org-ul">
<li>我们的render()函数每次只能返回一个html node,换句话说下面的代码是错误的
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Example</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">(</span>
            &lt;span&gt;
                Hello
            &lt;/span&gt;
                &lt;span&gt;
                World
            &lt;/span&gt;
        <span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>最简单的改动方法,是把它们放到一个div里面
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Example</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">(</span>
            &lt;div&gt;
            &lt;span&gt;
                Hello
            &lt;/span&gt;
                &lt;span&gt;
                World
            &lt;/span&gt;
            &lt;/div&gt;
        <span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>注意,我们只是render()不能返回多个node,我们完完全全还可以在js代码里面自己创
建复杂的一个array,然后把这个数组render()出去.要注意两点:
<ul class="org-ul">
<li>数组每个成员必须有key
</li>
<li>字符串(空或者不空)都不需要一个key
</li>
</ul>
</li>
<li>下面就是一个返回array的例子
<div class="org-src-container">

<pre class="src src-web">var Example = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
render: function<span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
    var greeting = <span style="color: #6c71c4;">[</span>
        &lt;span key="greet"&gt;Hello&lt;/span&gt;,
        ' ',
        &lt;span key="world"&gt; World&lt;/span&gt;
        '!'
    <span style="color: #6c71c4;">]</span>;

    return <span style="color: #6c71c4;">(</span>
        &lt;div&gt;
            <span style="color: #859900;">{</span>greeting<span style="color: #859900;">}</span>
        &lt;/div&gt;
    <span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>如果我们在&lt;Example&gt;`children`&lt;/Example&gt;里面把`children`也设置成array,也可以
达到上面一样的效果
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Example</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
  <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
    console.log<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.props.children.length<span style="color: #6c71c4;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">(</span>
      &lt;div&gt;
        <span style="color: #859900;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>.props.children<span style="color: #859900;">}</span>
      &lt;/div&gt;
    <span style="color: #6c71c4;">)</span>;
  <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

ReactDOM.render<span style="color: #2aa198;">(</span>
  &lt;Example&gt;
    &lt;span key=<span style="color: #2aa198;">"greet"</span>&gt;Hello&lt;/span&gt;
    <span style="color: #b58900;">{</span><span style="color: #2aa198;">' '</span><span style="color: #b58900;">}</span>
    &lt;span key=<span style="color: #2aa198;">"world"</span>&gt;World&lt;/span&gt;
    !
  &lt;/Example&gt;,
  document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">'app'</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-9" class="outline-3">
<h3 id="sec-4-9">JSX Versus HTML Differences</h3>
<div class="outline-text-3" id="text-4-9">
<ul class="org-ul">
<li>JSX的特点是看起来像HTML,但是使用js包裹(通过{})的方法来实现`变量,循环,逻辑判断`
</li>
<li>共同点总是容易找到但是不同点却会容易引起误会,下面介绍几个不同点
</li>
</ul>
</div>
<div id="outline-container-sec-4-9-1" class="outline-4">
<h4 id="sec-4-9-1">No class, What for?</h4>
<div class="outline-text-4" id="text-4-9-1">
<ul class="org-ul">
<li>class和for都是ECMAScript里面的关键字,所以在jsx里面要使用className和htmlFor
来代替:
<ul class="org-ul">
<li>错误版本
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">em</span> = &lt;em <span style="color: #859900; font-weight: bold;">class</span>=<span style="color: #2aa198;">"important"</span> /&gt;;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">label</span> = &lt;label <span style="color: #859900; font-weight: bold;">for</span>=<span style="color: #2aa198;">"thatInput"</span> /&gt;;
</pre>
</div>
</li>
<li>正确版本
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">em</span> = &lt;em className=<span style="color: #2aa198;">"important"</span> /&gt;;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">label</span> = &lt;label htmlFor=<span style="color: #2aa198;">"thatInput"</span> /&gt;;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-9-2" class="outline-4">
<h4 id="sec-4-9-2">Style Is an Object</h4>
<div class="outline-text-4" id="text-4-9-2">
<ul class="org-ul">
<li>style不是是接受一个字符串,而是接受一个object, css的property不能使用dash-delimited,
而要使用camelCase:
<ul class="org-ul">
<li>错误版本
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">em</span> = &lt;em style=<span style="color: #2aa198;">"font-Size: 2em; line-height: 1.6"</span>/&gt;;
</pre>
</div>
</li>
<li>正确版本
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">styles</span> = <span style="color: #2aa198;">{</span>
    fontSize: <span style="color: #2aa198;">'2em'</span>,
    lineHeight: <span style="color: #2aa198;">'1.6'</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">em</span> = &lt;em style=<span style="color: #2aa198;">{</span>style<span style="color: #2aa198;">}</span> /&gt;;
</pre>
</div>
</li>
<li>高阶版本,有两个{},一个是为js的object,另外一个是为了jsx的js代码解析
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">em</span> = &lt;em style = <span style="color: #2aa198;">{</span> <span style="color: #b58900;">{</span>fontSize: <span style="color: #2aa198;">'2em'</span>, lineHeight: <span style="color: #2aa198;">'1.6'</span><span style="color: #b58900;">}</span> <span style="color: #2aa198;">}</span> /&gt;;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-9-3" class="outline-4">
<h4 id="sec-4-9-3">Closing Tags</h4>
<div class="outline-text-4" id="text-4-9-3">
<ul class="org-ul">
<li>在HTML里面一些tag可以不关闭, JSX既然是JS Xml的简称,那么tag就必须关闭啦
<ul class="org-ul">
<li>错误版本:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">list</span> = &lt;ul&gt;&lt;li&gt;item&lt;/ul&gt;
</pre>
</div>
</li>
<li>正确版本
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">list</span> = &lt;ul&gt;&lt;li&gt;item&lt;/li&gt;&lt;/ul&gt;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-9-4" class="outline-4">
<h4 id="sec-4-9-4">camelCase Attributes</h4>
<div class="outline-text-4" id="text-4-9-4">
<ul class="org-ul">
<li>JSX里面所有的attribute都是camelCase的:
<ul class="org-ul">
<li>错误版本
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">a</span> = &lt;a onclick=<span style="color: #2aa198;">"reticulateSplines()"</span> /&gt;;
</pre>
</div>
</li>
<li>正确版本
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">a</span> = &lt;a onClick=<span style="color: #2aa198;">{</span>reticulateSplines<span style="color: #2aa198;">}</span> /&gt;;
</pre>
</div>
</li>
</ul>
</li>
<li>例外是data-和aria-开头的attribute
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-10" class="outline-3">
<h3 id="sec-4-10">JSX and Forms</h3>
<div class="outline-text-3" id="text-4-10">
<ul class="org-ul">
<li>html的form和jsx的form有很多不同,值得我们认真的写一下
</li>
</ul>
</div>
<div id="outline-container-sec-4-10-1" class="outline-4">
<h4 id="sec-4-10-1">onChange Handler</h4>
<div class="outline-text-4" id="text-4-10-1">
<ul class="org-ul">
<li>在人们和form打交道的时候,人们关注的,是你输入字符的情况下,form的反应.换句话
说,我们和form交流的方式是form value的改动
</li>
<li>在react的世界里面,你使用onChange attribute来订阅这些改动,然后可以施加某些
event handler
</li>
<li>而其他所有的老的html里面的监听鼠标键盘等的事件,统统不需要关注了!!!
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-10-2" class="outline-4">
<h4 id="sec-4-10-2">value Versus defaultValue</h4>
<div class="outline-text-4" id="text-4-10-2">
<ul class="org-ul">
<li>在HTML里面,如果你给&lt;input&gt;提供了一个value attribute,这个attribute的行为是
割裂的!是HTML设计的缺陷,比如&lt;input id="i" value="hello"/&gt;你的在输入框里面
输入bye,那么就有
<div class="org-src-container">

<pre class="src src-js">i.value;                        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"bye"</span>
i.getAttribute<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'value'</span><span style="color: #2aa198;">)</span>;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">"hello"</span>
</pre>
</div>
</li>
<li>在react里面肯定不会有这种割裂的bug存在了,如果你想要找到原来默认的值,那么你
需要的是defaultValue这个属性
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-10-3" class="outline-4">
<h4 id="sec-4-10-3">&lt;textarea&gt; Value</h4>
<div class="outline-text-4" id="text-4-10-3">
<ul class="org-ul">
<li>react里面的textarea和input有着一样的使用方法:
<ul class="org-ul">
<li>value是最新的内容
</li>
<li>defaultValue是默认值
</li>
</ul>
</li>
<li>注意HTML里面,你要在&lt;textarea&gt;&lt;/textarea&gt;里面来设置文本内容(因为html的属性
不能有换行符),但是jsx是javascript,它不会有这方便的顾虑,所以下面的代码是完
全可行的
<div class="org-src-container">

<pre class="src src-js">React.render<span style="color: #2aa198;">(</span>
    &lt;textarea defaultValue=<span style="color: #2aa198;">"hello\nworld"</span> /&gt;,
    document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">'app1'</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>注意上面这个例子中的"hello\nworld"会被转义,因为它是raw string,如果你不想被
转义那么要加上个{}
<div class="org-src-container">

<pre class="src src-js">React.render<span style="color: #2aa198;">(</span>
    &lt;textarea defaultValue=<span style="color: #b58900;">{</span><span style="color: #2aa198;">"hello\nworld"</span><span style="color: #b58900;">}</span> /&gt;,
    document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">'app2'</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-10-4" class="outline-4">
<h4 id="sec-4-10-4">&lt;select&gt; Value</h4>
<div class="outline-text-4" id="text-4-10-4">
<ul class="org-ul">
<li>在HTML里面,select是必须使用option selected来表达当前谁被选中了
<div class="org-src-container">

<pre class="src src-html"><span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">old school HTML </span><span style="color: #93a1a1;">--&gt;</span>
&lt;<span style="color: #268bd2;">select</span>&gt;
  &lt;<span style="color: #268bd2;">option</span> <span style="color: #268bd2;">value</span>=<span style="color: #2aa198;">"stay"</span>&gt; Should I stay&lt;/<span style="color: #268bd2;">option</span>&gt;
  &lt;<span style="color: #268bd2;">option</span> <span style="color: #268bd2;">value</span>=<span style="color: #2aa198;">"move"</span> selected&gt; or should I go&lt;/<span style="color: #268bd2;">option</span>&gt;
  &lt;<span style="color: #268bd2;">option</span> <span style="color: #268bd2;">value</span>=<span style="color: #2aa198;">"trouble"</span>&gt; If I stay it will be trouble&lt;/<span style="color: #268bd2;">option</span>&gt;
&lt;/<span style="color: #268bd2;">select</span>&gt;
</pre>
</div>
</li>
<li>react里面使用defaultValue,更加的reasonable
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">select</span> <span style="color: #268bd2;">defaultValue</span>=<span style="color: #2aa198;">"move"</span>&gt;
  &lt;<span style="color: #268bd2;">option</span> <span style="color: #268bd2;">value</span>=<span style="color: #2aa198;">"stay"</span>&gt; Should I stay&lt;/<span style="color: #268bd2;">option</span>&gt;
  &lt;<span style="color: #268bd2;">option</span> <span style="color: #268bd2;">value</span>=<span style="color: #2aa198;">"move"</span>&gt; or should I go&lt;/<span style="color: #268bd2;">option</span>&gt;
  &lt;<span style="color: #268bd2;">option</span> <span style="color: #268bd2;">value</span>=<span style="color: #2aa198;">"trouble"</span>&gt; If I stay it will be trouble&lt;/<span style="color: #268bd2;">option</span>&gt;
&lt;/<span style="color: #268bd2;">select</span>&gt;
</pre>
</div>
</li>
<li>多选就是defaultValue是一个数组
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">select</span> defaultValue={[<span style="color: #2aa198;">"stay"</span>, <span style="color: #2aa198;">"move"</span>]} multiple={true}&gt;
  &lt;<span style="color: #268bd2;">option</span> <span style="color: #268bd2;">value</span>=<span style="color: #2aa198;">"stay"</span>&gt; Should I stay&lt;/<span style="color: #268bd2;">option</span>&gt;
  &lt;<span style="color: #268bd2;">option</span> <span style="color: #268bd2;">value</span>=<span style="color: #2aa198;">"move"</span>&gt; or should I go&lt;/<span style="color: #268bd2;">option</span>&gt;
  &lt;<span style="color: #268bd2;">option</span> <span style="color: #268bd2;">value</span>=<span style="color: #2aa198;">"trouble"</span>&gt; If I stay it will be trouble&lt;/<span style="color: #268bd2;">option</span>&gt;
&lt;/<span style="color: #268bd2;">select</span>&gt;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-10-5" class="outline-4">
<h4 id="sec-4-10-5">Excel Component in JSX</h4>
<div class="outline-text-4" id="text-4-10-5">
<ul class="org-ul">
<li>使用jsx来实现excel的例子
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 5. Setting Up for App Development</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>这一章主要介绍公司开发的流程中,如何搭建SinglePageApplicatoin的开发环境
</li>
<li>其目的是使用最新的ES特性,但是通过transpiler来转换成老的浏览器也支持的js代码
</li>
</ul>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Boilerplate App</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>我们来创建一个boilerplate配置模板,其特点是支持JSX,以及所有已知的最新技术:
<ul class="org-ul">
<li>ES5
</li>
<li>ES6
</li>
<li>ES7
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1">Files and Folders</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>我们首先要有一个组织架构,大概如下
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #657b83; font-weight: bold;">.</span>
|-- css
|-- images
|-- js
|   |-- build
|   <span style="color: #6c71c4; font-weight: bold;">`-- source</span>
<span style="color: #6c71c4; font-weight: bold;">`</span>-- scripts

6 directories, 0 files
</pre>
</div>
</li>
<li>js文件夹被分成了build和souce,其实就是source里面是最新技术的js版本,被transpiler
以后,放到build文件夹里面
</li>
<li>scripts是bash的一些常用脚步
</li>
<li>我们下面进一步细化css和js/souce,在这两个文件夹下面都加上一个components文件
夹,这个文件夹里面存储我们react最重要的组成部分component
</li>
<li>component的js和css的文件名最好首字母大写(和react class名字一致)
</li>
<li>其他的不和react有关系的js和css文件就放到css和js/source里面,名字可以起的统
一一点就叫做app.js和app.css
</li>
<li>当然还要有承载所有文件的index.html
</li>
<li>现在,我们的结构如下
<pre class="example">
.
|-- css
|   |-- app.css
|   `-- components
|       `-- Logo.css
|-- images
|-- index.html
|-- js
|   |-- build
|   `-- source
|       |-- app.js
|       `-- components
|           `-- Logo.js
`-- scripts

8 directories, 5 files
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2">index.html</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>我们的index.html承载了很多东西:
<ul class="org-ul">
<li>所有的css文件都要被index包括,包括的方法是把所有的css文件整合在一起在一个
bundle.css文件里面
</li>
<li>同样的,所有的js文件整合在bundle.js里面,注意js的整合要比css麻烦,因为它需
要include dependency
</li>
<li>index里面要有&lt;div id="app"&gt;来放置我们的应用
</li>
</ul>
</li>
<li>代码如下,注意,我们只引用了一个css文件和一个js文件
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #859900; font-weight: bold;">!DOCTYPE</span> html&gt;
&lt;<span style="color: #268bd2;">html</span>&gt;
    &lt;<span style="color: #268bd2;">head</span>&gt;
        &lt;<span style="color: #268bd2;">title</span>&gt;<span style="font-weight: bold;">App</span>&lt;/<span style="color: #268bd2;">title</span>&gt;
        &lt;<span style="color: #268bd2;">meta</span> <span style="color: #268bd2;">charset</span>=<span style="color: #2aa198;">"utf-8"</span>&gt;
        &lt;<span style="color: #268bd2;">link</span> <span style="color: #268bd2;">rel</span>=<span style="color: #2aa198;">"stylesheet"</span> <span style="color: #268bd2;">type</span>=<span style="color: #2aa198;">"text/css"</span> <span style="color: #268bd2;">href</span>=<span style="color: #2aa198;">"bundle.css"</span>&gt;
    &lt;/<span style="color: #268bd2;">head</span>&gt;
    &lt;<span style="color: #268bd2;">body</span>&gt;
        &lt;<span style="color: #268bd2;">div</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"app"</span>&gt;&lt;/<span style="color: #268bd2;">div</span>&gt;
        &lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">src</span>=<span style="color: #2aa198;">"bundle.js"</span>&gt;&lt;/<span style="color: #268bd2;">script</span>&gt;
    &lt;/<span style="color: #268bd2;">body</span>&gt;
&lt;/<span style="color: #268bd2;">html</span>&gt;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-1-3" class="outline-4">
<h4 id="sec-5-1-3">CSS</h4>
<div class="outline-text-4" id="text-5-1-3">
<ul class="org-ul">
<li>/css/app.css会包括全局的一些配置
<div class="org-src-container">

<pre class="src src-css"><span style="color: #268bd2;">html </span><span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">background</span>: white;
  <span style="color: #268bd2;">font</span>: 16px Arial;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>/css/components/Logo.css就包括某个component的css配置啦
<div class="org-src-container">

<pre class="src src-css"><span style="color: #268bd2;">.Logo </span><span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">background-image</span>: url<span style="color: #b58900;">(</span><span style="color: #2aa198;">'../../images/react-logo.svg'</span><span style="color: #b58900;">)</span>;
  <span style="color: #268bd2;">background-size</span>: cover;
  <span style="color: #268bd2;">display</span>: inline-block;
  <span style="color: #268bd2;">height</span>: 50px;
  <span style="color: #268bd2;">vertical-align</span>: middle;
  <span style="color: #268bd2;">width</span>: 50px;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-1-4" class="outline-4">
<h4 id="sec-5-1-4">Javascript</h4>
<div class="outline-text-4" id="text-5-1-4">
<ul class="org-ul">
<li>js/source/app.js是全局的js代码,是设置react componet在html里面布局的代码
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">'use strict'</span>;

<span style="color: #859900; font-weight: bold;">import</span> React from <span style="color: #2aa198;">'react'</span>;
<span style="color: #859900; font-weight: bold;">import</span> ReactDOM from <span style="color: #2aa198;">'react-dom'</span>;
<span style="color: #859900; font-weight: bold;">import</span> Logo from <span style="color: #2aa198;">'./components/Logo'</span>;

ReactDOM.render<span style="color: #2aa198;">(</span>
  &lt;h1&gt;
    &lt;Logo /&gt; Welcome to The App!
  &lt;/h1&gt;,
  document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">'app'</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>js/source/componenets/Logo.js是某个react component的代码
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> React from <span style="color: #2aa198;">'react'</span>;

<span style="color: #859900; font-weight: bold;">class</span> Logo <span style="color: #859900; font-weight: bold;">extends</span> React.Component <span style="color: #2aa198;">{</span>
  render<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> &lt;div className=<span style="color: #2aa198;">"Logo"</span>/&gt;;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">export</span> <span style="color: #859900; font-weight: bold;">default</span> Logo
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-1-5" class="outline-4">
<h4 id="sec-5-1-5">Javascript: Modernized</h4>
<div class="outline-text-4" id="text-5-1-5">
<ul class="org-ul">
<li>nodejs引入javascript的一个大的概念就是package,我们不能再使用React或者
ReactDOM作为我们的global variable就不再适合了,这个时候,你就需要module了,
nodejs就提供了这个功能
</li>
<li>nodejs最开始的时候,是使用CommonJS来作为我们的module,这是一种纯的js实现(因
为当时不能使用es标准来实现这件事情,话说回来是有了nodejs之后,es新标准才更快
的推广的,这个是先有鸡还是先有蛋的问题),CommonJS的方法是我们创建了一个object,
然后使用module.exports的方法来导出这个module
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Logo</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>  <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span> <span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

module.exports = Logo;
</pre>
</div>
</li>
<li>需要注意的是,上面的代码用到了React,React已经不是全局变量了,它需要从其他地
方include来
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">React</span> = require<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'react'</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>总结起来就是:
<ul class="org-ul">
<li>declare requirement up top
</li>
<li>export at the bottom
</li>
<li>implement the "meat" between
</li>
</ul>
</li>
<li>ECMAScript后来再进一步,继承了上面的"三段式"但是使用更加先进的格式来declare
和export(因为ECMAScript是标准组织,它可以引入新的syntax, 当然我们要使用最新
的啦,因为肯定更先进,Babel会帮助我们转换成老的js的):
<ul class="org-ul">
<li>导入使用import
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> React from <span style="color: #2aa198;">'react'</span>;
</pre>
</div>
</li>
<li>导出使用export,注意最后没有分号
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">export</span> <span style="color: #859900; font-weight: bold;">default</span> Logo
</pre>
</div>
</li>
</ul>
</li>
<li>我们甚至不再需要原来的React.creatClass了,因为ECMAScript引入了class的概念
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">class</span> Logo <span style="color: #859900; font-weight: bold;">extends</span> React.Component <span style="color: #2aa198;">{</span><span style="color: #93a1a1;">/*</span><span style="color: #93a1a1;">...*/</span><span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>最新的class和原来的使用object作为class是有些不同的:
<ul class="org-ul">
<li>新的class内部只能有function, 定义property需要定义在this里面
</li>
<li>不再需要render: function() {}, 只需要直接定义函数render()就可以了
</li>
<li>函数之间也不再需要','分割
</li>
</ul>
</li>
<li>学习了新的格式,我们来看看各部分js代码:
<ul class="org-ul">
<li>app.js的代码如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">'use strict'</span>;

<span style="color: #859900; font-weight: bold;">import</span> React from <span style="color: #2aa198;">'react'</span>;
<span style="color: #859900; font-weight: bold;">import</span> ReactDOM from <span style="color: #2aa198;">'react-dom'</span>;
<span style="color: #859900; font-weight: bold;">import</span> Logo from <span style="color: #2aa198;">'./components/Logo'</span>;

ReactDOM.render<span style="color: #2aa198;">(</span>
  &lt;h1&gt;
    &lt;Logo /&gt; Welcome to The App!
  &lt;/h1&gt;,
  document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">'app'</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>Logo.js的代码如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> React from <span style="color: #2aa198;">'react'</span>;

<span style="color: #859900; font-weight: bold;">class</span> Logo <span style="color: #859900; font-weight: bold;">extends</span> React.Component <span style="color: #2aa198;">{</span>
  render<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> &lt;div className=<span style="color: #2aa198;">"Logo"</span>/&gt;;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">export</span> <span style="color: #859900; font-weight: bold;">default</span> Logo
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Install Prerequisites</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>即便有了上面的代码,你还是不可能马上执行的,原因很简单:index.html里面的bundle.css
和bundle.js都并没有,所以你还得:
<ul class="org-ul">
<li>创建bundle.css这个很简单只需要把多个css文件合并成一个就可以
</li>
<li>创建bundle.js这个有点麻烦,我们需要同时把所有的dependency都引入到我们的bundle.js
代码,引入依赖并且合并成一个文件的过程要通过一个叫做Browserify的nodejs插件来完成
</li>
<li>我们的代码还要transpiler, 这个过程需要Babel这个nodejs插件来完成
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1">Node.js</h4>
<div class="outline-text-4" id="text-5-2-1">
<ul class="org-ul">
<li>首先需要安装node.js,安装后打印下面的来判断安装是否成功
<div class="org-src-container">

<pre class="src src-sh">npm --version
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2-2" class="outline-4">
<h4 id="sec-5-2-2">Browersify</h4>
<div class="outline-text-4" id="text-5-2-2">
<ul class="org-ul">
<li>使用如下方法安装browersify,注意是安装到global的npm library
<div class="org-src-container">

<pre class="src src-sh">npm install --global browersify
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2-3" class="outline-4">
<h4 id="sec-5-2-3">Babel</h4>
<div class="outline-text-4" id="text-5-2-3">
<ul class="org-ul">
<li>Babel因为要使用其命令行,所以其命令行也要安装到global的npm library
<div class="org-src-container">

<pre class="src src-sh">npm install --global babel-cli
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2-4" class="outline-4">
<h4 id="sec-5-2-4">React, etc.</h4>
<div class="outline-text-4" id="text-5-2-4">
<ul class="org-ul">
<li>剩下的我们还需要的library有:
<ul class="org-ul">
<li>react这个不用说了
</li>
<li>react-dom, 从react分出来的
</li>
<li>babel-preset-react,Babel对于JSX和React的支持
</li>
<li>babel-preset-es2015, Babel对于最新ES规范的支持
</li>
</ul>
</li>
<li>这些library不需要使用command-line的binary,所以安装到local就可以了
<div class="org-src-container">

<pre class="src src-sh">npm install --save-dev react
npm install --save-dev react-dom
npm install --save-dev babel-preset-react
npm install --save-dev babel-preset-es2015
</pre>
</div>
</li>
<li>注意这里的&#x2013;save-dev, 它和&#x2013;save的区别就是:
<ul class="org-ul">
<li>&#x2013;save-dev会把这个安装到devDependencies下面, 这个是我们开发模式下需要的,
不会被部署到服务器
</li>
<li>&#x2013;save会把这个安装到dependencies下面, 这个是我们生产环境需要的,会被部署
到服务器
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Let's Build</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>我们的build分成了如下几个部分:
<ul class="org-ul">
<li>transpiler js, 使用babel cli:
<div class="org-src-container">

<pre class="src src-sh">babel --presets react,es2015 js/source -d js/build
</pre>
</div>
</li>
<li>package js,会从一个app.js出发,把所有的dependency都导入到一个js文件里面
<div class="org-src-container">

<pre class="src src-js">browserify js/build/app.js -o build.js
</pre>
</div>
</li>
<li>package css, 把所有的css文件合起来就好,再把'../../images'替换成'images'
<div class="org-src-container">

<pre class="src src-sh">cat css/*/* css/*.css | sed <span style="color: #2aa198;">'s/..\/..\/images/images/g'</span> &gt; bundle.css
</pre>
</div>
</li>
</ul>
</li>
<li>注意,我们的代码都会在root目录下面生成bundle.css和bundle.js两个文件,这也是我
们index.html里面写到的,但是正式工程可能会写入到一个out文件夹之类的
</li>
<li>每改动一个文件,就调用一遍上面的script是有点麻烦,型号我们可以使用nodejs听的watch package:
<ul class="org-ul">
<li>首先安装这个package,需要命令行,所以
<div class="org-src-container">

<pre class="src src-sh">npm install -g watch
</pre>
</div>
</li>
<li>然后调用watch 使用某个script,同时检测某些文件夹,比如这里的js/sources和css
<div class="org-src-container">

<pre class="src src-sh">watch <span style="color: #2aa198;">"sh scripts/build.sh"</span> js/sources css
</pre>
</div>
</li>
<li>build.sh的内容如下
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">js transform</span>
babel --presets react,es2015 js/source/ -d js/build
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">js package</span>
browserify js/build/app.js -o bundle.js
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">css package</span>
cat css/*/* css/*.css | sed <span style="color: #2aa198;">'s/..\/..\/images/images/g'</span> &gt; bundle.css
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">done</span>
date; <span style="color: #657b83; font-weight: bold;">echo</span>;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Deployment</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>我们已经做了很多工作,部署就是很简单了,只需要把前面的工作稍微改动一下:
<ul class="org-ul">
<li>创建一个deploy的文件夹
</li>
<li>把css和js文件build出来,然后做一下minification(开发的时候不需要,部署的时候
越小越好么)
</li>
<li>把html文件和image文件都拷贝到deploy文件夹下面
</li>
</ul>
</li>
<li>部署的script如下
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">cleanup last version</span>
rm -rf __deployme
mkdir __deployme

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">build</span>
sh scripts/build.sh

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">minify js</span>
uglify -s bundle.js -o __deployme/bundle.js
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">minify css</span>
cssshrink bundle.css &gt; __deployme/bundle.css
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">copy html and images</span>
cp index.html __deployme/index.html
cp -r images/ __deployme/images/

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">done</span>
date; <span style="color: #657b83; font-weight: bold;">echo</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Chapter 6. Building an App</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li>本章开始设计一个小的例子,创建一个评价葡萄酒的平台,叫做winepad
</li>
</ul>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Whinepad v.0.0.1</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>这个例子很简单,那就是把前面的Excel object全部都放入到app.js里面就可以了代码
大概是这个样子(用到了localStorage,可以暂时把它理解成大小为5MB的cookie)
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">headers</span> = localStorage.getItem<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'headers'</span><span style="color: #2aa198;">)</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">data</span> = localStorage.getItem<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'data'</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span>!headers<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
headers = <span style="color: #b58900;">[</span><span style="color: #2aa198;">'Title'</span>, <span style="color: #2aa198;">'Year'</span>, <span style="color: #2aa198;">'Rating'</span>, <span style="color: #2aa198;">'Comments'</span><span style="color: #b58900;">]</span>;
data = <span style="color: #b58900;">[</span><span style="color: #268bd2;">[</span><span style="color: #2aa198;">'Test'</span>, <span style="color: #2aa198;">'2015'</span>, <span style="color: #2aa198;">'3'</span>, <span style="color: #2aa198;">'meh'</span><span style="color: #268bd2;">]</span><span style="color: #b58900;">]</span>;
<span style="color: #2aa198;">}</span>

ReactDOM.render<span style="color: #2aa198;">(</span>
&lt;div&gt;
    &lt;h1&gt;
        &lt;Logo /&gt; Welcome to Whinepad!
    &lt;/h1&gt;
    &lt;Excel headers=<span style="color: #b58900;">{</span>headers<span style="color: #b58900;">}</span> initialData=<span style="color: #b58900;">{</span>data<span style="color: #b58900;">}</span> /&gt;
&lt;/div&gt;,
document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">'pad'</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">The Components</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>重新使用Excel是一个非常好的开始,但是使用完以后,你会发现Excel整体作为一个component
实在是太大了,可以把Excel分成几个更小的component,然后可以发挥更大的作用
</li>
<li>除了Excel可以从自己内部分拆出来的component,我们还需要类似亚马逊的评分系统:
使用start来评分
</li>
<li>在React这种特别重视component的系统中,我们需要建立一个component测试系统,让一
个component能在比较"孤立"的状态下进行创作, 下面就是创建步骤
</li>
</ul>
</div>
<div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1">Setup</h4>
<div class="outline-text-4" id="text-6-2-1">
<ul class="org-ul">
<li>首先把加入Excel成功的代码重新命名成whinepad
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2-2" class="outline-4">
<h4 id="sec-6-2-2">Discover</h4>
<div class="outline-text-4" id="text-6-2-2">
<ul class="org-ul">
<li>复制index.html到discovery.html,我们的discovery.html是用来研究新component的
所以它不需要include太多js,我们这里只需要让它include特点的js,也就是discover-bundle.js
<div class="org-src-container">

<pre class="src src-js">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Whinepad&lt;/title&gt;
    &lt;meta charset=<span style="color: #2aa198;">"utf-8"</span>&gt;
    &lt;link rel=<span style="color: #2aa198;">"stylesheet"</span> type=<span style="color: #2aa198;">"text/css"</span> href=<span style="color: #2aa198;">"bundle.css"</span>&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=<span style="color: #2aa198;">"pad"</span>&gt;&lt;/div&gt;
    &lt;script src=<span style="color: #2aa198;">"discover-bundle.js"</span>&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
</li>
<li>我们还需要在script里面创建这个discover-bundel.js
<div class="org-src-container">

<pre class="src src-sh">browserify js/build/discover.js -o discover-bundle.js
</pre>
</div>
</li>
<li>我们discover.js里面也要有些代码,就把Logo先放进去
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> React from <span style="color: #2aa198;">'react'</span>;
<span style="color: #859900; font-weight: bold;">import</span> ReactDOM from <span style="color: #2aa198;">'react-dom'</span>;
<span style="color: #859900; font-weight: bold;">import</span> Logo from <span style="color: #2aa198;">'./components/Logo'</span>;


ReactDOM.render<span style="color: #2aa198;">(</span>
  &lt;div style=<span style="color: #b58900;">{</span><span style="color: #268bd2;">{</span>padding: <span style="color: #2aa198;">'20px'</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">}</span>&gt;
    &lt;h1&gt;Component discoverer&lt;/h1&gt;

    &lt;h2&gt;Logo&lt;/h2&gt;
    &lt;div style=<span style="color: #b58900;">{</span><span style="color: #268bd2;">{</span>display: <span style="color: #2aa198;">'inline-block'</span>, background: <span style="color: #2aa198;">'purple'</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">}</span>&gt;&lt;Logo/&gt;&lt;/div&gt;


  &lt;/div&gt;,
  document.getElementById<span style="color: #b58900;">(</span><span style="color: #2aa198;">'pad'</span><span style="color: #b58900;">)</span>
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2-3" class="outline-4">
<h4 id="sec-6-2-3">Button Component</h4>
<div class="outline-text-4" id="text-6-2-3">
<ul class="org-ul">
<li>先说button,是因为这是一个很简单的component,我们只准备加一个&lt;a&gt;到这个button
里面,所以其使用接口应该是.注意代码里面的()=&gt; alert('ouch')是ES2015的arrow function
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> Button from <span style="color: #2aa198;">'./components/Button'</span>;

    &lt;h2&gt;Buttons&lt;/h2&gt;
    &lt;div&gt; Button <span style="color: #859900; font-weight: bold;">with</span> onClick: &lt;Button onClick=<span style="color: #2aa198;">{</span> <span style="color: #b58900;">()</span> =&gt; alert<span style="color: #b58900;">(</span><span style="color: #2aa198;">'ouch'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">}</span>&gt; Click me &lt;/Button&gt;&lt;/div&gt;
    &lt;div&gt; A link: &lt;Button href=<span style="color: #2aa198;">"https://reactjs.com"</span>&gt;Follow me&lt;/Button&gt;&lt;/div&gt;
    &lt;div&gt; Custom clsss name: &lt;Button className=<span style="color: #2aa198;">"custom"</span>&gt; I <span style="color: #859900; font-weight: bold;">do</span> nothing&lt;/Button&gt;&lt;/div&gt;
</pre>
</div>
</li>
<li>css部分要放在/css/components/Button.css, 需要我们的,要能用的上,必须要求我
们的html 元素的className(本来是class)里面至少有一个Button
<div class="org-src-container">

<pre class="src src-css"><span style="color: #268bd2;">.Button </span><span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">background-color</span>: #6f001b;
  <span style="color: #268bd2;">border-radius</span>: 28px;
  <span style="color: #268bd2;">border</span>: 0;
  <span style="color: #268bd2;">box-shadow</span>: 0px 1px 1px #d9d9d9;
  <span style="color: #268bd2;">color</span>: #fff;
  <span style="color: #268bd2;">cursor</span>: pointer;
  <span style="color: #268bd2;">display</span>: inline-block;
  <span style="color: #268bd2;">font-size</span>: 18px;
  <span style="color: #268bd2;">font-weight</span>: bold;
  <span style="color: #268bd2;">padding</span>: 5px 15px;
  <span style="color: #268bd2;">text-decoration</span>: none;
  <span style="color: #268bd2;">transition-duration</span>: 0.1s;
  <span style="color: #268bd2;">transition-property</span>: transform;
<span style="color: #2aa198;">}</span>

<span style="color: #268bd2;">.Button:hover </span><span style="color: #2aa198;">{</span>
  <span style="color: #268bd2;">transform</span>: scale<span style="color: #b58900;">(</span>1.1<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>好了,我们要实现我们的button.js,注意,要让我们的Button至少有个className叫做
Button才能正常的使用我们的css,所以我们引入了一个叫做classNames的npm package
它所做的就是把parent通过props传递来的className加上我们必须拥有的'Button'返
回一个字符串给新创建的react component
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">cssclasses</span> = classNames<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'Button'</span>, props.className<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>我们来看看整个Button.js的代码
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> classNames from <span style="color: #2aa198;">'classnames'</span>;
<span style="color: #859900; font-weight: bold;">import</span> React, <span style="color: #2aa198;">{</span>PropTypes<span style="color: #2aa198;">}</span> from <span style="color: #2aa198;">'react'</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Button</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">props</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">cssclasses</span> = className<span style="color: #b58900;">(</span><span style="color: #2aa198;">'Button'</span>, props.className<span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> props.href
        ? &lt;a <span style="color: #b58900;">{</span>...props<span style="color: #b58900;">}</span> className=<span style="color: #b58900;">{</span>cssclasses<span style="color: #b58900;">}</span> /&gt;
        : &lt;button <span style="color: #b58900;">{</span>...props<span style="color: #b58900;">}</span> className=<span style="color: #b58900;">{</span>cssclasses<span style="color: #b58900;">}</span> /&gt;;
<span style="color: #2aa198;">}</span>

Button.propTypes = <span style="color: #2aa198;">{</span>
    href: PropTypes.string,
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">export</span> <span style="color: #859900; font-weight: bold;">default</span> Button
</pre>
</div>
</li>
<li>这段代码好多地方也非常难以理解, 比如Destructuring assignment,也就是这一句
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> React, <span style="color: #2aa198;">{</span>PropTypes<span style="color: #2aa198;">}</span> from <span style="color: #2aa198;">'react'</span>;
</pre>
</div>
</li>
<li>其实是如下两句的简写
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> React from <span style="color: #2aa198;">'react'</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">PropTypes</span> = React.PropTypes;
</pre>
</div>
</li>
<li>下面是函数式的时间了,如果你的component比较小,你可以不用维护它的state,那么
你可以使用一个function来解决, 前面说过的()=&gt;{}就起作用了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Button</span> = props =&gt; <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>我们的代码如果使用了ternary operator的话,那么就是one-line的,连{}都可以省略
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">Button</span> = props =&gt;
  props.href
   ? &lt;a <span style="color: #2aa198;">{</span>...props<span style="color: #2aa198;">}</span> className=<span style="color: #2aa198;">{</span>classNames<span style="color: #b58900;">(</span><span style="color: #2aa198;">'Button'</span>, props.className<span style="color: #b58900;">)</span><span style="color: #2aa198;">}</span> /&gt;
   : &lt;button <span style="color: #2aa198;">{</span>...props<span style="color: #2aa198;">}</span> className=<span style="color: #2aa198;">{</span>classNames<span style="color: #b58900;">(</span><span style="color: #2aa198;">'Button'</span>, props.className<span style="color: #b58900;">)</span><span style="color: #2aa198;">}</span> /&gt;
</pre>
</div>
</li>
<li>前面我们定义propTypes都是定义在object体内的
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">PropTypes</span> = React.PropTypes;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">Button</span> = React.createClass<span style="color: #2aa198;">(</span><span style="color: #b58900;">{</span>
    propTypes: <span style="color: #268bd2;">{</span>
        href: PropTypes.string
    <span style="color: #268bd2;">}</span>,
    <span style="color: #268bd2;">render</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">render */</span>
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>而新的class内部是只有function的,所以要在外部设置static的成员property
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> React, <span style="color: #2aa198;">{</span>Component, PropTypes<span style="color: #2aa198;">}</span> from <span style="color: #2aa198;">'react'</span>;

<span style="color: #859900; font-weight: bold;">class</span> Button <span style="color: #859900; font-weight: bold;">extends</span> Component <span style="color: #2aa198;">{</span>
    render<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">render */</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

Button.propTypes = <span style="color: #2aa198;">{</span>
    href: PropTypes.string,
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2-4" class="outline-4">
<h4 id="sec-6-2-4">Forms</h4>
<div class="outline-text-4" id="text-6-2-4">
<ul class="org-ul">
<li>我们下面创建自己的&lt;FormInput&gt; component,这个FormInput component可以根据type
的不同来决定"返回"怎样的更generic的component,比如&lt;Suggest&gt; input或者是&lt;Rating&gt; input
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2-5" class="outline-4">
<h4 id="sec-6-2-5">&lt;Suggest&gt;</h4>
<div class="outline-text-4" id="text-6-2-5">
<ul class="org-ul">
<li>在输入的时候,自动补全用户的输入是一种互联网常见的技术,我们这里不去考量后台
数据,所以我们的suggest选择是有限的,通过一个数组传入
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">h2</span>&gt;<span style="font-weight: bold; font-style: italic;">Suggest</span>&lt;/<span style="color: #268bd2;">h2</span>&gt;
&lt;<span style="color: #268bd2;">div</span>&gt;&lt;<span style="color: #268bd2;">Suggest</span> options={['eenie', 'meenie', 'miney', 'mo']} /&gt;&lt;/<span style="color: #268bd2;">div</span>&gt;
</pre>
</div>
</li>
<li>然后我们来实现这个js文件:js/source/components/Suggest.js
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> React, <span style="color: #2aa198;">{</span>Component, PropTypes<span style="color: #2aa198;">}</span> from <span style="color: #2aa198;">'react'</span>;

<span style="color: #859900; font-weight: bold;">class</span> Suggest <span style="color: #859900; font-weight: bold;">extends</span> Component <span style="color: #2aa198;">{</span>
    getValue<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>.refs.lowlevelinput.value;
    <span style="color: #b58900;">}</span>

    render<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">randomid</span> = Math.random<span style="color: #268bd2;">()</span>.toString<span style="color: #268bd2;">(</span>16<span style="color: #268bd2;">)</span>.substring<span style="color: #268bd2;">(</span>2<span style="color: #268bd2;">)</span>;
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2;">(</span>
                &lt;div&gt;
                &lt;input list=<span style="color: #6c71c4;">{</span>randomid<span style="color: #6c71c4;">}</span>
                       defaultValue=<span style="color: #6c71c4;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>.prop.defaultValue<span style="color: #6c71c4;">}</span>
                       ref=<span style="color: #2aa198;">"lowlevelinput"</span>
                       id=<span style="color: #6c71c4;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>.props.id<span style="color: #6c71c4;">}</span> /&gt;
                &lt;datalist id=<span style="color: #6c71c4;">{</span>randomid<span style="color: #6c71c4;">}</span>&gt; <span style="color: #6c71c4;">{</span>
                    <span style="color: #268bd2; font-weight: bold;">this</span>.props.options.map<span style="color: #859900;">(</span><span style="color: #b58900;">(</span>item, idx<span style="color: #b58900;">)</span> =&gt;
                    &lt;option value=<span style="color: #b58900;">{</span>item<span style="color: #b58900;">}</span> key=<span style="color: #b58900;">{</span>idx<span style="color: #b58900;">}</span> /&gt;
                    <span style="color: #859900;">)</span>
                    <span style="color: #6c71c4;">}</span>
                &lt;/datalist&gt;
                &lt;/div&gt;
        <span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

Suggest.propTyes = <span style="color: #2aa198;">{</span>
    options: PropTypes.arrayOf<span style="color: #b58900;">(</span>PropTypes.tring<span style="color: #b58900;">)</span>,
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">export</span> <span style="color: #859900; font-weight: bold;">default</span> Suggest
</pre>
</div>
</li>
<li>我们看到这个&lt;Suggest&gt;也没有什么不同的,不过是对&lt;input&gt;和&lt;datalist&gt;的一个包装
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2-6" class="outline-4">
<h4 id="sec-6-2-6">&lt;Rating&gt; Component</h4>
<div class="outline-text-4" id="text-6-2-6">
<ul class="org-ul">
<li>打分又是一个经常应用的component,我们对&lt;Rating&gt;的使用方法如下
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">h2</span>&gt;<span style="font-weight: bold; font-style: italic;">Rating</span>&lt;/<span style="color: #268bd2;">h2</span>&gt;
&lt;<span style="color: #268bd2;">div</span>&gt;No initial value: &lt;<span style="color: #268bd2;">Rating</span> /&gt;&lt;/<span style="color: #268bd2;">div</span>&gt;
&lt;<span style="color: #268bd2;">div</span>&gt;Initial Value 4: &lt;<span style="color: #268bd2;">Rating</span> defaultValue={4} /&gt;&lt;/<span style="color: #268bd2;">div</span>&gt;
&lt;<span style="color: #268bd2;">div</span>&gt;This one goes to 11 &lt;<span style="color: #268bd2;">Rating</span> max={11} /&gt;&lt;/<span style="color: #268bd2;">div</span>&gt;
&lt;<span style="color: #268bd2;">div</span>&gt;Read-only: &lt;<span style="color: #268bd2;">Rating</span> readonly={true} detaulValue={3} /&gt;&lt;/<span style="color: #268bd2;">div</span>&gt;
</pre>
</div>
</li>
<li>好了,我们来看看实现的主体框架方法
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> classNames from <span style="color: #2aa198;">'classnames'</span>;
<span style="color: #859900; font-weight: bold;">import</span> React, <span style="color: #2aa198;">{</span>Component, PropTypes<span style="color: #2aa198;">}</span> from <span style="color: #2aa198;">'react'</span>;

<span style="color: #859900; font-weight: bold;">class</span> Rating <span style="color: #859900; font-weight: bold;">extends</span> Component <span style="color: #2aa198;">{</span>
    constructor<span style="color: #b58900;">(</span>props<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">super</span><span style="color: #268bd2;">(</span>props<span style="color: #268bd2;">)</span>;
        <span style="color: #268bd2; font-weight: bold;">this</span>.state = <span style="color: #268bd2;">{</span>
            rating: props.defaultValue,
            tmpRating: props.defaultValue,
        <span style="color: #268bd2;">}</span>;
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">More methods</span>
    <span style="color: #b58900;">}</span>

    Rating.propTypes = <span style="color: #b58900;">{</span>
        defaultValue: PropTypes.number,
        readonly: PropTypes.bool,
        max: PropTypes.number,
    <span style="color: #b58900;">}</span>;

    Rating.defaultProps = <span style="color: #b58900;">{</span>
        defaultValue: 0,
        max: 5,
    <span style="color: #b58900;">}</span>;

    <span style="color: #859900; font-weight: bold;">export</span> <span style="color: #859900; font-weight: bold;">default</span> Rating
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们需要一些helper函数
<div class="org-src-container">

<pre class="src src-js">getValue<span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>.state.rating;
<span style="color: #2aa198;">}</span>

setTemp<span style="color: #2aa198;">(</span>rating<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #b58900;">(</span><span style="color: #268bd2;">{</span>tmpRating: rating<span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

setRating<span style="color: #2aa198;">(</span>rating<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #b58900;">(</span><span style="color: #268bd2;">{</span>
        tmpRating: rating,
        rating: rating,
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

reset<span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.setTemp<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.state.rating<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

componentWillReceiveProps<span style="color: #2aa198;">(</span>nextProps<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.setRating<span style="color: #b58900;">(</span>nextProps.defaultValue<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>最后是我们的render()函数的实现
<div class="org-src-container">

<pre class="src src-js">render<span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">stars</span> = <span style="color: #b58900;">[]</span>;
  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">i</span> = 1; i &lt;= <span style="color: #268bd2; font-weight: bold;">this</span>.props.max; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    stars.push<span style="color: #268bd2;">(</span>
      &lt;span
        className=<span style="color: #6c71c4;">{</span>i &lt;= <span style="color: #268bd2; font-weight: bold;">this</span>.state.tmpRating ? <span style="color: #2aa198;">'RatingOn'</span> : <span style="color: #268bd2; font-weight: bold;">null</span><span style="color: #6c71c4;">}</span>
        key=<span style="color: #6c71c4;">{</span>i<span style="color: #6c71c4;">}</span>
        onClick=<span style="color: #6c71c4;">{</span>!<span style="color: #268bd2; font-weight: bold;">this</span>.props.readonly &amp;&amp; <span style="color: #268bd2; font-weight: bold;">this</span>.setRating.bind<span style="color: #859900;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>, i<span style="color: #859900;">)</span><span style="color: #6c71c4;">}</span>
        onMouseOver=<span style="color: #6c71c4;">{</span>!<span style="color: #268bd2; font-weight: bold;">this</span>.props.readonly &amp;&amp; <span style="color: #268bd2; font-weight: bold;">this</span>.setTemp.bind<span style="color: #859900;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>, i<span style="color: #859900;">)</span><span style="color: #6c71c4;">}</span>
      &gt;
        &amp;#9734;
      &lt;/span&gt;<span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>
    &lt;div
      className=<span style="color: #268bd2;">{</span>classNames<span style="color: #6c71c4;">(</span><span style="color: #859900;">{</span>
        <span style="color: #2aa198;">'Rating'</span>: <span style="color: #268bd2; font-weight: bold;">true</span>,
        <span style="color: #2aa198;">'RatingReadonly'</span>: <span style="color: #268bd2; font-weight: bold;">this</span>.props.readonly,
      <span style="color: #859900;">}</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">}</span>
      onMouseOut=<span style="color: #268bd2;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>.reset.bind<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">this</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">}</span>
    &gt;
      <span style="color: #268bd2;">{</span>stars<span style="color: #268bd2;">}</span>
      <span style="color: #268bd2;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>.props.readonly || !<span style="color: #268bd2; font-weight: bold;">this</span>.props.id
        ? <span style="color: #268bd2; font-weight: bold;">null</span>
        : &lt;input
            type=<span style="color: #2aa198;">"hidden"</span>
            id=<span style="color: #6c71c4;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>.props.id<span style="color: #6c71c4;">}</span>
            value=<span style="color: #6c71c4;">{</span><span style="color: #268bd2; font-weight: bold;">this</span>.state.rating<span style="color: #6c71c4;">}</span> /&gt;
      <span style="color: #268bd2;">}</span>
    &lt;/div&gt;
  <span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>TODO
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Chapter 7. Lint, Flow, Test, Repeat</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>下一章会介绍Flux,是一种新的管理component之间通信的手段(它替代了原来的
onDataChange).所以我们要重新重构一下我们的代码,重构的过程,首先就要要求我们的
测试要完整,能够保证改动后的效果不变
</li>
</ul>
</div>
<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">package.json</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>你已经知道了npm可以安装依赖,其实npm也可以把你的依赖分享在npmjs.com上面
</li>
<li>而你从npm获取依赖的整个过程,可以记录在你的root文件夹下,形成一个叫做package.json的文件
</li>
<li>我们首先创建一个新的空文件夹, 然后创建空文件package.json
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #657b83; font-weight: bold;">cd</span> ~/reactbook/whinepad2
touch package.json
</pre>
</div>
</li>
<li>最简单的package.json内容就是package名字加上version信息
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">{</span>
    <span style="color: #2aa198;">"name"</span>: <span style="color: #2aa198;">"whinepad"</span>,
    <span style="color: #2aa198;">"version"</span>: <span style="color: #2aa198;">"2.0.0"</span>,
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-7-1-1" class="outline-4">
<h4 id="sec-7-1-1">Configure Babel</h4>
<div class="outline-text-4" id="text-7-1-1">
<ul class="org-ul">
<li>我们的命令原来需要使用babel来transpiler文件,所以大概需要如下的命令
<div class="org-src-container">

<pre class="src src-sh">babel --presets react,es2015 js/source -d js/build
</pre>
</div>
</li>
<li>我们可以把参数配置到package.json里面(也就是&#x2013;presets这个option)
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">{</span>
    <span style="color: #2aa198;">"name"</span>: <span style="color: #2aa198;">"whinepad"</span>,
    <span style="color: #2aa198;">"version"</span>: <span style="color: #2aa198;">"2.0.0"</span>,
    <span style="color: #2aa198;">"babel"</span>: <span style="color: #b58900;">{</span>
        <span style="color: #2aa198;">"presets"</span> : <span style="color: #268bd2;">[</span>
            <span style="color: #2aa198;">"es2015"</span>,
            <span style="color: #2aa198;">"react"</span>
        <span style="color: #268bd2;">]</span>
    <span style="color: #b58900;">}</span>,
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这样已配置,命令行就可以如下书写了
<div class="org-src-container">

<pre class="src src-sh">babel js/source -d js/build
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-1-2" class="outline-4">
<h4 id="sec-7-1-2">scripts</h4>
<div class="outline-text-4" id="text-7-1-2">
<ul class="org-ul">
<li>NPM是允许你把在root运行的script放到package json里面的
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">{</span>
    <span style="color: #2aa198;">"name"</span>: <span style="color: #2aa198;">"whinepad"</span>,
    <span style="color: #2aa198;">"version"</span>: <span style="color: #2aa198;">"2.0.0"</span>,
    <span style="color: #2aa198;">"babel"</span>: <span style="color: #b58900;">{</span>
        <span style="color: #2aa198;">"presets"</span> : <span style="color: #268bd2;">[</span>
            <span style="color: #2aa198;">"es2015"</span>,
            <span style="color: #2aa198;">"react"</span>
        <span style="color: #268bd2;">]</span>
    <span style="color: #b58900;">}</span>,
    <span style="color: #2aa198;">"script"</span>: <span style="color: #b58900;">{</span>
        <span style="color: #2aa198;">"watch"</span>: <span style="color: #2aa198;">"watch \"sh scripts/build.sh\" js/source css/"</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这样你就可以使用npm run watch啦
</li>
<li>当然了你甚至可以去掉build.sh,而把所有的配置工作都放到package.json里面
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">ESLint</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>ESLint是用来检查你的代码是不是有"潜在"的错误,还能检查你的代码风格是不是统一
</li>
</ul>
</div>
<div id="outline-container-sec-7-2-1" class="outline-4">
<h4 id="sec-7-2-1">Setup</h4>
<div class="outline-text-4" id="text-7-2-1">
<ul class="org-ul">
<li>eslint本身只是知道最基本的js的规范,如果你想用jsx, es2015等最新的规范,你需要
安装插件给它
<div class="org-src-container">

<pre class="src src-sh">npm i -g eslint eslint-plugin-react eslint-plugin-babel babel-eslint
</pre>
</div>
</li>
<li>然后你就可以在package.json里面利用它了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">{</span>
    <span style="color: #2aa198;">"name"</span>: <span style="color: #2aa198;">"whinepad"</span>,
    <span style="color: #2aa198;">"version"</span>: <span style="color: #2aa198;">"2.0.0"</span>,
    <span style="color: #2aa198;">"babel"</span>: <span style="color: #b58900;">{</span>
        <span style="color: #2aa198;">"presets"</span> : <span style="color: #268bd2;">[</span>
            <span style="color: #2aa198;">"es2015"</span>,
            <span style="color: #2aa198;">"react"</span>
        <span style="color: #268bd2;">]</span>
    <span style="color: #b58900;">}</span>,
    <span style="color: #2aa198;">"script"</span>: <span style="color: #b58900;">{</span>
        <span style="color: #2aa198;">"watch"</span>: <span style="color: #2aa198;">"watch \"sh scripts/build.sh\" js/source css/"</span>
    <span style="color: #b58900;">}</span>,
    <span style="color: #2aa198;">"eslintConfig"</span>: <span style="color: #b58900;">{</span>
        <span style="color: #2aa198;">"parser"</span>: <span style="color: #2aa198;">"babel-eslint"</span>,
        <span style="color: #2aa198;">"plugins"</span>: <span style="color: #268bd2;">[</span>
            <span style="color: #2aa198;">"babel"</span>,
            <span style="color: #2aa198;">"react"</span>
        <span style="color: #268bd2;">]</span>,
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>配置之后的使用就很简单了(因为不需要急着option)
<div class="org-src-container">

<pre class="src src-sh">$ eslint js/source/app.js
</pre>
</div>
</li>
<li>我们需要让这个命令没有一点问题的过,这很容易,因为现在没有太多规则,所以我们
要加上一点规则
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">"eslintConfig"</span>: <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">....</span>
    <span style="color: #2aa198;">"extends"</span>: <span style="color: #2aa198;">"eslint:recommended"</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>配置完这个规则以后,问题又来了,我们的eslint运行会报错
<div class="org-src-container">

<pre class="src src-sh">$ eslint js/source/app.js

/Users/hfeng/tmp/w2/js/source/app.js
   6:8   error  <span style="color: #2aa198;">'React'</span> is defined but never used     no-unused-vars
  12:26  error  <span style="color: #2aa198;">'localStorage'</span> is not defined         no-undef
  27:3   error  <span style="color: #2aa198;">'document'</span> is not defined             no-undef

&#10006; 3 problems <span style="color: #2aa198;">(</span>3 errors, 0 warnings<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>我们需要告诉eslint,我们是运行在brower里面的, 这些全局变量(document,
localStorage)在brower里面都是可见的.
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">"env"</span>: <span style="color: #2aa198;">{</span>
    <span style="color: #2aa198;">"browser"</span>:<span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>另外的React错误,就要用下面的代码来清除
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">"rules"</span>: <span style="color: #2aa198;">{</span>
    <span style="color: #2aa198;">"react/jsx-uses-react"</span>: 1
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>可能还会有其他的问题,总之再加上rule就可以了
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">Flow</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>js是一种动态语言,类型检查不是必须的,但是flow提供了这种功能,从一定程度上会避免很多低级的错误
</li>
</ul>
</div>
<div id="outline-container-sec-7-3-1" class="outline-4">
<h4 id="sec-7-3-1">Setup</h4>
<div class="outline-text-4" id="text-7-3-1">
<ul class="org-ul">
<li>我们使用如下命令来安装flow
<div class="org-src-container">

<pre class="src src-js">$ npm install -g flow-bin
</pre>
</div>
</li>
<li>然后初始化一个.flowconfig文件
<div class="org-src-container">

<pre class="src src-js">$ flow init
</pre>
</div>
</li>
<li>设置.flowconfig的ignore和include文件
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #2aa198;">[</span>ignore<span style="color: #2aa198;">]</span>
<span style="color: #657b83; font-weight: bold;">.</span>*/ract/node_modules/.*
<span style="color: #2aa198;">[</span>include<span style="color: #2aa198;">]</span>
node_modules/react
node_modules/react-dom
node_modules/classnames
<span style="color: #2aa198;">[</span>libs<span style="color: #2aa198;">]</span>

<span style="color: #2aa198;">[</span>options<span style="color: #2aa198;">]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-3-2" class="outline-4">
<h4 id="sec-7-3-2">Running</h4>
<div class="outline-text-4" id="text-7-3-2">
<ul class="org-ul">
<li>使用flow,或者指定一个文件来进行检查
<div class="org-src-container">

<pre class="src src-sh">$ flow
$ flow js/source/app.j
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-3-3" class="outline-4">
<h4 id="sec-7-3-3">Signing Up for Typechecking</h4>
<div class="outline-text-4" id="text-7-3-3">
<ul class="org-ul">
<li>必须在文件的最开头设置如下的comment,flow才会检查你
<div class="org-src-container">

<pre class="src src-js"><span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">@flow */</span>
</pre>
</div>
</li>
<li>TODO
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Chapter 8. Flux</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>本章介绍flux,这是一种管理components直接通信,以及app内部的data flow通信的框架
</li>
<li>前面的章节中,你已经了解到了最简单的一种通信方式:parent发送properties给child,
然后监听child的change(通过onDataChange)
</li>
<li>这种最简单的数据传递存在一个问题,那就是properties太多了,你无法有效管理和测试
</li>
<li>还有一个问题就是随着你应用的扩大,你以后会遇到properties从parent到child,从child
到grandchild..等等,这就会导致代码的重复(不满足DRY)
</li>
<li>Flux就是为了解决这些问题而诞生的, 它不是一个library,而且一种管理你app中data的
best practice
</li>
</ul>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">The Big Idea</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>解决问题的核心理念是你的app就关于data的, data是你app的全部核心.而我们在flux
里面,会把data存放在Store里面
</li>
<li>你的React component(View)从Store里面读取数据,然后把数据render到Store里面去
</li>
<li>app的用户会来perform Action(比如点击一下), 这个点击的过程(Action)会导致Store
里面的数据update, 然后会(自动)的导致View改动
</li>
<li>整个过程是如下的一个单项的data flow,这种模型更容易让人理解
<pre class="example">
           +------------+
           |  Action    |
           +------------+
           /            ^
          /              \
         /                \
        V                  \
+----------+            +-----------+
| Store    +-----------&gt;|  View     |
+----------+            +-----------+
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">Another Look at Whinepad</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>Whinepad有一个top-lvel的component叫做&lt;Whinepad&gt;
<div class="org-src-container">

<pre class="src src-web">&lt;Whinepad
    schema=<span style="color: #2aa198;">{</span>schema<span style="color: #2aa198;">}</span>
    initialData=<span style="color: #2aa198;">{</span>data<span style="color: #2aa198;">}</span> /&gt;
</pre>
</div>
</li>
<li>而Whinepad又可以包含其他component比如Excel
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">Excel</span>
   schema={this.props.schema}
   initialData={this.state.data}
   onDataChange={this._onExcelDataChange.build(this)} /&gt;
</pre>
</div>
</li>
<li>schema和initialData是两个初始化值,但是传递的时候,方法却不一样:
<ul class="org-ul">
<li>Whinepad传递了this.props.schema给child Excel的schema
</li>
<li>Whinepad却传递了this.state.data给child Excel的initialData,我们知道这个state
是很有可能改变的,那问题来了,谁来保存这些改变,谁来告诉我,哪个数据更新更准确
</li>
<li>从前面的章节你可以看到&lt;Whinepad&gt;包含了最新的data,但是React作为一个View层,
让它来保存数据,不是一个明智的选择
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">The Store</h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li>保存数据的部分,在flux里面叫做store,我们创建两个Flux module, Store和Action:
<div class="org-src-container">

<pre class="src src-sh">touch js/source/flux/CRUDStore.js
touch js/source/flux/CRUDActions.js
</pre>
</div>
</li>
<li>我们先来看看CRUDStore,这是一个和react完全没关系的js代码,说白了,其实它是一个
简单的JavaSript Object
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">data</span>;
<span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">schema</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">CRUDStore</span> = <span style="color: #2aa198;">{</span>
    getData<span style="color: #b58900;">()</span>: Array&lt;Object&gt; <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> data;
    <span style="color: #b58900;">}</span>,

    getSchema<span style="color: #b58900;">()</span>: Array&lt;Object&gt; <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> schema;
    <span style="color: #b58900;">}</span>,
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">export</span> <span style="color: #859900; font-weight: bold;">default</span> CRUDStore
</pre>
</div>
</li>
<li>我们可以看到Store保存了single source of truth,每个想要得到datat和schema的都
会得到满意的答案,因为给了借口getData和getSchema
</li>
<li>Store也会允许data进行update(schema不会更新,它们是app生命周期内都不会改变的
constant)
<div class="org-src-container">

<pre class="src src-js">setData<span style="color: #2aa198;">(</span>newData: Array&lt;Object&gt;, commit: <span style="color: #b58900;">boolean</span> = <span style="color: #268bd2; font-weight: bold;">true</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    data = newData;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>commit &amp;&amp; <span style="color: #2aa198;">'localStorage'</span> <span style="color: #859900; font-weight: bold;">in</span> window<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        localStorage.setItem<span style="color: #268bd2;">(</span><span style="color: #2aa198;">'data'</span>, JSON.stringify<span style="color: #6c71c4;">(</span>newData<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    emitter.emit<span style="color: #b58900;">(</span><span style="color: #2aa198;">'change'</span><span style="color: #b58900;">)</span>;

<span style="color: #2aa198;">}</span>,
</pre>
</div>
</li>
<li>这里,我们的setData函数更新了data,同时也会更新permanent storage(也就是数据库)
但是更新permanent storage的前提是commit这个boolean值是true,因为有些时候你是
不想更新permanent storage的,比如当搜索的时候,你会想显示API返回的搜索的结果,
但是并不想存储它们
</li>
<li>还有些辅助函数,比如返回data的长度,和返回一个record是否在我们的data里面
</li>
<li>我们还要在Store里面初始化自己
<div class="org-src-container">

<pre class="src src-js">init<span style="color: #2aa198;">(</span>initialSchema: Array&lt;Object&gt;<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    schema = initialSchema;
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">storage</span> = <span style="color: #2aa198;">'localStorage'</span> <span style="color: #859900; font-weight: bold;">in</span> window
          ? localStorage.getItem<span style="color: #b58900;">(</span><span style="color: #2aa198;">'data'</span><span style="color: #b58900;">)</span>
          : <span style="color: #268bd2; font-weight: bold;">null</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>!storage<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        data = <span style="color: #268bd2;">[</span><span style="color: #6c71c4;">{}</span><span style="color: #268bd2;">]</span>;
        schema.forEach<span style="color: #268bd2;">(</span>item =&gt; data<span style="color: #6c71c4;">[</span>0<span style="color: #6c71c4;">][</span>item.id<span style="color: #6c71c4;">]</span> = item.sample<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
        data = JSON.parse<span style="color: #268bd2;">(</span>storage<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们另外需要在app.js开头初始化store(调用init),然后我们的&lt;Whinepad&gt;就不再需
要带着properties啦,它会直接去调用CRUDStore.getData()和CRUDStore.getSchema()
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> CRUDStore from <span style="color: #2aa198;">'./flux/CRUDStore'</span>;
<span style="color: #859900; font-weight: bold;">import</span> Whinepad from <span style="color: #2aa198;">'./components/Whinepad'</span>;
<span style="color: #859900; font-weight: bold;">import</span> schema from <span style="color: #2aa198;">'./schema'</span>;

CRUDStore.init<span style="color: #2aa198;">(</span>schema<span style="color: #2aa198;">)</span>;


ReactDOM.render<span style="color: #2aa198;">(</span>
        &lt;div&gt;
        &lt;Whinepad /&gt;
        &lt;/div&gt;
<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-8-3-1" class="outline-4">
<h4 id="sec-8-3-1">Store Events</h4>
<div class="outline-text-4" id="text-8-3-1">
<ul class="org-ul">
<li>记得emitter.emit('chagne');这句么,这句户是说让所有关系data'改动'的UI,现在
他们可以读取我们新的data值,然后更新UI了
</li>
<li>有很多方法来实现这种event suscription pattern: 其核心就是收集一系列的subscriber
在一个list里面,然后当event发生的时候,从头到尾便利这个list,调用每个subscriber
的callback函数
</li>
<li>我们使用fbemitter来做这个部分
<div class="org-src-container">

<pre class="src src-sh">npm i --save-dev fbemitter
</pre>
</div>
</li>
<li>初始化很简单
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">{</span>EventEmitter<span style="color: #2aa198;">}</span> from <span style="color: #2aa198;">'fbemitter'</span>;

<span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">data</span>;
<span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">schema</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">emitter</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">EventEmitter</span><span style="color: #2aa198;">()</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
</pre>
</div>
</li>
<li>使用的时候就是两个部分啦:
<ul class="org-ul">
<li>collect subscription
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">CRUDStore</span> = <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
    addListener<span style="color: #b58900;">(</span>eventType: string, fn: Function<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        emitter.addListener<span style="color: #268bd2;">(</span>eventType, fn<span style="color: #268bd2;">)</span>
    <span style="color: #b58900;">}</span>,
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>notify subscriber,也就是我们前面的触发
<div class="org-src-container">

<pre class="src src-js">emitter.emit<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'change'</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-3-2" class="outline-4">
<h4 id="sec-8-3-2">Using the Store in &lt;Whinepad&gt;</h4>
<div class="outline-text-4" id="text-8-3-2">
<ul class="org-ul">
<li>在Flux里面, &lt;Whinepad&gt; component也是非常simpl的,因为:
<ol class="org-ol">
<li>大部分的功能都放入了CRUDActions里面
</li>
<li>我们连this.state.data都不需要维护了,因为this.state.data的唯一作用就是传
递给&lt;Excel&gt;,而现在&lt;Excel&gt;可以自己去Store里面取了
</li>
</ol>
</li>
<li>说了半天,Whinepad甚至可以不去和store有关系(让Excel有关系就可以了),但是为了
让我们的故事写下去,我们"强行"让Whine和store有点关系,那就是加个搜索框,来搜索
所有的record
</li>
<li>之前&lt;Whinepad&gt;的constructor()如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #268bd2; font-weight: bold;">this</span>.state = <span style="color: #2aa198;">{</span>
    data: props.initialData,
    addnew: <span style="color: #268bd2; font-weight: bold;">false</span>,
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>但是我们知道了,&lt;Whinepad&gt;不再需要data了,Excel可以自己去取,但是我们的search
需要显示总体有多少给record,所以我们"勉强"和store搭上了关系:要去取自己有多
少个record,所以
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> CRUDStore from <span style="color: #2aa198;">'../flux/CRUDStore'</span>;

<span style="color: #859900; font-weight: bold;">class</span> Whinepad <span style="color: #859900; font-weight: bold;">extends</span> Component <span style="color: #2aa198;">{</span>
    constructor<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">super</span><span style="color: #268bd2;">()</span>;
        <span style="color: #268bd2; font-weight: bold;">this</span>.state = <span style="color: #268bd2;">{</span>
            addnew: <span style="color: #268bd2; font-weight: bold;">false</span>,
            count: CRUDStore.getCount<span style="color: #6c71c4;">()</span>,
        <span style="color: #268bd2;">}</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>光从Store获得初始化的count还不够,还需要注册listener,当count的值变动的时候
store能够调用我们的callback函数来updateUI
<div class="org-src-container">

<pre class="src src-js">constructor<span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">super</span><span style="color: #b58900;">()</span>;
    <span style="color: #268bd2; font-weight: bold;">this</span>.state = <span style="color: #b58900;">{</span>
        addnew: <span style="color: #268bd2; font-weight: bold;">false</span>,
        count: CRUDStore.getCount<span style="color: #268bd2;">()</span>,
    <span style="color: #b58900;">}</span>;
    CRUDStore.addListener<span style="color: #b58900;">(</span><span style="color: #2aa198;">'change'</span>, <span style="color: #268bd2;">()</span> =&gt; <span style="color: #268bd2;">{</span>
        <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #6c71c4;">(</span><span style="color: #859900;">{</span>
            count: CRUDStore.getCount<span style="color: #b58900;">()</span>,
        <span style="color: #859900;">}</span><span style="color: #6c71c4;">)</span>
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们可以看到,我们的callback函数设置的是setState,也就是说,一旦count有变,那么
就自动的调用setState,那么render()也就自动会被调用,UI也就更新了,UI什么样?看
下面代码
<div class="org-src-container">

<pre class="src src-js">render<span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>
            &lt;input placeholder=<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.state.count === 1
                                ? <span style="color: #2aa198;">'Search 1 record...'</span>
                                : <span style="color: #2aa198;">`Search ${this.state.count} records...`</span>
                               <span style="color: #657b83; background-color: #fdf6e3;">}</span>
            /&gt;
    <span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>一个精细化的管理就是&lt;Whinepad&gt;来实现shouldComponentUpdate(),因为store的
emitter.emit被触发的原因,是任意一种change的改变,某些属性被edit也会触发
emitter.emit,但是这种情况下其实count是不变的,所以render()会白白计算一次diff
我们可以通过实现shouldComponentUpdate()来减轻react引擎的压力
<div class="org-src-container">

<pre class="src src-js">shouldComponentUpdate<span style="color: #2aa198;">(</span>newProps: Object, newState: State<span style="color: #2aa198;">)</span>: <span style="color: #b58900;">boolean</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>
        newState.addnew !== <span style="color: #268bd2; font-weight: bold;">this</span>.state.addnew ||
            newState.count !== <span style="color: #268bd2; font-weight: bold;">this</span>.state.count
    <span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>好了&lt;hine&gt;不需要传递schema和data给Excel了,也不需要onDataChagne了,因为Store
都会处理,所以最后的render函数非常简单
<div class="org-src-container">

<pre class="src src-js">render<span style="color: #2aa198;">(){</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
            &lt;div className=<span style="color: #2aa198;">"WhinepadDatagrid"</span>&gt;
            &lt;Excel /&gt;
            &lt;/div&gt;
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
    <span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-3-3" class="outline-4">
<h4 id="sec-8-3-3">Using the Store in &lt;Excel&gt;</h4>
<div class="outline-text-4" id="text-8-3-3">
<ul class="org-ul">
<li>Excel也同样不需要接受任何的参数来初始化自己,它可以去Store读取.同时Excel也
要注册event handler,以便store更新的情况下,自己能自动更改UI,新的Excel的
constructor如下
<div class="org-src-container">

<pre class="src src-js">constructor<span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">super</span><span style="color: #b58900;">()</span>;
    <span style="color: #268bd2; font-weight: bold;">this</span>.state = <span style="color: #b58900;">{</span>
        data: CRUDStore.getData<span style="color: #268bd2;">()</span>,
        sortby: <span style="color: #268bd2; font-weight: bold;">null</span>,
        descending: <span style="color: #268bd2; font-weight: bold;">false</span>,
        edit: <span style="color: #268bd2; font-weight: bold;">null</span>,
        dialog: <span style="color: #268bd2; font-weight: bold;">null</span>,
    <span style="color: #b58900;">}</span>;
    <span style="color: #268bd2; font-weight: bold;">this</span>.schema = CRUDStore.getSchema<span style="color: #b58900;">()</span>;
    CRUDStore.addListender<span style="color: #b58900;">(</span><span style="color: #2aa198;">'change'</span>, <span style="color: #268bd2;">()</span> =&gt; <span style="color: #268bd2;">{</span>
        <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #6c71c4;">(</span><span style="color: #859900;">{</span>
            date: CRUDStore.getData<span style="color: #b58900;">()</span>,
        <span style="color: #859900;">}</span><span style="color: #6c71c4;">)</span>
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-3-4" class="outline-4">
<h4 id="sec-8-3-4">Using the Store in &lt;Form&gt;</h4>
<div class="outline-text-4" id="text-8-3-4">
<ul class="org-ul">
<li>form component也是相似的道理,只不过它没有注册store的event listener因为它不
关心
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> CRUDStore from <span style="color: #2aa198;">'../flux/CRUDStore'</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
type Props = <span style="color: #2aa198;">{</span>
    readonly? : <span style="color: #b58900;">boolean</span>,
    recordId: ?number,
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">class</span> From <span style="color: #859900; font-weight: bold;">extends</span> Component <span style="color: #2aa198;">{</span>
    fields: Array&lt;Object&gt;;
    initialData: ?Object;

    constructor<span style="color: #b58900;">(</span>props: Props<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">super</span><span style="color: #268bd2;">(</span>props<span style="color: #268bd2;">)</span>;
        <span style="color: #268bd2; font-weight: bold;">this</span>.fields = CRUDStore.getSchema<span style="color: #268bd2;">()</span>;
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span><span style="color: #2aa198;">'recordId'</span> <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #268bd2; font-weight: bold;">this</span>.props<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            <span style="color: #268bd2; font-weight: bold;">this</span>.initialData = CRUDStore.getRecord<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.props.recordId<span style="color: #6c71c4;">)</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">export</span> <span style="color: #859900; font-weight: bold;">default</span> Form
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4">Actions</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li>action指的是Store里面的data是怎么改动的,当user和View进行了一下互动以后,其实
它们是更新了store,更新了store以后,所有跟store"报道"过的感兴趣的UI,都会更新
</li>
<li>创建一个Action非常简单
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> CRUDStore from <span style="color: #2aa198;">'./CRUDStore'</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">CRUDActions</span> = <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">methods</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">export</span> <span style="color: #859900; font-weight: bold;">default</span> CRUDActions
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-8-4-1" class="outline-4">
<h4 id="sec-8-4-1">CRUD Actions</h4>
<div class="outline-text-4" id="text-8-4-1">
<ul class="org-ul">
<li>CRUD Action其实就是实现CRUD里面的CUD: create, update, delete. Read不需要实
现,因为在Store里面实现了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">CRUDActions</span> = <span style="color: #2aa198;">{</span>
    create<span style="color: #b58900;">(</span>newRecord: Object<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">data</span> = CRUDStore.getData<span style="color: #268bd2;">()</span>;
        data.unshift<span style="color: #268bd2;">(</span>newRecord<span style="color: #268bd2;">)</span>;
        CRUDStore.setData<span style="color: #268bd2;">(</span>data<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>,

    <span style="color: #859900; font-weight: bold;">delete</span><span style="color: #b58900;">(</span>recordId: number<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">data</span> = CRUDStore.getData<span style="color: #268bd2;">()</span>;
        data.splice<span style="color: #268bd2;">(</span>recordId, 1<span style="color: #268bd2;">)</span>;
        CRUDStore.setData<span style="color: #268bd2;">(</span>data<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>,

    updateRecord<span style="color: #b58900;">(</span>recordId: number, newRecord: Object<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">data</span> = CRUDStore.getData<span style="color: #268bd2;">()</span>;
        data<span style="color: #268bd2;">[</span>recordId<span style="color: #268bd2;">]</span> = newRecord;
        CRUDStore.setData<span style="color: #268bd2;">(</span>data<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>,

    updateField<span style="color: #b58900;">(</span>recordId: number, key: string, value: string|number<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">data</span> = CRUDStore.getData<span style="color: #268bd2;">()</span>;
        data<span style="color: #268bd2;">[</span>recordId<span style="color: #268bd2;">][</span>key<span style="color: #268bd2;">]</span> = value;
        CRUDStore.setData<span style="color: #268bd2;">(</span>data<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>,
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-4-2" class="outline-4">
<h4 id="sec-8-4-2">Searching and Sorting</h4>
<div class="outline-text-4" id="text-8-4-2">
<ul class="org-ul">
<li>搜索和排序(对于Excel很重要),放在Action或者Store里面都OK,我们在这里认为Store
里面的数据尽可能的单调一点作为getter和setter的合集,其他的函数在action里面实现
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">CRUDActions</span> = <span style="color: #2aa198;">{</span>

  _preSearchData: <span style="color: #268bd2; font-weight: bold;">null</span>,

  startSearching<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>._preSearchData = CRUDStore.getData<span style="color: #268bd2;">()</span>;
  <span style="color: #b58900;">}</span>,

  search<span style="color: #b58900;">(</span>e: Event<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">target</span> = <span style="color: #268bd2;">(</span><span style="color: #6c71c4;">(</span>e.target: any<span style="color: #6c71c4;">)</span>: HTMLInputElement<span style="color: #268bd2;">)</span>;
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">needle</span>: string = target.value.toLowerCase<span style="color: #268bd2;">()</span>;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>!needle<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      CRUDStore.setData<span style="color: #6c71c4;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>._preSearchData<span style="color: #6c71c4;">)</span>;
      <span style="color: #859900; font-weight: bold;">return</span>;
    <span style="color: #268bd2;">}</span>
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">fields</span> = CRUDStore.getSchema<span style="color: #268bd2;">()</span>.map<span style="color: #268bd2;">(</span>item =&gt; item.id<span style="color: #268bd2;">)</span>;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>!<span style="color: #268bd2; font-weight: bold;">this</span>._preSearchData<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      <span style="color: #859900; font-weight: bold;">return</span>;
    <span style="color: #268bd2;">}</span>
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">searchdata</span> = <span style="color: #268bd2; font-weight: bold;">this</span>._preSearchData.filter<span style="color: #268bd2;">(</span>row =&gt; <span style="color: #6c71c4;">{</span>
      <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #859900;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">f</span> = 0; f &lt; fields.length; f++<span style="color: #859900;">)</span> <span style="color: #859900;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>row<span style="color: #268bd2;">[</span>fields<span style="color: #6c71c4;">[</span>f<span style="color: #6c71c4;">]</span><span style="color: #268bd2;">]</span>.toString<span style="color: #268bd2;">()</span>.toLowerCase<span style="color: #268bd2;">()</span>.indexOf<span style="color: #268bd2;">(</span>needle<span style="color: #268bd2;">)</span> &gt; -1<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
          <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
        <span style="color: #b58900;">}</span>
      <span style="color: #859900;">}</span>
      <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
    <span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span>;
    CRUDStore.setData<span style="color: #268bd2;">(</span>searchdata, <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">commit */</span> <span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>,

  _sortCallback<span style="color: #b58900;">(</span>a: <span style="color: #268bd2;">(</span>string|number<span style="color: #268bd2;">)</span>, b: <span style="color: #268bd2;">(</span>string|number<span style="color: #268bd2;">)</span>, descending: <span style="color: #b58900;">boolean</span><span style="color: #b58900;">)</span>: number <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">res</span>: number = 0;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">typeof</span> a === <span style="color: #2aa198;">'number'</span> &amp;&amp; <span style="color: #859900; font-weight: bold;">typeof</span> b === <span style="color: #2aa198;">'number'</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
      res = a - b;
    <span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #268bd2;">{</span>
      res = String<span style="color: #6c71c4;">(</span>a<span style="color: #6c71c4;">)</span>.localeCompare<span style="color: #6c71c4;">(</span>String<span style="color: #859900;">(</span>b<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> descending ? -1 * res : res;
  <span style="color: #b58900;">}</span>,

  sort<span style="color: #b58900;">(</span>key: string, descending: <span style="color: #b58900;">boolean</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    CRUDStore.setData<span style="color: #268bd2;">(</span>CRUDStore.getData<span style="color: #6c71c4;">()</span>.sort<span style="color: #6c71c4;">(</span>
      <span style="color: #859900;">(</span>a, b<span style="color: #859900;">)</span> =&gt; <span style="color: #268bd2; font-weight: bold;">this</span>._sortCallback<span style="color: #859900;">(</span>a<span style="color: #b58900;">[</span>key<span style="color: #b58900;">]</span>, b<span style="color: #b58900;">[</span>key<span style="color: #b58900;">]</span>, descending<span style="color: #859900;">)</span>
    <span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>,
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">export</span> <span style="color: #859900; font-weight: bold;">default</span> CRUDActions
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-4-3" class="outline-4">
<h4 id="sec-8-4-3">Using the Actions in &lt;Whinepad&gt;</h4>
<div class="outline-text-4" id="text-8-4-3">
<ul class="org-ul">
<li>我们再来看看在Action引入之后的&lt;Whinepad&gt;如何利用这些action, 整体上来说,就是
一个import啦
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> CRUDActions from <span style="color: #2aa198;">'../flux/CRUDActions'</span>;

<span style="color: #859900; font-weight: bold;">class</span> Whinepad <span style="color: #859900; font-weight: bold;">extends</span> Component <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">... */</span><span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">export</span> <span style="color: #859900; font-weight: bold;">default</span> Whinepad
</pre>
</div>
</li>

<li>如果要加一个record,Whinepad之前要负责保存和更新自己的this.state.data:
<div class="org-src-container">

<pre class="src src-js">_addNew<span style="color: #2aa198;">(</span>action: string<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>action === <span style="color: #2aa198;">'dismiss'</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">{</span>addnew: <span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">data</span> = Array.from<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.state.data<span style="color: #268bd2;">)</span>;
        data.unshift<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.refs.from.getData<span style="color: #6c71c4;">()</span><span style="color: #268bd2;">)</span>;
        <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">{</span>
            addnew: <span style="color: #268bd2; font-weight: bold;">false</span>,
            data: data,
        <span style="color: #6c71c4;">}</span><span style="color: #268bd2;">)</span>;
        shit._commitToStorage<span style="color: #268bd2;">(</span>data<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>现在,一切的一切都交给Store就可以了
<div class="org-src-container">

<pre class="src src-js">_addNew<span style="color: #2aa198;">(</span>action: string<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.setState<span style="color: #b58900;">(</span><span style="color: #268bd2;">{</span>addnew: <span style="color: #268bd2; font-weight: bold;">false</span><span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>action === <span style="color: #2aa198;">'confirm'</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        CRUDAcations.create<span style="color: #268bd2;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>.refs.form.getData<span style="color: #6c71c4;">()</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>search也一样,核心就是我们不在维护state,不在维护data,都交给store去处理
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5">Flux Recap</h3>
<div class="outline-text-3" id="text-8-5">
<ul class="org-ul">
<li>以上就是我们对react的改写,加入了flux的支持
</li>
<li>我们所做的其实是:
<ul class="org-ul">
<li>View通过Action更新同一个Store
</li>
<li>而这个Store改动后,会发event,调用View的call back来更新view
</li>
</ul>
</li>
<li>这其实就是一个环
<pre class="example">
           +------------+
           |  Action    |
           +------------+
           /            ^
          /              \
         /                \
        V                  \
+----------+            +-----------+
| Store    +-----------&gt;|  View     |
+----------+            +-----------+
</pre>
</li>
<li>当然了如果我们在页面更改的时候,还有其他方法能够触动数据库,那么,我们还会创建
一种"额外"的action来触动store
<pre class="example">
                                   +------------+
                                   |  Action    |
                                   +------------+
                                   /            ^
                                  /              \
                                 /                \
                                V                  \
+------------+          +----------+            +-----------+
|  Action    +---------&gt;| Store    +-----------&gt;|  View     |
+------------+          +----------+            +-----------+
</pre>
</li>
<li>一旦有多个action的话,那么上面的问题就不那么简单了,为了数据安全的要求,你要有
以个dispatch而来协调多个action,于是就变成这样
<pre class="example">
                            +------------+
                            |  Action    |
                            +------------+
                            /            ^
                           /              \
                          /                \
                         V                  \
+--------+     +----------+     +------+    +-----------+
| Action +-----|Dispatcher|----&gt;|Store +---&gt;|  View     |
+--------+     +----------+     +------+    +-----------+
</pre>
</li>
<li>而上面的图更有可能随着项目的扩展除了Dispatcher都变成多份!!这种情况下就更需
要好的架构来处理
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-6" class="outline-3">
<h3 id="sec-8-6">Immutable</h3>
<div class="outline-text-3" id="text-8-6">
<ul class="org-ul">
<li>所谓immutable object,就是一旦创建不可改变的object,immutable object总是理解
起来简单,而且容易debug,也易于多线程的处理.
</li>
<li>在JS里面,你可以使用immutable package来实现immutable
</li>
</ul>
</div>
<div id="outline-container-sec-8-6-1" class="outline-4">
<h4 id="sec-8-6-1">Immutable Store Data</h4>
<div class="outline-text-4" id="text-8-6-1">
<ul class="org-ul">
<li>immutable提供了几种data structure,比如List, Stack, Map,我们先来看一个List
的例子, List和js内置的array很像
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">{</span>EventEmitter<span style="color: #2aa198;">}</span> from <span style="color: #2aa198;">'fbemitter'</span>;
<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #2aa198;">{</span>List<span style="color: #2aa198;">}</span> from <span style="color: #2aa198;">'immutable'</span>;

<span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">data</span>: List&lt;Object&gt;;
<span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">schema</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">emitter</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">EventEmitter</span><span style="color: #2aa198;">()</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">CRUDStore</span> = <span style="color: #2aa198;">{</span>
    init<span style="color: #b58900;">(</span>initialSchema: Array&lt;Object&gt;<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        schema = initialSchema;

        <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">storage</span> = <span style="color: #2aa198;">'localStorage'</span> <span style="color: #859900; font-weight: bold;">in</span> window
              ? localStorage.getItem<span style="color: #268bd2;">(</span><span style="color: #2aa198;">'data'</span><span style="color: #268bd2;">)</span>
              : <span style="color: #268bd2; font-weight: bold;">null</span>;
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>!storage<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">initialRecord</span> = <span style="color: #6c71c4;">{}</span>;
            schema.forEach<span style="color: #6c71c4;">(</span>item =&gt; initialRecord<span style="color: #859900;">[</span>item.id<span style="color: #859900;">]</span> = item.sample<span style="color: #6c71c4;">)</span>;
            data = List<span style="color: #6c71c4;">(</span><span style="color: #859900;">[</span>initialRecord<span style="color: #859900;">]</span><span style="color: #6c71c4;">)</span>;
        <span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #268bd2;">{</span>
            data = List<span style="color: #6c71c4;">(</span>JSON.parse<span style="color: #859900;">(</span>storage<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>,
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>我们可以看到List是使用array来初始化的.但是有些许不同, 比如:
<ul class="org-ul">
<li>没有data.length了,要使用data.count()
</li>
<li>不能使用[] operator比如data[recordId],而要使用data.get(recordId)
</li>
</ul>
</li>
<li>既然是从immutable package来的容器,这个容器自然就是不能改变的啦!不能改变的
怎么使用?如果对java有所了解的同学就会知道,为了提供更好的并发性能,java里面的
的immutable每次改动都会生成一个新的对象
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-6-2" class="outline-4">
<h4 id="sec-8-6-2">Immutable Data Manipulation</h4>
<div class="outline-text-4" id="text-8-6-2">
<ul class="org-ul">
<li>我们来看看immutable list的使用方法
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">list</span> = List<span style="color: #2aa198;">(</span><span style="color: #b58900;">[</span>1, 2<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;
<span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">newlist</span> = list.push<span style="color: #2aa198;">(</span>3, 4<span style="color: #2aa198;">)</span>;

list.size;                      <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2</span>
newlist.size;                   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4</span>
list.toArray<span style="color: #2aa198;">()</span>;                 <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Array [1, 2]</span>
newlist.toArray<span style="color: #2aa198;">()</span>;              <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Array [1, 2, 3, 4]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
