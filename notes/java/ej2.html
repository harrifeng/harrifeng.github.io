<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>ej2</title>
<!-- 2017-05-02 Tue 10:49 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">ej2</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 2: Creating and Destroying Objects</a>
<ul>
<li><a href="#sec-1-1">Item 1: Consider static factory methods instead of constructors</a></li>
<li><a href="#sec-1-2">Item 2: Consider a builder when faced with many constructor parameters</a></li>
<li><a href="#sec-1-3">Item 3: Enforce the singleton property with a private constructor or an enum type</a></li>
<li><a href="#sec-1-4">Item 4: Enforce noninstantiability with a private constructor</a></li>
<li><a href="#sec-1-5">Item 5: Avoid creating unnecessary objects</a></li>
<li><a href="#sec-1-6">Item 6: Eliminate obsolete object references</a></li>
<li><a href="#sec-1-7">Item 7: Avoid finalizers</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 3: Methods Common to All Objects</a>
<ul>
<li><a href="#sec-2-1">Item 8: Obey the general contract when overriding equals</a></li>
<li><a href="#sec-2-2">Item 9: Always override hashCode when you override equals</a></li>
<li><a href="#sec-2-3">Item 10: Always override toString</a></li>
<li><a href="#sec-2-4">Item 11: Override clone judiciously</a></li>
<li><a href="#sec-2-5">Item 12: Consider implementing Comparable</a></li>
</ul>
</li>
<li><a href="#sec-3">Chapter 4: Classes and Interfaces</a>
<ul>
<li><a href="#sec-3-1">Item 13: Minimize the accessibility of classes and members</a></li>
<li><a href="#sec-3-2">Item 14: In public classes, use accessor methods, not public fields</a></li>
<li><a href="#sec-3-3">Item 15: Minimize mutability</a></li>
<li><a href="#sec-3-4">Item 16: Favor composition over inheritance</a></li>
<li><a href="#sec-3-5">Item 17: Design and document for inheritane or else prohibit it</a></li>
<li><a href="#sec-3-6">Item 18: Perfer interfaces to abstract classes</a></li>
<li><a href="#sec-3-7">Item 19: Use interfaces only to define types</a></li>
<li><a href="#sec-3-8">Item 20: Prefer class hierarchies to tagged classes</a></li>
<li><a href="#sec-3-9">Item 21: Use function objects to represent strategies</a></li>
<li><a href="#sec-3-10">Item 22: Favor static member classes over nonstatic</a></li>
</ul>
</li>
<li><a href="#sec-4">Chapter 5: Generics</a>
<ul>
<li><a href="#sec-4-1">Item 23: Don't use raw types in new code</a></li>
<li><a href="#sec-4-2">Item 24: Eliminate unchecked warnings</a></li>
<li><a href="#sec-4-3">Item 25: Prefer lists to arrays</a></li>
<li><a href="#sec-4-4">Item 26: Favor generic types</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 2: Creating and Destroying Objects</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Item 1: Consider static factory methods instead of constructors</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>class实例化的常规做法是使用public ctor, 但是class提供一个public static factory
method给client使用是更好的办法
</li>
<li>比如为class Boolean是使用下面的办法把一个boolean primitive值转化成Boolean
object reference的
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">Boolean</span> <span style="color: #268bd2;">valueOf</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">boolean</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> b ? <span style="color: #268bd2; font-weight: bold;">Boolean</span>.TRUE : <span style="color: #268bd2; font-weight: bold;">Boolean</span>.FALSE;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>需要注意的是static factory method和设计模式里面的"Factory Method"没有直接联系
</li>
<li>使用static factory method是优缺点并存的:
<ul class="org-ul">
<li>优点1是: 和ctor不同的是static factory method是有名字的. 比起ctor来就更容
易使用
</li>
<li>优点2是: 和ctor不同, static factory method不需要每次都创建新的object: 这
个特点可以被immutable class使用来"预先创建instance"(preconstructed instances),
或者是cache他们已经创建的对象.比如Boolean.valueOf(boolean)就是这样(因为这
个函数是返回已经创建的instance,从来不会新创建instance
</li>
<li>优点3是: static factory method可以:
<ol class="org-ol">
<li>返回"函数返回类型"的"子类的object".
</li>
<li>返回的object,其class是private的
</li>
</ol>
</li>
<li>我们以Collection为例子来看看
<ol class="org-ol">
<li>首先, Collection是一个interface
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #b58900;">Collection</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">E</span><span style="color: #2aa198;">&gt;</span> <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900;">Iterable</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">E</span><span style="color: #2aa198;">&gt;</span>
</pre>
</div>
</li>
<li>其次, Collections是一个class,而且private ctor
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Collections</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Suppresses default constructor, ensuring non-instantiability.</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #268bd2;">Collections</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">}</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">....</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>Collections里面都是返回一些继承Collection interface的interface, 比如List
就是在函数定义返回值的时候,定义了一些'父类'(List).实际返回的时候,可以
根据情况返回'子类'(UnmodifiableRandomAccessList或者UnmodifiableList)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">T</span><span style="color: #2aa198;">&gt;</span> <span style="color: #b58900;">List</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">T</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">unmodifiableList</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">List</span><span style="color: #b58900;">&lt;</span>? <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900;">T</span><span style="color: #b58900;">&gt;</span> <span style="color: #268bd2;">list</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">(</span>list <span style="color: #859900; font-weight: bold;">instanceof</span> RandomAccess ?
            <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">UnmodifiableRandomAccessList</span><span style="color: #268bd2;">&lt;&gt;(</span>list<span style="color: #268bd2;">)</span> :
            <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">UnmodifiableList</span><span style="color: #268bd2;">&lt;&gt;(</span>list<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>Collections里面,会返回一些private的class的object. 就是通过我们的static
factory method.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">K</span>,<span style="color: #b58900;">V</span><span style="color: #2aa198;">&gt;</span> <span style="color: #b58900;">Map</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">K</span>,<span style="color: #b58900;">V</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">synchronizedMap</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Map</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">K</span>,<span style="color: #b58900;">V</span><span style="color: #b58900;">&gt;</span> <span style="color: #268bd2;">m</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">SynchronizedMap</span><span style="color: #b58900;">&lt;&gt;(</span>m<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #2aa198;">/**</span>
<span style="color: #2aa198;">  * </span><span style="color: #268bd2; font-weight: bold;">@serial</span><span style="color: #2aa198;"> include</span>
<span style="color: #2aa198;">  */</span>
<span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">SynchronizedMap</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">K</span>,<span style="color: #b58900;">V</span><span style="color: #2aa198;">&gt;</span>
    <span style="color: #859900; font-weight: bold;">implements</span> <span style="color: #b58900;">Map</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">K</span>,<span style="color: #b58900;">V</span><span style="color: #2aa198;">&gt;</span>, <span style="color: #b58900;">Serializable</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">serialVersionUID</span> = 1978198479659022715L;
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ol>
</li>
<li>从上面的例子可以看出, static factory method设计出来的代码,用户能够知道的就
是返回值是一个接口(父类), 而不用去关心其具体到底底层是什么实现,这通常来说
都是良好的设计实践: 因为下一个版本,我甚至是可以更改底层的实现,但是对用户来
说没有影响,因为原来只承诺了接口
</li>
<li>#TODO#
</li>
<li>优点4是:创建instance的时候,可以减少冗长的参数:
<ol class="org-ol">
<li>最开始是这样创建一个map
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">Map</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">String</span>, <span style="color: #b58900;">List</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">String</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">m</span> =
    <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">HashMap</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">String</span>, <span style="color: #b58900;">List</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">String</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;()</span>;
</pre>
</div>
</li>
<li>使用了static factory method后,可以简化成这样
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">Map</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">String</span>, <span style="color: #b58900;">List</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">String</span><span style="color: #b58900;">&gt;</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">m</span> = HashMap.newInstance<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>static factory method当然得如外提供啦
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">K</span>, <span style="color: #b58900;">V</span><span style="color: #2aa198;">&gt;</span> <span style="color: #b58900;">HashMap</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">K</span>, <span style="color: #b58900;">V</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">newInstance</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">HashMap</span><span style="color: #b58900;">&lt;</span><span style="color: #b58900;">K</span>, <span style="color: #b58900;">V</span><span style="color: #b58900;">&gt;()</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ol>
</li>
</ul>
</li>
<li>当然了,缺点也是存在的:
<ul class="org-ul">
<li>缺点1: 如果只依靠static factory method的话,那么ctor就是private的,所以他们
就无法被实例化
</li>
<li>缺点2: static factory method和其他的static函数没有明显区别,所以用户想用来
创建instance的时候,往往很难寻找.下面是我们建议的几个名字:
<ol class="org-ol">
<li>valueOf:返回一个和它参数一样的instance,通常用来类型转换
</li>
<li>of: 是valueOf的另外一种称呼
</li>
<li>getInstance: 如果有参数,那么就返回跟参数描述一致的instance. 如果是单例
模式(Singleton中), 那么就是没有参数,返回唯一存在的instance
</li>
<li>newInsstance: 和getInstance一样,不过保证返回的instance和其他的instance
完全不同
</li>
<li>getType: 返回值为Type类型的getInstance
</li>
<li>newType: 返回值为Type类型的newInstance
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Item 2: Consider a builder when faced with many constructor parameters</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>固定参数的ctor和item1介绍的factory来初始化object的时候,有一个致命的缺点:在
参数很多的情况下,扩展行不好,很容易用错.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Does not scale well!</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">NutritionFacts</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servingSize</span>;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">required</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servings</span>;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">required</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">calories</span>;        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">optional</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">fat</span>;             <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">optional</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sodium</span>;          <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">optional</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">carbohydrate</span>;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">optional</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">NutritionFacts</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">servingSize</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servings</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">this</span><span style="color: #268bd2;">(</span>servingSize, servings, 0<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">NutritionFacts</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">servingSize</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servings</span>,
                          <span style="color: #b58900;">int</span> <span style="color: #268bd2;">calories</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">this</span><span style="color: #268bd2;">(</span>servingSize, servings, calories, 0<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">NutritionFacts</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">servingSize</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servings</span>,
                          <span style="color: #b58900;">int</span> <span style="color: #268bd2;">calories</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">fat</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">this</span><span style="color: #268bd2;">(</span>servingSize, servings, calories, fat, 0<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">NutritionFacts</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">servingSize</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servings</span>,
                          <span style="color: #b58900;">int</span> <span style="color: #268bd2;">calories</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">fat</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sodium</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">this</span><span style="color: #268bd2;">(</span>servingSize, servings, calories, fat, sodium, 0<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">NutritionFacts</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">servingSize</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servings</span>,
                          <span style="color: #b58900;">int</span> <span style="color: #268bd2;">calories</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">fat</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sodium</span>,
                          <span style="color: #b58900;">int</span> <span style="color: #268bd2;">carbohydrate</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">this</span>.servingSize       = servingSize;
        <span style="color: #859900; font-weight: bold;">this</span>.servings          = servings;
        <span style="color: #859900; font-weight: bold;">this</span>.calories          = calories;
        <span style="color: #859900; font-weight: bold;">this</span>.fat               = fat;
        <span style="color: #859900; font-weight: bold;">this</span>.sodium            = sodium;
        <span style="color: #859900; font-weight: bold;">this</span>.carbohydrate      = carbohydrate;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>上面的例子中有两个必要的域,四个可选的域, 然后就出现了下面的实现方式: 多个ct
or,然后每个ctor里面去调用"下一个ctor", 这种方法叫做
<pre class="example">
telescoping constructor pattern (重叠构造器模式)
</pre>
</li>
<li>telescoping ctor的缺点有很多:
<ul class="org-ul">
<li>ctor非常难以书写,像绕口令一样
</li>
<li>非常难以阅读
</li>
<li>容易用错(特别是参数太多,不小心交换位置的情况,编译器不会报错)
</li>
</ul>
</li>
<li>除了telescoping 模式以外,在多参数的class里面,我们还可以通过JavaBean模式来设
置:设置一个没参赛的ctor,然后分别使用函数设置成员变量
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">NutritionFacts</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Parameters initialized to default values (if any)</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servingSize</span>   = -1; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Required; no default value</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servings</span> = -1;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">calories</span> = 0;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">fat</span>      = 0;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sodium</span>   = 0;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">carbohydrate</span>  = 0;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">NutritionFacts</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> <span style="color: #b58900;">}</span>

    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Setters</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">setServingSize</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">val</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        servingSize = val;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">setServings</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">val</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        servingSize = val;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">setCalories</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">val</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        calories = val;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">setFat</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">val</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        fat = val;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">setSodium</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">val</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        sodium = val;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">setCarbohydrate</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">val</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        carbohydrate = val;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>不幸的是JavaBean模式有着非常严重的缺点:
<ul class="org-ul">
<li>JavaBean模式可能在"构建"的过程中,经历inconsistent state的状态
</li>
<li>由于inconsistent state的存在, immutable class就变得不再可能
</li>
<li>需要额外的工作来保证程序的线程安全
</li>
</ul>
</li>
<li>在现有的Java语言特点下,多参数(并且很多是optional参数的)ctor的最佳实践是:
Builder pattern
</li>
<li>下面是builder pattern的一个例子
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">NutritionFacts</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servingSize</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servings</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">calories</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">fat</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sodium</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">carbohydrate</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Builder</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Required parameters</span>
        <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servingSize</span>;
        <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servings</span>;

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Optional parameters - initialized to default values</span>
        <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">calories</span>       = 0;
        <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">fat</span>            = 0;
        <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">carbohydrate</span>   = 0;
        <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">sodium</span>         = 0;

        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">Builder</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">servingSize</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">servings</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            <span style="color: #859900; font-weight: bold;">this</span>.servingSize = servingSize;
            <span style="color: #859900; font-weight: bold;">this</span>.servings = servings;
        <span style="color: #268bd2;">}</span>

        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Builder</span> <span style="color: #268bd2;">calories</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">val</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            calories = val;
            <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">this</span>;
        <span style="color: #268bd2;">}</span>

        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Builder</span> <span style="color: #268bd2;">fat</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">val</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            fat = val;
            <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">this</span>;
        <span style="color: #268bd2;">}</span>

        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Builder</span> <span style="color: #268bd2;">carbohydrate</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">val</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            carbohydrate = val;
            <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">this</span>;
        <span style="color: #268bd2;">}</span>

        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Builder</span> <span style="color: #268bd2;">sodium</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">val</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            sodium = val;
            <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">this</span>;
        <span style="color: #268bd2;">}</span>

        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">NutritionFacts</span> <span style="color: #268bd2;">build</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
            <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">NutritionFacts</span><span style="color: #6c71c4;">(</span><span style="color: #859900; font-weight: bold;">this</span><span style="color: #6c71c4;">)</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #268bd2;">NutritionFacts</span><span style="color: #b58900;">(</span><span style="color: #b58900;">Builder</span> <span style="color: #268bd2;">builder</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        servingSize   = builder.servingSize;
        servings      = builder.servings;
        calories      = builder.calories;
        fat           = builder.fat;
        sodium        = builder.sodium;
        carbohydrate  = builder.carbohydrate;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>使用方法如下
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">NutritionFacts</span> <span style="color: #268bd2;">cocaCola</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #268bd2; font-weight: bold;">NutritionFacts</span>.<span style="color: #b58900;">Builder</span><span style="color: #2aa198;">(</span>240, 8<span style="color: #2aa198;">)</span>.
    calories<span style="color: #2aa198;">(</span>100<span style="color: #2aa198;">)</span>.sodium<span style="color: #2aa198;">(</span>35<span style="color: #2aa198;">)</span>.carbohydrate<span style="color: #2aa198;">(</span>27<span style="color: #2aa198;">)</span>.build<span style="color: #2aa198;">()</span>
</pre>
</div>
</li>
<li>Java的代码的确就是长啊,说白了,这就是模拟python的"Optional parameter &amp; Named  paramter"
<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">info</span><span style="color: #2aa198;">(</span><span style="color: #657b83; font-weight: bold;">object</span>, spacing=10, collapse=1<span style="color: #2aa198;">)</span>:
<span style="background-color: #eee8d5;"> </span>   <span style="color: #859900; font-weight: bold;">pass</span>

<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">With only one argument, spacing gets its default value of 10 and collapse gets</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">its default value of 1</span>
info<span style="color: #2aa198;">(</span>odbchelper<span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">With two arguments, collapse gets it default value of 1</span>
info<span style="color: #2aa198;">(</span>odbchelper, 12<span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Here you are naming the collapse argument explicitly and specifying its value,</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">spacing still gets its default value of 10</span>
info<span style="color: #2aa198;">(</span>odbchelper, collapse=0<span style="color: #2aa198;">)</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">Even required arguments(like object, which has no defult value) can be named,</span>
<span style="color: #93a1a1;"># </span><span style="color: #93a1a1;">and named arguments can appear in any order</span>
info<span style="color: #2aa198;">(</span>spacing=15, <span style="color: #657b83; font-weight: bold;">object</span>=odbchelper<span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>#TODO#
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Item 3: Enforce the singleton property with a private constructor or an enum type</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>所谓singleton就是某种只能实例化一次的class. 某些系统组件(比如Windows manager)
是唯一的,重复实例化它们没有意义
</li>
<li>在java1.5以前,我们有两种方法来实现singleton:
<ul class="org-ul">
<li>方法一:把ctor设置为private, 但是把自己的public static member露出来. (private
的ctor可能会被调用的方法只有一个就是AccessibleObject.setAccessible的帮助.
如果很小心的用户,可以通过设置ctor被两次调用就抛异常来解决这个问题)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Elvis</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Elvis</span> <span style="color: #268bd2;">INSTANCE</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Elvis</span><span style="color: #b58900;">()</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #268bd2;">Elvis</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">leaveTheBuilding</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">..</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>方法二:和方法一类似只不过露出来的是static factory method(item1介绍)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Singleton with static factory</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Elvis</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Elvis</span> <span style="color: #268bd2;">INSTANCE</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Elvis</span><span style="color: #b58900;">()</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #268bd2;">Elvis</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">Elvis</span> <span style="color: #268bd2;">getInstance</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> INSTANCE;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">leaveTheBuilding</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>public member的方法仅仅是让用户更容易理解自己"singleton"的形象而已,在效率上
面没有提高,因为
<pre class="example">
Modern JVM implementations are almost certain to inline the call to the static factory method
</pre>
</li>
<li>而static factory method暴露了接口,没有暴露内部实现,更利于以后修改.比如,以后
可以为每一个thread都返回一个unique的instance.
</li>
<li>static factory method的方法还有利于generic type
</li>
<li>但是,static factory method的两种优点都不是很重要,所以,还是使用public 成员的
方法应用更为广泛.
</li>
<li>上面两种方法无论使用哪一种,如果实现了Serializable接口,都要做下面的操作来防止
singleton状态"在反序列化的时候"被破坏:
<ul class="org-ul">
<li>把所有变量声明为transient
</li>
<li>提供一个readResolve函数
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">Object</span> <span style="color: #268bd2;">readResolve</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Return the one true Elvis and let the argabe collector</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">take care of the Elvis imersonator.</span>
    <span style="color: #859900; font-weight: bold;">return</span> INSTANCE;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>到了java1.5以后,使用"单元素枚举类型"来实现singleton是best practice. 他不仅
形式简单,还可以规避"反序列"时候可能造成的问题
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Enum singleton - the preferred approach</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">enum</span> <span style="color: #b58900;">Elvis</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2;">INSTANCE</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">leaveTheBuilding</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">...</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>网上一个比较全的实现如下
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">enum</span> <span style="color: #b58900;">Singleton</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2;">INSTANCE</span>;

    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">instance vars, constructor</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Connection</span> <span style="color: #268bd2;">connection</span>;

    <span style="color: #268bd2;">Singleton</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Initialize the connection</span>
        connection = DB.getConnection<span style="color: #268bd2;">()</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Static getter</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">Singleton</span> <span style="color: #268bd2;">getInstance</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> INSTANCE;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Connection</span> <span style="color: #268bd2;">getConnection</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> connection;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Item 4: Enforce noninstantiability with a private constructor</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>有时候,你会想创建一个class,然后这个class里面只有static method和field. 这种
class,确有其价值.比如
<ul class="org-ul">
<li>java.lang.Math
</li>
<li>java.util.Arrays
</li>
</ul>
</li>
<li>这种class另外的用法就是:class作用只是聚集static method(包括static factory
method), 比如java.util.Collections
</li>
<li>无论是上面哪种情况, class都是utility类,都没有实例化的必要.但是
<pre class="example">
       妄图通过设置class为abstract来组织class被实例化的方法是不正确的
</pre>
</li>
<li>因为设置了abstract,subclass继承了它以后,还是可以实例化. 更重要的是,设置了
abstract的话,用户会以为这个类设计了就是为了继承的.
</li>
<li>正确的做法是:把类的ctor设计成private的(其实effective cpp里面也有相似章节,只
不过java源代码里面有诸多良好的例子)
</li>
<li>下面就是一个防止实例化的代码例子(其实代码中的Math, Arrays, Collections都是
private ctor)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Noinstantiable utility class</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">UtilityClass</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">SUpress default ctor for noninstantiablity</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #268bd2;">UtilityClass</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">AssertionError</span><span style="color: #268bd2;">()</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Remainder omitted</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>上面的throw new AssertionError()其实并不是必须.其作用是防止自身在后面的代码
中不小心调用ctor
</li>
<li>设计了private ctor的另外一个副作用是:继承是肯定没法实现了.因为继承都要"依次"
调用父类的ctor,父类都private了.自然无法继承
</li>
<li></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Item 5: Avoid creating unnecessary objects</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>如果可以的话,重用一个object总是非常高效而且更直观. 如果一个object是immutable
的话, 那么它总是可以重用的
</li>
<li>下面是一个非常反面的例子.因为每次执行这个语句的时候都会创建一个String instance,
而且参数"stringette"本身就是一个String instance. 如果在一个循环里面的话,会产生
非常多的instance
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">String</span> <span style="color: #268bd2;">s</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">String</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"stringette"</span><span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">DON"t DO THIS</span>
</pre>
</div>
</li>
<li>正确的做法是如下: 因为只有一个instance(参数"stringette"), 所以在循环里面也不会
多创建instance.同时, 如果同一个虚拟机如果还有其他字符串叫"stringette"的话,还可
以重用这个String instance
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">String</span> <span style="color: #268bd2;">s</span> = <span style="color: #2aa198;">"stringette"</span>;
</pre>
</div>
</li>
<li>避免创建不必要的object的话, 使用immutable class的ctor来创建一个对象是可以的,
但是最好的方法是:使用static factory method!
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">Boolean</span> <span style="color: #268bd2;">b1</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Boolean</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"true"</span><span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Good</span>
<span style="color: #b58900;">Boolean</span> <span style="color: #268bd2;">b2</span> = Boolean.valueOf<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"true"</span><span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Better!</span>
</pre>
</div>
</li>
<li>如果你的object虽然是mutable的,但是你知道他不会改变,那么你也可以重用!(当然要
非常小心).
</li>
<li>下面是一个不太合理的例子: 因为每次调用都会创建一个Calendar, TimeZone 和两个
Date instance
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Person</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Date</span> <span style="color: #268bd2;">birthDate</span>;
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Other fields, methods, and constructor omitted</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">DON'T DO THIS!</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">boolean</span> <span style="color: #268bd2;">isBabyBoomer</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Unnecessary allocation of expensive object</span>
        <span style="color: #b58900;">Calendar</span> <span style="color: #268bd2;">gmtCal</span>=
            Calendar.getInstance<span style="color: #268bd2;">(</span>TimeZone.getTimeZone<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"GMT"</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>;
        gmtCal.set<span style="color: #268bd2;">(</span>1946, <span style="color: #268bd2; font-weight: bold;">Calendar</span>.JANUARY, 1, 0, 0, 0<span style="color: #268bd2;">)</span>;
        <span style="color: #b58900;">Date</span> <span style="color: #268bd2;">boomStart</span> = gmtCal.getTime<span style="color: #268bd2;">()</span>;
        gmtCal.set<span style="color: #268bd2;">(</span>1965, <span style="color: #268bd2; font-weight: bold;">Calendar</span>.JANUARY, 1, 0, 0, 0<span style="color: #268bd2;">)</span>;
        <span style="color: #b58900;">Date</span> <span style="color: #268bd2;">boomEnd</span> = gmtCal.getTime<span style="color: #268bd2;">()</span>;
        <span style="color: #859900; font-weight: bold;">return</span> birthDate.compareTo<span style="color: #268bd2;">(</span>boomStart<span style="color: #268bd2;">)</span> &gt;= 0
            &amp;&amp; birthDate.compareTo<span style="color: #268bd2;">(</span>boomEnd<span style="color: #268bd2;">)</span> &lt; 0;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们来更改一下, 减少一下不必要object的创建. 下面例子中, Calendar, TimeZone和
Date都只创建了一次(在类实例化的时候), 而不是每次 isBabyBoomer调用的时候都创建
一套.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Person</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Date</span> <span style="color: #268bd2;">birthDate</span>;
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Other fields, methods, and constructor omitted</span>

    <span style="color: #93a1a1;">/////////////////////////////////////////////////////</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The starting and ending dates of the baby boom. //</span>
    <span style="color: #93a1a1;">/////////////////////////////////////////////////////</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Date</span> <span style="color: #268bd2;">BOOM_START</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Date</span> <span style="color: #268bd2;">BOOM_END</span>;

    <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">{</span>
        <span style="color: #b58900;">Calendar</span> <span style="color: #268bd2;">gmtCal</span> =
            Calendar.getInstance<span style="color: #268bd2;">(</span>TimeZone.getTimeZone<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"GMT"</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>;
        gmtCal.set<span style="color: #268bd2;">(</span>1946, <span style="color: #268bd2; font-weight: bold;">Calendar</span>.JANUARY, 1, 0, 0, 0<span style="color: #268bd2;">)</span>;
        BOOM_START = gmtCal.getTime<span style="color: #268bd2;">()</span>;
        gmtCal.set<span style="color: #268bd2;">(</span>1965, <span style="color: #268bd2; font-weight: bold;">Calendar</span>.JANUARY, 1, 0, 0, 0<span style="color: #268bd2;">)</span>;
        BOOM_END = gmtCal.getTime<span style="color: #268bd2;">()</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">boolean</span> <span style="color: #268bd2;">isBabyBoomer</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> birthDate.compareTo<span style="color: #268bd2;">(</span>BOOM_START<span style="color: #268bd2;">)</span> &gt;= 0
            &amp;&amp; birthDate.compareTo<span style="color: #268bd2;">(</span>BOOM_END<span style="color: #268bd2;">)</span> &lt; 0;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>上面的改动不仅仅体现在performance上面, 而且把身为local variable 的boomStart,
boomEnd改成static final 的BOOM_START, BOOM_END, 也让他们的const本性一览无余
</li>
<li>当然,如果isBabyBoomer函数从来没有被调用的话,那么BOOM_START, BOOM_END的创建
     就没有必要了. 如果想进一步优化,可以使用lazy initialization BOOM_START, BOOM_END
     但是!这个方法不推荐,因为:
<ul class="org-ul">
<li>lazy initialization总是会让视线变得复杂
</li>
<li>lazy initialization也不会有太明显的性能提高
</li>
</ul>
</li>
<li>上面的例子中,重用的部分的"不变性"是很明显的,但是有些情况下,"不变性"不容易发现:
<ul class="org-ul">
<li>适配器模式(adapter): 所谓适配器是这样一个对象: 它把功能委托给一个后备对象(backing
object), 从而让后备对象有了一个"新的接口". 但是适配器除了和后备对象有联系外,
没有任何其他的关联.所以,为某一个对象(given object)没必要提供超过一个的adapter
object
</li>
<li>Map接口的keySet方法返回该Map对象的Set试图.看起来好像每次都要创建一个Set实例.
而实际的情况确实, keySet是和Map紧密联系的, 一旦Map变了,所有keySet的返回值
都变了.所以其实keySet返回的都是同一个Set instance
</li>
</ul>
</li>
<li>Java 1.5里面有一个新特性: 自动装箱(autoboxing): 它会自动帮助程序员把"基本类
型"和"装箱类型(boxed primitive type)"混用.但是如果你不小心的话,会暗地里创建
不必要的对象!
</li>
<li>比如下面的例子,不小心把long写成了Long, 会造成程序多创建了2^31个多余的Long实
     例. 这也告诉我们,要优先使用基本类型,而不是装箱基本类型, 当心无意识的自动装箱
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hideously slow program! Can you spot the object creation?</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">String</span><span style="color: #b58900;">[]</span> <span style="color: #268bd2;">args</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">Long</span> <span style="color: #268bd2;">sum</span> = 0L;
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #b58900;">long</span> <span style="color: #268bd2;">i</span> = 0; i &lt; <span style="color: #268bd2; font-weight: bold;">Integer</span>.<span style="color: #b58900;">MAX_VALUE</span>; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        sum += i;
    <span style="color: #b58900;">}</span>
    System.out.printf<span style="color: #b58900;">(</span><span style="color: #2aa198;">"sum"</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Item 6: Eliminate obsolete object references</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>虽然Java帮助你进行内存管理,但这并不意味着Java就没有内存泄露
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Can you spot the "memory leak"?</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Stack</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">Object</span><span style="color: #b58900;">[]</span> <span style="color: #268bd2;">elements</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">size</span> = 0;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">DEFAULT_INITIAL_CAPACITY</span> = 16;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">Stack</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        elements = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Object</span><span style="color: #268bd2;">[</span>DEFAULT_INITIAL_CAPACITY<span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">push</span><span style="color: #b58900;">(</span><span style="color: #b58900;">Object</span> <span style="color: #268bd2;">e</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        ensureCapacity<span style="color: #268bd2;">()</span>;
        elements<span style="color: #268bd2;">[</span>size++<span style="color: #268bd2;">]</span> = e;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Object</span> <span style="color: #268bd2;">pop</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>size == 0<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">EmptyStackException</span><span style="color: #6c71c4;">()</span>;
        <span style="color: #268bd2;">}</span>
        <span style="color: #859900; font-weight: bold;">return</span> elements<span style="color: #268bd2;">[</span>--size<span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">}</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Ensure space for at least one more element</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">roughly doubling the capacity each time the array</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">needs to grow</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">ensureCapacity</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>element.length == size<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            elements = Arrays.copyOf<span style="color: #6c71c4;">(</span>elements, 2 * size + 1<span style="color: #6c71c4;">)</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>上面的程序是一个Java写的Stack, 它内存泄露的原因是:一开始stack会增长. 然后pop
弹出后会减小.循环往复.但是虽然element被弹出了. 但是! 这些element不会被GC!
</li>
<li>这些元素没有被GC的原因是stack再pop的时候,element[size]这个reference还一直
指向那个object(这种reference不会被在反引用,所以叫做obsolete reference). 知道
了原因,那么解决起来就很简单了
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Object</span> <span style="color: #268bd2;">pop</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>size == 0<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">EmptyStackException</span><span style="color: #268bd2;">()</span>;
    <span style="color: #b58900;">}</span>
    <span style="color: #b58900;">Object</span> <span style="color: #268bd2;">result</span> = elements<span style="color: #b58900;">[</span>--size<span style="color: #b58900;">]</span>;
    elements<span style="color: #b58900;">[</span>size<span style="color: #b58900;">]</span> = <span style="color: #268bd2; font-weight: bold;">null</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Eliminate obsolete reference</span>
    <span style="color: #859900; font-weight: bold;">return</span> result;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这种把object reference值零的做法应该是一种例外,而不是常态.出现的原因在于
<pre class="example">
Stack这个程序管理了自己的内存. 也就是elements数值. 数组size以下的部分是分配好的, 其他部分是free的.但是GC不知道!
</pre>
</li>
<li>另外一个重要的memory leak的地方是cache: 一旦你把object引用放到cache里面以后,
很容易忘记它,从而导致它在cache里面很久,而相应内存无法释放.
</li>
<li>解决这种问题的"天然"选择就是WeakHashMap. 这个数据结构简直就是天生为这个情况
设计的:
<pre class="example">
WeakHashMap，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此
map会自动丢弃此值(注意,是对key的引用,不是value)
</pre>
</li>
<li>内存泄露常见的第三种情况就是Listener和回调函数. 如果你实现了一个API, 客户端
在这个API中注册回调,却没有显式的取消注册.那么就会产生内存泄露. 解决的方法是
存储"这些callback函数的object reference"到WeakHashMap里面作为key.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">Item 7: Avoid finalizers</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>上来先对finalizer来个"盖棺定论"
<pre class="example">
Finalizers are unpredictable, often dangerous, and generally unnecessary.
</pre>
</li>
<li>C++用户首先要注意的是不要把Java的finalizer想成是C++里面的dtor:
<ul class="org-ul">
<li>dtor有和try-finally block一致的部分:处理nonmemory resource
</li>
<li>相对应的,dtor也有和try-finally block不一致的部分:处理memory resource
</li>
</ul>
</li>
<li>finalizer最大的问题在于JVM设计的时候没有对它们的运行做出保证:这也就是说,一个
object变的不可用,到它被推入finalizer进行处理,中间间隔的时间会是"任意的长"
</li>
<li>正是由于这种时间的不确定性,在finalizer里面是绝不能处理time-critical是绝不能
容忍的.举个例子:
<ul class="org-ul">
<li>我们知道一个进程能够拥有的file descriptor的数目是一定的.
</li>
<li>如果一个进程在finalizer里面close file descriptor,那么就很可能发生过很久才
去执行finalizer里面的close代码,而进程里面打开了超过自己能力的file descriptor
最终导致进程崩溃
</li>
</ul>
</li>
<li>及时的执行finalizer是JVM的责任,而不同的JVM对待finalizer的态度不同,实现不同.
会导致最后在一个JVM里面运行良好的(含有finalizer)的代码在另外一个JVM里面失败
</li>
<li>Java语言规范不是"不保证"finalizer的及时运行,而是"根本不能保证实际运行与否!",
所以,如果出现了program在没有运行finalizer的情况下就terminate,你也不要惊奇.
</li>
<li>这也就意味着
<pre class="example">
       不能依靠finalizer去释放重要的资源比如数据库的锁(lock)
</pre>
</li>
<li>不要被System.gc和System.runFinalization所诱惑, 它们只是增加了finalizer执行
的机会.并不是真正能够finalize
</li>
<li>曾经有能强制finalize的函数System.runFinalizersOnExit,但是都因为它们致命的缺
陷而被废弃了
</li>
<li>Finalizer另外一个大问题在于:
<pre class="example">
Finalizer因为在try-catch之后,已经脱离了exception的运行机制控制. 这也就是说如果在
finalizer里面出现了异常,那么这个异常是会被ignored,从而导致很多无法预测的问题!
</pre>
</li>
<li>Finalizer还会导致"严重的性能下降"
</li>
<li>Finalizer已经是众矢之的了,在绝大部分情况下,我们要避免使用他们.那么我们如何释
放对象的某些资源(比如文件)呢? 方法是:
<ul class="org-ul">
<li>"提供一个明确的termination method"
</li>
<li>在资源不需要的时候自己调用termination method,并去private filed里面设置自己
的状态
</li>
<li>其他函数运行之前要先去查看private filed里面确认这个资源还在.否则抛出异常:
IllegalStateException
</li>
</ul>
</li>
<li>这种方法广泛的在java里面运用,比如InputStream,OutputStream和java.util.Connection
里面都有一个close()的函数.
</li>
<li>termination method通常还会和try-finally block合用,保证如果object被使用的时候
出了异常的话termination也能进行
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">try-finally block guarantees execution of termination method</span>
<span style="color: #b58900;">Foo</span> <span style="color: #268bd2;">foo</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Foo</span><span style="color: #2aa198;">(</span>...<span style="color: #2aa198;">)</span>;
<span style="color: #859900; font-weight: bold;">try</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Do what must be done with foo</span>
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">..</span>
<span style="color: #2aa198;">}</span> <span style="color: #859900; font-weight: bold;">finally</span> <span style="color: #2aa198;">{</span>
    foo.terminate<span style="color: #b58900;">()</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Explicit termination method</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>最后的最后,来看看finalizer勉强可以算作还有用的两个场景:
<ol class="org-ol">
<li>作为安全网:
<ul class="org-ul">
<li>一个资源释放的晚总比不释放好,finalizer作为termination method以外的最后
一道屏障.事实上FileInputStream, FileOutputStream, Connection等都是有
try-finally block在里面再次调用termination method.
</li>
<li>finalizer除了要起到"再次释放"资源的目的以外,还应该加一个log. 因为在finalizer
里面调用"释放资源"是不对的.所以应该记录异常事件,把这种情况作为一个bug.
很遗憾FileInputSream等的try-finally block代码里面没有这么做
</li>
</ul>
</li>
<li>释放没有重要资源的native peer (TODO)
</li>
</ol>
</li>
<li>实在要使用finalizer的话,也要知道finalizer如果含有继承的话,继承关系是不会自动
调用的.要自己手动写super.finalize()
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">Manual finalizer chaining</span>
<span style="color: #268bd2; font-weight: bold;">@Override</span>
<span style="color: #859900; font-weight: bold;">protected</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">finalize</span><span style="color: #2aa198;">()</span> <span style="color: #859900; font-weight: bold;">throws</span> <span style="color: #b58900;">Throwable</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">try</span> <span style="color: #b58900;">{</span>
        ... <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Finalize subclass state</span>
    <span style="color: #b58900;">}</span> <span style="color: #859900; font-weight: bold;">finally</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">super</span>.finalize<span style="color: #268bd2;">()</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 3: Methods Common to All Objects</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Item 8: Obey the general contract when overriding equals</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>实现equals是一件非常困难的事情,实现的不好就会造成灾难,所以最好是"能不实现,就
不实现", 满足下面任意一个条件,就可以不用"自己实现equals":
<ol class="org-ol">
<li>Each instance of the class is inherently unique: 比如Thread这种,其对象肯
定是实例,而不是value,那么唯一性是肯定的.Object里面的equals实现就够用了
</li>
<li>You don't care whether the class provides a "logical euqality" test: 比
如你可以为java.util.Random实现一个equals来对比两次实现的随机数是否一样.
但显然这个设计是多余的,没有人会用这个功能
</li>
<li>A superclass has already overridden equals, and the superclass behavior
is appropriate for this class: 比如大多数Set的具体实现都继承于AbstractSet.
List的实现继承于AbstractList, Map的实现继承于AbstractMap
</li>
<li>class是private或者是package-private的,然后你确信这个equals method不会有人
调用,保险起见, 你还要加上如下代码
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2; font-weight: bold;">@Override</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">boolean</span> <span style="color: #268bd2;">equals</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Object</span> <span style="color: #268bd2;">o</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">AssertionError</span><span style="color: #b58900;">()</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Method is never called</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ol>
</li>
<li>那什么情况下要实现equals呢? 具体来说就是superclass没有实现equals 的value class:
所谓value class 就是class有'值'(比如Integer, Date). 用户比较这种class的instance
的时候,不想比较他们'是否refer to the same object', 而是想比较他们'是否逻辑上相等'
</li>
<li>需要说明的是使用"instance control(就是保证class的一种value只有一个instance
的情况)"的class是不需要equals的, 比如Enum type, 对他们来说逻辑上相对,就意味
着是同一个intance
</li>
<li>#TODO#
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Item 9: Always override hashCode when you override equals</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>如果要实现equals, 就必须实现hashCode, 这个是两者的合同契约关系: 如果两个object
通过equals method证明为相同的话,那么他们的hashCode method返回的integer也必须
相同
</li>
<li>对于value class来说,如果实现了两者的equals method, 那么也要改写hashCode, 因
为对于hashCode来说.两者只是不同instance而已. 如果忘记实现hashCode, 那么你的
class的instance就无法作为Hash类(比如HashMap, HashSet, HashTable)的key啦
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">clas</span> <span style="color: #268bd2;">PhoneNumber</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">short</span> <span style="color: #268bd2;">areaCode</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">short</span> <span style="color: #268bd2;">prefix</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">short</span> <span style="color: #268bd2;">lineNumber</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">PhoneNumber</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">areaCode</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">prefix</span>,
                       <span style="color: #b58900;">int</span> <span style="color: #268bd2;">lineNumber</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        rangeCheck<span style="color: #268bd2;">(</span>areaCode,    999, <span style="color: #2aa198;">"area code"</span><span style="color: #268bd2;">)</span>;
        rangeCheck<span style="color: #268bd2;">(</span>prefix,      999, <span style="color: #2aa198;">"prefix"</span><span style="color: #268bd2;">)</span>;
        rangeCheck<span style="color: #268bd2;">(</span>lineNumber,  999, <span style="color: #2aa198;">"line number"</span><span style="color: #268bd2;">)</span>;

        <span style="color: #859900; font-weight: bold;">this</span>.areaCode = <span style="color: #268bd2;">(</span><span style="color: #b58900;">short</span><span style="color: #268bd2;">)</span> areaCode;
        <span style="color: #859900; font-weight: bold;">this</span>.prefix = <span style="color: #268bd2;">(</span><span style="color: #b58900;">short</span><span style="color: #268bd2;">)</span> prefix;
        <span style="color: #859900; font-weight: bold;">this</span>.lineNumber = <span style="color: #268bd2;">(</span><span style="color: #b58900;">short</span><span style="color: #268bd2;">)</span> lineNumber;

        <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">rangeCheck</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">arg</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">max</span>,
                                       <span style="color: #b58900;">String</span> <span style="color: #268bd2;">name</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span>arg &lt; 0 || arg &gt; max<span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
                <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">IllegalArgumentException</span><span style="color: #859900;">(</span>name + <span style="color: #2aa198;">": "</span> + arg<span style="color: #859900;">)</span>;
            <span style="color: #6c71c4;">}</span>
        <span style="color: #268bd2;">}</span>

        <span style="color: #268bd2; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">boolean</span> <span style="color: #268bd2;">equals</span><span style="color: #268bd2;">(</span><span style="color: #b58900;">Object</span> <span style="color: #268bd2;">o</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span>o == <span style="color: #859900; font-weight: bold;">this</span><span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
            <span style="color: #6c71c4;">}</span>
            <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span><span style="color: #b58900; font-weight: bold;">!</span><span style="color: #859900;">(</span>o <span style="color: #859900; font-weight: bold;">instanceof</span> PhoneNumber<span style="color: #859900;">)</span><span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
                <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
            <span style="color: #6c71c4;">}</span>
            <span style="color: #b58900;">PhoneNumber</span> <span style="color: #268bd2;">pn</span> = <span style="color: #6c71c4;">(</span><span style="color: #b58900;">PhoneNumber</span><span style="color: #6c71c4;">)</span>o;
            <span style="color: #859900; font-weight: bold;">return</span> pn.lineNumber == lineNumber
                &amp;&amp; pn.prefix == prefix
                &amp;&amp; pn.areaCode == areCode;
        <span style="color: #268bd2;">}</span>

        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Broken - no hashCode method!</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>不要为了提高性能而把object里面的关键部分去掉再做hashCode.
<ul class="org-ul">
<li>1.2版本以前的String hashCode不会检查所有的成员char,而且均匀的选择16个字符
进行哈希,得到hashCode. 这样一来虽然相同的字符串一定会产生相同的hashCode,
但是某些不同的字符串(虽然概率较低)也会产生相同的hashCode.
</li>
<li>这样导致散列函数把String作为key的时候, 如果key的数量足够大,那么不同字符串
就会产生很多相同的hashCode,最终导致Hash系列的查找非常的慢(因为有很多的冲突!)
</li>
</ul>
</li>
<li>1.2版本以后的String已经开始使用所有的char啦
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">hashCode</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">h</span> = hash;
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>h == 0 &amp;&amp; value.length &gt; 0<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #b58900;">char</span> <span style="color: #268bd2;">val</span><span style="color: #268bd2;">[]</span> = value;

        <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #268bd2;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; value.<span style="color: #b58900;">length</span>; i++<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            h = 31 * h + val<span style="color: #6c71c4;">[</span>i<span style="color: #6c71c4;">]</span>;
        <span style="color: #268bd2;">}</span>
        hash = h;
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> h;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Item 10: Always override toString</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>虽然不如equals和hashCode的约定那么重要,但是为每一个子类实现toString函数是非
常好的一个建议
</li>
<li>是否要把toString的格式在文档中体现出来是很重要的一个决定:
<ul class="org-ul">
<li>优点: 易于阅读
</li>
<li>缺点: 如果这个类被广泛使用,那么一旦指定格式,就必须坚持,因为程序员会根据这
个格式编写了代码
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Item 11: Override clone judiciously</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>Cloneable接口是一个设计上的失败, 因为作为借口,它里面什么内容都没有
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">package</span> java.<span style="color: #268bd2; font-weight: bold;">lang</span>;

<span style="color: #2aa198;">/**</span>
<span style="color: #2aa198;"> * A class implements the </span><span style="color: #268bd2; font-weight: bold;">&lt;code&gt;</span><span style="color: #2aa198;">Cloneable</span><span style="color: #268bd2; font-weight: bold;">&lt;/code&gt;</span><span style="color: #2aa198;"> interface to</span>
<span style="color: #2aa198;"> * indicate to the </span><span style="color: #268bd2; font-weight: bold;">{@link java.lang.Object#clone()}</span><span style="color: #2aa198;"> method that it</span>
<span style="color: #2aa198;"> * is legal for that method to make a</span>
<span style="color: #2aa198;"> * field-for-field copy of instances of that class.</span>
<span style="color: #2aa198;"> * </span><span style="color: #268bd2; font-weight: bold;">&lt;p&gt;</span>
<span style="color: #2aa198;"> * Invoking Object's clone method on an instance that does not implement the</span>
<span style="color: #2aa198;"> * </span><span style="color: #268bd2; font-weight: bold;">&lt;code&gt;</span><span style="color: #2aa198;">Cloneable</span><span style="color: #268bd2; font-weight: bold;">&lt;/code&gt;</span><span style="color: #2aa198;"> interface results in the exception</span>
<span style="color: #2aa198;"> * </span><span style="color: #268bd2; font-weight: bold;">&lt;code&gt;</span><span style="color: #2aa198;">CloneNotSupportedException</span><span style="color: #268bd2; font-weight: bold;">&lt;/code&gt;</span><span style="color: #2aa198;"> being thrown.</span>
<span style="color: #2aa198;"> * </span><span style="color: #268bd2; font-weight: bold;">&lt;p&gt;</span>
<span style="color: #2aa198;"> * By convention, classes that implement this interface should override</span>
<span style="color: #2aa198;"> * </span><span style="color: #268bd2; font-weight: bold;">&lt;tt&gt;</span><span style="color: #2aa198;">Object.clone</span><span style="color: #268bd2; font-weight: bold;">&lt;/tt&gt;</span><span style="color: #2aa198;"> (which is protected) with a public method.</span>
<span style="color: #2aa198;"> * See </span><span style="color: #268bd2; font-weight: bold;">{@link java.lang.Object#clone()}</span><span style="color: #2aa198;"> for details on overriding this</span>
<span style="color: #2aa198;"> * method.</span>
<span style="color: #2aa198;"> * </span><span style="color: #268bd2; font-weight: bold;">&lt;p&gt;</span>
<span style="color: #2aa198;"> * Note that this interface does </span><span style="color: #268bd2; font-weight: bold;">&lt;i&gt;</span><span style="color: #2aa198;">not</span><span style="color: #268bd2; font-weight: bold;">&lt;/i&gt;</span><span style="color: #2aa198;"> contain the </span><span style="color: #268bd2; font-weight: bold;">&lt;tt&gt;</span><span style="color: #2aa198;">clone</span><span style="color: #268bd2; font-weight: bold;">&lt;/tt&gt;</span><span style="color: #2aa198;"> method.</span>
<span style="color: #2aa198;"> * Therefore, it is not possible to clone an object merely by virtue of the</span>
<span style="color: #2aa198;"> * fact that it implements this interface.  Even if the clone method is invoked</span>
<span style="color: #2aa198;"> * reflectively, there is no guarantee that it will succeed.</span>
<span style="color: #2aa198;"> *</span>
<span style="color: #2aa198;"> * </span><span style="color: #268bd2; font-weight: bold;">@author</span><span style="color: #2aa198;">  unascribed</span>
<span style="color: #2aa198;"> * </span><span style="color: #268bd2; font-weight: bold;">@see</span><span style="color: #2aa198;">     java.lang.CloneNotSupportedException</span>
<span style="color: #2aa198;"> * </span><span style="color: #268bd2; font-weight: bold;">@see</span><span style="color: #2aa198;">     java.lang.Object#clone()</span>
<span style="color: #2aa198;"> * </span><span style="color: #268bd2; font-weight: bold;">@since</span><span style="color: #2aa198;">   JDK1.0</span>
<span style="color: #2aa198;"> */</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #b58900;">Cloneable</span> <span style="color: #2aa198;">{</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>它只是"声明"这个对象可以被克隆,但具体怎么克隆是类设计者的事情,类设计者可以
根本就不去实现一个clone函数, 而这个错误直到runtime才会被发现.如果把clone函
数放在Cloneable接口里面的话,无疑会更加的合理,因为"implement一个接口,但是没有
重载它的函数"本身就是一个错误.
</li>
<li>那Cloneable为什么这么设计呢? 这是因为clone这个函数被定义在了Object里面(具体
实现是使用的c语言)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">cpp implementation can be found here</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/share/vm/prims/jvm.cpp</span>
<span style="color: #859900; font-weight: bold;">protected</span> <span style="color: #859900; font-weight: bold;">native</span> <span style="color: #b58900;">Object</span> <span style="color: #268bd2;">clone</span><span style="color: #2aa198;">()</span> <span style="color: #859900; font-weight: bold;">throws</span> <span style="color: #b58900;">CloneNotSupportedException</span>;
</pre>
</div>
</li>
<li>Cloneable的设计还充满了以下各种问题:
<ul class="org-ul">
<li>与final域的正常使用冲突(final域只能初始化,无法赋值)
</li>
<li>会抛出不必要的checked exception(CloneNotSupportedException).
</li>
<li>实现深拷贝或者浅拷贝有赖于文档
</li>
</ul>
</li>
<li>总结起来就是:不要使用Cloneable接口,而应该使用拷贝构造器(copy ctor)或者拷贝
工厂(copy factory)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">copy ctor</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">Yum</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Yum</span> <span style="color: #268bd2;">yum</span><span style="color: #2aa198;">)</span>;
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">copy factory</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">Yum</span> <span style="color: #268bd2;">newInstance</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">Yum</span> <span style="color: #268bd2;">yum</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Item 12: Consider implementing Comparable</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>Comparable的设计颇为合适,它有自己的interface,然后interface里面还有函数
compareTo(而不是像Cloneable一样,有一个空的interface)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #b58900;">Comparable</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">T</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">{</span>
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">compareTo</span><span style="color: #b58900;">(</span><span style="color: #b58900;">T</span> <span style="color: #268bd2;">t</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>如果一个class实现了Comparable,意味着它遵守如下的承诺:
<pre class="example">
       这个class的instance拥有了natural ordering的能力
</pre>
</li>
<li>所谓natural ordering能力,就是作为a, Arrays.sort(int[] a)就可以成功排序,不需
要一个comparator
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">T</span><span style="color: #2aa198;">&gt;</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">sort</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">T</span><span style="color: #b58900;">[]</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">Comparator</span><span style="color: #b58900;">&lt;</span>? <span style="color: #859900; font-weight: bold;">super</span> <span style="color: #b58900;">T</span><span style="color: #b58900;">&gt;</span> <span style="color: #268bd2;">c</span><span style="color: #2aa198;">)</span>
</pre>
</div>
</li>
<li>我们常见的implements了Comparable,从而拥有natural ordering能力的就是digit和
String
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">String</span>
    <span style="color: #859900; font-weight: bold;">implements</span> <span style="color: #268bd2; font-weight: bold;">java</span>.<span style="color: #268bd2; font-weight: bold;">io</span>.<span style="color: #b58900;">Serializable</span>, <span style="color: #b58900;">Comparable</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">String</span><span style="color: #2aa198;">&gt;</span>, <span style="color: #b58900;">CharSequence</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">....</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>如果你想改变"natural ordering",那么就要implement Comparator, 实现其compare函
数. 注意,在使用的时候,如果没有加Comparator的参数的话,默认是按照Comparable来
实现的(因为它是"natural"的);
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">package</span> org.hfeng.misc.ej2.<span style="color: #268bd2; font-weight: bold;">item12</span>;

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #268bd2; font-weight: bold;">java</span>.<span style="color: #268bd2; font-weight: bold;">util</span>.<span style="color: #b58900;">Arrays</span>;
<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #268bd2; font-weight: bold;">java</span>.<span style="color: #268bd2; font-weight: bold;">util</span>.<span style="color: #b58900;">Comparator</span>;

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Player</span> <span style="color: #859900; font-weight: bold;">implements</span> <span style="color: #b58900;">Comparable</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">Player</span><span style="color: #2aa198;">&gt;</span>, <span style="color: #b58900;">Comparator</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">Player</span><span style="color: #2aa198;">&gt;{</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">_number</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">String</span> <span style="color: #268bd2;">_name</span>;

    <span style="color: #268bd2;">Player</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">number</span>, <span style="color: #b58900;">String</span> <span style="color: #268bd2;">name</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        _number = number;
        _name = name;
    <span style="color: #b58900;">}</span>

    <span style="color: #268bd2;">Player</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">String</span> <span style="color: #268bd2;">toString</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> String.format<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"No:%d-Name: %s"</span>, _number, _name<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">compare</span><span style="color: #b58900;">(</span><span style="color: #b58900;">Player</span> <span style="color: #268bd2;">p</span>, <span style="color: #b58900;">Player</span> <span style="color: #268bd2;">p2</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> p._name.compareTo<span style="color: #268bd2;">(</span>p2._name<span style="color: #268bd2;">)</span>;

    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">compareTo</span><span style="color: #b58900;">(</span><span style="color: #b58900;">Player</span> <span style="color: #268bd2;">p</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">this</span>._number - p._number;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">TestOrder</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span><span style="color: #b58900;">(</span><span style="color: #b58900;">String</span><span style="color: #268bd2;">[]</span> <span style="color: #268bd2;">args</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #b58900;">Player</span><span style="color: #268bd2;">[]</span> <span style="color: #268bd2;">players</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Player</span><span style="color: #268bd2;">[]{</span><span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Player</span><span style="color: #6c71c4;">(</span>1, <span style="color: #2aa198;">"Allen"</span><span style="color: #6c71c4;">)</span>,
                <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Player</span><span style="color: #6c71c4;">(</span>2, <span style="color: #2aa198;">"Wade"</span><span style="color: #6c71c4;">)</span>, <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Player</span><span style="color: #6c71c4;">(</span>3, <span style="color: #2aa198;">"Benson"</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">}</span>;
        Arrays.sort<span style="color: #268bd2;">(</span>players<span style="color: #268bd2;">)</span>;
        System.out.println<span style="color: #268bd2;">(</span>Arrays.toString<span style="color: #6c71c4;">(</span>players<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>;
        Arrays.sort<span style="color: #268bd2;">(</span>players, <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Player</span><span style="color: #6c71c4;">()</span><span style="color: #268bd2;">)</span>;
        System.out.println<span style="color: #268bd2;">(</span>Arrays.toString<span style="color: #6c71c4;">(</span>players<span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[No:1-Name: Allen, No:2-Name: Wade, No:3-Name: Benson] //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[No:1-Name: Allen, No:3-Name: Benson, No:2-Name: Wade] //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 4: Classes and Interfaces</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Item 13: Minimize the accessibility of classes and members</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>良好的设计首先就是要将内部实现和外部接口(API)完全分开.这个也是软件设计准则
里面"封装(encapsulation)"的要求
</li>
<li>封装可以使得软件各个部分能够分开进行测试,开发,优化.但是"不能"提高软件的性能,
提高的只是开发效率,以及分析系统性能瓶颈时候的效率:一旦开发完毕测试出系统瓶颈
在哪里,就可以专注优化瓶颈部分
</li>
<li>只对于java来说,如下的几点可以帮助我们更好的实现"封装"成员
<ol class="org-ol">
<li>尽可能的使每个类或者成员不被外界访问:
<ul class="org-ul">
<li>对于top level的class或者interface来说, 只有两个选择package-private或者
是public. 如果能够选择package-private,那么毫不犹豫的选择package-private.
因为package-private使得你的代码是"实现"的一部分,而不是"API"的一部分,成
为API总是要付出责任的.
</li>
<li>如果某个类只是被"一个类"在内部使用,那么甚至可以把这个类从package-private改成
那"一个类"的private nested class
</li>
</ul>
</li>
<li>一般来说,某个class所有的成员一开始都必须是private的(只有class内部可以
访问).只有当同一个package的另外的class需要使用这个的时候,才要把private去掉
从而使得它变成package-private. package-private和private都是"实现"的一部分,
只有在极其特殊的情况下(比如implements Serializable接口的情况下)才会泄露
</li>
<li>对public class的成员来说从package-private到protected是一个非常大的accessibility
的提升,因为protected其实是对subclass的public, 对subclass来说,也就相当于
API了,而且还有一部分继承方面的承诺(所以应该尽量少用protected来保护成员)
</li>
<li>对于method来说,有一个特殊的要求:
<pre class="example">
          如果一个函数override了superclass的函数,那么,这个函数不能有一个更低级的access level. 只有这样才能保证继承类的功能不比基类差
</pre>
</li>
<li>为了测试方便是可以把public class的成员从private临时调整为package-private的,
但是不能进一步调成了.因为private和package-private说白了,还是implementation
</li>
<li>如果一个'成员变量'是非final的(或者final reference指向一个mutable object),
那么这个'成员变量'一定不能是public的: 因为一旦设置为public,你的'成员变量'
会被肆意改变,你也无能为力. 而且你的class肯定不是'thread safe'的了,因为
<pre class="example">
Classes with public mutable fields are not thread-safe
</pre>
</li>
<li>同样需要注意的是static的域,也是必须不能public的. 只有一个例外 (通常来说,这些域都是'全部大写'的)
<pre class="example">
static final fields contains either primitive values or references to immutable objects
</pre>
</li>
<li>需要特别注意的是nonzero-length array始终是mutable的
<pre class="example">
It is wrong for a class to have a public static final array field, or an accessor that returns such a field
</pre>
</li>
<li>上面提到了,即便把array设置成了private,但是IDE自动生成的accessor的话,会直
接返回private的array ref,这是不对的,正常的写法应该如下
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Thing</span><span style="color: #2aa198;">[]</span> <span style="color: #268bd2;">PRIVATE_VALUES</span> = <span style="color: #2aa198;">{</span> <span style="color: #93a1a1;">/*</span><span style="color: #93a1a1;">...*/</span> <span style="color: #2aa198;">}</span>;
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">List</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">Thing</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">VALUES</span> =
    Collections.unmodifiableList<span style="color: #2aa198;">(</span>Arrays.asList<span style="color: #b58900;">(</span>PRIVATE_VALUES<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">//</span><span style="color: #93a1a1;">OR</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Thing</span><span style="color: #2aa198;">[]</span> <span style="color: #268bd2;">values</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> PRIVATE_VALUES.clone<span style="color: #b58900;">()</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>除了上面的static final 指向primitive或者immutable,public class不能有任何其他的成员变量是public的
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Item 14: In public classes, use accessor methods, not public fields</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>有时候,你会有如下定义的class,只有public field,没有函数
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Degenerate classes like this should not be public!</span>
<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Point</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">x</span>;
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">y</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>有些强硬派的OO设计者,认为上面的class"必须"如下实现
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Encapsulation of data by accessor methods and mutators</span>
<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Point</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">x</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">y</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">Point</span><span style="color: #b58900;">(</span><span style="color: #b58900;">double</span> <span style="color: #268bd2;">x</span>, <span style="color: #b58900;">double</span> <span style="color: #268bd2;">y</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">this</span>.x = x;
        <span style="color: #859900; font-weight: bold;">this</span>.y = y;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">getX</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> x;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">getY</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> y;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">setX</span><span style="color: #b58900;">(</span><span style="color: #b58900;">double</span> <span style="color: #268bd2;">x</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">this</span>.x = x;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">setY</span><span style="color: #b58900;">(</span><span style="color: #b58900;">double</span> <span style="color: #268bd2;">y</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">this</span>.y = y;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>注意!上面的做法如果class是public的话,那么是正确的,如果不public的(private
或者package-private)的话,这么做是没必要的!因为private或者package-private
本来就是内部实现的一部分,而不是public API的一部分.
</li>
<li>虽然把public class里面的一些field变成public的是不受欢迎的举动,但是如果这些
field是immutable的话,那么危害性会小一点
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Public class with exposed immutable fields - questionable</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Time</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">HOURS_PER_DAY</span>    = 24;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">MINUTES_PER_HOUR</span> = 60;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">hour</span>;
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">minute</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Item 15: Minimize mutability</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>所谓immutable class就是:它的instance不能被更改的class.
</li>
<li>immutable class内部所有的信息在创建的时候就已经具有了,并且终生不会改变
</li>
<li>Java内部的几个著名immutable class:
<ul class="org-ul">
<li>String
</li>
<li>boxed primitive classes
</li>
<li>BigInteger
</li>
<li>BigDecimal
</li>
</ul>
</li>
<li>为了能够让class变得immutable,必须遵循以下几点的要求:
<ol class="org-ol">
<li>不要提供任何修改对象state的函数
</li>
<li>不要让class可以被继承(通常是声明class为final)
</li>
<li>让所有的field都变成final的
</li>
<li>让所有的field都变成private的
</li>
<li>保证对所有内部mutable成员的"独占性"的访问.
</li>
</ol>
</li>
<li>实现了immutable以后,有如下好处:
<ul class="org-ul">
<li>Immutable object are simple: immutable 对象的状态在一开始就固定了么,你可以
放心的把他们的state作为固定的条件
</li>
<li>Immutable objects are inherently thread-safe; they reqire no synchronization:
当多个线程访问它们的时候, 它们的数据不会被破坏, 所以immutable object是天然的
thread-safe, 天然的易于在thread之间分享. 所以对于immutable object来说,工厂
模式非常流行:因为同一个'值',我只需要一个对象就可以了(BigInteger就有这样的工厂).
</li>
<li>Immutable object还可以分享内部的成员变量
</li>
<li>Immutable object make great building blocks for other objects:一个典型的例
子是: Immutable object是Map中Key,以及Set中的element
</li>
</ul>
</li>
<li>immutable唯一的缺点是:创建一个比较大的不可变类的代价比较高. 比如一个BigInteger
的instance, 我们要更改其中一个bit,那么因为BigInteger是immutable的,我们唯一的
办法就是再申请一块这么大的内存,然后改变其中一个bit
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">BigInteger</span> <span style="color: #268bd2;">moby</span> = ...;
moby = moby.flipBit<span style="color: #2aa198;">(</span>0<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>但,并不是所有的类都有那么好的运气,能够成为immutable的class.如果不能设计成
immutable class,至少也要"尽可能的降低可变现":
<pre class="example">
       除非有令人信服的理由要使得域变成非final的,否则要使某个每个域都是final的
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Item 16: Favor composition over inheritance</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>这里的继承专指extends(而不是implements)
</li>
<li>继承,封装,多肽是OO编程的三个特性,但是真实的情况是,多数情况下继承并不适用,
有限的几个适用继承的情况是(在java范围内):
<ul class="org-ul">
<li>在包内部使用继承(子类和父类都在同一个程序员控制之下)
</li>
<li>设计转门被用来继承的类(并且文档全面)
</li>
</ul>
</li>
<li>可能与你的认识不同的是"继承其实打破了封装性": 因为子类的实现一来于父类的特定
代码, 而父类的代码如果在新版本中发生了改变,子类可能会遭到破坏(即便子类没有做
改变)
</li>
<li>所以一个不是专门设计用来"extends"的class,最好不要去extends它,下面是一个例子
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Broken - Inappropriate use of inheritance!</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">InstrumentedHashSet</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">E</span><span style="color: #2aa198;">&gt;</span> <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900;">HashSet</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">E</span><span style="color: #2aa198;">&gt;</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The number of attempted element insertions</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">addCount</span> = 0;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">InstrumentedHashSet</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #268bd2;">InstrumentedHashSet</span><span style="color: #b58900;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">initCap</span>, <span style="color: #b58900;">float</span> <span style="color: #268bd2;">loadFactor</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">super</span><span style="color: #268bd2;">(</span>initCap, loadFactor<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #268bd2; font-weight: bold;">@Override</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">boolean</span> <span style="color: #268bd2;">add</span><span style="color: #b58900;">(</span><span style="color: #b58900;">E</span> <span style="color: #268bd2;">e</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        addCount++;
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">super</span>.add<span style="color: #268bd2;">(</span>e<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #268bd2; font-weight: bold;">@Override</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">boolean</span> <span style="color: #268bd2;">addAll</span><span style="color: #b58900;">(</span><span style="color: #b58900;">Collection</span><span style="color: #268bd2;">&lt;</span>? <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900;">E</span><span style="color: #268bd2;">&gt;</span> <span style="color: #268bd2;">c</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        addCount += c.size<span style="color: #268bd2;">()</span>;
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">super</span>.addAll<span style="color: #268bd2;">(</span>c<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">getAddCount</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> addCount;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>这个例子中我们创建了一个新的class(继承于HashSet), 除了继承HashSet的全部功能
外,我们还提供了一点功能上的改进:我们可以O(1)时间就求出总共增加了多少个成员.
但是当我们按照设想进行试验的时候,发现结果比预想值大了一倍(预想结果是3)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">package</span> org.hfeng.misc.ej2.<span style="color: #268bd2; font-weight: bold;">item16</span>;

<span style="color: #859900; font-weight: bold;">import</span> <span style="color: #268bd2; font-weight: bold;">java</span>.<span style="color: #268bd2; font-weight: bold;">util</span>.<span style="color: #b58900;">Arrays</span>;

<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Test</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span><span style="color: #b58900;">(</span><span style="color: #b58900;">String</span><span style="color: #268bd2;">[]</span> <span style="color: #268bd2;">args</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #b58900;">InstrumentedHashSet</span><span style="color: #268bd2;">&lt;</span><span style="color: #b58900;">String</span><span style="color: #268bd2;">&gt;</span> <span style="color: #268bd2;">s</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">InstrumentedHashSet</span><span style="color: #268bd2;">&lt;</span><span style="color: #b58900;">String</span><span style="color: #268bd2;">&gt;()</span>;
        s.addAll<span style="color: #268bd2;">(</span>Arrays.asList<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"Snap"</span>, <span style="color: #2aa198;">"Crackle"</span>, <span style="color: #2aa198;">"Pop"</span><span style="color: #6c71c4;">)</span><span style="color: #268bd2;">)</span>;
        System.out.println<span style="color: #268bd2;">(</span>s.getAddCount<span style="color: #6c71c4;">()</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">6                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Item 17: Design and document for inheritane or else prohibit it</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>要想继承某个类,这个类的文档就必须精确的描述覆盖(override)每个方法所带来的影响:
这个要求的范围是:
<ul class="org-ul">
<li>可覆盖的,也就是非final的
</li>
<li>公开的,也就是public(或者protected的)
</li>
<li>什么情况下会调用上面的'可被覆盖'的函数.
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">Item 18: Perfer interfaces to abstract classes</h3>
</div>
<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7">Item 19: Use interfaces only to define types</h3>
<div class="outline-text-3" id="text-3-7">
<ul class="org-ul">
<li>当一个classs实现一个interface的时候,这个interface就可以当做这个class的instance
的类型(type). 也就是说这种instance因为实现了某个interface,所以具有了某种能力.
只能因为这个目的来实现接口,为其他目的实现接口的做法都是错误的
</li>
<li>有种接口叫做常量接口(constant interface),接口里面没有函数,只有常量
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Constant interface antipattern - do not use !</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #b58900;">PhysicalConstants</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">ELECTRON_MASS</span> = 9.1093;
    <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">double</span> <span style="color: #268bd2;">BOLTZMANN_CONSTANT</span> = 1.38065;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>常量接口是对接口的不良使用:
<ul class="org-ul">
<li>首先常量是实现细节,不应该暴露出来
</li>
<li>如果在将来的发型版中不再需要这些常量了,那么依然需要实现这个接口,以确保二
进制兼容性.
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8">Item 20: Prefer class hierarchies to tagged classes</h3>
</div>
<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9">Item 21: Use function objects to represent strategies</h3>
</div>
<div id="outline-container-sec-3-10" class="outline-3">
<h3 id="sec-3-10">Item 22: Favor static member classes over nonstatic</h3>
<div class="outline-text-3" id="text-3-10">
<ul class="org-ul">
<li>nested class是一种定义在其他类里面的类
</li>
<li>nested class应该只服务于包裹它的类(enclosing class),否则nested 应该被声明为
top-level class
</li>
<li>nested class一共有四种:
<ul class="org-ul">
<li>static member class:是最简单的nested class
</li>
<li>nonstatic member classes
</li>
<li>anonymous classes
</li>
<li>local classes
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 5: Generics</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Item 23: Don't use raw types in new code</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>声明中带有一个或者多个类(或者接口)来作为类型参数(type parameter)的情况就是generic, 比如
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Collection</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">Stamp</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">stamps</span> = ...;
</pre>
</div>
</li>
<li>这是1.5才引入的特性,原来的时候,所有的对象都是以Object的形式存入容器的.所以取
出来的时候,还要转义
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Item 24: Eliminate unchecked warnings</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>在使用范型编码的时候,会遇到一些警告,比如
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">Set</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">Lark</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">exaltation</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">HashSet</span><span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>如果你编译的话,会出现如下错误
<pre class="example">
Venery.java:4: warning: [unchecked] unchecked conversion
</pre>
</li>
<li>正确改正方法
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">Set</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">Lark</span><span style="color: #2aa198;">&gt;</span> <span style="color: #268bd2;">exaltation</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">HashSet</span><span style="color: #2aa198;">&lt;</span><span style="color: #b58900;">Lark</span><span style="color: #2aa198;">&gt;()</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Item 25: Prefer lists to arrays</h3>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Item 26: Favor generic types</h3>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
