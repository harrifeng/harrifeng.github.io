<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>restful</title>
<!-- 2017-05-02 Tue 10:44 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">restful</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 01: Using te Uniform Interface</a>
<ul>
<li><a href="#sec-1-1">How to Keep Interactions Visible</a>
<ul>
<li><a href="#sec-1-1-1">Problem</a></li>
<li><a href="#sec-1-1-2">Solution</a></li>
<li><a href="#sec-1-1-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-1-2">When to Trade Visibility</a>
<ul>
<li><a href="#sec-1-2-1">Problem</a></li>
<li><a href="#sec-1-2-2">Solution</a></li>
<li><a href="#sec-1-2-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-1-3">How to Maintain Application State</a>
<ul>
<li><a href="#sec-1-3-1">Problem</a></li>
<li><a href="#sec-1-3-2">Solution</a></li>
<li><a href="#sec-1-3-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-1-4">How to Implement Safe and Idempotent Methods on the Server</a>
<ul>
<li><a href="#sec-1-4-1">Problem</a></li>
<li><a href="#sec-1-4-2">Solution</a></li>
<li><a href="#sec-1-4-3">Discussion</a>
<ul>
<li><a href="#sec-1-4-3-1">Implementing safe methods</a></li>
<li><a href="#sec-1-4-3-2">Implementing idempotent methods</a></li>
<li><a href="#sec-1-4-3-3">Idempotency of DELETE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-5">How to Treat Safe and Idempotent Methods in Clients</a>
<ul>
<li><a href="#sec-1-5-1">Problem</a></li>
<li><a href="#sec-1-5-2">Solution</a></li>
<li><a href="#sec-1-5-3">Discussion</a>
<ul>
<li><a href="#sec-1-5-3-1">Safe methods</a></li>
<li><a href="#sec-1-5-3-2">Idempotent methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-6">When to Use GET</a>
<ul>
<li><a href="#sec-1-6-1">Problem</a></li>
<li><a href="#sec-1-6-2">Solution</a></li>
<li><a href="#sec-1-6-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-1-7">When to Use Post</a>
<ul>
<li><a href="#sec-1-7-1">Problem</a></li>
<li><a href="#sec-1-7-2">Solution</a></li>
<li><a href="#sec-1-7-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-1-8">How to Create Resources Using POST</a>
<ul>
<li><a href="#sec-1-8-1">Problem</a></li>
<li><a href="#sec-1-8-2">Solution</a></li>
<li><a href="#sec-1-8-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-1-9">When to Use PUT to Create New Resources</a>
<ul>
<li><a href="#sec-1-9-1">Problem</a></li>
<li><a href="#sec-1-9-2">Solution</a></li>
<li><a href="#sec-1-9-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-1-10">How to Use POST for Asynchronous Tasks</a>
<ul>
<li><a href="#sec-1-10-1">Problem</a></li>
<li><a href="#sec-1-10-2">Solution</a></li>
<li><a href="#sec-1-10-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-1-11">How to Use DELETE for Asynchronous Deletion</a>
<ul>
<li><a href="#sec-1-11-1">Problem</a></li>
<li><a href="#sec-1-11-2">Solution</a></li>
<li><a href="#sec-1-11-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-1-12">When to Use Custom HTTP Methods</a>
<ul>
<li><a href="#sec-1-12-1">Problem</a></li>
<li><a href="#sec-1-12-2">Solution</a></li>
<li><a href="#sec-1-12-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-1-13">When and How to Use Custom HTTP Headers</a>
<ul>
<li><a href="#sec-1-13-1">Problem</a></li>
<li><a href="#sec-1-13-2">Solution</a></li>
<li><a href="#sec-1-13-3">Discussion</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">Chapter 02: Identifying Resources</a>
<ul>
<li><a href="#sec-2-1">How to Identify Resources from Domain Nouns</a>
<ul>
<li><a href="#sec-2-1-1">Problem</a></li>
<li><a href="#sec-2-1-2">Solution</a></li>
<li><a href="#sec-2-1-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-2-2">How to Choose Resource Granularity</a>
<ul>
<li><a href="#sec-2-2-1">Problem</a></li>
<li><a href="#sec-2-2-2">Solution</a></li>
<li><a href="#sec-2-2-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-2-3">How to Organize Resources into Collections</a>
<ul>
<li><a href="#sec-2-3-1">Problem</a></li>
<li><a href="#sec-2-3-2">Solution</a></li>
<li><a href="#sec-2-3-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-2-4">When to Combine Resources into Composites</a>
<ul>
<li><a href="#sec-2-4-1">Problem</a></li>
<li><a href="#sec-2-4-2">Solution</a></li>
<li><a href="#sec-2-4-3">Discussion</a></li>
</ul>
</li>
<li><a href="#sec-2-5">How to Support Computing/Processing Function</a>
<ul>
<li><a href="#sec-2-5-1">Problem</a></li>
<li><a href="#sec-2-5-2">Solution</a></li>
</ul>
</li>
<li><a href="#sec-2-6">When and How to Use Controllers to Operate on Resources</a>
<ul>
<li><a href="#sec-2-6-1">Problem</a></li>
<li><a href="#sec-2-6-2">Solution</a></li>
<li><a href="#sec-2-6-3">Discussion</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 01: Using te Uniform Interface</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>HTTP协议是一个应用层协议,定义了一些client对server的resource的操作,比如GET,
POST, PUT等等. 这些都是有"实用意义的method", 如果像SOAP或者一些Ajax framework
一样,用HTTP协议来传递数据(就相当于把HTTP协议当TCP来用), 那么就失去了HTTP协议
</li>
</ul>
<p>
存在的意义
</p>
<ul class="org-ul">
<li>你能多大限度的利用HTTP协议,取决于你是否能多大限度的把HTTP协议当作一个"应用层"
协议来使用
<pre class="example">
How much you can benefit from the HTTP infrastructure largely depends on
how well you can use HTTP as an application-level protocol
</pre>
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">How to Keep Interactions Visible</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>HTTP 协议设计的宗旨是保持client和server之间的interaction是对所有的
部分都是visible的.比如proxy, cache等等,只有这样这些部分才能参与到协议里来,
改善HTTP协议.
</li>
<li>我们可以把interaction理解为requst+response
</li>
</ul>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Problem</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>了解何为"visibility", 并且怎样做才能让HTTP request和response变得"visible"
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">Solution</h4>
<div class="outline-text-4" id="text-1-1-2">
<ul class="org-ul">
<li>当你使用resource的时候:
<ul class="org-ul">
<li>使用GET来获取resource的内容
</li>
<li>使用PUT来更新resource
</li>
<li>使用DELETE来删除resource
</li>
<li>使用POST来进行不安全的并且可能改变resource的操作
</li>
<li>增加合适的HTTP header来描述request和response
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">Discussion</h4>
<div class="outline-text-4" id="text-1-1-3">
<ul class="org-ul">
<li>HTTP的以下特性都非常依赖request和response的"visibility":
<ul class="org-ul">
<li>Caching: 非常热门的response会被caching, 一旦原有的resource被更改,那么它
的caching也要相应的被invalidated
</li>
<li>Optimistic concurrency control: 发现并发的"写操作", 防止这些操作是进行在
一个"已经不是最新内容"的资源上面
</li>
<li>Content negotiation: 为某个resource选择一些"替补"
</li>
<li>Safety and idempotency: 保证client能够多次发出某一个HTTP request
</li>
</ul>
</li>
<li>保证HTTP的"visibility"还可以让你使用已有的为HTTP写的代码.
</li>
<li>HTTP的visiblity是依靠下面的特性来"保证的"
<ul class="org-ul">
<li>HTTP的interaction都是没有状态的(statelesse), 每一个HTTP的中间部分(比如
proxy)都可以查询任意一个request或者response的意义.不需要了解某个request
或者response之前或者之后的情况
</li>
<li>HTTP的一系列method,都是只针对"一个且仅仅一个"resource. 而且每个命令的意义
是不能改变的(在所有application应用中GET的意思都一样),所以HTTP也叫做uniform
interface
</li>
<li>HTTP使用了MIME-like的格式,这种格式的特点是: 明确区分了header和body, header
是visible的,而body则对所有人都是opaque的,当然除了body的创建者(client)和
处理者(server或者还有其他一些proxy等)
</li>
</ul>
</li>
<li>下面来看一个update resource的例子
<pre class="example">
# Request
PUT /movie/gone_with_the_wind HTTP/1.1
Host: www.example.org
Content-Type: application/x-www-form-urlencoded

summary=...&amp;rating=5&amp;...

# Response
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: ...

&lt;html&gt;
...
&lt;/html&gt;
</pre>
</li>
<li>上面的例子中, request的第一行描述了request使用的method和path, 接下来两行描
述了header的一些属性.然后用一个空行进行分割:header和body. summary那一行就是
body部分了
</li>
<li>reponse也是一样,前三行是header, 然后一个空行分割,后面的是body
</li>
<li>让visibility更可行的方法有:
<ul class="org-ul">
<li>使用大家都任何的method语意
</li>
<li>合理使用几个header的属性,让你的意图更为其他人所理解
</li>
<li>合理使用status code(后面会讲到)
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">When to Trade Visibility</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>visibility不是HTTP唯一的目的,有时候为了其他的特性,比如网络效率,用户便捷等,
要牺牲一些visibility,下面是一个例子
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Problem</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>你想知道在哪些常用的情景下, 你要牺牲一些visibility
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Solution</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>当你有多个resource共享数据,或者一个操作更改多个resource的时候, visibility
就要被牺牲一些了.
</li>
<li>牺牲的原因, 是为了能获取如下更好的特性:
<ul class="org-ul">
<li>更好的信息抽象
</li>
<li>更松的耦合
</li>
<li>更高的网络效率
</li>
<li>更高的资源的颗粒度
</li>
<li>更好的用户使用便捷性
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Discussion</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>下面是一个要牺牲visibility的例子: client可以GET person或者address的数据, 而
server为了client的方便, 会把address的数据放到person里面
<div class="org-src-container">

<pre class="src src-xml"># Request to get the person
GET /person/1 HTTP/1.1
Host: www.example.org
Content-Type: application/xml;charset=UTF-8

&lt;<span style="color: #268bd2;">person</span>&gt;
    &lt;<span style="color: #268bd2;">name</span>&gt; John Doe&lt;/<span style="color: #268bd2;">name</span>&gt;
    &lt;<span style="color: #268bd2;">address</span> <span style="color: #268bd2;">type</span>=<span style="color: #2aa198;">"</span><span style="color: #2aa198;">home</span><span style="color: #2aa198;">"</span>&gt;
        &lt;<span style="color: #268bd2;">street</span>&gt; 1 Main Street&lt;/<span style="color: #268bd2;">street</span>&gt;
        &lt;<span style="color: #268bd2;">city</span>&gt;Bellevue&lt;/<span style="color: #268bd2;">city</span>&gt;
        &lt;<span style="color: #268bd2;">state</span>&gt;WA&lt;/<span style="color: #268bd2;">state</span>&gt;
    &lt;/<span style="color: #268bd2;">address</span>&gt;
&lt;/<span style="color: #268bd2;">person</span>&gt;

# Request to get the address
GET /person/1/address HTTP/1.1
Host: www.example.org
Content-Type: application/xml;charset=UTF-8


&lt;<span style="color: #268bd2;">address</span> <span style="color: #268bd2;">type</span>=<span style="color: #2aa198;">"</span><span style="color: #2aa198;">home</span><span style="color: #2aa198;">"</span>&gt;
    &lt;<span style="color: #268bd2;">street</span>&gt;1 Main Street &lt;/<span style="color: #268bd2;">street</span>&gt;
    &lt;<span style="color: #268bd2;">city</span>&gt;Bellevue&lt;/<span style="color: #268bd2;">city</span>&gt;
    &lt;<span style="color: #268bd2;">state</span>&gt;WA&lt;/<span style="color: #268bd2;">state</span>&gt;
&lt;/<span style="color: #268bd2;">address</span>&gt;
</pre>
</div>
</li>
<li>我们继续假设server可以允许client进行PUT request来更新person和address这两个
数据.那就存在一个问题: 在HTTP看来person和address是两个相互独立的数据.但是server
知道,他们俩是相关联的. 如果还是按照原来的一个HTTP request只能对应一个resource,
从而达到visibility的话, 是不可行的了.所以visibility要牺牲掉了
</li>
<li>牺牲visibility的最显著的恶果,就是caching不再好使了.
</li>
<li>上面的例子是为了client convenience来牺牲了visibility, 除此之外还有:
<ul class="org-ul">
<li>abstraction: 为了让复杂的业务逻辑代码更好的抽象(比如多个资源改变组成一个
事务),也要牺牲visibility
</li>
<li>network efficienty: 如果每个资源都使用一个GET的话,网络传输就会变得非常的
繁重. 网络使用效率也会很低下. 为此server在设计web service的时候,可以把某
些经常在一起的资源设计成一个batch, 从而减少网络传输负担
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">How to Maintain Application State</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>REST设计有一个推荐要求就是"keep the application state on the client".
</li>
</ul>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Problem</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>如何不适用in-memory的session来控制application的state
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Solution</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>让用户通过URI来和resource交流,如果resource太大,或者由于安全原因无法在网络
上传输.把application存在数据库里面.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">Discussion</h4>
<div class="outline-text-4" id="text-1-3-3">
<ul class="org-ul">
<li>假设一个自动"上保险"的例子. :
<ul class="org-ul">
<li>第一步: client首先把自己的驾驶员姓名和汽车状态发送给server, 然后server返
回一个报价(一周内有效)
</li>
<li>第二步: client认为这个报价合理,于是就会申请以这个报价来拿下自己的保险
</li>
</ul>
</li>
<li>在这个例子中,server第一步中提供的"报价"就是我们所说的application state.server
必须记住第一步的"报价",否则无法进行交易
</li>
<li>HTTP是一个stateless 的协议, 每一个request都是和其他request无关的.而client
往往都是要按照一定的顺序来发起request才能得到服务的.所以server要有办法来维
护application state.
</li>
<li>最好的办法是再Request的body部分保存这些数据. 比如下面的例子, 是一个POST的
request, 再body部分提供了参数fname, lname等
<pre class="example">
# Request
POST /quotegen HTTP/1.1
Host: www.example.org
Content-Type: application/x-www-form-urlencoded

fname=...&amp;lname=...&amp;

# Respose
HTTP/1.1 200 OK
Content-Type: application/xml;charset=UTF-8

&lt;quote xmlns:atom="http://www.w3.org/2005/Atom"&gt;
  &lt;driver&gt;
  ...
  &lt;/driver&gt;
  &lt;vehicle&gt;
  ...
  &lt;/vehicle&gt;
  &lt;offer&gt;
  ...
    &lt;valid-until&gt;2009-10-02&lt;/valid-until&gt;
    &lt;atom:link href="http://www.example.org/quotes/buy?quote=abc1234"
               rel="http://www.example.org/rels/quotes/buy"/&gt;
  &lt;/offer&gt;
&lt;/html&gt;
</pre>
</li>
<li>server端使用数据库保存了client的价格,然后返回给用户.
</li>
<li>除了使用POST,然后body保存参数的方法以外,还可以使用GET,然后把参数都写再URL
里面(我们最初学动态网页的时候就是这样用)
<pre class="example">
# Request
GET /quotegen?fname=...&amp;lname=...&amp;... HTTP/1.1
Host: www.example.org

# Response
HTTP/1.1 200 OK
Content-Type: application/xml;charset=UTF-8

&lt;quote xmlns:atom="http://www.w3.org/2005/Atom"&gt;
  &lt;driver&gt;
  ...
  &lt;/driver&gt;
  &lt;vehicle&gt;
  ...
  &lt;/vehicle&gt;
  &lt;offer&gt;
  ...
    &lt;valid-until&gt;2009-08-02&lt;/valid-until&gt;
    &lt;atom:link href="http://www.example.org/quotes/buy?fname=...&amp;lname=...&amp;..."
               rel="http://www.example.org/quotes/buy"/&gt;
  &lt;/offer&gt;
&lt;/html&gt;
</pre>
</li>
<li>在link里面保存application state的方法要注意,要进行额外的检查,防止参数被更改.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">How to Implement Safe and Idempotent Methods on the Server</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">Problem</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li>学习什么是"安全性"和"幂等性",并且如何再sever实现他们
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">Solution</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>当实现GET, OPTIONS以及HEAD函数的时候, 不要产生任何的side effects. 当Client
发送GET, HEAD, OPTIONS, PUT,或者DELETE的request的时候,server能够返回相同的
response
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3">Discussion</h4>
<div class="outline-text-4" id="text-1-4-3">
<ul class="org-ul">
<li>下面的表列出了哪些HTTP method是安全的,哪些是幂等的
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Method</th>
<th scope="col" class="left">Safe?</th>
<th scope="col" class="left">Idempotent?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">GET</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="left">HEAD</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="left">OPTIONS</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="left">PUT</td>
<td class="left">No</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="left">DELETE</td>
<td class="left">No</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="left">POST</td>
<td class="left">No</td>
<td class="left">NO</td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
<div id="outline-container-sec-1-4-3-1" class="outline-5">
<h5 id="sec-1-4-3-1">Implementing safe methods</h5>
<div class="outline-text-5" id="text-1-4-3-1">
<ul class="org-ul">
<li>safe method就是client发送了也不用担心会有"side effect", 不用担心"负责任"
的method:这些safe的method的安全性通过把他们设置成read-only来保障
</li>
<li>safe并不是意味着这个操作得到的结果一直不变,而是意味着它不会让server担心"它
会干坏事情". 比如下面的例子,虽然两次GET的结果不一样,但是GET肯定还safe的
method
<pre class="example">
# First request
GET /quots?symb=YHOO HTTP/1.1

HTTP/1.1 200 OK
Content-Type: text/plain:charset=UTF-8

# First response
15.96

# Second request
GET /quots?symb=YHOO HTTP/1.1

HTTP/1.1 200 OK
Content-Type: text/plain:charset=UTF-8

# Second response
16.10
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4-3-2" class="outline-5">
<h5 id="sec-1-4-3-2">Implementing idempotent methods</h5>
<div class="outline-text-5" id="text-1-4-3-2">
<ul class="org-ul">
<li>所谓幂等性,是说client可以连续不断的发送同一个request, 而且每次从server得
到的结果都是一样的.
</li>
<li>幂等性有点像setter: 把一个变量set成某个值,无论执行多少遍,结果应该都是一样的.
</li>
<li>比如我们PUT一个value的时候,网络一次两次的错误,不会影响我们的结果,我们失败
了再来一次就是了
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4-3-3" class="outline-5">
<h5 id="sec-1-4-3-3">Idempotency of DELETE</h5>
<div class="outline-text-5" id="text-1-4-3-3">
<ul class="org-ul">
<li>如果要把DELETE也实现成"幂等性"的method的话,必须要做到的就是记录所有的已删
除项目, 否则连续发送两次的话,(第一次已经成功删除的情况下)第二次就不记得这
个项目了,会返回404(Not Found)
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">How to Treat Safe and Idempotent Methods in Clients</h3>
<div class="outline-text-3" id="text-1-5">
</div><div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">Problem</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li>如何实现安全,幂等的HTTP request
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">Solution</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li>把GET,OPTIONS, HEAD设计成只读操作,能用的时候,毫不含糊的用
</li>
<li>如果出现了网络故障,那么在重新发送GET, PUT, DELETE request的时候,一定要提供
If-Unmodified-Since和If-Match选项
</li>
<li>不要重复发送POST, 除非client知道某个特定的时间内,POST是幂等的(也就是server
会记录已经删除的数据多久)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3">Discussion</h4>
<div class="outline-text-4" id="text-1-5-3">
</div><div id="outline-container-sec-1-5-3-1" class="outline-5">
<h5 id="sec-1-5-3-1">Safe methods</h5>
<div class="outline-text-5" id="text-1-5-3-1">
<ul class="org-ul">
<li>任何一个Client都应该可以无限制的调用那些safe method,比如: GET, OPTIONS, HEAD
如果这都不能保证的话,那么server的设计,有问题
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-3-2" class="outline-5">
<h5 id="sec-1-5-3-2">Idempotent methods</h5>
<div class="outline-text-5" id="text-1-5-3-2">
<ul class="org-ul">
<li>除了Post以外的method都是幂等的,所以只要失败了都要继续调用
</li>
<li>Post是最危险的一个,除非server告诉你,其他情况下不要擅自重复调用post
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">When to Use GET</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>Web的设计很大的倚重GET, 因为它是既安全又幂等的.
</li>
</ul>
</div>
<div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">Problem</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>何时使用GET最好
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2">Solution</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>使用GET来安全幂等的获取资源
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-3" class="outline-4">
<h4 id="sec-1-6-3">Discussion</h4>
<div class="outline-text-4" id="text-1-6-3">
<ul class="org-ul">
<li>GET最常的"滥用"是: 把它用来执行不安全的操作
<pre class="example">
# Bookmark a page
GET /bookmarks/add_bookmark?href=http3A%2F%2Fwww.example.org%2F
2009%2F10%2F10%2Fnotes.html HTTP/1.1
Host: www.example.org

# Add an item to a shopping cart
GET /add_cart?pid=1234 HTTP/1.1
Host: www.example.org

# Send a message
GET /message/send?message=Iamreading HTTP/1.1
Host: www.example.org

# Delete a note
GET /notes/delete?id=1234 HTTP/1.1
Host: www.example.org
</pre>
</li>
<li>对于server来说,这些操作都是不安全,不幂等的.但是再HTTP协议这个层面上来讲,反
而是安全幂等的.这对server来说是一个隐患
</li>
<li>如果你一定要这样实现的话,那么要注意三点(当然最后不要乱用GET):
<ul class="org-ul">
<li>让你的response不要cache=&gt;设置Cache-Control为no-cache
</li>
<li>不要不小心更改了核心代码
</li>
<li>让server端代码进行更改,让这些操作都幂等
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">When to Use Post</h3>
<div class="outline-text-3" id="text-1-7">
</div><div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1">Problem</h4>
<div class="outline-text-4" id="text-1-7-1">
<ul class="org-ul">
<li>使用POST的时机
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2">Solution</h4>
<div class="outline-text-4" id="text-1-7-2">
<ul class="org-ul">
<li>以下几种情况下,适合使用POST:
<ul class="org-ul">
<li>创建一个resource,像工厂一样使用resource
</li>
<li>使用controller来更改某些resource
</li>
<li>如果输入很大的时候,即便是查询代码,也要使用POST
</li>
<li>当执行其他不安全,不幂等的操作的时候.
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-7-3" class="outline-4">
<h4 id="sec-1-7-3">Discussion</h4>
<div class="outline-text-4" id="text-1-7-3">
<ul class="org-ul">
<li>再HTTP的语意中, POST的意义最为广泛:
<ul class="org-ul">
<li>标记已有资源
</li>
<li>给新闻组,邮件列表发送帖子
</li>
<li>发送一组数据(比如submitting of a form)给data-handling process
</li>
<li>扩展数据库功能.
</li>
</ul>
</li>
<li>对于所有了解HTTP协议的周边设备或者软件来说,POST意味着:
<ul class="org-ul">
<li>Post的response不可cache
</li>
<li>爬虫不会自动激活POST request
</li>
<li>大多数HTTP 工具不会重复发送 POST request
</li>
</ul>
</li>
<li>正是由于server端对于POST如此多的"考虑",所以POST成了"多用途"method
</li>
<li>以下两种情况考虑使用POST:
<ul class="org-ul">
<li>URI传参数可能会泄露数据
</li>
<li>查询用GET的话,参数太多不好,还是使用POST
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">How to Create Resources Using POST</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>POST最重要的作用就是创建新的resource. 其方法和工厂模式类似
</li>
</ul>
</div>
<div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1">Problem</h4>
<div class="outline-text-4" id="text-1-8-1">
<ul class="org-ul">
<li>如何创建新的resource, reqeust和response里面各引入什么
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-2" class="outline-4">
<h4 id="sec-1-8-2">Solution</h4>
<div class="outline-text-4" id="text-1-8-2">
<ul class="org-ul">
<li>让client提交一个POST request, 创造的结果其就像工厂资源一样
</li>
<li>Slug是一个optional的header,像server建议我们的参数叫什么名字
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-3" class="outline-4">
<h4 id="sec-1-8-3">Discussion</h4>
<div class="outline-text-4" id="text-1-8-3">
<ul class="org-ul">
<li>假设我们创建一个用户adderss, 那么用户就像工厂
<pre class="example">
# Request
POST /user/smith HTTP/1.1
Slug: Home Address
Host: www.example.org
Content-Type: application/xml;charset=UTF-8
Slug: Home Address

&lt;address&gt;
  &lt;street&gt;1, Main Street&lt;/street&gt;
  &lt;city&gt;Some city&lt;/city&gt;
&lt;/address

# Respose
HTTP/1.1 201 Created
Location: http://ww.example.org/user/smith/address/home_address
Content-Location: http://ww.example.org/user/smith/address/home_address
Content-Type: application/xml;charset=UTF-8

&lt;address&gt;
  &lt;id&gt;urn:example:user:smith:address:1&lt;/id&gt;
  &lt;atom:link ref="self" href="http://ww.example.org/user/smith/address/home_address"/&gt;
  &lt;street&gt;1, Main Street&lt;/street&gt;
  &lt;city&gt;Some City&lt;/city&gt;
&lt;/address&gt;
</pre>
</li>
<li>从返回的结果看server尊重了client提出的resource名字的要求
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">When to Use PUT to Create New Resources</h3>
<div class="outline-text-3" id="text-1-9">
</div><div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1">Problem</h4>
<div class="outline-text-4" id="text-1-9-1">
<ul class="org-ul">
<li>创建用户既可以使用PUT,也可以使用POST, 如何选择
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-9-2" class="outline-4">
<h4 id="sec-1-9-2">Solution</h4>
<div class="outline-text-4" id="text-1-9-2">
<ul class="org-ul">
<li>如果client可以决定resource的URI,那么使用PUT来创建新的resource,否则使用POST
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-9-3" class="outline-4">
<h4 id="sec-1-9-3">Discussion</h4>
<div class="outline-text-4" id="text-1-9-3">
<ul class="org-ul">
<li>下面是使用PUT来创建资源的例子
<pre class="example">
# Request
PUT /user/smith/addres/home_address HTTP/1.1
Host: www.example.org
Content-Type: application/xml;charset=UTF-8

&lt;address&gt;
  &lt;street&gt;1, Main Street&lt;/street&gt;
  &lt;city&gt;Some City&lt;/city&gt;
&lt;/address&gt;

# Response
HTTP/1.1 201 Created
Location: http://www.example.org/user/smith/address/home_address
Content-Location: http://www.example.org/uer/smith/address/home_address
Content-Type: application/xml;charset=UTF-8

&lt;address&gt;
  &lt;id&gt;urn:example:user:smith:address:1&lt;/id&gt;
  &lt;atom:link rel="self" href="http://www.example.org/user/smith/address/home_address"/&gt;
  &lt;street&gt;1, Main Street&lt;/street&gt;
  &lt;city&gt;Some City&lt;/city&gt;
&lt;/address&gt;
</pre>
</li>
<li>而在client无法控制URI的情况下,要使用Slug来为server提供一些名字的帮助, 但是
具体URI位置还是由server来决定
</li>
<li>想让client能够PUT就创建URI, 需要:
<ul class="org-ul">
<li>server必须跟client解释server是如何组织的,什么样的URI是合法的
</li>
<li>server必须给client一个自由的限度,某些URI才能合适,不能让client无线创造
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">How to Use POST for Asynchronous Tasks</h3>
<div class="outline-text-3" id="text-1-10">
<ul class="org-ul">
<li>HTTP是stateless的,每次request必须有一个痛快的response,要么行,要么不行
</li>
<li>但是server有时候需要运行一段时间才能给出答复, client必须再次查询才能得到结果
</li>
</ul>
</div>
<div id="outline-container-sec-1-10-1" class="outline-4">
<h4 id="sec-1-10-1">Problem</h4>
<div class="outline-text-4" id="text-1-10-1">
<ul class="org-ul">
<li>如何设计那些需要server非常长时间完成的POST request
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-10-2" class="outline-4">
<h4 id="sec-1-10-2">Solution</h4>
<div class="outline-text-4" id="text-1-10-2">
<ul class="org-ul">
<li>收到client的POST request的时候,创建一个叫做task resource的东西,这个东西好比
一个进度表,能让client再次来查询进度(甚至包括剩余时间)
</li>
<li>然后server返回给client一个status 202 (Accept)表明我已经开始创建任务了,但是
因为时间很长,所以你要等一会来查询状态.
</li>
<li>然后人物在server端开始了,client可以不时发送GET来跟踪task resource的状态.会
有如下几种状态:
<ul class="org-ul">
<li>Still processing: 返回status 200 (OK), 并且把task resource的状态告诉client
</li>
<li>On Successful completion: 返回status 303 (See Other), 然后在response里面
包含一个Location header来指明花费很久才成功的resource的地址
</li>
<li>On task failue: 返回status 200(OK), 并且把task resource的失败和原因告诉client
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-10-3" class="outline-4">
<h4 id="sec-1-10-3">Discussion</h4>
<div class="outline-text-4" id="text-1-10-3">
<ul class="org-ul">
<li>我们给一个实际的例子,client发送一个图片到server,让server去ps. server会花费
很久才能完成,在这其间client就是可以查询进度
</li>
<li>client的request分成了两个部分,第一部分使用XML来描述来描述image需要怎么ps,
第二部分才是真正的pic部分. 这叫做multipart message(再Content-Type里面设置了)
<pre class="example">
# Request
POST /images/tasks HTTP/1.1
Content-Type: multipart/related; boundary=xyz

--xyz
Content-Type: application/xml;charset=UTF-8
...

--xyz
Content-Type: image/png
...

--xyz--
</pre>
</li>
<li>server会马上开始满足client这个请求,同时创建了task/1来让client追踪状态.
<pre class="example">
# Response
HTTP/1.1 202 Accepted
Content-Type: application/xml;charset=UTF-8
Content-Location: http://www.example.org/images/task/1
Date: Sun, 12 Sep 2009 01:49:27 GMT

&lt;status xmlns:atom="http://www.w3.org/2005/Atom"&gt;
  &lt;state&gt;pending&lt;/state&gt;
  &lt;atom:link href="http://www.example.org/images/task/1" rel="self"/&gt;
  &lt;message xml:lang="en"&gt; Your request has been accepted for processing.&lt;/message&gt;
  &lt;ping-after&gt; 2009-09-1T01:59:27Z &lt;/ping-after&gt;   # hint to check for the status later time
&lt;/status&gt;
</pre>
</li>
<li>client(在没过ping-after时间)就不断查询状态, 如果sever还没弄完的话,那么会出
现下面的request和response的对话
<pre class="example">
# Request
GET /images/task/1 HTTP/1.1
Host: www.example.org

# Response
HTTP/1.1 200 OK
Content-Type: application/xml;charset=UTF-8

&lt;status xmlns:atom="http://www.w3.org/2005/Atom"&gt;
  &lt;state&gt;pending&lt;/state&gt;
  &lt;atom:link href="http://www.example.org/images/task/1" rel="self"/&gt;
  &lt;message xml:lange="en"&gt; Your request is currently being processed.&lt;/message&gt;
  &lt;ping-after&gt; 2009-09-1T01:59:27Z &lt;/ping-after&gt;
&lt;/status&gt;
</pre>
</li>
<li>client查询时,如果server已经完工了,就会有如下的"会话". 而且会告诉client,你
可以去"images/1"这个位置找到我处理好的照片啦!
<pre class="example">
# Request
GET /images/task/1 HTTP/1.1
Host:www.example.org

# Response
HTTP/1.1 303 See Other
Location: http://www.example.org/images/1
Content-Location: http://www.example.org/images/task/1

&lt;status xmlns:atom="http://www.w3.org/2005/Atom"&gt;
  &lt;state&gt;done&lt;/state&gt;
  &lt;atom:link href="http://www.example.org/images/task/1" rel-"self"/&gt;
  &lt;message xml:lange="en"&gt;Your request has been processed.&lt;/message&gt;
&lt;/status&gt;
</pre>
</li>
<li>如果server处理照片失败的话
<pre class="example">
# Request
GET /images/task/1 HTTP/1.1
Host:www.example.org

# Response
HTTP/1.1 200 OK
Content-Location: http://www.example.org/images/task/1

&lt;status xmlns:atom="http://www.w3.org/2005/Atom"&gt;
  &lt;state&gt;failed&lt;/state&gt;
  &lt;atom:link href="http://www.example.org/images/task/1" rel-"self"/&gt;
  &lt;message xml:lange="en"&gt;Failed to complete the request.&lt;/message&gt;
  &lt;detail xml:lang="en"&gt;Invalid image format&lt;/detail&gt;
  &lt;complted&gt;2009-09-13T02:10:00Z&lt;/complted&gt;
&lt;/status&gt;
</pre>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">How to Use DELETE for Asynchronous Deletion</h3>
<div class="outline-text-3" id="text-1-11">
</div><div id="outline-container-sec-1-11-1" class="outline-4">
<h4 id="sec-1-11-1">Problem</h4>
<div class="outline-text-4" id="text-1-11-1">
<ul class="org-ul">
<li>如何处理那种需要很久才能删除的DELETE request(和很久创建的POST request对应)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-11-2" class="outline-4">
<h4 id="sec-1-11-2">Solution</h4>
<div class="outline-text-4" id="text-1-11-2">
<ul class="org-ul">
<li>sever收到client的请求以后,回以202(Accept), 然后创建一个task resource,之后
client可以查询这个task resource 的状态(总体和POST一个长久resource类似)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-11-3" class="outline-4">
<h4 id="sec-1-11-3">Discussion</h4>
<div class="outline-text-4" id="text-1-11-3">
<ul class="org-ul">
<li>client提出请求删除resource
<pre class="example">
DELETE /users/john HTTP/1.1
Host: www.example.org
</pre>
</li>
<li>然后server会创建task resource
<pre class="example">
HTTP/1.1 202 Accepted
Content-Type: application/xml;charset=UTF-8

&lt;status xmlns:atom="http://www.w3.org/2005/Atom"&gt;
  &lt;state&gt;pending&lt;/state&gt;
  &lt;atom:link href="http://www.example.org/task/1" rel="self"/&gt;
  &lt;message xml:lange="en"&gt;Your request has been accepted for processing.&lt;/message&gt;
  &lt;created&gt;2009-07-05T03:10:00Z&lt;/created&gt;
  &lt;ping-after&gt;2009-07-05T03:15:00Z&lt;/ping-after&gt;
&lt;/status&gt;
</pre>
</li>
<li>然后client就可以通过URI <a href="http://www.example.org/task/1">http://www.example.org/task/1</a> 来了解状态,其他就和
POST一个非常费时的资源.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">When to Use Custom HTTP Methods</h3>
<div class="outline-text-3" id="text-1-12">
<ul class="org-ul">
<li>历史上也有很多的扩展HTTP的努力.最著名的就是WebDAV.
</li>
</ul>
</div>
<div id="outline-container-sec-1-12-1" class="outline-4">
<h4 id="sec-1-12-1">Problem</h4>
<div class="outline-text-4" id="text-1-12-1">
<ul class="org-ul">
<li>想知道使用custom HTTP的函数
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-12-2" class="outline-4">
<h4 id="sec-1-12-2">Solution</h4>
<div class="outline-text-4" id="text-1-12-2">
<ul class="org-ul">
<li>不要使用nonstandard custom HTTP method
</li>
<li>如果实在要使用custom HTTP method,那么要设计一个controller, 把custom HTTP的
包裹成POST请求(POST真是万金油啊)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-12-3" class="outline-4">
<h4 id="sec-1-12-3">Discussion</h4>
<div class="outline-text-4" id="text-1-12-3">
<ul class="org-ul">
<li>POST是比custom HTTP method更好也更安全的选择
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13">When and How to Use Custom HTTP Headers</h3>
<div class="outline-text-3" id="text-1-13">
<ul class="org-ul">
<li>HTTP server会"经常的"使用custom header.常见的custom header包括:
<ul class="org-ul">
<li>X-Powered-By
</li>
<li>X-Cached
</li>
<li>X-Pingback
</li>
<li>X-Forwarded-For
</li>
<li>X-HTTP-Method-Override
</li>
</ul>
</li>
<li>HTTP并不阻止新的header诞生,但是这通常意味着有时候会降低通用性,协作性
</li>
</ul>
</div>
<div id="outline-container-sec-1-13-1" class="outline-4">
<h4 id="sec-1-13-1">Problem</h4>
<div class="outline-text-4" id="text-1-13-1">
<ul class="org-ul">
<li>你想了解使用custome header的注意事项和常用规范
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-13-2" class="outline-4">
<h4 id="sec-1-13-2">Solution</h4>
<div class="outline-text-4" id="text-1-13-2">
<ul class="org-ul">
<li>把custom header作为一种"额外信息"的提供者,而不是要改变HTTP method的常见的,
广泛被承认的功能.
</li>
<li>不要让你的custom header作用重要到会"影响解析的结果"
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-13-3" class="outline-4">
<h4 id="sec-1-13-3">Discussion</h4>
<div class="outline-text-4" id="text-1-13-3">
<ul class="org-ul">
<li>大部分使用WordPress的系统,都会在HTTP response里面包含如下的header
<pre class="example">
X-Powered-By: PHP/5.2.6-2ubuntu4.2
X-Pingback: http://www.example.org/xmlrpc.php
</pre>
</li>
<li>这两个header都是custom的:
<ul class="org-ul">
<li>第一个header告诉client,server是搭建在ubuntu的某个PHP版本
</li>
<li>第二个header告诉client,可以通过下面的URI来通知wordpress,我进行了引用
</li>
</ul>
</li>
<li>通过这几个例子我们发现custom header通常是如下命名的
<pre class="example">
X-{company-name}-{header-name}
</pre>
</li>
<li>不要使用custom header的原因还有,在client和server之间会有HTTP intermedary,
他们很可能会丢弃custom header
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 02: Identifying Resources</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">How to Identify Resources from Domain Nouns</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">Problem</h4>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2">Solution</h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>使用POST,DELETE,PUT和GET来表示网络资源的"增删改查"
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3">Discussion</h4>
<div class="outline-text-4" id="text-2-1-3">
<ul class="org-ul">
<li>REST 和CRUD(Create, Read, Update, Delete)是完全合拍的.
</li>
<li>现实情况的有很多操作,并不是一个method(POST,DELETE,PUT,GET)能够完成的,需要
很多method在一起,通力合作.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">How to Choose Resource Granularity</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">Problem</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>如何设计一个resource的粒度
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">Solution</h4>
<div class="outline-text-4" id="text-2-2-2">
<ul class="org-ul">
<li>粒度大小的设计要考虑:
<ul class="org-ul">
<li>网络效率
</li>
<li>client的方便性
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">Discussion</h4>
<div class="outline-text-4" id="text-2-2-3">
<ul class="org-ul">
<li>我们以一个社交网络上的用户为例.这个用户肯定有很多的数据:
<ul class="org-ul">
<li>朋友列表
</li>
<li>分享列表
</li>
<li>活动列表
</li>
</ul>
</li>
<li>我们不可能一次把某个user的所有数据都传输的.所以我们要设计好大小,而不同的客
户端, 其颗粒大小也不一样.富客户端很可能一次得到的数据就多一点(因为可以存储)
</li>
<li>还要考虑数据的可变性,如果不可变,那么cache住是很好的办法
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">How to Organize Resources into Collections</h3>
<div class="outline-text-3" id="text-2-3">
</div><div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Problem</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>如何把具有某个共同特质的资源结合起来.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Solution</h4>
<div class="outline-text-4" id="text-2-3-2">
<ul class="org-ul">
<li>一般来说,常规的能够在一起组合成一个collection的数据是:
<ul class="org-ul">
<li>那些共享同一个数据库的创建语句(同一类对象)
</li>
<li>某些attribute对于client来说比较相似的资源
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3">Discussion</h4>
<div class="outline-text-4" id="text-2-3-3">
<ul class="org-ul">
<li>一旦你把某些资源group成一个collection, 你可以使用一个GET来把这一群数据都取
回来.
</li>
<li>还是上面的例子,用户有很多的朋友,用户和朋友肯定都是使用相同的数据库语句创建
出来的,那么我可以根据朋友们的兴趣,把具有某个兴趣的人都"一次GET回来",比如所
有都喜欢跑步的人,某个用户的朋友.
<pre class="example">
# Request
GET /users HTTP/1.1
Host: www.example.org

# Response
HTTP/1.1 200 OK
Content-Type: application/xml;charset=UTF-8

&lt;users xmlns:atom="http://www.w3.org/2005/Atom"&gt;
  &lt;atom:link ref="self" href="http://www.example.org/users"/&gt;
  &lt;user&gt;
    &lt;id&gt;urn:example:user:001&lt;/id&gt;
    &lt;atom:link rel="self" href="http://www.example.org/user/uesr001"
    &lt;name&gt;John Doe&lt;/name&gt;
    &lt;email&gt;john.doe@example.org&lt;/email&gt;
  &lt;/user&gt;
  &lt;user&gt;
    &lt;id&gt;urn:example:user:002&lt;/id&gt;
    &lt;atom:link rel="self" href="http://www.example.org/user/uesr002"
    &lt;name&gt;John Doe&lt;/name&gt;
    &lt;email&gt;john.doe@example.org&lt;/email&gt;
  &lt;/user&gt;
&lt;/users&gt;
</pre>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">When to Combine Resources into Composites</h3>
<div class="outline-text-3" id="text-2-4">
</div><div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1">Problem</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li>如何提供一个资源,这个资源能够从两个以上的资源里面提取state
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2">Solution</h4>
<div class="outline-text-4" id="text-2-4-2">
<ul class="org-ul">
<li>其实是为了效率,某次去identity资源A的时候,同时也把其他资源BCDEF的结果都response
回去.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3">Discussion</h4>
<div class="outline-text-4" id="text-2-4-3">
<ul class="org-ul">
<li>这种response里面"捎带"其他资源的"顺风车"行为,要建立在"产品逻辑的基础上",比
如下面这三个GET是, 查阅某个用户的资料, 并且附加这个用户最近的购买记录,和
pend记录
<pre class="example">
# Get the customer data
GET /customer/1234 HTTP/1.1
Host: www.example.org

# Get the 10 latest purchase orders
GET /orders?customerid=1234&amp;sortby=date_desc&amp;limit=10 HTTP/1.1
Host: www.example.org

# Get the 10 latest pending quotes
GET /quotes?customerid=1234&amp;sortby=date_desc&amp;status=pending&amp;limit=10 HTTP/1.1
Host: www.example.org
</pre>
</li>
<li>这三个GET,是我们产品的一个逻辑代码.因为经常使用,我们可以设计一个新的GET,可
以一次把这三个都GET回来.
<pre class="example">
# Request
GET /customer/1234/snapshot HTTP/1.1
Host: www.example.org

# Response
HTTP/1.1 200 OK
Content-Type: application/xml;charset=UTF-8
&lt;snapshot xmlns:atom="http://www.w3.org/2005/Atom"&gt; &lt;!-- Customer info --&gt;
  &lt;customer&gt;
    &lt;id&gt;1234&lt;/id&gt;
    &lt;atom:link rel="self" href="http://www.example.org/customer/1234"&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;address&gt;...&lt;/address&gt;
  &lt;/customer&gt;
  &lt;!-- Most 10 recent orders placed by the customer --&gt;
  &lt;orders&gt;
    &lt;atom:link rel="http://www.example.org/rels/orders/recent" href="http://www.example.org/orders?customerid=1234&amp;sortby=date_desc&amp;"/&gt;
    &lt;order&gt;
      &lt;id&gt;...&lt;/id&gt; ...
    &lt;/order&gt;
    ...
  &lt;/orders&gt;
  &lt;!-- Most 10 pending quotes for the customer --&gt;
  &lt;quotes&gt;
    &lt;atom:link rel="http://www.example.org/rels/quotes/recent"
               href="http://www.example.org/quotes?customerid=1234&amp;sortby=date_desc&amp;"/&gt; ...
  &lt;/quotes&gt;
&lt;/snapshot&gt;
</pre>
</li>
<li>设计这种"顺风车"的request也是有讲究的:
<ul class="org-ul">
<li>如果这种"组合"的request不是太经常使用,那么是不合算的
</li>
<li>如果server要把三个部分的内容结合起来,也是非常麻烦的.
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">How to Support Computing/Processing Function</h3>
<div class="outline-text-3" id="text-2-5">
</div><div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1">Problem</h4>
<div class="outline-text-4" id="text-2-5-1">
<ul class="org-ul">
<li>如何使用request来询问某些抽象的事件,比如:
<ul class="org-ul">
<li>性能测试
</li>
<li>数据验证(validate)
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-5-2" class="outline-4">
<h4 id="sec-2-5-2">Solution</h4>
<div class="outline-text-4" id="text-2-5-2">
<ul class="org-ul">
<li>把处理函数作为一个资源,使用HTTP GET来获取处理函数的结果,在GET的时候,使用
parameter来为这些处理函数提供参数
</li>
<li>抽象事件其实广泛的存在于CS的领域内,比如client给定两个地址,server来规划路线
给定用户名密码,server来验证.这其实是把计算力放置在server的一个集中体现.
</li>
<li>我们先看第一个例子,求两个点之间的距离,我们把计算的这个函数"看做是资源"(因为
RESTful只有资源这个概念,没有函数的概念,RESTful是面向对象的,不是面向过程的)
<pre class="example">
# Request
GET /distance_calc?lats=47.610&amp;lngs=-122.333&amp;late=37.788&amp;lnge=-122.406 HTTP/1.1
Host: www.example.org

# Response
HTTP/1.1 200 OK
Content-Type: application/xml; charset=UTF-8

&lt;result xmlns:atom="http:/www.w3.org/2005/Atom"&gt;
  &lt;atom:link rel="self"
             href="http://ww.example.org/distance_calc?lats=47.610&amp;lngs=-122.333&amp;late=37.788&amp;lnge=-122.406"/&gt;
  &lt;distance unit="miles"&gt;808.0&lt;/distance&gt;
&lt;/result&gt;
</pre>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">When and How to Use Controllers to Operate on Resources</h3>
<div class="outline-text-3" id="text-2-6">
</div><div id="outline-container-sec-2-6-1" class="outline-4">
<h4 id="sec-2-6-1">Problem</h4>
<div class="outline-text-4" id="text-2-6-1">
<ul class="org-ul">
<li>如何处理一次操作但是涉及了多个资源的情况
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6-2" class="outline-4">
<h4 id="sec-2-6-2">Solution</h4>
<div class="outline-text-4" id="text-2-6-2">
<ul class="org-ul">
<li>Client发送一个POST请求就可以更改server的资源(一个或者多个):
<ul class="org-ul">
<li>如果资源只有一个被更改,那么server返回status 201 (Created)
</li>
<li>如果资源有多个被更改,那么server返回status 303 (See Other), 然后返回一个
Location里面有URI来列举哪些资源被修改了
</li>
<li>如果资源多个被更改,但是sever无法使用一个Location来返回所有的被更改资源,那
么server返回status 200, 在自己的body部分进行说明
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6-3" class="outline-4">
<h4 id="sec-2-6-3">Discussion</h4>
<div class="outline-text-4" id="text-2-6-3">
<ul class="org-ul">
<li>这种情况下,其实使用native的request函数也可以解决,有如下两种不是很高效的手段:
<ol class="org-ol">
<li>整体处理:
<ul class="org-ul">
<li>从server下载全部联系人
</li>
<li>把本地的联系人和这个下载的联系人进行merge
</li>
<li>传递数据回到server
</li>
</ul>
</li>
<li>单个处理:
<ul class="org-ul">
<li>把单个联系人从server上面下载下来
</li>
<li>如果联系人本地有的话,查看一下,如果需要update,那么就更改,然后上传
</li>
<li>如果本地有联系人,server没有,那么就直接上传
</li>
</ul>
</li>
</ol>
</li>
<li>两种方法都有缺点:
<ol class="org-ol">
<li>整体处理太浪费流量
</li>
<li>单个处理要不停的和网络连接,在mobile的情况下不太好用
</li>
</ol>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
