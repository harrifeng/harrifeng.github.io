<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>secrets-of-the-javascript-ninja-2nd</title>
<!-- 2017-08-09 Wed 13:28 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">secrets-of-the-javascript-ninja-2nd</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 1: JavaScript is everywhere</a>
<ul>
<li><a href="#sec-1-1">Understanding the JavaScript language</a>
<ul>
<li><a href="#sec-1-1-1">How will JavaScript evolve?</a></li>
<li><a href="#sec-1-1-2">Transpilers give us access to tomorrow's JavaScript today</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Understanding the brower</a></li>
<li><a href="#sec-1-3">Using current best practices</a>
<ul>
<li><a href="#sec-1-3-1">Debugging</a></li>
<li><a href="#sec-1-3-2">Testing</a></li>
<li><a href="#sec-1-3-3">Performance analysis</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">Chapter 2: Building the page at runtime</a>
<ul>
<li><a href="#sec-2-1">2.1 The lifecycle overview</a></li>
<li><a href="#sec-2-2">The page-building phase</a>
<ul>
<li><a href="#sec-2-2-1">Parsing the HTML and building the DOM</a></li>
<li><a href="#sec-2-2-2">Executing JavaScript Code</a>
<ul>
<li><a href="#sec-2-2-2-1">GLOBAL OBJECTS IN JAVASCRIPT</a></li>
<li><a href="#sec-2-2-2-2">DIFFERENT TYPES OF JAVASCRIPT CODE</a></li>
<li><a href="#sec-2-2-2-3">EXECUTING JAVASCRIPT CODE IN THE PAGE-BUILDING PHASE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2-3">Event handling phase</a>
<ul>
<li><a href="#sec-2-3-1">Event-handling overview</a>
<ul>
<li><a href="#sec-2-3-1-1">EVENTS ARE ASYNCHRONOUS</a></li>
</ul>
</li>
<li><a href="#sec-2-3-2">Registering event handlers</a></li>
<li><a href="#sec-2-3-3">Handling events</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">Chapter 3: First-class functions fro novice: definitions and arguments</a>
<ul>
<li><a href="#sec-3-1">What's with the functional difference?</a>
<ul>
<li><a href="#sec-3-1-1">Functions as first-class objects</a></li>
<li><a href="#sec-3-1-2">Callback functions</a>
<ul>
<li><a href="#sec-3-1-2-1">SORTING WITH A COMPARATOR</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3-2">Fun with functions as objects</a>
<ul>
<li><a href="#sec-3-2-1">Storing functions</a></li>
<li><a href="#sec-3-2-2">Self-memoizing function</a></li>
</ul>
</li>
<li><a href="#sec-3-3">Defining functions</a>
<ul>
<li><a href="#sec-3-3-1">Function declarations and function expressions:</a>
<ul>
<li><a href="#sec-3-3-1-1">IMMEDIATE FUNCTIONS</a></li>
</ul>
</li>
<li><a href="#sec-3-3-2">Arrow functions</a></li>
</ul>
</li>
<li><a href="#sec-3-4">Arguments and function parameters</a>
<ul>
<li><a href="#sec-3-4-1">Rest parameters</a></li>
<li><a href="#sec-3-4-2">Default parameters</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">Chapter 4: Functions for the journeyman: understanding function</a>
<ul>
<li><a href="#sec-4-1">Using implicit function parameters</a>
<ul>
<li><a href="#sec-4-1-1">The arguments paramter</a>
<ul>
<li><a href="#sec-4-1-1-1">ARGUMENTS OBJECT AS AN ALIAS TO FUNCTION PARAMETERS</a></li>
<li><a href="#sec-4-1-1-2">AVOIDING ALIASES</a></li>
</ul>
</li>
<li><a href="#sec-4-1-2">The this parameter: introducing the function context</a></li>
</ul>
</li>
<li><a href="#sec-4-2">Invoking functions</a>
<ul>
<li><a href="#sec-4-2-1">Invocation as a function</a></li>
<li><a href="#sec-4-2-2">Invocation as a method</a></li>
<li><a href="#sec-4-2-3">Invocation as a constructor</a>
<ul>
<li><a href="#sec-4-2-3-1">THE SUPERPOWERS OF CONSTRUCTORS</a></li>
<li><a href="#sec-4-2-3-2">CONSTRUCTOR RETURN VALUES</a></li>
<li><a href="#sec-4-2-3-3">CODING CONSIDERATIONS FOR CONSTRUCTORS</a></li>
</ul>
</li>
<li><a href="#sec-4-2-4">Invocation with the apply and call methods</a></li>
</ul>
</li>
<li><a href="#sec-4-3">Fixing the problem of function contexts</a>
<ul>
<li><a href="#sec-4-3-1">Using arrow functions to get around function contexts</a></li>
<li><a href="#sec-4-3-2">Using the bind method</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">Chapter 5: Functions for the master: closures and scopes</a>
<ul>
<li><a href="#sec-5-1">Understanding closures</a></li>
<li><a href="#sec-5-2">Putting closures to work</a>
<ul>
<li><a href="#sec-5-2-1">Mimicking private variables</a></li>
<li><a href="#sec-5-2-2">Using closures with callbacks</a></li>
</ul>
</li>
<li><a href="#sec-5-3">Tracking code execution with execution context</a></li>
<li><a href="#sec-5-4">Keep track of identifiers with lexical environments</a>
<ul>
<li><a href="#sec-5-4-1">Coding nesting</a></li>
<li><a href="#sec-5-4-2">Code nesting and lexical environments</a></li>
</ul>
</li>
<li><a href="#sec-5-5">Understanding types of JavaScript variables</a>
<ul>
<li><a href="#sec-5-5-1">Variable mutability</a></li>
<li><a href="#sec-5-5-2">Variable definition keywords and lexical environments</a></li>
<li><a href="#sec-5-5-3">Registering identifiers within lexical environments</a></li>
</ul>
</li>
<li><a href="#sec-5-6">Exploring how closures work</a>
<ul>
<li><a href="#sec-5-6-1">Revisiting mimicking private variables with closures</a></li>
<li><a href="#sec-5-6-2">Private variables caveat</a></li>
<li><a href="#sec-5-6-3">Revisiting the closures and callbacks example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">Chapter 6: Functions for the future: generators and promises</a>
<ul>
<li><a href="#sec-6-1">Makeing our async code elegant with generators and promises</a></li>
<li><a href="#sec-6-2">Working with generator functions</a>
<ul>
<li><a href="#sec-6-2-1">Controlling the generator throught the Iterator object</a></li>
<li><a href="#sec-6-2-2">Using generators</a></li>
<li><a href="#sec-6-2-3">Communicating with a generator</a></li>
<li><a href="#sec-6-2-4">Exploring generatos under the hood</a></li>
</ul>
</li>
<li><a href="#sec-6-3">Working with promises</a>
<ul>
<li><a href="#sec-6-3-1">Understanding the problems with simple callbacks</a></li>
<li><a href="#sec-6-3-2">Diving into promises</a></li>
<li><a href="#sec-6-3-3">Rejecting promises</a></li>
<li><a href="#sec-6-3-4">Creating our firs real-world promise</a></li>
<li><a href="#sec-6-3-5">Chaining promises</a></li>
<li><a href="#sec-6-3-6">Waiting for a number of promises</a></li>
</ul>
</li>
<li><a href="#sec-6-4">Combining generators and promises</a></li>
</ul>
</li>
<li><a href="#sec-7">Chapter 7: Object orientation with prototypes</a>
<ul>
<li><a href="#sec-7-1">Understanding prototypes</a></li>
<li><a href="#sec-7-2">Object construction and prototypes</a>
<ul>
<li><a href="#sec-7-2-1">Instance properties</a></li>
<li><a href="#sec-7-2-2">Side effects of the synamic nature of JavaScript</a></li>
<li><a href="#sec-7-2-3">Object typing via constructors</a></li>
</ul>
</li>
<li><a href="#sec-7-3">Achieving inheritance</a></li>
<li><a href="#sec-7-4">Using JavaScript "classes" in ES6</a></li>
</ul>
</li>
<li><a href="#sec-8">Chapter 8: Controlling acces to objects</a>
<ul>
<li><a href="#sec-8-1">Controlling access to properties with getters and setters</a>
<ul>
<li><a href="#sec-8-1-1">Defining getters and setters</a></li>
<li><a href="#sec-8-1-2">Using getters and setters to validate property values</a></li>
</ul>
</li>
<li><a href="#sec-8-2">Using proxies to control access</a>
<ul>
<li><a href="#sec-8-2-1">Using proxie for logging</a></li>
<li><a href="#sec-8-2-2">Using proxies for measuring performance</a></li>
<li><a href="#sec-8-2-3">Using proxies to autopopulate properties</a></li>
<li><a href="#sec-8-2-4">Using proxies to implement negative array Indexes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-9">Chapter 9: Dealing with collections</a>
<ul>
<li><a href="#sec-9-1">Arrays</a>
<ul>
<li><a href="#sec-9-1-1">Creating arrays</a></li>
<li><a href="#sec-9-1-2">Adding and removing Items at either end of an array</a></li>
<li><a href="#sec-9-1-3">Adding and removing items at any array location</a></li>
<li><a href="#sec-9-1-4">Common operations on arrays</a>
<ul>
<li><a href="#sec-9-1-4-1">ITERATING OVER ARRAYS</a></li>
<li><a href="#sec-9-1-4-2">MAPPING ARRAYS</a></li>
<li><a href="#sec-9-1-4-3">AGGREGATING ARRAY ITEMS</a></li>
<li><a href="#sec-9-1-4-4">TESTING ARRAY ITEMS</a></li>
<li><a href="#sec-9-1-4-5">SEARCHING ARRAYS</a></li>
<li><a href="#sec-9-1-4-6">SORTING ARRAYS</a></li>
</ul>
</li>
<li><a href="#sec-9-1-5">Resuing built-in array functions</a></li>
</ul>
</li>
<li><a href="#sec-9-2">Maps</a>
<ul>
<li><a href="#sec-9-2-1">Creating our first map</a></li>
<li><a href="#sec-9-2-2">Iterating over maps</a></li>
</ul>
</li>
<li><a href="#sec-9-3">Sets</a></li>
</ul>
</li>
<li><a href="#sec-10">Chapter 10: Wrangling regular expresions</a>
<ul>
<li><a href="#sec-10-1">Why regular expressions rock</a></li>
</ul>
</li>
<li><a href="#sec-11">Chapter 11: Code modularization techniques</a>
<ul>
<li><a href="#sec-11-1">Modularizing code in pre-ES6 JavaScript</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 1: JavaScript is everywhere</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Understanding the JavaScript language</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>很多的js coder都会在使用js的时候感到熟悉，因为他们会用到很多来自其他语言的
特性
</li>
<li>然而除了一些很基本的情况以外，这些'相同感'却并不一定正确,不能因为js从C-like
language那里借鉴了很多东西(比如关键字),就说js和他们在机制上也有相同点
</li>
<li>理解了java就理解了js是一种错觉,和其他语言相比,js拥有更多的functional语言的
特性:
<ul class="org-ul">
<li>Function是first-class object:function是js最核心的概念, 在js中function和object
拥有完全一样的能力,外加还能被call
</li>
<li>Function closure: function closure也是js最核心的概念,而且同时还被人民广泛
的误解着.简单的理解就是,function本身就是一个closure,内部被使用的外部变量都
在这个closure里面被维护着
</li>
<li>Scope: 知道ES5, js都没有block-level的variable,所以我们要依靠global variable
和function level variable
</li>
<li>Prototype-based object orientation: 和其他的主流编程语言不同(它们主要使用
class-based object orientation), js里面使用的是prototype.
</li>
</ul>
</li>
<li>js里面有两组紧密联系的概念, 理解这两组概念,有利于加深我们对js的理解
<ul class="org-ul">
<li>object和prototype
</li>
<li>function和closure
</li>
</ul>
</li>
<li>除了这些概念,一些js的feature可以帮助你写出更elegant和efficient的代码.这些feature
有:
<ul class="org-ul">
<li>generators: 就是一个function,但是会generate多个value
</li>
<li>promises: 能够更好的控制asynchronous代码
</li>
<li>proxies:能够让我控制一些object
</li>
<li>Advanced array methods: 能够让array的处理更加优雅
</li>
<li>Map和set: 常用的数据结构
</li>
<li>Regular expression: 能让我们代码更简单
</li>
<li>Modules: 让代码变得更小,更容易维护
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">How will JavaScript evolve?</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>ECMAScript委员会负责js的标准工作,并且已经提出了ES7/ES2016的标准
</li>
<li>这次升级比起ES6来说并不多,因为以后js每年都会升级
</li>
<li>yearly的升级很令人振奋,但是并不意味着web开发者能够马上用到这些特性,我们可
以通过下面的链接来跟踪各大浏览器对最新规范的支持
<a href="https://kangax.github.io/compat-table/es6/">https://kangax.github.io/compat-table/es6/</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">Transpilers give us access to tomorrow's JavaScript today</h4>
<div class="outline-text-4" id="text-1-1-2">
<ul class="org-ul">
<li>即便浏览器更新的再快,我们也不能要求所有的用户马上开始使用最新版本的浏览器,
还是会有老的浏览器在被使用.
</li>
<li>为了让我们包含最新feature的代码能够在所有老的浏览器里面也能跑,我们的办法是
使用transpiler把包含最新feature的代码,转换成大部分浏览器支持的代码.尽可能
保证代码的功效一致
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Understanding the brower</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>今天,js可以从多个平台进行运行(指的nodejs已经诞生),但是这一切的根源还是来自
于浏览器
</li>
<li>对于浏览器来说,主要的三个重点是:
<ul class="org-ul">
<li>Document Object Model (DOM): 所谓DOM,是client-side web application UI的一
种'结构化的表达方式'.理解DOM对于能够写好js非常重要
</li>
<li>Events: 大部分的JS application都是event-driven的application,这就意味着大
部分的代码被运行,其实是为了响应某些event,比如click,mouse move, keyboard
press. 而其中的timer则是更让人难以理解的部分
</li>
<li>Browser API: 为了帮助我们和world进行交流,browser提供了一个API,让我们来了解
设备信息,存储local data,和远程的server通信
</li>
</ul>
</li>
<li>但是我们首先面对的,却是浏览器的各种不方便,因为浏览器总是存在各种bug,而且对API
的支持也不充分
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Using current best practices</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>掌握js语言,并且理解跨浏览器的coding issue罪域我们变成web 开发高手非常重要,但
是除了这两者以外,前人的,被经验证明好的一些实践也很重要.这就是我们说的best
practice, 包括:
<ul class="org-ul">
<li>Debuggin skill
</li>
<li>Testing
</li>
<li>Performance analysis
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Debugging</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>曾经对于js来说, 调试就是使用alter来打印变量,但是今天已经有很多的浏览器都有
内置的developer工具了
</li>
<li>大部分的浏览器都内置了debug工具,这些工具的功能相同,都来源于Firebug的创意,
包括如下的几个方面:
<ul class="org-ul">
<li>对DOM的探索
</li>
<li>debug js
</li>
<li>编辑Css
</li>
<li>跟踪network
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Testing</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>本书采用的是assert(condition, message)的方式来测试是否结果如愿,比如测试a是
否为1
<div class="org-src-container">

<pre class="src src-js">assert<span style="color: #2aa198;">(</span>a === 1, <span style="color: #2aa198;">"Disaster! a is not 1!"</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">Performance analysis</h4>
<div class="outline-text-4" id="text-1-3-3">
<ul class="org-ul">
<li>JS engine已经为performance做了很多努力,但是我们还要在自己的代码中测试自己
的性能,我们代码的主要逻辑如下
<div class="org-src-container">

<pre class="src src-web">&lt;html&gt;
    &lt;head&gt;
        &lt;script&gt;
         console.<span style="color: #268bd2;">time</span><span style="color: #2aa198;">(</span>"my start"<span style="color: #2aa198;">)</span>;
         <span style="color: #b58900;">for</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">var</span> <span style="color: #268bd2;">n</span> = 0;  n &lt; 12345; n++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
             console.<span style="color: #268bd2;">log</span><span style="color: #b58900;">(</span>'log'<span style="color: #b58900;">)</span>;
         <span style="color: #2aa198;">}</span>
         console.<span style="color: #268bd2;">timeEnd</span><span style="color: #2aa198;">(</span>'end'<span style="color: #2aa198;">)</span>;
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 2: Building the page at runtime</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>我们对js的探索主要是在client-side的context下进行的,并且把browser作为执行的engine
</li>
<li>为了让我们的探索更加容易,我们首先要理解完整的web application lifecycle,特别
是如何把js嵌入到这个lifecycle里面
</li>
<li>我们从page开始被request开始来查看client-side web application的lifecycle.在接
下来的过程中,用户会有交互,直到page被关闭
</li>
<li>开始的时候是HTML代码的执行,然后关注js code,最后就是event handle
</li>
<li>在这个过程中,我们会探索一些概念,比如DOM,或者event loop(决定event如何被application
处理)
</li>
</ul>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">2.1 The lifecycle overview</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>client-side的lifecycle开始于我们在浏览器里面打入url,比如google.com
</li>
<li>浏览器会为用户服务,把刚才的url转换成一股request,并把这个request发给server
</li>
<li>server会处理这个request,然后把这个request转换成一个response返回给server, 这
个response里面往往就包含HTML, CSS, JS等
</li>
<li>浏览器接收到response的时候,就是我们client-side web app真正开始它的life的时候
</li>
<li>我们的client-side web application(js代码和浏览器一起)是一个GUI程序,GUI程序
无论是我们web的,还是desktop的,都遵守一些相似的phase,比如如下两个步骤:
<ul class="org-ul">
<li>page building: 设置user interface
</li>
<li>event handling: 进入一个loop然后等待event来临,然后event来临以后就触发event
handler
</li>
</ul>
</li>
<li>event handling就是一个循环了,只有用户关闭这个页面才会结束这个循环
</li>
<li>下面我们看一个例子
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #859900; font-weight: bold;">!DOCTYPE</span> html&gt;
&lt;<span style="color: #268bd2;">html</span>&gt;
    &lt;<span style="color: #268bd2;">head</span>&gt;
        &lt;<span style="color: #268bd2;">title</span>&gt;<span style="font-weight: bold; text-decoration: underline;"> Web app lifecycle</span>&lt;/<span style="color: #268bd2;">title</span>&gt;
        &lt;<span style="color: #268bd2;">style</span>&gt;
         #first { color: green; }
         #second { color: red; }
        &lt;/<span style="color: #268bd2;">style</span>&gt;
    &lt;/<span style="color: #268bd2;">head</span>&gt;
    &lt;<span style="color: #268bd2;">body</span>&gt;
        &lt;<span style="color: #268bd2;">ul</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"first"</span>&gt;&lt;/<span style="color: #268bd2;">ul</span>&gt;
        &lt;<span style="color: #268bd2;">script</span>&gt;
         function addMessage(element, message) {
             var messageElement = document.createElement(<span style="color: #2aa198;">"li"</span>);
             messageElement.textContent = message;
             element.appendChild(messageElement);
         }
         var first = document.getElementById(<span style="color: #2aa198;">"first"</span>);
         addMessage(first, <span style="color: #2aa198;">"Page loading"</span>);
        &lt;/<span style="color: #268bd2;">script</span>&gt;

        &lt;<span style="color: #268bd2;">ul</span> id =<span style="color: #2aa198;">"second"</span>&gt;&lt;/<span style="color: #268bd2;">ul</span>&gt;
        &lt;<span style="color: #268bd2;">script</span>&gt;
         document.body.addEventListener(<span style="color: #2aa198;">"mousemove"</span>, function(){
             var second = document.getElementById(<span style="color: #2aa198;">"second"</span>);
             addMessage(second, <span style="color: #2aa198;">"Event: mousemove"</span>);
         });

         document.body.addEventListener(<span style="color: #2aa198;">"click"</span>, function(){
             var second = document.getElementById(<span style="color: #2aa198;">"second"</span>);
             addMessage(second, <span style="color: #2aa198;">"Event: click"</span>);
         });
        &lt;/<span style="color: #268bd2;">script</span>&gt;
    &lt;/<span style="color: #268bd2;">body</span>&gt;
&lt;/<span style="color: #268bd2;">html</span>&gt;
</pre>
</div>
</li>
<li>这个例子主要有两个部分:
<ul class="org-ul">
<li>创建一个first &lt;ul&gt; element,然后使用js加载一个&lt;ul&gt;的&lt;li&gt; element,写上'page
loading', 这代表了page building的过程
</li>
<li>创建一个second &lt;ul&gt; element,然后使用js在document.body里面增加了两个event
listener: 一个是mouse move一个是mouse click. 用户一旦有相应的鼠标动作,则
最后会打印在页面上.这个代表了event handling的过程
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">The page-building phase</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>在一个web application可以被展示(进而操作)之前, 一个page必须使用server传过来
的response(包括html, css, js)来组合成自己的页面.这个phase的目标就是建设好web
application的UI, 而这个phase又分成了两个step:
<ol class="org-ol">
<li>分析HTML,并且建设好Document Object Model(DOM)
</li>
<li>执行JS 代码
</li>
</ol>
</li>
<li>简单点说,step1就是分析html element代码(除了script的部分),而step2就是分析script
的部分.这两个部分的分析可以交替进行,并不是严格的一个接着一个
</li>
</ul>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">Parsing the HTML and building the DOM</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>page-building phase是从接到html代码开始的, 浏览器根据对html代码的分析建立起
一个DOM结构,所谓DOM就是对HTML的一种structured的表达方式
</li>
<li>DOM通常会被叫做DOM tree,因为它确实是一种树形结构的,比如我们上面代码在遇到
&lt;script&gt; tag之前就会建设成如下的一种DOM tree
<pre class="example">
                            +--------+
                  +---------+  html  +----------+
                  |         +--------+          |
                  |                             |
                  |                             |
            +-----+--+                      +---+----+
     +------+  head  +---+               +--+  body  +---+
     |      +--------+   |               |  +--------+   |
     |                   |               |               |
+----+---+         +-----+--+         +--+-----+   +-----+--+
| title  |         | style  |         |   ul   |   | script |
+--------+         +--------+         +--------+   +--------+
</pre>
</li>
<li>需要注意的是html和DOM不是一回事,html是DOM的蓝图,DOM是根据html来创建的,而且
浏览器有时候还会修正html里面的一些错误.比如下面的例子,&lt;p&gt;写在了&lt;head&gt;里面
其实&lt;p&gt;是要在body里面才会有意义,DOM创建的时候就会自动修正
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">html</span>&gt;
  &lt;<span style="color: #268bd2;">head</span>&gt;
    &lt;<span style="color: #268bd2;">p</span>&gt;
      Hello
    &lt;/<span style="color: #268bd2;">p</span>&gt;
  &lt;/<span style="color: #268bd2;">head</span>&gt;
  &lt;<span style="color: #268bd2;">body</span>&gt;
  &lt;/<span style="color: #268bd2;">body</span>&gt;
&lt;/<span style="color: #268bd2;">html</span>&gt;
</pre>
</div>
</li>
<li>当DOM碰到特殊的tag的时候,比如&lt;script&gt;它会停下自己的脚步,转换为另外一个step,
也就是js代码执行阶段(当然了两个step是交替执行的,一会还会回来)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">Executing JavaScript Code</h4>
<div class="outline-text-4" id="text-2-2-2">
<ul class="org-ul">
<li>所有html里面的script element都是由浏览器的javascript engine来执行的,这些引
擎最出名的就是google的V8了,同时还有firefox的Spidermonkey
</li>
<li>js和浏览器交互的方法是: 浏览器通过'global object'提供了一些API,让js来和page
进行互动
</li>
</ul>
</div>
<div id="outline-container-sec-2-2-2-1" class="outline-5">
<h5 id="sec-2-2-2-1">GLOBAL OBJECTS IN JAVASCRIPT</h5>
<div class="outline-text-5" id="text-2-2-2-1">
<ul class="org-ul">
<li>浏览器expose给js引擎最重要的global object是window object,这个object代表了
包含当前page的窗口!
</li>
<li>这个window object有很多properties,每个property都是对我们非常重要的.换句话
说, window的最主要作用就是包裹了一系列properties给我们用
</li>
<li>被包裹的一系列properties最重要的是document,也就是DOM的js表示.
</li>
<li>这里插入介绍一个重要的概念的解读,就是
<pre class="example">
JavaScript that runs in the browser has Window as it's top level
</pre>
</li>
<li>换句话说,定义在浏览器js里面的global variable就会变成window的properties,而
windows在设计的时候的哪些'有用的property'同时也会变成我们js代码的global
variable.
<div class="org-src-container">

<pre class="src src-js">window.document === document    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
</pre>
</div>
</li>
<li>这也为什么我们可以直接在html里面使用document,而不需要window.document
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">first</span> = document.getElementById<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"first"</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>我们得到了这个first的变量,其实就是一个object啦,它指代的就是id为'first'的
html element. 我们可以通过代码来给这个element增加一个child,或者更改这个
element本身.这个例子是为这个element增加了一个&lt;li&gt;的element作为child
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">messageElement</span> = document.createElement<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"li"</span><span style="color: #2aa198;">)</span>;
element.appendChild<span style="color: #2aa198;">(</span>messageElement<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-2-2" class="outline-5">
<h5 id="sec-2-2-2-2">DIFFERENT TYPES OF JAVASCRIPT CODE</h5>
<div class="outline-text-5" id="text-2-2-2-2">
<ul class="org-ul">
<li>在广义上,运行在浏览器里面的js代码会被分成两类:
<ul class="org-ul">
<li>global code: 会被浏览器js engine'自动'调用运行
</li>
<li>function code: 定义逻辑,不会被'自动'运行
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2-2-3" class="outline-5">
<h5 id="sec-2-2-2-3">EXECUTING JAVASCRIPT CODE IN THE PAGE-BUILDING PHASE</h5>
<div class="outline-text-5" id="text-2-2-2-3">
<ul class="org-ul">
<li>当浏览器遇到script tag的时候,它只能放下自己的DOM创建工作,腾出手来处理&lt;script&gt;
tag带来的js code
</li>
<li>在这个例子里面就是第一个&lt;script&gt; tag,在这个tag里面会为id为'first'的&lt;ul&gt;创
建一个&lt;li&gt; tag
</li>
<li>通过document.getElementById找到某个element以后,理论上我们可以对"DOM做任何
事情",但也不是绝对,比如我们就没法对id为"second"的element做什么,因为在第一
个&lt;script&gt; tag里面还没有创建"second" element.这也是为什么很多人选择把js的
代码放在最后的原因
</li>
<li>执行完&lt;script&gt;tag,我们的代码就会继续自己的'根据html element来创建DOM'的工
作,然后遇到&lt;script&gt;tag在来依靠js engine工作,循环往复这两个过程,直到所有的
html代码都处理完毕
</li>
<li>需要注意的是,因为window这个top level的存在,所以在某个&lt;script&gt;里面创建的全
局变量,在其他的&lt;script&gt; tag里面都继续可用
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Event handling phase</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>client-side web application其实也是一种GUI: 它也是处理用户的点击,键盘敲动,
鼠标移动等操作
</li>
<li>所以我们在page-building phase阶段的js代码除了可以'帮助创建DOM tree'以外,还
可以register event listener.所谓event listener就是
<pre class="example">
Functions that are executed by the browser when an event occurs.
</pre>
</li>
</ul>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Event-handling overview</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>browser运行的核心model是single-threaded execution model,也就是说浏览器内部
最多只有一个thread在运行,那么也只有一段代码可以"占据"浏览器而运行
</li>
<li>single-threaded execution model的特点是需要一个queue来存储所有的发生的event
原因很简单,event的发生是快速的,异步的.不过不记录下的话,你不能保证browser都
能记住,使用queue的原因是因为这个是一个明显的"先到先服务"的例子
</li>
<li>所有的event(包括user-generated,比如点击页面,和server-generated,比如Ajax event)
都会放到同一个queue里面,顺序是browser发现他们的顺序
</li>
<li>queue的处理顺序是我们很熟悉的了:
<ul class="org-ul">
<li>browser会去queue里面找head的event
</li>
<li>如果queue里面没有event,那么就keep checking
</li>
<li>在处理head event的时候,queue里面的其他的event要耐心的等待
</li>
</ul>
</li>
<li>因为event handle是一次处理一个的,所以我们非常的小心handle event的时间不要
太长
</li>
<li>还需要注意的是,我们是调用的windows的API来添加的event listener,但是如下两个
方面不在我们本书的讨论范围:
<ul class="org-ul">
<li>具体browser如何把event放到自己的queue里面
</li>
<li>browser如何发现的有新的event发生
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-2-3-1-1" class="outline-5">
<h5 id="sec-2-3-1-1">EVENTS ARE ASYNCHRONOUS</h5>
<div class="outline-text-5" id="text-2-3-1-1">
<ul class="org-ul">
<li>event的发生是没法预料的,顺序也是没有规则的.所以我们说对event的handling(以
及对于handling function的调用)都是"异步的(asynchronous)"
</li>
<li>event可能是下面的任何一种type:
<ul class="org-ul">
<li>Browser event: 比如'page load完成'就是一种event
</li>
<li>Network event: 比如server发送来response
</li>
<li>User event: 比如mouse clicks, mouse move, key press等等
</li>
<li>Timer event: 比如当一个timeout到期了
</li>
</ul>
</li>
<li>除了global code 以外,我们放到&lt;script&gt;里面的绝大部分的代码都是"某种event发
生"后才会去执行的
</li>
<li>哪些代码会"钟意"哪些event是由我们的注册机制决定的
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Registering event handlers</h4>
<div class="outline-text-4" id="text-2-3-2">
<ul class="org-ul">
<li>在client-side web application里面,有两种方式来设置event:
<ul class="org-ul">
<li>把某个function设置成object'特殊的'几个property,比如onload. 注意,所有window
下面的任意的object的onload如果被设置成了某个function都会注册相应的handler
<div class="org-src-container">

<pre class="src src-js">window.onload = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>
document.body.onload = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>
</pre>
</div>
</li>
<li>使用内置的addEventListener函数
<div class="org-src-container">

<pre class="src src-js">document.body.addEventListener<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"mousemove"</span>, <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(){}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</li>
<li>这里两种方法,我们更推荐第二种,因为第二种是'add',也就是在现有的event handler
里面为某个event'再加一个event', 而第一种是'replace',会覆盖掉原来的event handler
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3">Handling events</h4>
<div class="outline-text-4" id="text-2-3-3">
<ul class="org-ul">
<li>event handling的方式很简单,浏览器发现了新的event以后,就调用相应的handler
function,需要注意的是只有某个function fully 返回以后,下一个handler function
才有机会
</li>
<li>所以我们要注意,我们的event handler的时间不要太长,否则client-side web app会
看起来没有响应
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 3: First-class functions fro novice: definitions and arguments</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>不太了解js的人肯定有些诧异,我们最开始介绍的不是object,而是function. 懂得人其
实应该知道,因为javascript不是一个object-oriented language,而是一个functional
language !
</li>
<li>js里面的function被称之为first-class object是因为:
<ul class="org-ul">
<li>首先object可以做的(被variable refer, literal式的声明, pass as 函数参数)function
都可以做.
</li>
<li>其次function还有比object高明的地方:它可以被调用
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">What's with the functional difference?</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>functional的思想非常重要的原因在于function是JS里面执行的'主要的执行小单元':
所谓的'主要的执行小单元'是因为除了global的在page-building阶段就会被执行的代
码外,绝大部分的js代码都'以function的形式执行的'
</li>
<li>我们已经说了function是object的超集(object的能力,function都具备),下面就列举
一下js下面object的能力:
<ul class="org-ul">
<li>可以使用literal的方式创建
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">{}</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">an object</span>
</pre>
</div>
</li>
<li>可以被赋值给variable, array, 或者其他object的properties
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #2aa198;">{}</span>;
ninjaArray.push<span style="color: #2aa198;">(</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>;
ninja.data = <span style="color: #2aa198;">{}</span>;
</pre>
</div>
</li>
<li>可以作为参数传递给function
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">hide</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">ninja</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    ninja.visibility = <span style="color: #268bd2; font-weight: bold;">false</span>;
<span style="color: #2aa198;">}</span>
hide<span style="color: #2aa198;">(</span><span style="color: #b58900;">{}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>可以被function返回
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">returnNinja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #b58900;">{}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>object可以动态创建,然后'再'赋于它property
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #2aa198;">{}</span>;
ninja.name = <span style="color: #2aa198;">"Hanzo"</span>;
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">Functions as first-class objects</h4>
<div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li>function拥有object前面所述的所有能力:
<ul class="org-ul">
<li>通过literal创建
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">ninjaFunction</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>
</pre>
</div>
</li>
<li>赋值给变量,加入数组,或者作为其他object的property
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninjaFunction</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>;
ninjaArray.push<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(){}</span><span style="color: #2aa198;">)</span>;
ninja.data = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(){}</span>;
</pre>
</div>
</li>
<li>作为其他function的参数
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">call</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">ninjaFunction</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    ninjaFunction<span style="color: #b58900;">()</span>;
<span style="color: #2aa198;">}</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">use it</span>
call<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(){}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>作为function的返回值
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">returnNewNinjaFunction</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(){}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>动态创建,'再'加property
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninjaFunction</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(){}</span>;
ninjaFunction.name = <span style="color: #2aa198;">"Hanzo"</span>;   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">add a new property to a function</span>
</pre>
</div>
</li>
</ul>
</li>
<li>在这么多的特性中,有个特性更接近特殊,那就是我们可以把function作为参数传递给
另外一个function,而另外一个参数在自己内部调用'参数function',我们把这个叫做
callback function
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2">Callback functions</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li>每当我们设置一个function,然后这个function在一个later time被调用,那么我们就
把这种情况叫做callback
</li>
<li>我们前面为event设置listener, 然后浏览器自动为event帮我们调用event handler(其
实就是一个hans)的情形其实就是callback
</li>
<li>我们可以自己实践callback,就是把一个function作为参数传递给另外一个function
</li>
<li>我们先来看一个callback的例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">text</span> = <span style="color: #2aa198;">"Demo !"</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">useless</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">ninjaCallback</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span><span style="color: #2aa198;">"In useless function"</span><span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> ninjaCallback<span style="color: #b58900;">()</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">getText</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span><span style="color: #2aa198;">"In getText function"</span><span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> text;
<span style="color: #2aa198;">}</span>

console.log<span style="color: #2aa198;">(</span>useless<span style="color: #b58900;">(</span>getText<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">In useless function                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">In getText function                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Demo !                                         //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>这里的useless就是一个callback(当然了,有些人认为马上调用'传入function参数'
的做法不叫callback,我们这里只是以这个为例子),它在自己的内容调用了'传入的
function参数'作为返回值
</li>
<li>js最重要的一个feature就是能够在任何'expression可以出现的地方'创建一个function
这样做有两个好处:
<ul class="org-ul">
<li>让代码compact,而且易懂
</li>
<li>因为这个function只在这里使用,我们完全可以不用给这个function取名字,这样就
不会污染global namespace啦!
</li>
</ul>
</li>
<li>重写后代码如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">text</span> = <span style="color: #2aa198;">"Demo !"</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">useless</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">ninjaCallback</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span><span style="color: #2aa198;">"In useles function"</span><span style="color: #b58900;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> ninjaCallback<span style="color: #b58900;">()</span>;
<span style="color: #2aa198;">}</span>

console.log<span style="color: #2aa198;">(</span>useless<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(){</span>
    console.log<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"In parameter"</span><span style="color: #6c71c4;">)</span>;
    <span style="color: #859900; font-weight: bold;">return</span> text;
<span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">In useles function                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">In parameter                                   //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Demo !                                         //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>前面我们为event增加event listener的例子,也是一个callback的例子,在那个例子
中,我们的callback函数,也是匿名的
<div class="org-src-container">

<pre class="src src-js">document.body.addEventListener<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"mousemove"</span>, <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">second</span> = document.getElementById<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"second"</span><span style="color: #268bd2;">)</span>;
    addMessage<span style="color: #268bd2;">(</span>second, <span style="color: #2aa198;">"Event: mousemove"</span><span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-3-1-2-1" class="outline-5">
<h5 id="sec-3-1-2-1">SORTING WITH A COMPARATOR</h5>
<div class="outline-text-5" id="text-3-1-2-1">
<ul class="org-ul">
<li>说起使用function作为参数这件事情,在js里面有个特别好的例子,就是排序数组.我
们知道在java里面,你要给数组一个comparator来决定其顺序
</li>
<li>在js里面,我们只需要一个函数.这个函数设计也很新颖,参数是数组的两个成员:
<ul class="org-ul">
<li>两个参数比较,如果返回负数,说明他俩位置是对的.
</li>
<li>如果返回正数,说明位置要swap
</li>
<li>如果返回0,说明他俩相等
</li>
</ul>
</li>
<li>代码如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">values</span> = <span style="color: #2aa198;">[</span>0, 3, 2, 5, 7, 4, 8, 1<span style="color: #2aa198;">]</span>;

console.log<span style="color: #2aa198;">(</span>values.sort<span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">value1</span>, <span style="color: #268bd2;">value2</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> value1 - value2;
<span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 0, 1, 2, 3, 4, 5, 7, 8 ]                     //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Fun with functions as objects</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>一个可能令人吃惊的事情是:我们完全可以给function赋予一个property,因为object
可以有property,那么function就必然可以有property
</li>
<li>这个特性,可以让js做下面的两种hack
</li>
</ul>
</div>
<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">Storing functions</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>这个hack看起来很厉害,其实就是给function一个identification而已,防止重复加载
一个function到一个列表(collection)里面
</li>
<li>这个特性在维护event的call back列表的时候非常有用: 我们希望我们的event的call
back 函数礼包里面所有的函数只出现了一次.
</li>
<li>面对'唯一性'的问题,set(或者hash)是一个非常简单的思路.其实这里就是利用了function
可以多加一个域(property),把这个域作为set或者hash里面的key而已(同时下例中的
cache就是这个hash(set)
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">assert</span> = require<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'assert'</span><span style="color: #2aa198;">)</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">store</span> = <span style="color: #2aa198;">{</span>
    nextId: 1,
    cache: <span style="color: #b58900;">{}</span>,
    <span style="color: #268bd2;">add</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(</span><span style="color: #268bd2;">fn</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>!fn.id<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            fn.id = <span style="color: #268bd2; font-weight: bold;">this</span>.nextId++;
            <span style="color: #268bd2; font-weight: bold;">this</span>.cache<span style="color: #6c71c4;">[</span>fn.id<span style="color: #6c71c4;">]</span> = fn;
            <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">ninja</span><span style="color: #2aa198;">(){}</span>

console.log<span style="color: #2aa198;">(</span>store.add<span style="color: #b58900;">(</span>ninja<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>store.add<span style="color: #b58900;">(</span>ninja<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined                                      //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">Self-memoizing function</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li>既然函数内部可以存储property,那么我们可以考虑在function内部记录已经计算过
的值,比如下面计算prime number的例子,每次计算完一个参数我们把值记录下来,下
次再有相同的计算我们之间返回就是了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">isPrime</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">value</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>!isPrime.answers<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        isPrime.answers = <span style="color: #268bd2;">{}</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>isPrime.answers<span style="color: #268bd2;">[</span>value<span style="color: #268bd2;">]</span> !== <span style="color: #268bd2; font-weight: bold;">undefined</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Cached value returned!"</span><span style="color: #268bd2;">)</span>;
        <span style="color: #859900; font-weight: bold;">return</span> isPrime.answers<span style="color: #268bd2;">[</span>value<span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">prime</span> = value !== 1; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1 is not a prime</span>

    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">i</span> = 2; i &lt; value / 2; i++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>value % i === 0<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
            prime = <span style="color: #268bd2; font-weight: bold;">false</span>;
            <span style="color: #859900; font-weight: bold;">break</span>;
        <span style="color: #268bd2;">}</span>
    <span style="color: #b58900;">}</span>
    <span style="color: #859900; font-weight: bold;">return</span> isPrime.answers<span style="color: #b58900;">[</span>value<span style="color: #b58900;">]</span> = prime;
<span style="color: #2aa198;">}</span>

console.log<span style="color: #2aa198;">(</span>isPrime<span style="color: #b58900;">(</span>5<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>isPrime<span style="color: #b58900;">(</span>5<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Cached value returned!                         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Defining functions</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>js提供了如下几种定义function的方法:
<ul class="org-ul">
<li>function declaration 和 function expression: 名字和长相很像,但确实是两种
不同的定义方法
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">myFun</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> 1;<span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">function declaration</span>
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">myFun2</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> 2; <span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">function expression</span>
</pre>
</div>
</li>
<li>arrow function: es6提供的新的函数定义方式
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">myFun3</span> = <span style="color: #2aa198;">(</span>x<span style="color: #2aa198;">)</span> =&gt; x + 1;
</pre>
</div>
</li>
<li>function constructor: 比较偏门的方法,我们不予讨论
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Function</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'a'</span>, <span style="color: #2aa198;">'b'</span>, <span style="color: #2aa198;">'return a + b'</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>generator function: 也是ES6新加的,和普通函数不同的是,它可以exited然后后面
reentered application execution,同时保存他们的variable
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">myGen</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">yield</span> 1; <span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">Function declarations and function expressions:</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>这两种的确很像,但是也有区别:
<ul class="org-ul">
<li>function declaration的名字是"必须要的", 因为否则你无法调用这个函数. 因为
function declaration必须自己是一个statement
</li>
<li>function expression的名字却"不是必须要的",因它是一个expression,是一个statement
的一部分,它总是会把:
<ol class="org-ol">
<li>自己放到一个变量里面.
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">doNothing</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>;
doNothing<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>或者赋予一个参数, 其实也是变相的赋值给参数:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">doSomething</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">action</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    action<span style="color: #b58900;">()</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-3-3-1-1" class="outline-5">
<h5 id="sec-3-3-1-1">IMMEDIATE FUNCTIONS</h5>
<div class="outline-text-5" id="text-3-3-1-1">
<ul class="org-ul">
<li>因为function expression嘛,它也可以是一个call statement的"调用者",如下
<div class="org-src-container">

<pre class="src src-js">console.log<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">(</span><span style="color: #268bd2;">x</span><span style="color: #268bd2;">){</span> <span style="color: #859900; font-weight: bold;">return</span> x *x; <span style="color: #268bd2;">}</span><span style="color: #b58900;">)(</span>6<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">36                                             //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>前面的例子在function expression的左右使用了'()'来告诉js engine,我们面对的
不是statement,而是expression.还有更难懂的方法,就是在前面使用一个unary operator
作用也是一样,告诉js engine,我们处理的是function expression,不是statement.
而unary operator处理的结果就被直接丢弃了,我们不需要了.在很多library里面都
有这种奇怪的用法
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2">Arrow functions</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>因为js里面function用到的地方太多,es6专门为function设计了一种新的格式,其格式为
<div class="org-src-container">

<pre class="src src-js">paramter =&gt; expression
</pre>
</div>
</li>
<li>expression的值会直接作为返回值返回,ruby用户会非常熟悉
<div class="org-src-container">

<pre class="src src-js">values.sort<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>value1, value2<span style="color: #b58900;">)</span> =&gt; value1 - value2<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>但是如果有多个statement的情况下,还是需要一个return的,而且这个时候要在=&gt; 后
面加上一个{}包裹这些statement. 如果忘记return的话,这个function返回值为undefined
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">greet</span> = name =&gt; <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">helloString</span> = <span style="color: #2aa198;">'Greetings '</span>;
    <span style="color: #859900; font-weight: bold;">return</span> helloString + name;
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Arguments and function parameters</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>当讨论function的时候,我们会讨论两个概念:
<ul class="org-ul">
<li>parameter: 是function 定义的时候概念
</li>
<li>argument: 是function调用的时候的概念
</li>
</ul>
</li>
<li>js中,argument和paramter的个数不要求对应(不会去检查):
<ul class="org-ul">
<li>如果argument的个数少于parameter,那么'从左到右'进行赋值.没有得到赋值的parameter
就会被设置为undefiend
</li>
<li>如果argument的个数多余parameter,剩下的依然可以使用关键字arguments访问TODO
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1">Rest parameters</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>rest parameter也是ES6新加入的特性
</li>
<li>rest parameter有点类似c语言里面的'参数个数不定'的情况(golang里面也有相似的
设置),就是有些情况下,我们肯定会有'至少一个参数',但是从第二个参数到最后一个
参数具体有多少个不定.而我们可以把这些(从2到最后)个参数设置成一个数组
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">multiMax</span> = <span style="color: #2aa198;">(</span>first, ...remaining<span style="color: #2aa198;">)</span> =&gt; first * remaining.sort<span style="color: #2aa198;">()[</span>2<span style="color: #2aa198;">]</span>;

console.log<span style="color: #2aa198;">(</span>multiMax<span style="color: #b58900;">(</span>3, 1, 2, 3<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">9                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2">Default parameters</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>这就是其他语言早就有的特性了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">performAction</span> = <span style="color: #2aa198;">(</span>ninja, action=<span style="color: #2aa198;">"skulking"</span><span style="color: #2aa198;">)</span> =&gt;
    ninja + <span style="color: #2aa198;">" "</span> + action;

console.log<span style="color: #2aa198;">(</span>performAction<span style="color: #b58900;">(</span><span style="color: #2aa198;">"Fuma"</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Fuma skulking                                  //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 4: Functions for the journeyman: understanding function</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>本章我们主要讨论如下的两个implicit function parameter,说是implicit parameter
是因为:即便你在function调用的时候,没有传入这两个参数,它们依然可以被当做传入
了一样被使用:
<ul class="org-ul">
<li>this: 指代了当前function"所属"的object,是js一种特殊的靠近'面向对象编程'的特性
</li>
<li>arguments: 指代传入的所有参数的集合,是一种'类似'数组的东西
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Using implicit function parameters</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>implicit parameter是'默默'的传入,但是使用起来和explicit paramter 没有区别
</li>
</ul>
</div>
<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">The arguments paramter</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>arguments能够获取到传入的所有的argument(无论他们和paramter对应的好不好)
</li>
<li>在rest parameter引入了以后,arguments的作用就没那么大了,但是在处理legacy
code的时候还是会遇到,我们要了解它
</li>
<li>arguments在两个方面很像array:
<ul class="org-ul">
<li>它有一个property叫做length
</li>
<li>它可以使用operator[]来访问
</li>
</ul>
</li>
<li>但是我们极力避免把arguments叫做array, 因为它的确就不是array. 这一点容易被
人们忽略,我们要谨记不要把array的feature使用在arguments上面
</li>
<li>这也是为什么rest paramter更好的原因,因为rest parameter的最后一个参数的的确
确是array
</li>
</ul>
</div>
<div id="outline-container-sec-4-1-1-1" class="outline-5">
<h5 id="sec-4-1-1-1">ARGUMENTS OBJECT AS AN ALIAS TO FUNCTION PARAMETERS</h5>
<div class="outline-text-5" id="text-4-1-1-1">
<ul class="org-ul">
<li>换句话说就是, arguments和paramter是一种'硬链接'的关系:
<ul class="org-ul">
<li>一旦对argument进行更改, 第一个参数也会随之更改
</li>
<li>一旦对第n个参数更改, argument[n-1]也会随之更改
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-1-1-2" class="outline-5">
<h5 id="sec-4-1-1-2">AVOIDING ALIASES</h5>
<div class="outline-text-5" id="text-4-1-1-2">
<ul class="org-ul">
<li>arguments的这种alias关系是不好的.所以我们要禁止使用
</li>
<li>由于老的js中存在这很多这种不是特别好的特性,我们发明了一种禁止'一类js不好
的特性'的方法: strict mode
</li>
<li>strict mode很简单,只要在js代码最上面协商'strict mode'就可以了,这等于告诉
js engine:我们希望安装strict mode 来执行代码:
<ul class="org-ul">
<li>不使用strict mode
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">infiltrate</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">person</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>person<span style="color: #b58900;">)</span>;
    <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span> = <span style="color: #2aa198;">'ninja'</span>;
    console.log<span style="color: #b58900;">(</span>person<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

infiltrate<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"gradener"</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">gradener                                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninja                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>使用strict mode
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">"use strict"</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">infiltrate</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">person</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>person<span style="color: #b58900;">)</span>;
    <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span> = <span style="color: #2aa198;">'ninja'</span>;
    console.log<span style="color: #b58900;">(</span>person<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

infiltrate<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"gradener"</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">gradener                                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">gradener                                       //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2">The this parameter: introducing the function context</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li>this是一个很有意思的参数. 在objected-oriented语言中,一般都会有一个this来指
代当前的function是被那个object调用的.
</li>
<li>js并不是一个oo语言,function的创建也并不一定要在object里面. 但是js为了有oo
特性,特意发明了this参数.并且为oo做了一些'妥协':
<ul class="org-ul">
<li>如果我们的method有caller的话,那么this肯定就是指的caller object
</li>
<li>更多的情况下,我们并不会为一个function指定一个caller, 这种情况下又有两说:
<ol class="org-ol">
<li>老的js实现,也就是none-strict mode下面,我们的this会指向window,这是非常
不好的实现,因为我们调用function'没指定object',你却默认给我一个object,
这首先不合理.其实我们后面会看到,这种实现会'污染global namespace'
</li>
<li>新的js为了修正老的js实现,引入了strict mode(前面的arguments的alias我们
已经看到过strict mode修正过一次js的不良设计了), 在strict mode里面.如
果调用function不加object的话,this会指向undefined
</li>
</ol>
</li>
</ul>
</li>
<li>下面我们来介绍下function有哪些被调用的方法
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Invoking functions</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>在js里面有如下几种调用function的方式:
<ul class="org-ul">
<li>As a function: 这是最直接的调用function的方式,比如skulk()
</li>
<li>As a method: 这种方式会联系上一个object,为了oo设计而实现的, 比如ninja.skulk()
</li>
<li>As a constructor: 使用new来调用function,比如new Ninja(), 是一种类oo的object
创建方法
</li>
<li>通过apply或者call调用,这种是把object'当做参数'的调用方式: 比如skulk.call(ninja)
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">Invocation as a function</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>这么说的意思是function以最纯粹的方式调用:只使用operator()
</li>
<li>细细品味,有如下三种详细的调用方式:
<ul class="org-ul">
<li>function declaration, invoked as a function
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>;
ninja<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>function expression invoked as a function
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">samurai</span> = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(){}</span>;
samurai<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>immediately invoked function expression, invoked as a function
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(){}</span><span style="color: #2aa198;">)()</span>
</pre>
</div>
</li>
</ul>
</li>
<li>以这种方式调用function,在function内部this会:
<ul class="org-ul">
<li>在strict mode下面指向undefined
</li>
<li>在none strict mode下面指向window object
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2">Invocation as a method</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>当一个function被'设置'为一个object的property,然后当这个object调用这个function
的时候,我们就说function is invoked as a method of that object
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #2aa198;">{}</span>;
ninja.skulk = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(){}</span>;
ninja.skulk<span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>这种情况下,this自然就指向了调用我们的object.这也是js极力模仿其他oo语言的地
方.
</li>
<li>这种情况下,function的this是不停变动的,根据调用method的object的不同,this会
会有各种不同
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">whatsMyContext</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">nodejs' [window] equivalent global variable [global]</span>
console.log<span style="color: #2aa198;">(</span>whatsMyContext<span style="color: #b58900;">()</span> === global<span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">getMyThis</span> = whatsMyContext;
console.log<span style="color: #2aa198;">(</span>getMyThis<span style="color: #b58900;">()</span> === global<span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #2aa198;">{</span>
    getMyThis: whatsMyContext
<span style="color: #2aa198;">}</span>;

console.log<span style="color: #2aa198;">(</span>ninja1.getMyThis<span style="color: #b58900;">()</span> === ninja1<span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #2aa198;">{</span>
    getMyThis: whatsMyContext
<span style="color: #2aa198;">}</span>;

console.log<span style="color: #2aa198;">(</span>ninja2.getMyThis<span style="color: #b58900;">()</span> === ninja2<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>虽然我们的ninja1和ninja2都共享了一个function实体,但是其内部this的值确是不
一样的.
</li>
<li>this的灵活指向,完成了js对oo语言的一种追求.但是这个例子中,这样实现ninja1和
ninja2其实是有点repeat代码的,也就是把两个object的getMyThis都指向whatsMyContext
</li>
<li>oo语言中是可以通过继承来减少这种repeated代码的,我们后面会介绍
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-3" class="outline-4">
<h4 id="sec-4-2-3">Invocation as a constructor</h4>
<div class="outline-text-4" id="text-4-2-3">
<ul class="org-ul">
<li>总体上来说,任何一个function都可以作为一个constructor(可能arrow function有
些区别,后面会介绍),比如前面我们设置的whatsMyContext
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">whatsMyContext</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>; <span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">whatsMyContext</span><span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>但是这样做却是没有什么意义的,因为constructor function要做些事情,但是这里却
完全没做.只是说这样做编译器不会报错而已,并没有实现constructor的核心价值.要
实现ctor的核心价值,就得让ctor function和普通函数有点不同才行
</li>
</ul>
</div>
<div id="outline-container-sec-4-2-3-1" class="outline-5">
<h5 id="sec-4-2-3-1">THE SUPERPOWERS OF CONSTRUCTORS</h5>
<div class="outline-text-5" id="text-4-2-3-1">
<ul class="org-ul">
<li>先看一个例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.skulk = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;

console.log<span style="color: #2aa198;">(</span>ninja1.skulk<span style="color: #b58900;">()</span> === ninja1<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja2.skulk<span style="color: #b58900;">()</span> === ninja2<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>根据这个例子我们可以列出使用operator new xx()的方法来调用function的一些特
殊的地方:
<ul class="org-ul">
<li>会首先创建一个empty object
</li>
<li>这个object会传递给ctor function,作为这个ctor function的this paramter,那
么也就成为了这cotr function的context
</li>
<li>这个ctor函数返回的时候,我们会把ctor function的this作为返回值返回,所以ctor
function的结果可以返回给某个变量
</li>
</ul>
</li>
<li>后面两点说明了为什么whatsMyContext不是一个好的ctor: 一个ctor是创建一个object,
然后再function内部对这个object进行配置,说白了就是对this进行配置,最终返回.
whatsContxt都没有对this做过什么,自然就没有ctor的灵魂了
</li>
<li>我们一个标准的ctor应该如Ninja()
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.skulk = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-3-2" class="outline-5">
<h5 id="sec-4-2-3-2">CONSTRUCTOR RETURN VALUES</h5>
<div class="outline-text-5" id="text-4-2-3-2">
<ul class="org-ul">
<li>其实ctor的设计,很明显是一种js这种functional语言"强行"适应面向对象编程语言
的一种妥协设计.所以最后出来了一种ctor function最后会返回'传递给它的新建的
object'的this指针的设计.
</li>
<li>所以问题来了,如果我们ctor function自己return了返回值怎么办?
</li>
<li>答案是, 看情况:
<ul class="org-ul">
<li>如果返回的是nonobject value,比如1, 那么没事,everything 都OK
</li>
<li>如果返回的是object value, 那么ctor function的返回值就不再是那个新建的this
了,而是这个明确return的object.正是这种情况的存在,让我们必须要小心,同时
也使用各种办法让ctor function看起来更加不一样一点
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-3-3" class="outline-5">
<h5 id="sec-4-2-3-3">CODING CONSIDERATIONS FOR CONSTRUCTORS</h5>
<div class="outline-text-5" id="text-4-2-3-3">
<ul class="org-ul">
<li>我们的ctor function的价值在于我们对new创建的新object进行配置,所以一个有意义
的ctor function内部肯定会着重处理this
</li>
<li>但是如果我们调用的时候不小心忘了加new,那么我们ctor function里面对this的操作
都会是对window的操作!这会极大的污染global namespace.(在strict mode这不会发
生)
<div class="org-src-container">

<pre class="src src-js"><span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">global equvivalent for window in nodejs</span>
console.log<span style="color: #2aa198;">(</span>Object.keys<span style="color: #b58900;">(</span>global<span style="color: #b58900;">)</span>.includes<span style="color: #b58900;">(</span><span style="color: #2aa198;">'skulk'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.skulk = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">whatever</span> = Ninja<span style="color: #2aa198;">()</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">forget new !</span>
console.log<span style="color: #2aa198;">(</span>Object.keys<span style="color: #b58900;">(</span>global<span style="color: #b58900;">)</span>.includes<span style="color: #b58900;">(</span><span style="color: #2aa198;">'skulk'</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>在strict mode诞生之前,我们能做出的努力(让ctor function看起来不一样一点)就
是naming convention了:
<ul class="org-ul">
<li>普通函数的命名是首字母小写的驼峰模式,并且表述下自己做了什么,比如
<div class="org-src-container">

<pre class="src src-js">skulk, creep, sneak, doSomethingWonderful
</pre>
</div>
</li>
<li>ctor函数的命名是首字母大写的,一般是名词,比如
<div class="org-src-container">

<pre class="src src-js">Ninja, Samurai, Emperor, Ronin
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-2-4" class="outline-4">
<h4 id="sec-4-2-4">Invocation with the apply and call methods</h4>
<div class="outline-text-4" id="text-4-2-4">
<ul class="org-ul">
<li>到目前为止,我们看到的不同的function invocation类型的主要区别在于:implicit this
指向的function context是什么:
<ul class="org-ul">
<li>对于method来说,this指向了method的object
</li>
<li>对于top-level来说,this指向window或者undfined
</li>
<li>对于ctor来说,this指向new新创建的这个object
</li>
</ul>
</li>
<li>如果我们想随意指定一个object怎么办,比如top-level的function,我们不想使用window,
而想使用document来调用它们.
</li>
<li>为了解决这个问题,我们先来看一个'非常常见的'和event handling相关的bug.
</li>
<li>看这个bug之前,先来了解event handling的机制: 每当event handler被调用的时候,
function context是被设置为event绑定的object
<pre class="example">
When an event handler is called, the function context is set to
the object to which the event was bound.
</pre>
</li>
<li>我们的这个buggy的例子如下
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">button</span> id =<span style="color: #2aa198;">"test"</span>&gt; Click Me! &lt;/<span style="color: #268bd2;">button</span>&gt;
&lt;<span style="color: #268bd2;">script</span>&gt;
 function Button() {
     this.clicked = false;
     this.click = function() {
         this.clicked = true;
         assert(button.clicked, <span style="color: #2aa198;">"The button has been clicked"</span>); <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">false </span><span style="color: #93a1a1;">--&gt;</span>
     };
 }
 var button = new Button();
 var elem = document.getElementById(<span style="color: #2aa198;">"test"</span>);
 elem.addEventListener(<span style="color: #2aa198;">"click"</span>, button.click);
&lt;/<span style="color: #268bd2;">script</span>&gt;
</pre>
</div>
</li>
<li>这个例子的结果并不如人意, 每次调用都会显示'红色'的message,表示clicked的值是
false
</li>
<li>这个例子的问题在于button.click的调用,如果不和addEventListener掺和的话,那么
会把this默认为button object(这个是method的典型用法啊),而这里的问题是addEventListener
会把后面的callback的this改成elem(也就是addEventListener的调用者!),所以你对
this.clicked的操作,都会延续到elem上面!
</li>
<li>我们姑且还是认为这是js设计不合理的地方吧
</li>
<li>这个问题的根源在于我们没有'准确'函数的this object! 函数的this object如果能
够随心所欲的更改的话,那么我们就可以完成我们的工作了.
</li>
<li>幸运的是js确实是有这样的feature,那就是:
<ul class="org-ul">
<li>apply
</li>
<li>call
</li>
</ul>
</li>
<li>apply和call其实是一回事,只不过apply要求第二个参数是数组,call则是把这个数组展开
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">juggle</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">result</span> = 0;
    <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">n</span> = 0; n &lt; <span style="color: #268bd2; font-weight: bold;">arguments</span>.length; n++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        result += <span style="color: #268bd2; font-weight: bold;">arguments</span><span style="color: #268bd2;">[</span>n<span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">}</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.result = result;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #2aa198;">{}</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #2aa198;">{}</span>;

juggle.apply<span style="color: #2aa198;">(</span>ninja1, <span style="color: #b58900;">[</span>1,2, 3, 4<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;
juggle.call<span style="color: #2aa198;">(</span>ninja2, 5, 6, 7, 8<span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninja1.result<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja2.result<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10                                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">26                                             //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>好了,你信心满满的把代码改成如下,希望能够得到'绿色'的结果
<div class="org-src-container">

<pre class="src src-js">elem.addEventListener.call<span style="color: #2aa198;">(</span>button, <span style="color: #2aa198;">"click"</span>, button.click<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>结果浏览器却报错了,因为addEventListener是一个浏览器提供的API,它并不是一个真
正的js function
</li>
<li>要想真正的解决这个问题,我们要用到arrow function
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Fixing the problem of function contexts</h3>
<div class="outline-text-3" id="text-4-3">
</div><div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1">Using arrow functions to get around function contexts</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>除了写起来简单以外,arrow function还有一个特性和原来的function与众不同,而且
更容易把它作为一个callback: arrow function的this不再是一个动态的值,它是不
能再次改变的(可以被认为是一个const, 无论call, apply还是bind都不能改变它),
它的初始化值是'创建时期enclosing scope'的this值
<pre class="example">
Arrow functions don't have their own this value. Instead, they remember
the value of the this parameter at the time of their definition.
</pre>
</li>
<li>它的初始化值是'创建时期enclosing scope'的this值, 这句比较难以理解,我们可以
看看下面几个例子:
<ul class="org-ul">
<li>在global创建的function,其this始终是指向window(global)的
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">script</span>&gt;
    var o = {
        traditionalFunc: function() {
            assert(this === o, <span style="color: #2aa198;">"traditionalFunc this === o?"</span>); <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">true </span><span style="color: #93a1a1;">--&gt;</span>
        },
        arrowFunc: () =&gt; {
            assert(this === o, <span style="color: #2aa198;">"arrowFunc this === o?"</span>); <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">false </span><span style="color: #93a1a1;">--&gt;</span>
            assert(this === window, <span style="color: #2aa198;">"arrowFunc this === window?"</span>); <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">true </span><span style="color: #93a1a1;">--&gt;</span>
        }
    };

    o.traditionalFunc();
    o.arrowFunc();
&lt;/<span style="color: #268bd2;">script</span>&gt;
</pre>
</div>
</li>
<li>在ctor里面创建的,其this始终指向新创建的object,也就是我们后面的例子展现的.
</li>
</ul>
</li>
<li>这样一来,刚才的问题就迎刃而解了.下面的例子中,所有的this都是一个this,就是button object
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Button</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
  <span style="color: #268bd2; font-weight: bold;">this</span>.clicked = <span style="color: #268bd2; font-weight: bold;">false</span>;
  <span style="color: #268bd2; font-weight: bold;">this</span>.click = <span style="color: #b58900;">()</span> =&gt; <span style="color: #b58900;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.clicked = <span style="color: #268bd2; font-weight: bold;">true</span>;
    assert<span style="color: #268bd2;">(</span>button.clicked, <span style="color: #2aa198;">"The button has been clicked"</span><span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">button</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Button</span><span style="color: #2aa198;">()</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">elem</span> = document.getElementById<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"test"</span><span style="color: #2aa198;">)</span>;
elem.addEventListener<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"click"</span>, button.click<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2">Using the bind method</h4>
<div class="outline-text-4" id="text-4-3-2">
<ul class="org-ul">
<li>我们再来回顾下前面的event handler出问题的那句代码
<div class="org-src-container">

<pre class="src src-js">elem.addEventListener<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"click"</span>, button.click<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>前面说addEventListener不是真正的js function,那么我们可以从button.click上面
来做做文章,依照我们现有的知识,我们可以这么做
<div class="org-src-container">

<pre class="src src-js">elem.addEventListener<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"click"</span>, button.click.call<span style="color: #b58900;">(</span>button<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>这样做看起来可以,但是有一个问题:我们的apply或者call,是"调用一个函数",我们
的assert的确变成绿的了,但是只能绿一次,我们不能把这个function'再传递'给addEventListener
</li>
<li>所以我们很自然的想到,'再创建一个新的function,只不过this换掉的方案',那就是
bind了
</li>
<li>每个function都可以访问bind, bind会:
<ul class="org-ul">
<li>创建一个新的函数并且作为返回值返回
</li>
<li>而且这个函数的this函数变成了bind的第一个参数
</li>
<li>这种bind是强制的,不会受到'如何调用'的影响(如果还受到addEventListener的影
响,那就没完没了了)
</li>
</ul>
</li>
<li>下例中,我们使用bind来把button.click'绑定'在button上,然后返回就解决了这个问题
<div class="org-src-container">

<pre class="src src-html">var button = {
   clicked: false,
   click: function(){
     this.clicked = true;
     assert(button.clicked,<span style="color: #2aa198;">"The button has been clicked"</span>); <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">true </span><span style="color: #93a1a1;">--&gt;</span>
   }
 };
 var elem = document.getElementById(<span style="color: #2aa198;">"test"</span>);
 elem.addEventListener(<span style="color: #2aa198;">"click"</span>, button.click.bind(button));

 var boundFunction = button.click.bind(button);
 assert(boundFunction !== button.click,
        <span style="color: #2aa198;">"Calling bind creates a completyl new function"</span>); <span style="color: #93a1a1;">&lt;!-- </span><span style="color: #93a1a1;">true </span><span style="color: #93a1a1;">--&gt;</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 5: Functions for the master: closures and scopes</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>和我们前面讲的function一样,closure也是最重要的javascript特性.虽然很多js开发
者可以在完全不理解closure带来的好处的基础上写出代码.但是我们还是要说,closure
的引进,为js增添了如下的好处:
<ul class="org-ul">
<li>为一些高端的特性减少了代码的数量和复杂度: 和callback有关的代码,比如event
handling,如果没有closure,就会非常的麻烦
</li>
<li>让我们使用一些如果没有closure根本不能实现的特性:比如private object variable
</li>
</ul>
</li>
<li>closure其实是functional programming language的特性,了解它有助于理解复杂的js
代码
</li>
<li>closure其实是一种副作用(side effect),它是js scope工作原理的副作用
<pre class="example">
Closures are a side effect of how scopes work in JavaScript.
</pre>
</li>
</ul>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Understanding closures</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>closure的出现,让js的function可以'读写'不在function内部的variable,当然这些个
variable必须是在function定义的scope里面(也就是说是function定义所在的那个{})
</li>
<li>closure给function带来的好处,就是一个function可以在'以后任何的时间'被调用,甚
至是它定义的scope已经结束了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">outerValue</span> = <span style="color: #2aa198;">"samurai"</span>;
<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">later</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">outerFunction</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">innerValue</span> = <span style="color: #2aa198;">"ninja"</span>;

    <span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">innerFunction</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">'outerValue is '</span> + outerValue<span style="color: #268bd2;">)</span>;
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">'innerValue is '</span> + innerValue<span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    later = innerFunction;
<span style="color: #2aa198;">}</span>

outerFunction<span style="color: #2aa198;">()</span>;
later<span style="color: #2aa198;">()</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">outerValue is samurai                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">innerValue is ninja                            //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>我们使用later变量来保存innerFunction,然后再后面去调用它,否则我们无法获取它
的名字(因为innerFunction定义在outerFunction里面)
</li>
<li>later()调用的时候,outerFunction()已经运行完毕了,但是later()还是能看到outerVale
和innerValue,其中原因就是closure
</li>
<li>当我们在outer function里面定义innerFunction的时候,不知function declaration
定义了.同时一个closure也会被定义, 这个closure里面包括, function 定义时候的
所有的variable
<pre class="example">
+----------------------------------------------------+
|        +------------------------+                  |
|        | function outerFunction |                  |
|        +------------------------+                  |
|                                                    |
|   +-----------+                                    |
|   | var later |                                    |
|   +-----------+                                    |
|                                                    |
|            +--------------------------------+      |
|            | function innerFunction() {...} |      |
|            +--------------------------------+      |
|                                                    |
|             +----------------+                     |
|             | var innerValue |                     |
|             +----------------+                     |
|                                                    |
|        +----------------+                          |
|        | var outerValue |                          |
|        +----------------+       CLOSURE            |
|                                                    |
+----------------------------------------------------+
</pre>
</li>
<li>一旦closure创建起来了以后,function就有了它运行所有需要的一切(the function
has all it needs to execute), 好了,这里有一个问题了,为什么"仅仅"包括了function
定义时刻scope的内容,closure就肯定包括了function运行所需要的一切?难道function
不能使用'其他'内容么?
</li>
<li>答案是function'不一定'能使用'其他'内容,原因很简单:它看不到!function能看到的
变量有两种:
<ul class="org-ul">
<li>看到自己定义所在的scope里面的变量,所以它内部也仅仅可能使用这些变量
</li>
<li>global scope的内容(所有人都看得到)
</li>
</ul>
</li>
<li>每个function都带有一个closure,所以可以在无论什么时候进行运行,但是也是有代价
的: 每个function都要在内存里面维护这么一个closure,直到js engine它不会再被需
要,或者page unload的时候
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Putting closures to work</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>我们已经从概念上了解了closure,下面来看看closure如何在js代码中起作用的例子
</li>
</ul>
</div>
<div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1">Mimicking private variables</h4>
<div class="outline-text-4" id="text-5-2-1">
<ul class="org-ul">
<li>很多语言都有private variable这个概念,这是oo语言实现内聚的重要特性
</li>
<li>在js里面,我们通过closure来实现private variable,看下面的例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">feints</span> = 0;
    <span style="color: #268bd2; font-weight: bold;">this</span>.getFeints = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> feints;
    <span style="color: #b58900;">}</span>;
    <span style="color: #268bd2; font-weight: bold;">this</span>.feint = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        feints++;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
ninja1.feint<span style="color: #2aa198;">()</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">private data is inaccessible to us</span>
console.log<span style="color: #2aa198;">(</span>ninja1.feints<span style="color: #2aa198;">)</span>;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined</span>

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">We're able to access the internal feint count via getter</span>
console.log<span style="color: #2aa198;">(</span>ninja1.getFeints<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninja2 gets its own feints variable</span>
console.log<span style="color: #2aa198;">(</span>ninja2.getFeints<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>这个例子中,我们使用Ninja function作为一个ctor.这是一个常规操作
</li>
<li>不常规的操作在于我们在ctor里面定义了一个变量feints来hold state: 这个时候,
首先起作用的是javascript的scoping rule(不是closure是scope!!):这个变量只能
在constructor里面访问(within the ctor)
</li>
<li>好了,下面该closure出场了:为了让外面也能'访问'这个变量,我们设计了一个function
作为getter.这里体现了closure起作用的一大特点,在function里面定义function的
时候,往往意味着用到closure了!
<pre class="example">
Whenever you use function inside another function, a closure is used.
</pre>
</li>
<li>下面还是在function里面定义function:在Ninja()里面定义了一个setter: feint,这
里只是简单的增加1
</li>
<li>好了,我们的代码显示出,我们只能使用setter: feint来更改private variable,这跟
oo语言里面的封装是一个道理
</li>
<li>ninja2的例子还告诉我们,这个variable是每个instance都有一个的&#x2013;和private variable
一样
</li>
<li>使用closure(在scope和new的帮助下),ninja object的state只能通过特定的method
来访问
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2-2" class="outline-4">
<h4 id="sec-5-2-2">Using closures with callbacks</h4>
<div class="outline-text-4" id="text-5-2-2">
<ul class="org-ul">
<li>closure另外经常出现的地方就是callbacks(when a function is called at an
unspecified later time)
</li>
<li>下面是一个callback使用closure的例子
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">body</span>&gt;
    &lt;<span style="color: #268bd2;">div</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"box1"</span>&gt;First Box&lt;/<span style="color: #268bd2;">div</span>&gt;
  &lt;<span style="color: #268bd2;">script</span>&gt;
    function animateIt(elementId) {
      var elem = document.getElementById(elementId);
      var tick = 0;
      var timer = setInterval(function(){
        if (tick &lt; 100) {
          elem.style.left = elem.style.top = tick + <span style="color: #2aa198;">"px"</span>;
          tick++;
        }
        else {
          clearInterval(timer);
          assert(tick === 100,
                 <span style="color: #2aa198;">"Tick accessed via a closure."</span>);
          assert(elem,
                 <span style="color: #2aa198;">"Element also accessed via a closure."</span>);
          assert(timer,
                 <span style="color: #2aa198;">"Timer reference also obtained via a closure."</span> );
        }
      }, 10);
    }
    animateIt(<span style="color: #2aa198;">"box1"</span>);
  &lt;/<span style="color: #268bd2;">script</span>&gt;
&lt;/<span style="color: #268bd2;">body</span>&gt;
</pre>
</div>
</li>
<li>这个例子的主体是其实就是对某个element(box1)调用一个函数animateIt, 而animateIt
的内部其主要作用的是setInterval这个函数
</li>
<li>setInterval函数的作用是'间隔性'的调用某个function(这个function肯定是callback
啦), 会返回一个timerId,这个timerId以后可以传递给clearInterval()来取消这个'间
歇性'的callback调用(这里是通过判断tick到没到100下来决定的)
</li>
<li>那重点又转移到了这个callback函数上面,这个callback函数其实就是根据tick来移
动elem,所以这个函数一共用到三个variable:
<ul class="org-ul">
<li>tick:调用了多少次callback
</li>
<li>elem:移动那个element
</li>
<li>timer: callback返回的timer,callback一定次数之后返回
</li>
</ul>
</li>
<li>我们发现这三个变量,其实是托closure的福才能访问的到,我们也发现我们的callback
函数正好是use function inside another function.
</li>
<li>那么我们有没有可能不使用closure呢?
</li>
<li>其实也可以,把三个变量都定义成全局变量就可以了,但是这会:
<ul class="org-ul">
<li>极大的污染全局变量.
</li>
<li>如果你有两个以上的animataion,那么会相互影响!
</li>
</ul>
</li>
<li>所以这是closure可以让我们做的better的一个特性(而不是像private variable那样
的没有就实现不了的特性)
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Tracking code execution with execution context</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>在js里面,最基本的单位就是function.为了完成某些功能,我们可以在一个function里
面调用另外的function,继续嵌套等等
</li>
<li>当一个function完成工作的时候,它必须退回到call 它时候的状态,学过c语言的都知
道这个是通过stack来完成的
</li>
<li>前面也说过了,我们有两种js code:
<ul class="org-ul">
<li>global code: 在所有的function之外的代码
</li>
<li>function code: 在function内部的代码
</li>
</ul>
</li>
<li>我们为这两种js code都准备了一种execution context:
<ul class="org-ul">
<li>global execution context: 全局只有一个
</li>
<li>function execution context: 每个function创建的时候都会创建一个
</li>
</ul>
</li>
<li>每次function调用的时候push一个context到stack里面,当function返回的时候,这个
context就会被pop而放弃
</li>
<li>除了保存运行的position以外,execution context还能够检查某个variable时候合法,
这是通过lexical environment来完成的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Keep track of identifiers with lexical environments</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>lexical environment是一个js engine内部的概念,所以说起来是这么的拗口,我们通
常把这个叫做scope.
</li>
<li>lexical是把identifier和内存值映射的这么一个机制,有点像编译里面的变量表
</li>
<li>在es6之前,scope只能有一种,那就是function,其他c-like语言里面的`{}`内部就是一
个scope的情况,在js里面没有实现,幸好es6实现了!
</li>
</ul>
</div>
<div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">Coding nesting</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>先看下面的一个例子
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">html</span>&gt;
    &lt;<span style="color: #268bd2;">script</span>&gt;
     var ninja = "Muneyoshi";
     function skulk() {
         var action = <span style="color: #2aa198;">"skulking"</span>;
         function report() {
             var reportNum = 3;

             for (var i = 0; i &lt; reportNum; i++) {
                 console.log(ninja + <span style="color: #2aa198;">" "</span> + action + <span style="color: #2aa198;">" "</span> + i);
             }
         }
         report();
     }
     skulk();
    &lt;/<span style="color: #268bd2;">script</span>&gt;
&lt;/<span style="color: #268bd2;">html</span>&gt;
</pre>
</div>
</li>
<li>这个例子中,我们看到了好多的nested:
<ul class="org-ul">
<li>for loop被nested在report function里面
</li>
<li>report()被nested在skulk()里面
</li>
<li>skulk()被nested在global code里面
</li>
</ul>
</li>
<li>在scope的语义里面,每次的"调用"都会获得一个新的lexical environment,就是一个
独立的scope,这个是和c-like语言保持一致的
<pre class="example">
In terms of scopes, each of these code structures gets an associated lexical
environment every time the code is evaluated.
</pre>
</li>
<li>还有一点需要强调的是,inner code'还必须可以'access to 定义在outer code的
variable,比如:
</li>
<li>for需要有能力去使用:
<ul class="org-ul">
<li>report()里面的变量
</li>
<li>skulk()里面的变量
</li>
<li>global里面的变量
</li>
</ul>
</li>
<li>report()需要能够访问:
<ul class="org-ul">
<li>skulk()里面的变量
</li>
<li>global里面的变量
</li>
</ul>
</li>
<li>skulk()只能访问:
<ul class="org-ul">
<li>global里面的变量
</li>
</ul>
</li>
<li>这些也是c-like语言里面常见的能力,但是在js里面,实现方法有所不同
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">Code nesting and lexical environments</h4>
<div class="outline-text-4" id="text-5-4-2">
<ul class="org-ul">
<li>js里面的实现策略就是每一个lexical environment都会保存一个指向parent lexical
environment的"指针",这样当当前的environment找不到响应变量的时候,它可以顺着
指针向上寻找,直到global scope
</li>
<li>我们把function也可以看成是一种scope,但是这个scope更加的牛逼,它可以调用已经
运行完了的数据! 它实现起来也更加的麻烦:
</li>
<li>每当一个function被创建的时候,function都会有一个叫做\[\[ Environment\]\]的
property被创建,指向这个function`被创建时期`的scope. 这样保证了,我们的function
就算当做参数传递出去,也始终能通过\[\[ Environment\]\]来记住自己的'来历'
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Understanding types of JavaScript variables</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li>java中,我们可以使用三种方法定义变量:
<ul class="org-ul">
<li>var
</li>
<li>let
</li>
<li>const
</li>
</ul>
</li>
<li>它们的区别在"是否可变"以及和lexical environment的关系不同
</li>
</ul>
</div>
<div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1">Variable mutability</h4>
<div class="outline-text-4" id="text-5-5-1">
<ul class="org-ul">
<li>那就是分成:
<ul class="org-ul">
<li>const
</li>
<li>let或者var
</li>
</ul>
</li>
<li>const就是不可变'变量',es6代码的风格趋向于如果不确定,就把变量定义成const
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-5-2" class="outline-4">
<h4 id="sec-5-5-2">Variable definition keywords and lexical environments</h4>
<div class="outline-text-4" id="text-5-5-2">
<ul class="org-ul">
<li>var是上古时期的产物,它对于scope是不认识的,所以它只能定义在最近的function scope
或者是global scope
</li>
<li>const和let就会尊重scope啦
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-5-3" class="outline-4">
<h4 id="sec-5-5-3">Registering identifiers within lexical environments</h4>
<div class="outline-text-4" id="text-5-5-3">
<ul class="org-ul">
<li>js是一个script语言,但是script语言其实也不是从上到下一次运行的,它还是有点静
态语言的味道:因为它会先"大概过一下代码",了解定义了哪些function,所以,下面的
代码执行效果如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">firstRonin</span> = <span style="color: #2aa198;">"Kiyokawa"</span>;
check<span style="color: #2aa198;">(</span>firstRonin<span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">check</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">ronin</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>ronin<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Kiyokawa                                       //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>js engine往往会visit代码两遍:
<ul class="org-ul">
<li>第一遍不运行,只是把当前lexical environment的变量和function都注册一下
</li>
<li>第二遍才是正常的运行
</li>
</ul>
</li>
<li>我们详细来解释下,js engine把代码的执行分成了两个phase:
<ul class="org-ul">
<li>第一个phase被激发的条件,是new lexical environment被创建的时候,这个phase
不会执行代码,js engine会访问并注册当前lexical environment里面所有的declared
variable和function
</li>
<li>第二个phase,才是真正的execution
</li>
</ul>
</li>
<li>相比之下,第二个phase就是一行一行执行,比较容易理解. 而第一个phase却非常的复
杂,根据variable类型的不同,和environment的不同,都有不同的执行方法:
<ul class="org-ul">
<li>如果我们的lexical environment是function environment,那么就会创建arguments
当然了还要给这个arguments类数组赋值.只有function environment才会做这一步
</li>
<li>如果我们的lexical environment是global或者function environment,当前的代码
主体会被扫描并注册,同时还会为每个发现的function创建一个指向当前environment的指针
扫描并注册的时候,但是注意如下两点:
<ol class="org-ol">
<li>arrow function不会被注意到!
</li>
<li>function的body不会去检查,否则没完了
</li>
</ol>
</li>
<li>如果我们的lexical environment是global或者function environment, 我们还会
去扫描variable,所有定义在global scope和function scope的var变量以及const,
let变量,都会被找到.
</li>
<li>如果我们的lexical environment是block environment,那么变量方面,只有const和
let被找到
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6">Exploring how closures work</h3>
<div class="outline-text-3" id="text-5-6">
<ul class="org-ul">
<li>我们这一章的开始是从介绍closure开始的,closure是一种能够让function在"运行的
时候"回忆起自己在"创建的时候scope"的变量的机制
</li>
<li>你还学到了使用closure可以模拟private object,或者是让代码和callback配合的更好
</li>
</ul>
</div>
<div id="outline-container-sec-5-6-1" class="outline-4">
<h4 id="sec-5-6-1">Revisiting mimicking private variables with closures</h4>
<div class="outline-text-4" id="text-5-6-1">
<ul class="org-ul">
<li>我们先来回顾下创建一个ninja1的代码
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">feints</span> = 0;
    <span style="color: #268bd2; font-weight: bold;">this</span>.getFeints = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> feints;
    <span style="color: #b58900;">}</span>;

    <span style="color: #268bd2; font-weight: bold;">this</span>.feint = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        feints++;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>js的ctor其实是调用function(只不过是使用了new来调用),那么每调用一次function
我们就有一个lexical environment(这个environment会保存对这个ctor创建时期可
见的variable),这是由scope的机制决定的
</li>
<li>js的evaulate一段scope(这里是调用一段function)会创建Environment,而同时js"创
建"一段function的时候,它会保持一个ref到它'创建时刻'的lexical environment(js
engine内部概念)
</li>
<li>理解上面的一段文字非常重要,它说明了两个问题:
<ul class="org-ul">
<li>js的调用,本质上是一个evaluate scope的过程(曾经function是唯一的一种scope
但是在es6之后,不再是唯一了,但也是scope的一种), 每次evaluate scope都会创建
一个Environment
</li>
<li>js的创建,会记录其创建时刻的Environment,在绝大多数情况下,function是会created
在global的scope,所以这个function会把global记录自己的\[\[Environment\]\].
而这个例子的情况"非常特殊",getter和setter是建立在ctor里面的,也就是说,它们
会把ctor的Environment设计成自己的\[\[Environment\]\].ctor每次的evaluate
scope都会创建一个Environment,而其中的function会记录这个Environment
</li>
</ul>
</li>
<li>getter和setter另外一个特殊的地方(一个是不是建立在global scope),是它们是赋予
给cotr所创建的this的,所以它们可以在ctor之外被访问(通过new赋值的变量),这样,
我们就创建了一个新的特殊的函数:
<ul class="org-ul">
<li>定义在另外一个函数里面,所以可以访问这个函数里面的变量
</li>
<li>可以在global scope使用
</li>
</ul>
</li>
<li>好了,我们继续使用下面的代码创建第二个object
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
</pre>
</div>
</li>
<li>那么我们Ninja()会再次调用,也就会生成新的Environment(every invocation都会产
生新的Environment), 那setter和getter也都会指向新的Environment,所以
<pre class="example">
ninja1.getFeints mehtod is different from the ninja2.getFeints method!!
</pre>
</li>
<li>好了,我们来总结下Environment和Closure的区别:
<ul class="org-ul">
<li>Environment可以看做是stack的一个js engine对应:记录当前可以访问的变量,在
历史上是使用stack的,所有在stack里面的(可能有好多层)变量都可以访问.但是
stack有一个致命的问题是,它可能会弹出,一旦弹出就没有存储了.对于js这种functional
语言来说是致命的(因为它要始终记得'自己创建时候'的变量可访问性),所以js engine
就设计了Environment,它内容等同于stack,但是却不会消失
</li>
<li>closure是使用一个指针\[\[Environment\]\]来记录function'必须使用的variable'
而已,占了Environment的便宜,closure只需要一指针就实现了
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-6-2" class="outline-4">
<h4 id="sec-5-6-2">Private variables caveat</h4>
<div class="outline-text-4" id="text-5-6-2">
<ul class="org-ul">
<li>我们需要注意的是,我们使用closure实现的private variable其实只是一种"尽可能好"
的模仿而已.我们依然可以通过把一个object的function赋给另外一个object,从
而丧失任何的private特性
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">feints</span> = 0;
    <span style="color: #268bd2; font-weight: bold;">this</span>.getFeints = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> feints;
    <span style="color: #b58900;">}</span>;
    <span style="color: #268bd2; font-weight: bold;">this</span>.feint = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        feints++;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
ninja1.feint<span style="color: #2aa198;">()</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">imposter</span> = <span style="color: #2aa198;">{}</span>;
imposter.getFeints = ninja1.getFeints;

console.log<span style="color: #2aa198;">(</span>imposter.getFeints<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>但是很多js开发者依然认为使用closure来模拟private variable的方法很有效!谁用
谁知道
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-6-3" class="outline-4">
<h4 id="sec-5-6-3">Revisiting the closures and callbacks example</h4>
<div class="outline-text-4" id="text-5-6-3">
<ul class="org-ul">
<li>我们再来看看上面的callback的例子,这次我们使用了两个object
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #268bd2;">div</span> id =<span style="color: #2aa198;">"box1"</span>&gt;First Box&lt;/<span style="color: #268bd2;">div</span>&gt;
&lt;<span style="color: #268bd2;">div</span> id =<span style="color: #2aa198;">"box2"</span>&gt;Second Box&lt;/<span style="color: #268bd2;">div</span>&gt;

&lt;<span style="color: #268bd2;">script</span>&gt;
 function animateIt(elementId) {
     var elem = document.getElementById(elementId);
     var tick = 0;
     var timer = setInterval(function() {
         if (tick &lt; 100) {
             elem.style.left = elem.style.top = tick + <span style="color: #2aa198;">"px"</span>;
             tick++;
         } else {
             clearInterval(timer);
             assert(tick === 100,
                    <span style="color: #2aa198;">"Tick accessed via a closure."</span>);
             assert(elem,
                    <span style="color: #2aa198;">"Element also accessed via a closure."</span>);
             assert(timer,
                    <span style="color: #2aa198;">"Timer reference also obtained via a closure."</span>);
         }
     }, 10);
 }
 animateIt(<span style="color: #2aa198;">"box1"</span>);
 animateIt(<span style="color: #2aa198;">"box2"</span>);
&lt;/<span style="color: #268bd2;">script</span>&gt;
</pre>
</div>
</li>
<li>每一次的function调用都会产生一个新的lexical environment,这里调用了两次animateIt
那么显然会有两个Environment产生,那么显然,每个Environment里面都会有各自的一
个elem和tick,所以两次调用也不会相互影响.这里我们就从理论上解释了为什么closure
能让callback函数更简单
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Chapter 6: Functions for the future: generators and promises</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Makeing our async code elegant with generators and promises</h3>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">Working with generator functions</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>generator是一种完全崭新的function类型,它会generate一系列的值,但是并不是一次
返回,而是每次调用返回一次结果,知道没有结果返回了.
</li>
<li>什么时候没有结果了呢?我们新引入了一个关键字yield,你可以看做是return的特殊形
式,yield了几次,就可以返回几次.如果调用的次数超过yield的次数,那么就没有结果
返回了.generator会明确告诉调用者的,看例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">WeaponGenerator</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Katana"</span>,
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Wakizashi"</span>;
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Kusarigama"</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">weapon</span> = WeaponGenerator<span style="color: #2aa198;">()</span>;
console.log<span style="color: #2aa198;">(</span>weapon.next<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>weapon.next<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>weapon.next<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>weapon.next<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ value: 'Katana', done: false }               //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ value: 'Wakizashi', done: false }            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ value: 'Kusarigama', done: false }           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ value: undefined, done: true }               //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>这个例子引入了很多的新知识:
<ul class="org-ul">
<li>generator定义是使用function*来定义的
</li>
<li>yield相当于"不马上返回的"的return
</li>
<li>调用这个函数不会去执行,而是返回一个object,叫做iterator.这里的的weapon
object就是一个iterator,特点是自带一个函数叫做next(). 这其实就是实现了经典
的Iterator设计模式
<pre class="example">
         迭代器模式能够提高你的'遍历'的性能,从一个节点可以直接到下一个节点,遍历
         的时间复杂度是O(N).
         如果使用普通的遍历方法,每遍历一个节点就要使用get(idx)方法,会遍历半个列
         表去查找,所以整个遍历的复杂度是O(N^2)
</pre>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1">Controlling the generator throught the Iterator object</h4>
<div class="outline-text-4" id="text-6-2-1">
<ul class="org-ul">
<li>对generator的调用,不会去执行function的内部代码,相反,调用会产生一个iterator
object: 整个是一个我们可以利用的,用来和iterator进行通信的利器
</li>
<li>iterator每次都会返回一个object,其解构我们都看到了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">{</span>
    value: <span style="color: #2aa198;">'xxx'</span>,
    done: <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们可以把iterator暴露出来的next()函数看成是它的interface,这个函数是我们唯
一可以依赖的,但是依赖的好,会有特别好的效果, 比如我们可以使用while来判断next()
返回的的done值是不是true
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">WeaponGenerator</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Katana"</span>,
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Wakizashi"</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">weaponsIterator</span> = WeaponGenerator<span style="color: #2aa198;">()</span>;

<span style="color: #859900; font-weight: bold;">while</span><span style="color: #2aa198;">(</span>!<span style="color: #b58900;">(</span>item = weaponsIterator.next<span style="color: #268bd2;">()</span><span style="color: #b58900;">)</span>.done<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>item.value<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Katana                                         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Wakizashi                                      //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>其实我们使用while的这种方法,用另外的语法糖的方法表示出来,就是for-of loop啦
for-of loop不再需要我们去直接调用next(), 自然也不再需要关注next()返回值的
结构
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">WeaponGenerator</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Katana"</span>,
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Wakizashi"</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">item</span> of WeaponGenerator<span style="color: #b58900;">()</span><span style="color: #2aa198;">){</span>
    console.log<span style="color: #b58900;">(</span>item<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Katana                                         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Wakizashi                                      //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>上面我们介绍的是最基本的generator的使用方法,其实还有一些高端的使用方法,比如
下面要介绍的把generator的execution代理给其他的generator,先看代码
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">WarriorGenerator</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Sun Tzu"</span>;
    <span style="color: #859900; font-weight: bold;">yield</span>* NinjaGenerator<span style="color: #b58900;">()</span>;
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Genhis Khan"</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">NinjaGenerator</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Hattori"</span>;
    <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #2aa198;">"Yoshi"</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">warrior</span> of WarriorGenerator<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>warrior<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Sun Tzu                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hattori                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Yoshi                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Genhis Khan                                    //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>注意,这里面的yield有一个是特殊的,是yield*,而不是单单的yield,使用了yield*之
后,我们的yield不再是直接返回后面的值了,而是返回后面值里面的yield.换句话说,
<pre class="example">
        就是把控制权交给了新的generator,让它去遍历,遍历完再把控制权还回来
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2-2" class="outline-4">
<h4 id="sec-6-2-2">Using generators</h4>
<div class="outline-text-4" id="text-6-2-2">
<ul class="org-ul">
<li>生产sequences of item这件事情,看起来不起眼,但是在程序中却经常被用到,比如一
个特别常用的例子,就是生成unique的ID
</li>
<li>每当创建一个object的时候,我们都想给这个object一个不会重复的id,在没有generator
的帮助下,我们可以通过一个global counter来做到.但是这样太丑陋了,而且谁都有
权限去更改这个全局变量
</li>
<li>有了generator这种语言级别的特性,这个件事情做起来就非常容易了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> *<span style="color: #268bd2;">IdGenerator</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">id</span> = 0;
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">true</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">yield</span> ++id;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">idIterator</span> = IdGenerator<span style="color: #2aa198;">()</span>;

console.log<span style="color: #2aa198;">(</span>idIterator.next<span style="color: #b58900;">()</span>.value<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>idIterator.next<span style="color: #b58900;">()</span>.value<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>idIterator.next<span style="color: #b58900;">()</span>.value<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>例子中的id是generator自己的local variable,完全不会被外界干扰
</li>
<li>虽然我们使用了while(true)这种语法,看似会产生无限循环,但是由于yield这种可以
suspend的特性,我们也不必担心无限循环的问题.
</li>
<li>在来看一个遍历DOM的例子,在没有generator之前,代码如下
<div class="org-src-container">

<pre class="src src-html">&lt;<span style="color: #859900; font-weight: bold;">!DOCTYPE</span> html&gt;
&lt;<span style="color: #268bd2;">html</span>&gt;
    &lt;<span style="color: #268bd2;">head</span>&gt;
        &lt;<span style="color: #268bd2;">meta</span> <span style="color: #268bd2;">charset</span>=<span style="color: #2aa198;">"utf-8"</span>&gt;
        &lt;<span style="color: #268bd2;">title</span>&gt;<span style="font-weight: bold; text-decoration: underline;">Recursive DOM traversal</span>&lt;/<span style="color: #268bd2;">title</span>&gt;
        &lt;<span style="color: #268bd2;">link</span> <span style="color: #268bd2;">rel</span>=<span style="color: #2aa198;">"stylesheet"</span> <span style="color: #268bd2;">href</span>=<span style="color: #2aa198;">"../assert.css"</span>&gt;
        &lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">src</span>=<span style="color: #2aa198;">"../assert.js"</span>&gt;&lt;/<span style="color: #268bd2;">script</span>&gt;
    &lt;/<span style="color: #268bd2;">head</span>&gt;
    &lt;<span style="color: #268bd2;">body</span>&gt;
        &lt;<span style="color: #268bd2;">div</span> <span style="color: #268bd2;">id</span>=<span style="color: #2aa198;">"subTree"</span>&gt;
            &lt;<span style="color: #268bd2;">form</span>&gt;
                &lt;<span style="color: #268bd2;">input</span> <span style="color: #268bd2;">type</span>=<span style="color: #2aa198;">"text"</span>/&gt;
            &lt;/<span style="color: #268bd2;">form</span>&gt;
            &lt;<span style="color: #268bd2;">p</span>&gt;Paragraph&lt;/<span style="color: #268bd2;">p</span>&gt;
            &lt;<span style="color: #268bd2;">span</span>&gt;Span&lt;/<span style="color: #268bd2;">span</span>&gt;
        &lt;/<span style="color: #268bd2;">div</span>&gt;
        &lt;<span style="color: #268bd2;">script</span>&gt;
         "use strict";

         function traverseDOM(element, callback) {
             callback(element);
             element = element.firstElementChild;
             while (element) {
                 traverseDOM(element, callback);
                 element = element.nextElementSibling;
             }
         }

         const subTree = document.getElementById(<span style="color: #2aa198;">"subTree"</span>);
         traverseDOM(subTree, function(element) {
             assert(element !== null, element.nodeName);
         });
        &lt;/<span style="color: #268bd2;">script</span>&gt;
    &lt;/<span style="color: #268bd2;">body</span>&gt;
&lt;/<span style="color: #268bd2;">html</span>&gt;
</pre>
</div>
</li>
<li>怎么说呢,这个例子在我看来,挺顺眼的!反倒是使用generator看起来还真是费劲,如下
<div class="org-src-container">

<pre class="src src-js">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=<span style="color: #2aa198;">"utf-8"</span>&gt;
        &lt;title&gt;Generator DOM traversal&lt;/title&gt;
        &lt;link rel=<span style="color: #2aa198;">"stylesheet"</span> href=<span style="color: #2aa198;">"../assert.css"</span>&gt;
        &lt;script src=<span style="color: #2aa198;">"../assert.js"</span>&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=<span style="color: #2aa198;">"subTree"</span>&gt;
            &lt;form&gt;
                &lt;input type=<span style="color: #2aa198;">"text"</span>/&gt;
            &lt;/form&gt;
            &lt;p&gt;Paragraph&lt;/p&gt;
            &lt;span&gt;Span&lt;/span&gt;
        &lt;/div&gt;

        &lt;script&gt;
         <span style="color: #2aa198;">"use strict"</span>;

         <span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">DomTraversal</span><span style="color: #2aa198;">(</span>element<span style="color: #2aa198;">){</span>
             <span style="color: #859900; font-weight: bold;">yield</span> element;
             element = element.firstElementChild;
             <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #b58900;">(</span>element<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
                 <span style="color: #859900; font-weight: bold;">yield</span>* DomTraversal<span style="color: #268bd2;">(</span>element<span style="color: #268bd2;">)</span>;
                 element = element.nextElementSibling;
             <span style="color: #b58900;">}</span>
         <span style="color: #2aa198;">}</span>

         <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">subTree</span> = document.getElementById<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"subTree"</span><span style="color: #2aa198;">)</span>;
         <span style="color: #859900; font-weight: bold;">for</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">element</span> of DomTraversal<span style="color: #b58900;">(</span>subTree<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
             assert<span style="color: #b58900;">(</span>element !== <span style="color: #268bd2; font-weight: bold;">null</span>, element.nodeName<span style="color: #b58900;">)</span>;
         <span style="color: #2aa198;">}</span>
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2-3" class="outline-4">
<h4 id="sec-6-2-3">Communicating with a generator</h4>
<div class="outline-text-4" id="text-6-2-3">
<ul class="org-ul">
<li>前面的例子,generator是一个纯的"输出"的对象,如果加上输入,那就是双向的,就能
称得上'交流'了
</li>
<li>我们和generator交流的方式有两种:
<ul class="org-ul">
<li>第一种比较简单,就是从function传入参数了, generator也是函数,自然可以读取
输入参数
</li>
<li>第二种就比较麻烦了,是从next()函数里面传入参数,这个传入的参数"赋值给了上次
next的调用".看清楚了,是上次next的调用,所以第一次使用next()就传参数都没地
方收, 但是第一次next()调用你可以使用generator function的参赛直接传入进去!
</li>
</ul>
</li>
<li>两种调用方式在下面的例子中均有体现
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span>* <span style="color: #268bd2;">NinjaGenerator</span><span style="color: #2aa198;">(</span>action<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">imposter</span> = <span style="color: #859900; font-weight: bold;">yield</span> <span style="color: #b58900;">(</span><span style="color: #2aa198;">"Hattori "</span> + action<span style="color: #b58900;">)</span>;

    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span>imposter === <span style="color: #2aa198;">"Hanzo"</span><span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"The generator has been infiltrated"</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>

    <span style="color: #859900; font-weight: bold;">yield</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Yoshi ("</span> + imposter + <span style="color: #2aa198;">") "</span> + action<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjaIterator</span> = NinjaGenerator<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"skulk"</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninjaIterator.next<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjaIterator.next<span style="color: #b58900;">(</span><span style="color: #2aa198;">"Hanzo"</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ value: 'Hattori skulk', done: false }        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The generator has been infiltrated             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ value: 'Yoshi (Hanzo) skulk', done: false }  //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2-4" class="outline-4">
<h4 id="sec-6-2-4">Exploring generatos under the hood</h4>
<div class="outline-text-4" id="text-6-2-4">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">Working with promises</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>在js中,我们很依赖asynchronous计算,所谓asynchronous计算就是说,当前无法知道计
算的结果,但是later一定会知道结果.
</li>
<li>es6新进引入的promise就是来处理asynchronous task的object
</li>
<li>我们可以把promise看成是一种placeholder,用来存放我们当前还不知道结果的值,promise
保证我们最后会得到一个结果,因为最坏的结果也就是失败,或者是是一个我们为啥没
办法deliver的excuse
</li>
<li>一个最常见例子就是使用promise来从server获取data,我们保证能够从服务器获取数据,
当然server也可能出现问题,但是我们保证我们对调用者有个交代
</li>
<li>下面是一个promise的例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjaPromise</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Promise</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>resolve, reject<span style="color: #b58900;">)</span> =&gt; <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #268bd2;">(</span>Math.random<span style="color: #6c71c4;">()</span> &gt; 0.5<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
        resolve<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"Hattori"</span><span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">else</span> <span style="color: #268bd2;">{</span>
        reject<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"An error happened"</span><span style="color: #6c71c4;">)</span>;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

ninjaPromise.then<span style="color: #2aa198;">(</span>ninja =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span>ninja<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span>, err =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span>err<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">///////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================possible OUTPUT 1===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hattori                                                   //</span>
<span style="color: #93a1a1;">///////////////////////////////////////////////////////////////</span>


<span style="color: #93a1a1;">///////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================possible OUTPUT 2===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">An error happened                                         //</span>
<span style="color: #93a1a1;">///////////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>为了创建一个promise,我们使用了内置的Promise constructor, 这个ctor要求传入一
个function作为参数(我们这里使用的是arrow function)
</li>
<li>这个传入的function参数叫做executor function, 有两个参数(其实也是两个函数):
<ul class="org-ul">
<li>resolve
</li>
<li>reject
</li>
</ul>
</li>
<li>这个executor function会在Promise object创建的那一刻'马上调用',这个function
一般都会根据"情势"来决定到底是调用resolve函数还是reject函数,通常是正常的情
况调用resolve,异常的情况调用reject
</li>
<li>好了,promise在创建了以后就返回了,object ref存在变量ninjaPromise里面,对这个
object的使用是调用这个object的函数then(),这个函数也是有两个callback作为参数:
<ul class="org-ul">
<li>success callback: resolve()调用的时候使用
</li>
<li>failure callback: reject()调用的时候使用
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-6-3-1" class="outline-4">
<h4 id="sec-6-3-1">Understanding the problems with simple callbacks</h4>
<div class="outline-text-4" id="text-6-3-1">
<ul class="org-ul">
<li>我们的js代码通常对响应性要求很高,所以当long-running task执行的时候,我们不
想block当前的application运行.当前的做法是把这个long-running task排挤出当前
运行的stack,然后为这个long-running task准备一个callback function,当这个task
运行完的时候,我们运行callback就好了
</li>
<li>比如,从服务器获取json file是一个典型的long-running task,为了不让我们获取json
的时候app变得unresponsive,我们必须为这个task配备一个callback
<div class="org-src-container">

<pre class="src src-js">getJSON<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"data/ninjas.json"</span>, <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Handle results */</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>但是问题在于,这个long-running task有可能是会发生错误的,但是我们不能使用try
catch来处理这个问题,如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">try</span> <span style="color: #2aa198;">{</span>
    getJSON<span style="color: #b58900;">(</span><span style="color: #2aa198;">"data/ninjas.json"</span>, <span style="color: #859900; font-weight: bold;">function</span><span style="color: #268bd2;">()</span> <span style="color: #268bd2;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Handle results</span>
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span> <span style="color: #859900; font-weight: bold;">catch</span><span style="color: #2aa198;">(</span>e<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Handle errors</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>不能使用try-catch的原因在于,如下两段代码并不在同一个event loop里面:
<ul class="org-ul">
<li>invoking callback的代码
</li>
<li>start the long-running task的代码
</li>
</ul>
</li>
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-3-2" class="outline-4">
<h4 id="sec-6-3-2">Diving into promises</h4>
<div class="outline-text-4" id="text-6-3-2">
<ul class="org-ul">
<li>看一个结合了delayjob和普通job的promise的例子
<div class="org-src-container">

<pre class="src src-js">console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"At code start---------&gt;"</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninjaDelayedPromise</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Promise</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>resolve, reject<span style="color: #b58900;">)</span> =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"ninjaDelayedPromise executor"</span><span style="color: #268bd2;">)</span>;
    setTimeout<span style="color: #268bd2;">(</span><span style="color: #6c71c4;">()</span> =&gt; <span style="color: #6c71c4;">{</span>
        console.log<span style="color: #859900;">(</span><span style="color: #2aa198;">"Resolving ninjaDelayedPromise"</span><span style="color: #859900;">)</span>;
        resolve<span style="color: #859900;">(</span><span style="color: #2aa198;">"Hattori"</span><span style="color: #859900;">)</span>;
    <span style="color: #6c71c4;">}</span>, 500<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninjaDelayedPromise<span style="color: #2aa198;">)</span>;

ninjaDelayedPromise.then<span style="color: #2aa198;">(</span>ninja =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"ninjaDelayedPromise resolve handled with "</span> + ninja<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjaImmediatePromise</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Promise</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>resolve, reject<span style="color: #b58900;">)</span> =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"ninjaImmediatepromise executor"</span><span style="color: #268bd2;">)</span>;
    resolve<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Yoshi"</span><span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninjaImmediatePromise<span style="color: #2aa198;">)</span>;

ninjaImmediatePromise.then<span style="color: #2aa198;">(</span>ninja =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"ninjaImmediatepromise resolve handled with "</span> + ninja<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"At code end-----------&gt;"</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">//////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;   //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">At code start---------&gt;                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninjaDelayedPromise executor                     //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Promise { &lt;pending&gt; }                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninjaImmediatepromise executor                   //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Promise { 'Yoshi' }                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">At code end-----------&gt;                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninjaImmediatepromise resolve handled with Yoshi //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Resolving ninjaDelayedPromise                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">ninjaDelayedPromise resolve handled with Hattori //</span>
<span style="color: #93a1a1;">//////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>我们首先建立了ninjaDelayedPromise,这个ctor里面使用了setTimeout来在500毫秒
以后对我们的代码进行resolve."然后马上返回"
</li>
<li>注意,setTimer这种操作都是马上返回,放弃对cpu的控制的,然后在系统级别注册一个
中断,在500毫秒以后,中断会发送给浏览器,浏览器会把这个中断放入event queue,然
后最终终究会被执行
</li>
<li>当ninjaDelayedPromise被创建的时候,它是不知道自己的value的,所以这个时候,我们
打印出来就发现value为{ &lt;pending&gt; }
</li>
<li>然后我们来调用then函数,then函数里面也会注册"成功后"的callback,要注意,这个callback
无论如何都不会马上运行的,这是js engine的设计决定的,任何then函数都会在当前event
loop之后再运行
<pre class="example">
Promises are designed to deal with asynchronous actions, so the
JavaScript engine always resorts to asynchronous handling, to
make the promise behavior predictable.The engine does this by executing
the then callbacks after all the code in the current steop of
event loop is executed.
</pre>
</li>
<li>后面我们又创建了一个ninjaImmediatepromise, 这次我们的resolve是马上执行了,
所以我们的promise是立马有值的,也打印出来了.但是这并不能保证我们的then函数
马上实现, 它还是等到后面才实现,只不过比ninjaDelayedPromise的then函数早一点
罢了
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-3-3" class="outline-4">
<h4 id="sec-6-3-3">Rejecting promises</h4>
<div class="outline-text-4" id="text-6-3-3">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-3-4" class="outline-4">
<h4 id="sec-6-3-4">Creating our firs real-world promise</h4>
<div class="outline-text-4" id="text-6-3-4">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-3-5" class="outline-4">
<h4 id="sec-6-3-5">Chaining promises</h4>
<div class="outline-text-4" id="text-6-3-5">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-3-6" class="outline-4">
<h4 id="sec-6-3-6">Waiting for a number of promises</h4>
<div class="outline-text-4" id="text-6-3-6">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">Combining generators and promises</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>TODO
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Chapter 7: Object orientation with prototypes</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>你已经了解到了function是js里面的first-class,做到first-class还依靠了closure的
灵活性
</li>
<li>现在,你要了解js另外一个重要的特性了,就是object prototype
</li>
<li>首先,prototype是一个object,别的普通object可以把寻找某个specific property的任
务代理给prototype.
</li>
<li>我们其实可以把property看做是其他oo语言里面的class的作用
<pre class="example">
Prototypes serve a similar purpose to that of classes in classical
object-oriented languages
</pre>
</li>
</ul>
</div>
<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Understanding prototypes</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>在js里面,object就是一系列property和value的组合体,value可以是:
<ul class="org-ul">
<li>simple value
</li>
<li>function
</li>
<li>another object
</li>
</ul>
</li>
<li>例子如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">obj</span> = <span style="color: #2aa198;">{</span>
    prop1: 1,
    <span style="color: #268bd2;">prop2</span>: <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">(){}</span>,
    prop3: <span style="color: #b58900;">{}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>我们还可以几乎不受控制的对object进行"增删改查"
<div class="org-src-container">

<pre class="src src-js">obj.prop1 = 1;
obj.prop1 = <span style="color: #2aa198;">[]</span>;
<span style="color: #859900; font-weight: bold;">delete</span> obj.prop2;
obj.prop4 = <span style="color: #2aa198;">"Hello"</span>;
</pre>
</div>
</li>
<li>得到结果如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">{</span>
    prop1: <span style="color: #b58900;">[]</span>,
    prop3: <span style="color: #b58900;">{}</span>,
    prop4: <span style="color: #2aa198;">"Hello"</span>
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>继承,是oo编程的重要概念,能够极大的减少代码的重复.js正是通过prototype来实现
了继承.我们前面说过,prototype说白了也是一个object,那我们如何使用object来完
成inheritance呢?
</li>
<li>原理在于js重新定义了property search技术, 对于一个property的寻找:
<ul class="org-ul">
<li>首先在自己的object体内寻找,如果找到就用
</li>
<li>如果不在自己体内,就去'自己体内一个特殊的object'里面去寻找,这个'特殊的object'
就是prototype
</li>
</ul>
</li>
<li>通过下面的例子,那就可以发现,prototyp'只不过是一个普通object',只是被其他object
设置为'plan B'的property寻找地
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">yoshi</span> = <span style="color: #2aa198;">{</span>
    skulk: <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #2aa198;">}</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">hattori</span> = <span style="color: #2aa198;">{</span>
    sneak: <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #2aa198;">}</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">kuma</span> = <span style="color: #2aa198;">{</span>
    creep: <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #2aa198;">}</span>;

console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"skulk"</span> <span style="color: #859900; font-weight: bold;">in</span> yoshi<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"sneak"</span> <span style="color: #859900; font-weight: bold;">in</span> yoshi<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"creep"</span> <span style="color: #859900; font-weight: bold;">in</span> yoshi<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'------------------------'</span><span style="color: #2aa198;">)</span>;

Object.setPrototypeOf<span style="color: #2aa198;">(</span>yoshi, hattori<span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"skulk"</span> <span style="color: #859900; font-weight: bold;">in</span> yoshi<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"sneak"</span> <span style="color: #859900; font-weight: bold;">in</span> yoshi<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"creep"</span> <span style="color: #859900; font-weight: bold;">in</span> yoshi<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">'------------------------'</span><span style="color: #2aa198;">)</span>;

Object.setPrototypeOf<span style="color: #2aa198;">(</span>yoshi, kuma<span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"skulk"</span> <span style="color: #859900; font-weight: bold;">in</span> yoshi<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"sneak"</span> <span style="color: #859900; font-weight: bold;">in</span> yoshi<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"creep"</span> <span style="color: #859900; font-weight: bold;">in</span> yoshi<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">------------------------                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">------------------------                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>js里面, 某个object的prototype 也是一个property,而且这个property是普通人看不
到的,不能直接访问的,被记做\[\[prototype\]\]
</li>
<li>通过Object.setPrototypeOf的帮助,我们可以在自己'体内'找不到property的情况下,
去\[\[prototype\]\]指定的object里面去寻找,如下图
<pre class="example">
+---------------+           +---------------+
|     yoshi     |           |    hattori    |
|               |           |               |
|skulk: true    +----------&gt;|sneak: true    |
|[[prototype]]  |           |               |
+---------------+           +---------------+
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">Object construction and prototypes</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>js里面创建一个object是很简单的,对其操作也是可以直接的
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">warrior</span> = <span style="color: #2aa198;">{}</span>;

warrior.name = <span style="color: #2aa198;">'Saito'</span>;
warrior.occupation = <span style="color: #2aa198;">'marksman'</span>;
</pre>
</div>
</li>
<li>oo背景的人,会非常想念class的概念,在创建'某一类'特别相似的object的时候,使用
class会极大的减少复杂度.js也提供了继承的概念,但是不是使用class,而是使用ctor
然后用new来调用ctor,就模拟了oo语言里面new一个class
</li>
<li>使用new + ctor创建一个object,然后ctor里面'建设'这个object,是我们前面学到的,
但是我们前面没学到的是:
<pre class="example">
ctor的名字叫prototype的property,会被自动设置为新创建object的[[prototype]].
</pre>
</li>
<li>前面说过,每个object都有\[\[prototype\]\],但是它不能去直接操作,但是如果这个
object来自某个ctor,这个ctor是可以替它操作\[\[prototype\]\]的.
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">(){}</span>

Ninja.<span style="color: #268bd2; font-weight: bold;">prototype</span>.swingSword = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja1</span> = Ninja<span style="color: #2aa198;">()</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">none new</span>
console.log<span style="color: #2aa198;">(</span>ninja1<span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"swingSword"</span> <span style="color: #859900; font-weight: bold;">in</span> ninja2<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>上面的例子中,我们直接使用了Ninja.prototype, 这是因为prototype(不加[])是每个
function都有的property(因为每个function都是个"潜力股",都可以被new调用), 这个
property作为一个object,其实也是有自带的一个property的,就是constructor,指向
包含它的函数也就是Ninja.换句话说,Ninja和prototype是"双向链接"的
<pre class="example">
                   +--------------------+
                   | function Ninja(){} |
                   | prototype:---+     |&lt;-----------+
                   +--------------+-----+            |
                                  |                  |
                                  |                  |
                                  v                  |
+---------------+           +-------------------+    |
|     ninja2    |           |  Ninja prototype  |    |
|     ------    |           |  ---------------  |    |
|               |           |  constructor------+----+      +-------------+
| [[prototype]]-+----------&gt;|  swingSword ------+----------&gt;|function(){} |
+---------------+           +-------------------+           +-------------+
</pre>
</li>
<li>注意,只有object的prototype property是加[]的,内置的.函数的prototype就是普通
的property
</li>
</ul>
</div>
<div id="outline-container-sec-7-2-1" class="outline-4">
<h4 id="sec-7-2-1">Instance properties</h4>
<div class="outline-text-4" id="text-7-2-1">
<ul class="org-ul">
<li>我们知道,一个object寻找method的过程被分成了两部分:
<ul class="org-ul">
<li>从ctor的method里面寻找
</li>
<li>从自己的<i>prototype</i>里面去寻找
</li>
</ul>
</li>
<li>如果两个部分里面都有名字相同的函数(我们知道js是没有overload的)的话,我们选
哪个呢?看例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.swingSword = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"in the ctor"</span><span style="color: #268bd2;">)</span>;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

Ninja.<span style="color: #268bd2; font-weight: bold;">prototype</span>.swingSword = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span><span style="color: #2aa198;">"in the ctor's prototype"</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
ninja.swingSword<span style="color: #2aa198;">()</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">in the ctor                                    //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>结果证明,ctor里面的函数有更高的优先权.那是不是method要更主要的放在ctor里面
呢?
</li>
<li>结果恰恰相反:
<ul class="org-ul">
<li>如果是为了使用定义在ctor里面的method和variable来实现getter和setter private
variable的话,我们只能把method定义在ctor里面
</li>
<li>其他所有的其他情况下,我们都要尽量把method定义在cotr的prototype里面.原因
如下,如果我们有多个ninja instance的情况下,ctor的property都会维护一份自己
的拷贝, 对于value来说比较正常,对于method来说,就显得重复,因为函数是一种不
带有"副作用"的操作,定义一份就可以了
<pre class="example">
                    +---------------+           +-------------------+
                    |    ninja1     |           |function Ninja(){} |
+------------+      |    ------     |           |prototype:---+     |&lt;-----+
|function(){}|&lt;-----+-swingWord     |           +-------------+-----+      |
+------------+      | [[prototype]]-+-----+                   |            |
                    +---------------+     |                   |            |
                                          |     +-------------------+      |
                                          |     | Ninja prototype   |      |
                    +---------------+     |---&gt; | ---------------   |      |
                    |    ninja1     |     |     | constructor ------+------|
+------------+      |    ------     |     |     | swingSword  ------+-+
|function(){}|&lt;-----+--wingWord     |     |     +-------------------+ |
+------------+      | [[prototype]]-+-----+                           |
                    +---------------+     |                           |
                                          |                           |
                                          |                           |
                    +---------------+     |                           |
                    |    ninja1     |     |                           |
+------------+      |    ------     |     |                           |   +------------+
|function(){}|&lt;-----+--wingWord     |     |                           +-&gt; |function(){}|
+------------+      | [[prototype]]-+-----+                               +------------+
                    +---------------+
</pre>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-2-2" class="outline-4">
<h4 id="sec-7-2-2">Side effects of the synamic nature of JavaScript</h4>
<div class="outline-text-4" id="text-7-2-2">
<ul class="org-ul">
<li>作为动态语言,一个object的property可以随意的被"增删改查",prototype也是一个
property,所以也免不了相同的命运.
</li>
<li>而这种动态的特性会引入很多的问题,如果不熟悉的话,会感到很困惑,比如下面的例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.swung = <span style="color: #268bd2; font-weight: bold;">true</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;

Ninja.<span style="color: #268bd2; font-weight: bold;">prototype</span>.swingSword = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>.swung;
<span style="color: #2aa198;">}</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">the method is added after the object creation</span>
console.log<span style="color: #2aa198;">(</span>ninja1.swingSword<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #b58900;">Ninja</span>.<span style="color: #268bd2; font-weight: bold;">prototype</span> = <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2;">pierce</span>:<span style="color: #859900; font-weight: bold;">function</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">still see the method, as we keep the ref to old prototype</span>
console.log<span style="color: #2aa198;">(</span>ninja1.swingSword<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">newly created ninjas refer to new prototyp, forget about swing</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"pierce"</span> <span style="color: #859900; font-weight: bold;">in</span> ninja2<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"swingSword"</span> <span style="color: #859900; font-weight: bold;">in</span> ninja2<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-2-3" class="outline-4">
<h4 id="sec-7-2-3">Object typing via constructors</h4>
<div class="outline-text-4" id="text-7-2-3">
<ul class="org-ul">
<li>我们前面就说到过,我们可以通过一个叫做constructor的property(存储在object的
<i>prototype</i>里面)来找到我们的object是从哪个ctor创建来的
</li>
<li>这个constructor property能够让我们使用instanceof来判断自己的类型
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;

console.log<span style="color: #2aa198;">(</span>ninja.constructor<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja.constructor === Ninja<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja <span style="color: #859900; font-weight: bold;">instanceof</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[Function: Ninja]                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">Achieving inheritance</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>在es6之前,想要做到"继承"非常的麻烦,因为js模拟oo语言的机制涉及到两个变量:
<ul class="org-ul">
<li>propertype
</li>
<li>constructor
</li>
</ul>
</li>
<li>所以我们要"手动"设置这两个变量,代码看起来就非常的麻烦
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Person</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>
Person.<span style="color: #268bd2; font-weight: bold;">prototype</span>.dance = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>;

<span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>
Ninja.<span style="color: #268bd2; font-weight: bold;">prototype</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Person</span><span style="color: #2aa198;">()</span>;

Object.defineProperty<span style="color: #2aa198;">(</span>Ninja.<span style="color: #268bd2; font-weight: bold;">prototype</span>, <span style="color: #2aa198;">"constructor"</span>, <span style="color: #b58900;">{</span>
    enumerable: <span style="color: #268bd2; font-weight: bold;">false</span>,
    value: Ninja,
    writable: <span style="color: #268bd2; font-weight: bold;">true</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;

console.log<span style="color: #2aa198;">(</span>ninja.constructor === Ninja<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"dance"</span> <span style="color: #859900; font-weight: bold;">in</span> Ninja.<span style="color: #268bd2; font-weight: bold;">prototype</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4">Using JavaScript "classes" in ES6</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li>如此麻烦的代码,让人无法忍受,所以es6引入了class这个概念,因为javascript为了赶
时髦,故意模仿java,所以把所有java的关键字都作为了自己的关键字.这样一来,引入
新的关键字毫无压力
</li>
<li>但是class并没有新的架构,只不过是语法糖罢了:
<ul class="org-ul">
<li>一个简单的class例子:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">class</span> Ninja<span style="color: #2aa198;">{</span>
    constructor<span style="color: #b58900;">(</span>name<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #268bd2; font-weight: bold;">this</span>.name = name;
    <span style="color: #b58900;">}</span>
    swingSword<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>其实就相当于如下:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">name</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.name = name;
<span style="color: #2aa198;">}</span>

Ninja.<span style="color: #268bd2; font-weight: bold;">prototype</span>.swingSword = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
</ul>
</li>
<li>其实总结起来很简单:
<ul class="org-ul">
<li>原来在ctor里面写的,现在写在constructor里面
</li>
<li>原来在prototype里面写的,现在写在{}里面
</li>
</ul>
</li>
<li>现在还可以写static函数:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">class</span> Ninja <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">static</span> compare<span style="color: #b58900;">(</span>ninja1, ninja2<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">...</span>
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>其实就是原来ctor的函数的"函数property"
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{}</span>
Ninja.compare = <span style="color: #859900; font-weight: bold;">function</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">ninja1</span>, <span style="color: #268bd2;">ninja2</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>...<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>class的引入更重要的是让"继承"更加简单了
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">class</span> Person <span style="color: #2aa198;">{</span>
    constructor<span style="color: #b58900;">(</span>name<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #268bd2; font-weight: bold;">this</span>.name = name;
    <span style="color: #b58900;">}</span>

    dance<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">class</span> Ninja <span style="color: #859900; font-weight: bold;">extends</span> Person <span style="color: #2aa198;">{</span>
    constructor<span style="color: #b58900;">(</span>name, weapon<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">super</span><span style="color: #268bd2;">(</span>name<span style="color: #268bd2;">)</span>;
        <span style="color: #268bd2; font-weight: bold;">this</span>.weapon = weapon;
    <span style="color: #b58900;">}</span>

    wieldWeapon<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">person</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Person</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Bob"</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>person <span style="color: #859900; font-weight: bold;">instanceof</span> <span style="color: #b58900;">Person</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>person.dance<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>person.name<span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"---------------------------"</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Yoshi"</span>, <span style="color: #2aa198;">"Wakizashi"</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja <span style="color: #859900; font-weight: bold;">instanceof</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja.wieldWeapon<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja <span style="color: #859900; font-weight: bold;">instanceof</span> <span style="color: #b58900;">Person</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja.dance<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja.name<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Bob                                            //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">---------------------------                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Yoshi                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Chapter 8: Controlling acces to objects</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>通过前面的章节,我们了解到,在js里面,object非常的灵活,可以增加更改,甚至删除object
的property,本章我们学习管理我们object的办法(控制访问,监督改变,等等)
</li>
</ul>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Controlling access to properties with getters and setters</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>先看下面的代码
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">level</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    <span style="color: #268bd2; font-weight: bold;">this</span>.skillLevel = level;
<span style="color: #2aa198;">}</span>
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">(</span>100<span style="color: #2aa198;">)</span>;
</pre>
</div>
</li>
<li>这里,我们定义了ctor,在初始化object ninja的时候,我们赋予了这个object一个100,
作为初始化值来初始化object的内部state: skillLevel.如果我们想更改object的内
部state,我们可以使用最简单的代码,如下
<div class="org-src-container">

<pre class="src src-js">ninja.skillLevel = 20;
</pre>
</div>
</li>
<li>上面的做法过于的随意,所以我们希望能够做到如下的'限制':
<ul class="org-ul">
<li>我们希望能够正确的设置property,比如我们不希望把level设置成字符串,比如
<div class="org-src-container">

<pre class="src src-js">ninja.skillLevel = <span style="color: #2aa198;">"high"</span>
</pre>
</div>
</li>
<li>我们希望log所有对于skillLevel的改动
</li>
<li>我们要能可以获得skillLevel的值
</li>
</ul>
</li>
<li>满足上面三个'限制'要求的,其实就是传统意义上的getter和setter,我们来看看如何
实现一个最naive的版本
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">skillLevel</span>;

    <span style="color: #268bd2; font-weight: bold;">this</span>.getSkillLevel = <span style="color: #b58900;">()</span> =&gt; skillLevel;

    <span style="color: #268bd2; font-weight: bold;">this</span>.setSkillLevel = value =&gt; <span style="color: #b58900;">{</span>
        skillLevel = value;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
ninja.setSkillLevel<span style="color: #2aa198;">(</span>100<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja.getSkillLevel<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100                                            //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>把skillLevel设置成"private"从而只能使用getter和setter访问,这是我们前面学到
过的知识了,而如果我们想log所有的访问,也很简单:在setter和getter里面log就可以
了,因为所有的访问只能通过做两个函数
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">skillLevel</span>;
    <span style="color: #268bd2; font-weight: bold;">this</span>.getSkillLevel = <span style="color: #b58900;">()</span> =&gt; <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Getting skill level value"</span><span style="color: #268bd2;">)</span>;
        <span style="color: #859900; font-weight: bold;">return</span> skillLevel;
    <span style="color: #b58900;">}</span>;

    <span style="color: #268bd2; font-weight: bold;">this</span>.setSkillLevel = value =&gt; <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Modifying skillLevel property from: "</span>,
            skillLevel, <span style="color: #2aa198;">"to: "</span>, value<span style="color: #268bd2;">)</span>;
        skillLevel = value;
    <span style="color: #b58900;">}</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;
ninja.setSkillLevel<span style="color: #2aa198;">(</span>100<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja.getSkillLevel<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">/////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Modifying skillLevel property from:  undefined to:  100 //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Getting skill level value                               //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">100                                                     //</span>
<span style="color: #93a1a1;">/////////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>这看起来很完美了,但是用户希望更简洁的方式使用setter和getter,就是使用一个
ninja.skillLevel来进行set和get.但是同时还希望保留比如log这种功能.这个时候js
就设计出了"实际上是函数(所以可以在里面写log)",但"用起来当property一样"的"理
想型"的setter getter
</li>
</ul>
</div>
<div id="outline-container-sec-8-1-1" class="outline-4">
<h4 id="sec-8-1-1">Defining getters and setters</h4>
<div class="outline-text-4" id="text-8-1-1">
<ul class="org-ul">
<li>在js里面,上面我们提到的"理想型的"setter和getter可以使用如下两种方式定义:
<ul class="org-ul">
<li>在object里面,使用object literal(或者ES6的class语法)
</li>
<li>使用内置的一个叫做Object.defineProperty的方法
</li>
</ul>
</li>
<li>首先看看object literal的方式
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjaCollection</span> = <span style="color: #2aa198;">{</span>
    ninjas: <span style="color: #b58900;">[</span><span style="color: #2aa198;">"Yoshi"</span>, <span style="color: #2aa198;">"Kuma"</span>, <span style="color: #2aa198;">"Hattori"</span><span style="color: #b58900;">]</span>,
    get firstNinja<span style="color: #b58900;">(){</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Getting firstNinja"</span><span style="color: #268bd2;">)</span>;
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>.ninjas<span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">}</span>,
    set firstNinja<span style="color: #b58900;">(</span>value<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Setting firstNinja"</span><span style="color: #268bd2;">)</span>;
        <span style="color: #268bd2; font-weight: bold;">this</span>.ninjas<span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span> = value;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

console.log<span style="color: #2aa198;">(</span>ninjaCollection.firstNinja<span style="color: #2aa198;">)</span>;

ninjaCollection.firstNinja = <span style="color: #2aa198;">"Hachi"</span>;

console.log<span style="color: #2aa198;">(</span>ninjaCollection.firstNinja<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjaCollection.ninjas<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Getting firstNinja                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Yoshi                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Setting firstNinja                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Getting firstNinja                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hachi                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hachi                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>好,我们再看看使用ES6的class语法,效果如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">class</span> NinjaCollection <span style="color: #2aa198;">{</span>
    constructor<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #268bd2; font-weight: bold;">this</span>.ninjas = <span style="color: #268bd2;">[</span><span style="color: #2aa198;">"Yoshi"</span>, <span style="color: #2aa198;">"Kuma"</span>, <span style="color: #2aa198;">"Hattori"</span><span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">}</span>
    get firstNinja<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Getting firstNinja"</span><span style="color: #268bd2;">)</span>;
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>.ninjas<span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">}</span>
    set firstNinja<span style="color: #b58900;">(</span>value<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        console.log<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Setting firstNinja"</span><span style="color: #268bd2;">)</span>;
        <span style="color: #268bd2; font-weight: bold;">this</span>.ninjas<span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span> = value;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjaCollection</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">NinjaCollection</span><span style="color: #2aa198;">()</span>;

console.log<span style="color: #2aa198;">(</span>ninjaCollection.firstNinja<span style="color: #2aa198;">)</span>;

ninjaCollection.firstNinja = <span style="color: #2aa198;">"Hachi"</span>;

console.log<span style="color: #2aa198;">(</span>ninjaCollection.firstNinja<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjaCollection.ninjas<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Getting firstNinja                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Yoshi                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Setting firstNinja                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Getting firstNinja                             //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hachi                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hachi                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>object literal和es6 class中定义setter和getter的语法其实是一致的.我们同时还
知道,在class里面定义函数,其实就相当于在proptype里面定义函数,定义的函数是'无
法访问function的private variable'的,所以我们前面的使用closure来模拟private
variable的方法在这里行不通!需要其他的手段
</li>
<li>其他的手段就是Object.defineProperty方法啦
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">_skillLevel</span> = 0;

    Object.defineProperty<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>, <span style="color: #2aa198;">'skillLevel'</span>, <span style="color: #268bd2;">{</span>
        get: <span style="color: #6c71c4;">()</span> =&gt; <span style="color: #6c71c4;">{</span>
            console.log<span style="color: #859900;">(</span><span style="color: #2aa198;">"The get method is called"</span><span style="color: #859900;">)</span>;
            <span style="color: #859900; font-weight: bold;">return</span> _skillLevel;
        <span style="color: #6c71c4;">}</span>,
        set: value =&gt; <span style="color: #6c71c4;">{</span>
            console.log<span style="color: #859900;">(</span><span style="color: #2aa198;">"The set method is called"</span><span style="color: #859900;">)</span>;
            _skillLevel = value;
        <span style="color: #6c71c4;">}</span>
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;

console.log<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">typeof</span> ninja._skillLevel<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninja.skillLevel<span style="color: #2aa198;">)</span>;
ninja.skillLevel = 10;
console.log<span style="color: #2aa198;">(</span>ninja.skillLevel<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The get method is called                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The set method is called                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">The get method is called                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10                                             //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>使用defineProperty的方法定义函数和'object literal以及class'的不同,就在于他
们和'private variable'定义在同一个scope(function scope),所以可以看到并访问
'private variable'
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-1-2" class="outline-4">
<h4 id="sec-8-1-2">Using getters and setters to validate property values</h4>
<div class="outline-text-4" id="text-8-1-2">
<ul class="org-ul">
<li>我们知道,getter和setter设置了以后,会成为我们访问'内部state'是唯一的方式,那
么,我们就可以在这一条"必经之路"上做些文章,比如validate传入的数据
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">Ninja</span><span style="color: #2aa198;">()</span> <span style="color: #2aa198;">{</span>
    <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">_skillLevel</span> = 0;

    Object.defineProperty<span style="color: #b58900;">(</span><span style="color: #268bd2; font-weight: bold;">this</span>, <span style="color: #2aa198;">'skillLevel'</span>, <span style="color: #268bd2;">{</span>
        get: <span style="color: #6c71c4;">()</span> =&gt; _skillLevel,
        set: value =&gt; <span style="color: #6c71c4;">{</span>
            <span style="color: #859900; font-weight: bold;">if</span><span style="color: #859900;">(</span>!Number.isInteger<span style="color: #b58900;">(</span>value<span style="color: #b58900;">)</span><span style="color: #859900;">)</span> <span style="color: #859900;">{</span>
                <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">TypeError</span><span style="color: #b58900;">(</span><span style="color: #2aa198;">"Skill level should be a number"</span><span style="color: #b58900;">)</span>;
            <span style="color: #859900;">}</span>
            _skillLevel = value;
        <span style="color: #6c71c4;">}</span>
    <span style="color: #268bd2;">}</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Ninja</span><span style="color: #2aa198;">()</span>;

ninja.skillLevel = 10;
console.log<span style="color: #2aa198;">(</span>ninja.skillLevel<span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">try</span> <span style="color: #2aa198;">{</span>
    ninja.skillLevel = <span style="color: #2aa198;">"Great"</span>;
    console.log<span style="color: #b58900;">(</span><span style="color: #2aa198;">"Failed!, should not be here"</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span> <span style="color: #859900; font-weight: bold;">catch</span><span style="color: #2aa198;">(</span>e<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span><span style="color: #2aa198;">"Passed! setting a non-integer value throws an exception"</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">/////////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">10                                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Passed! setting a non-integer value throws an exception //</span>
<span style="color: #93a1a1;">/////////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>getter和setter还有一种用法,就是计算computed property:不是简单的设置和返回
内部的state,而是把内部的state进行'计算'后返回或设置
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">shogun</span> = <span style="color: #2aa198;">{</span>
    name: <span style="color: #2aa198;">"Yoshiaki"</span>,
    clan: <span style="color: #2aa198;">"Ashikaga"</span>,

    get fullTitle<span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">this</span>.name + <span style="color: #2aa198;">" "</span> + <span style="color: #268bd2; font-weight: bold;">this</span>.clan;
    <span style="color: #b58900;">}</span>,

    set fullTitle<span style="color: #b58900;">(</span>value<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
        <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">segments</span> = value.split<span style="color: #268bd2;">(</span><span style="color: #2aa198;">" "</span><span style="color: #268bd2;">)</span>;
        <span style="color: #268bd2; font-weight: bold;">this</span>.name = segments<span style="color: #268bd2;">[</span>0<span style="color: #268bd2;">]</span>;
        <span style="color: #268bd2; font-weight: bold;">this</span>.clan = segments<span style="color: #268bd2;">[</span>1<span style="color: #268bd2;">]</span>;
    <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>;

console.log<span style="color: #2aa198;">(</span>shogun.name<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>shogun.clan<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>shogun.fullTitle<span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"----------------"</span><span style="color: #2aa198;">)</span>;
shogun.fullTitle = <span style="color: #2aa198;">"Leyasu Tokugawa"</span>;

console.log<span style="color: #2aa198;">(</span>shogun.name<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>shogun.clan<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>shogun.fullTitle<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Yoshiaki                                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Ashikaga                                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Yoshiaki Ashikaga                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">----------------                               //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Leyasu                                         //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Tokugawa                                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Leyasu Tokugawa                                //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">Using proxies to control access</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>我们的getter和setter都是去保护对一个object的'读取和吸入',从更广义上来讲'proxy'
这个概念是能保护'所有的访问,包括读取和写入', 公司内网都是通过proxy和外部接
触的,从而保护内网的机器
</li>
<li>es6在js里面也引入了proxy这个概念,用来"保护所有对object的访问", 包括:
<ul class="org-ul">
<li>读取
</li>
<li>写入
</li>
<li>method call
</li>
</ul>
</li>
<li>我们先来看看一个proxy的例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">emperor</span> = <span style="color: #2aa198;">{</span>
    name: <span style="color: #2aa198;">"Komei"</span>
<span style="color: #2aa198;">}</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">representative</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Proxy</span><span style="color: #2aa198;">(</span>emperor, <span style="color: #b58900;">{</span>
    get: <span style="color: #268bd2;">(</span>target, key<span style="color: #268bd2;">)</span> =&gt; <span style="color: #268bd2;">{</span>
        console.log<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"Reading "</span> + key + <span style="color: #2aa198;">" through a proxy"</span><span style="color: #6c71c4;">)</span>;
        <span style="color: #859900; font-weight: bold;">return</span> key <span style="color: #859900; font-weight: bold;">in</span> target ? target<span style="color: #6c71c4;">[</span>key<span style="color: #6c71c4;">]</span> :
            <span style="color: #2aa198;">"Don't bother the emperor!"</span>;
    <span style="color: #268bd2;">}</span>,
    set: <span style="color: #268bd2;">(</span>target, key, value<span style="color: #268bd2;">)</span> =&gt; <span style="color: #268bd2;">{</span>
        console.log<span style="color: #6c71c4;">(</span><span style="color: #2aa198;">"Writing "</span> + key + <span style="color: #2aa198;">" through a proxy"</span><span style="color: #6c71c4;">)</span>;
        target<span style="color: #6c71c4;">[</span>key<span style="color: #6c71c4;">]</span> = value;
    <span style="color: #268bd2;">}</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>emperor.name<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"--------------------------------"</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>representative.name<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"--------------------------------"</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>emperor.nickname<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"--------------------------------"</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>representative.nickname<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"--------------------------------"</span><span style="color: #2aa198;">)</span>;
representative.nickname = <span style="color: #2aa198;">"Tenno"</span>;
console.log<span style="color: #2aa198;">(</span>emperor.nickname<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"--------------------------------"</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>representative.nickname<span style="color: #2aa198;">)</span>;


<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Komei                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">--------------------------------               //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Reading name through a proxy                   //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Komei                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">--------------------------------               //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">--------------------------------               //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Reading nickname through a proxy               //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Don't bother the emperor!                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">--------------------------------               //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Writing nickname through a proxy               //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Tenno                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">--------------------------------               //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Reading nickname through a proxy               //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Tenno                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-8-2-1" class="outline-4">
<h4 id="sec-8-2-1">Using proxie for logging</h4>
<div class="outline-text-4" id="text-8-2-1">
<ul class="org-ul">
<li>todo
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-2-2" class="outline-4">
<h4 id="sec-8-2-2">Using proxies for measuring performance</h4>
<div class="outline-text-4" id="text-8-2-2">
<ul class="org-ul">
<li>todo
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-2-3" class="outline-4">
<h4 id="sec-8-2-3">Using proxies to autopopulate properties</h4>
<div class="outline-text-4" id="text-8-2-3">
<ul class="org-ul">
<li>todo
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-2-4" class="outline-4">
<h4 id="sec-8-2-4">Using proxies to implement negative array Indexes</h4>
<div class="outline-text-4" id="text-8-2-4">
<ul class="org-ul">
<li>todo
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Chapter 9: Dealing with collections</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">Arrays</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>数组是最常见的数据结构了,基本所有的语言里面都有数组
</li>
<li>在javascript里面,数组其实就是一个object:
<ul class="org-ul">
<li>这一方面会降低数组的性能
</li>
<li>这另一方面能让数组有些function可供调用
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-9-1-1" class="outline-4">
<h4 id="sec-9-1-1">Creating arrays</h4>
<div class="outline-text-4" id="text-9-1-1">
<ul class="org-ul">
<li>主要有两种方法来创建array:
<ul class="org-ul">
<li>使用内置的Array constructor
</li>
<li>使用literals []
</li>
</ul>
</li>
<li>例子如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjas</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">"Kuma"</span>, <span style="color: #2aa198;">"Hattori"</span>, <span style="color: #2aa198;">"Yagyu"</span><span style="color: #2aa198;">]</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">samurai</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Array</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Oda"</span>, <span style="color: #2aa198;">"Tomoe"</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninjas.length<span style="color: #2aa198;">)</span>;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3</span>
console.log<span style="color: #2aa198;">(</span>samurai.length<span style="color: #2aa198;">)</span>;    <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2</span>

console.log<span style="color: #2aa198;">(</span>ninjas<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Kuma</span>
console.log<span style="color: #2aa198;">(</span>samurai<span style="color: #b58900;">[</span>samurai.length-1<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Tomoe</span>

console.log<span style="color: #2aa198;">(</span>ninjas<span style="color: #b58900;">[</span>4<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined</span>
ninjas<span style="color: #2aa198;">[</span>4<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">"Ishi"</span>;
console.log<span style="color: #2aa198;">(</span>ninjas.length<span style="color: #2aa198;">)</span>;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5</span>

ninjas.length = 2;
console.log<span style="color: #2aa198;">(</span>ninjas.length<span style="color: #2aa198;">)</span>;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2</span>
console.log<span style="color: #2aa198;">(</span>ninjas<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Kuma</span>
console.log<span style="color: #2aa198;">(</span>ninjas<span style="color: #b58900;">[</span>2<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined</span>

ninjas.length = 5;
console.log<span style="color: #2aa198;">(</span>ninjas.length<span style="color: #2aa198;">)</span>;     <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5</span>
console.log<span style="color: #2aa198;">(</span>ninjas<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Kuma</span>
console.log<span style="color: #2aa198;">(</span>ninjas<span style="color: #b58900;">[</span>2<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;         <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined</span>
</pre>
</div>
</li>
<li>这个例子最令我们震撼的是,我们竟然可以通过设置数组的长度来去掉后面某些item,
注意,这里不是像c语言一样会把内存放在那里不去清理,一旦设置了length,后面的内
存就被收走了"Yagyu"再也找不到了
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-1-2" class="outline-4">
<h4 id="sec-9-1-2">Adding and removing Items at either end of an array</h4>
<div class="outline-text-4" id="text-9-1-2">
<ul class="org-ul">
<li>添加删除数组的成员从两头都可以:
<ul class="org-ul">
<li>push() adds an item to the end of array
</li>
<li>pop() removes an item from the end of array
</li>
<li>unshift() add an item to the beginning of the array
</li>
<li>shift() removes an item from the beginning of the array.
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-1-3" class="outline-4">
<h4 id="sec-9-1-3">Adding and removing items at any array location</h4>
<div class="outline-text-4" id="text-9-1-3">
<ul class="org-ul">
<li>js里面的delete函数很特别,它其实不是其他语言里面删除一个数组成员,而是把某个
成员设置成undefined
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjas</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">"Yagyu"</span>, <span style="color: #2aa198;">"Kuma"</span>, <span style="color: #2aa198;">"Hattori"</span>, <span style="color: #2aa198;">"Fuma"</span><span style="color: #2aa198;">]</span>;

<span style="color: #859900; font-weight: bold;">delete</span> ninjas<span style="color: #2aa198;">[</span>1<span style="color: #2aa198;">]</span>;

console.log<span style="color: #2aa198;">(</span>ninjas.length<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjas<span style="color: #b58900;">[</span>0<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjas<span style="color: #b58900;">[</span>1<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjas<span style="color: #b58900;">[</span>2<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjas<span style="color: #b58900;">[</span>3<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Yagyu                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">undefined                                      //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hattori                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Fuma                                           //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>上面的例子用图画表示就是
<pre class="example">
const ninjas = ["Yagyu", "Kuma", "Hattori", "Fuma"];
+-----------+-----------+-----------+-----------+
|   Yagyu   |    Kuma   |  Hattori  |    Fuma   |
+-----------+-----------+-----------+-----------+

delete ninjas[1];
+-----------+-----------+-----------+-----------+
|   Yagyu   | undefined |  Hattori  |    Fuma   |
+-----------+-----------+-----------+-----------+
</pre>
</li>
<li>js里面真正起到删除作用的是splice, 它的返回值就是'真正删除掉的sub数组'
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjas</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">"Yagyu"</span>, <span style="color: #2aa198;">"Kuma"</span>, <span style="color: #2aa198;">"Hattori"</span>, <span style="color: #2aa198;">"Fuma"</span><span style="color: #2aa198;">]</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">removedItems</span> = ninjas.splice<span style="color: #2aa198;">(</span>1, 1<span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>removedItems<span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninjas.length<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjas<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 'Kuma' ]                                     //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 'Yagyu', 'Hattori', 'Fuma' ]                 //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>splice还可以"在删除的同时,在删除的位置再添加数据",返回值还是删除了的子数组
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjas</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">"Yagyu"</span>, <span style="color: #2aa198;">"Kuma"</span>, <span style="color: #2aa198;">"Hattori"</span>, <span style="color: #2aa198;">"Fuma"</span><span style="color: #2aa198;">]</span>;

<span style="color: #859900; font-weight: bold;">var</span> <span style="color: #268bd2;">removedItems</span> = ninjas.splice<span style="color: #2aa198;">(</span>1, 2, <span style="color: #2aa198;">"Mochizuki"</span>, <span style="color: #2aa198;">"Yoshi"</span>, <span style="color: #2aa198;">"Momochi"</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>removedItems<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjas<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">//////////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt;       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 'Kuma', 'Hattori' ]                                //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 'Yagyu', 'Mochizuki', 'Yoshi', 'Momochi', 'Fuma' ] //</span>
<span style="color: #93a1a1;">//////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-1-4" class="outline-4">
<h4 id="sec-9-1-4">Common operations on arrays</h4>
<div class="outline-text-4" id="text-9-1-4">
</div><div id="outline-container-sec-9-1-4-1" class="outline-5">
<h5 id="sec-9-1-4-1">ITERATING OVER ARRAYS</h5>
<div class="outline-text-5" id="text-9-1-4-1">
<ul class="org-ul">
<li>对数组来说,遍历是最常见的操作,最开始的时候js是使用和c差不多的循环进行遍历
的:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjas</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">"Kuma"</span>, <span style="color: #2aa198;">"Hattori"</span>, <span style="color: #2aa198;">"Yagyu"</span><span style="color: #2aa198;">]</span>;

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">i</span> = 0; i &lt; ninjas.length; i++<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
    console.log<span style="color: #b58900;">(</span>ninjas<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Kuma                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hattori                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Yagyu                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>后来js引入了更加functional的forEach,参数是一个"马上被调用"的callback
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjas</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">"Kuma"</span>, <span style="color: #2aa198;">"Hattori"</span>, <span style="color: #2aa198;">"Yagyu"</span><span style="color: #2aa198;">]</span>;

ninjas.forEach<span style="color: #2aa198;">(</span>ninja =&gt; <span style="color: #b58900;">{</span>
    console.log<span style="color: #268bd2;">(</span>ninja<span style="color: #268bd2;">)</span>;
<span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Kuma                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hattori                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Yagyu                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-1-4-2" class="outline-5">
<h5 id="sec-9-1-4-2">MAPPING ARRAYS</h5>
<div class="outline-text-5" id="text-9-1-4-2">
<ul class="org-ul">
<li>map reduce也是functional语言里面的重要概念,js也引入了.引入方法和forEach一
样:得益于array就是一个object,直接在Array.propotype里面添加这个函数,那么所
有的array就都可以调用这个函数了
</li>
<li>来看看map的调用例子
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjas</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">{</span>
    name: <span style="color: #2aa198;">"Yagyu"</span>,
    weapon: <span style="color: #2aa198;">"shuriken"</span>
<span style="color: #b58900;">}</span>, <span style="color: #b58900;">{</span>
    name: <span style="color: #2aa198;">"Yoshi"</span>,
    weapon: <span style="color: #2aa198;">"katana"</span>
<span style="color: #b58900;">}</span>, <span style="color: #b58900;">{</span>
    name: <span style="color: #2aa198;">"Kuma"</span>,
    weapon: <span style="color: #2aa198;">"wakizashi"</span>
<span style="color: #b58900;">}</span><span style="color: #2aa198;">]</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">weapons</span> = ninjas.map<span style="color: #2aa198;">(</span>ninja =&gt; ninja.weapon<span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>weapons<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 'shuriken', 'katana', 'wakizashi' ]          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-1-4-3" class="outline-5">
<h5 id="sec-9-1-4-3">AGGREGATING ARRAY ITEMS</h5>
<div class="outline-text-5" id="text-9-1-4-3">
<ul class="org-ul">
<li>有了map, reduce还远么
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">[</span>1, 3, 5, 7, 2, 4, 6<span style="color: #2aa198;">]</span>.reduce<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>sum, cur<span style="color: #b58900;">)</span> =&gt; sum + cur<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">28</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-1-4-4" class="outline-5">
<h5 id="sec-9-1-4-4">TESTING ARRAY ITEMS</h5>
<div class="outline-text-5" id="text-9-1-4-4">
<ul class="org-ul">
<li>ruby里面有个叫做all?的函数,就是通过一个block来判断数组的每个成员是不是都
是满足block里面的要求
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #2aa198;">[</span>1, 2, 3, 4, 5<span style="color: #2aa198;">]</span>.all? <span style="color: #2aa198;">{</span> |one| one &gt;= 1 <span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">#</span><span style="color: #93a1a1;">=&gt; true</span>
<span style="color: #2aa198;">[</span>1, 2, 3, 4, 5<span style="color: #2aa198;">]</span>.all? <span style="color: #2aa198;">{</span> |one| one &gt; 1 <span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">#</span><span style="color: #93a1a1;">=&gt; false</span>
</pre>
</div>
</li>
<li>js里面借鉴这个all?的功能,设计了一个Array.propotype.every()
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">[</span>1, 2, 3, 4, 5<span style="color: #2aa198;">]</span>.every<span style="color: #2aa198;">(</span>one =&gt; one &gt;= 1<span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
<span style="color: #2aa198;">[</span>1, 2, 3, 4, 5<span style="color: #2aa198;">]</span>.every<span style="color: #2aa198;">(</span>one =&gt; one &gt; 1<span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false</span>
</pre>
</div>
</li>
<li>同样的ruby里面还有一个判断某个成员满足要求的any?
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #2aa198;">[</span>1, 2, 3, 4, 5<span style="color: #2aa198;">]</span>.any? <span style="color: #2aa198;">{</span> |one| one &gt;= 5 <span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">#</span><span style="color: #93a1a1;">=&gt; true</span>
<span style="color: #2aa198;">[</span>1, 2, 3, 4, 5<span style="color: #2aa198;">]</span>.any? <span style="color: #2aa198;">{</span> |one| one &gt; 5 <span style="color: #2aa198;">}</span> <span style="color: #93a1a1;">#</span><span style="color: #93a1a1;">=&gt; false</span>
</pre>
</div>
</li>
<li>js的对应者是some()
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">[</span>1, 2, 3, 4, 5<span style="color: #2aa198;">]</span>.some<span style="color: #2aa198;">(</span>one =&gt; one &gt;= 5<span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true</span>
<span style="color: #2aa198;">[</span>1, 2, 3, 4, 5<span style="color: #2aa198;">]</span>.some<span style="color: #2aa198;">(</span>one =&gt; one &gt; 5<span style="color: #2aa198;">)</span>; <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-1-4-5" class="outline-5">
<h5 id="sec-9-1-4-5">SEARCHING ARRAYS</h5>
<div class="outline-text-5" id="text-9-1-4-5">
<ul class="org-ul">
<li>ruby里面就有find(也叫detect)命令
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #2aa198;">(</span>1..10<span style="color: #2aa198;">)</span>.detect   <span style="color: #2aa198;">{</span> |i| i % 5 == 0 <span style="color: #859900; font-weight: bold;">and</span> i % 7 == 0 <span style="color: #2aa198;">}</span>   <span style="color: #93a1a1;">#</span><span style="color: #93a1a1;">=&gt; nil</span>
<span style="color: #2aa198;">(</span>1..100<span style="color: #2aa198;">)</span>.find    <span style="color: #2aa198;">{</span> |i| i % 5 == 0 <span style="color: #859900; font-weight: bold;">and</span> i % 7 == 0 <span style="color: #2aa198;">}</span>   <span style="color: #93a1a1;">#</span><span style="color: #93a1a1;">=&gt; 35</span>
</pre>
</div>
</li>
<li>js的对应还是find
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjas</span> = <span style="color: #2aa198;">[</span>
    <span style="color: #b58900;">{</span>name: <span style="color: #2aa198;">"Yagyu"</span>, weapon: <span style="color: #2aa198;">"shuriken"</span><span style="color: #b58900;">}</span>,
    <span style="color: #b58900;">{</span>name: <span style="color: #2aa198;">"Yoshi"</span><span style="color: #b58900;">}</span>,
    <span style="color: #b58900;">{</span>name: <span style="color: #2aa198;">"Kuma"</span>, weapon: <span style="color: #2aa198;">"wakizashi"</span><span style="color: #b58900;">}</span>
<span style="color: #2aa198;">]</span>;

console.log<span style="color: #2aa198;">(</span>ninjas.find<span style="color: #b58900;">(</span>ninja =&gt; ninja.weapon === <span style="color: #2aa198;">"wakizashi"</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ name: 'Kuma', weapon: 'wakizashi' }          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>find命令(无论ruby还是js)都是只返回一个结果,如果想返回多个结果:
<ul class="org-ul">
<li>ruby里面是select
<div class="org-src-container">

<pre class="src src-ruby"><span style="color: #2aa198;">[</span>1,2,3,4,5<span style="color: #2aa198;">]</span>.select <span style="color: #2aa198;">{</span> |num|  num.even?  <span style="color: #2aa198;">}</span>   <span style="color: #93a1a1;">#</span><span style="color: #93a1a1;">=&gt; [2, 4]</span>
</pre>
</div>
</li>
<li>js里面是filter
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">[</span>1, 2, 3, 4, 5<span style="color: #2aa198;">]</span>.filter<span style="color: #2aa198;">(</span>one =&gt; one % 2 === 0<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 2, 4 ]</span>
</pre>
</div>
</li>
</ul>
</li>
<li>寻找array成员的index使用indexOf和lastIndexOf
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">[</span>1, 2, 3, 4, 5, 1<span style="color: #2aa198;">]</span>.indexOf<span style="color: #2aa198;">(</span>1<span style="color: #2aa198;">)</span>   <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">0</span>
<span style="color: #2aa198;">[</span>1, 2, 3, 4, 5, 1<span style="color: #2aa198;">]</span>.lastIndexOf<span style="color: #2aa198;">(</span>1<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">5</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-1-4-6" class="outline-5">
<h5 id="sec-9-1-4-6">SORTING ARRAYS</h5>
<div class="outline-text-5" id="text-9-1-4-6">
<ul class="org-ul">
<li>sorting是经常拿来举例子的功能,相比大家非常熟悉:
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">[</span>1, 3, 5, 7, 2, 4, 6<span style="color: #2aa198;">]</span>.sort<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>a, b<span style="color: #b58900;">)</span> =&gt; a - b<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 1, 2, 3, 4, 5, 6, 7 ]</span>
</pre>
</div>
</li>
<li>js的sort有一定的内在逻辑:
<ul class="org-ul">
<li>如果callback返回值小于0,那么a就b前面(自然顺序)
</li>
<li>如果callback返回值为0,a和b是平等的
</li>
<li>如果callback返回值大于0,那么a就在b后面
</li>
</ul>
</li>
<li>所以如果想逆序排序呢,就是后面减去前面
<div class="org-src-container">

<pre class="src src-js"><span style="color: #2aa198;">[</span>1, 3, 5, 7, 2, 4, 6<span style="color: #2aa198;">]</span>.sort<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>a, b<span style="color: #b58900;">)</span> =&gt; b - a<span style="color: #2aa198;">)</span> <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 7, 6, 5, 4, 3, 2, 1 ]</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9-1-5" class="outline-4">
<h4 id="sec-9-1-5">Resuing built-in array functions</h4>
<div class="outline-text-4" id="text-9-1-5">
<ul class="org-ul">
<li>我们完全可以使用object来模拟数组,但是不推荐
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">Maps</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li>在以前,当我们要使用map这种数据结构的时候,object看起来是一个天然的map
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">dictionary</span> = <span style="color: #2aa198;">{</span>
  <span style="color: #2aa198;">"one"</span>: 1,
  <span style="color: #2aa198;">"two"</span>: 2,
  <span style="color: #2aa198;">"three"</span>: 3
<span style="color: #2aa198;">}</span>;
</pre>
</div>
</li>
<li>这种"看起来没什么问题"的例子却隐藏着很多问题,比如我们试图访问dictionary的域
constructor,本来应该返回undefined,却返回了function值!
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">dictionary</span> = <span style="color: #2aa198;">{</span>
  <span style="color: #2aa198;">"one"</span>: 1,
  <span style="color: #2aa198;">"two"</span>: 2,
  <span style="color: #2aa198;">"three"</span>: 3
<span style="color: #2aa198;">}</span>;


console.log<span style="color: #2aa198;">(</span>dictionary<span style="color: #b58900;">[</span><span style="color: #2aa198;">"constructor"</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[Function: Object]                             //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>原因很简单, 所有的objects都会有prototype, 刚好constructor是这个dictionary的
prototype里面"内置"的几个property
</li>
<li>使用object作为Map的另外一个问题,就是object的key,只能是string,所以有时候你的
key不是string的话,会强制调用toString(),这不是我们想要的
</li>
</ul>
</div>
<div id="outline-container-sec-9-2-1" class="outline-4">
<h4 id="sec-9-2-1">Creating our first map</h4>
<div class="outline-text-4" id="text-9-2-1">
<ul class="org-ul">
<li>针对object作为map的各种弊端,我们的es6推出了一个新的内置的容器:map
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjaIslandMap</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Map</span><span style="color: #2aa198;">()</span>;

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja1</span> = <span style="color: #2aa198;">{</span> name: <span style="color: #2aa198;">"Yoshi"</span><span style="color: #2aa198;">}</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja2</span> = <span style="color: #2aa198;">{</span> name: <span style="color: #2aa198;">"Hattori"</span><span style="color: #2aa198;">}</span>;
<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninja3</span> = <span style="color: #2aa198;">{</span> name: <span style="color: #2aa198;">"Kuma"</span><span style="color: #2aa198;">}</span>;

ninjaIslandMap.set<span style="color: #2aa198;">(</span>ninja1, <span style="color: #b58900;">{</span>homeIsland: <span style="color: #2aa198;">"Honshu"</span><span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;
ninjaIslandMap.set<span style="color: #2aa198;">(</span>ninja2, <span style="color: #b58900;">{</span>homeIsland: <span style="color: #2aa198;">"Hokkaido"</span><span style="color: #b58900;">}</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninjaIslandMap.get<span style="color: #b58900;">(</span>ninja1<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjaIslandMap.get<span style="color: #b58900;">(</span>ninja2<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;


console.log<span style="color: #2aa198;">(</span>ninjaIslandMap.has<span style="color: #b58900;">(</span>ninja1<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjaIslandMap.has<span style="color: #b58900;">(</span>ninja3<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjaIslandMap.size<span style="color: #2aa198;">)</span>;
ninjaIslandMap.<span style="color: #859900; font-weight: bold;">delete</span><span style="color: #2aa198;">(</span>ninja1<span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjaIslandMap.size<span style="color: #2aa198;">)</span>;

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ homeIsland: 'Honshu' }                       //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">{ homeIsland: 'Hokkaido' }                     //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">2                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">1                                              //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-2-2" class="outline-4">
<h4 id="sec-9-2-2">Iterating over maps</h4>
<div class="outline-text-4" id="text-9-2-2">
<ul class="org-ul">
<li>我们可以使用所有对数组奏效的循环手段,外加map增加了两个函数:
<ul class="org-ul">
<li>keys()返回所有的key作为一个数组访问
</li>
<li>values()返回所有的value作为一个数组访问
</li>
</ul>
</li>
<li>例子如下
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">directory</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Map</span><span style="color: #2aa198;">()</span>;

directory.set<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Yoshi"</span>, <span style="color: #2aa198;">"+81 26 6462"</span><span style="color: #2aa198;">)</span>;
directory.set<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Kuma"</span>, <span style="color: #2aa198;">"+81 522378 6462"</span><span style="color: #2aa198;">)</span>;
directory.set<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Hiro"</span>, <span style="color: #2aa198;">"+81 76 277 46"</span><span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">item</span> of directory<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  console.log<span style="color: #b58900;">(</span>item<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">key</span> of directory.keys<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  console.log<span style="color: #b58900;">(</span>key<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">value</span> of directory.values<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  console.log<span style="color: #b58900;">(</span>value<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 'Yoshi', '+81 26 6462' ]                     //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 'Kuma', '+81 522378 6462' ]                  //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">[ 'Hiro', '+81 76 277 46' ]                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Yoshi                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Kuma                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hiro                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">+81 26 6462                                    //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">+81 522378 6462                                //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">+81 76 277 46                                  //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">Sets</h3>
<div class="outline-text-3" id="text-9-3">
<ul class="org-ul">
<li>set 也是es6的新feature,使用方法和map也差不多
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">ninjas</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Set</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[</span><span style="color: #2aa198;">"Kuma"</span>, <span style="color: #2aa198;">"Hattori"</span>, <span style="color: #2aa198;">"Yagyu"</span>, <span style="color: #2aa198;">"Hattori"</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninjas.has<span style="color: #b58900;">(</span><span style="color: #2aa198;">"Hattori"</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjas.size<span style="color: #2aa198;">)</span>;

console.log<span style="color: #2aa198;">(</span>ninjas.has<span style="color: #b58900;">(</span><span style="color: #2aa198;">"YoShi"</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>;
ninjas.add<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"YoShi"</span><span style="color: #2aa198;">)</span>;
console.log<span style="color: #2aa198;">(</span>ninjas.size<span style="color: #2aa198;">)</span>;

<span style="color: #859900; font-weight: bold;">for</span> <span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">ninja</span> of ninjas<span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  console.log<span style="color: #b58900;">(</span>ninja<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>

<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">true                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">3                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">false                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">4                                              //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Kuma                                           //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Hattori                                        //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Yagyu                                          //</span>
<span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">YoShi                                          //</span>
<span style="color: #93a1a1;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Chapter 10: Wrangling regular expresions</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>现在的程序开发完全离不开正则表达式,虽然可以避免使用正则表达式,但是很多长达半
页的代码可能只需要一行正则表达式来进行处理
</li>
<li>打开每一个js的库,你都会发现,在如下的几种任务中,正则表达式的应用最为流行:
<ul class="org-ul">
<li>处理HTML nodes字符串
</li>
<li>在CSS selector表达式中定位某些selector
</li>
<li>确定某个element时候具有一个特定的classname
</li>
<li>input validation
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">Why regular expressions rock</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>先看一个正则表达式的例子,我们要验证用户在form里面的输入是不是符合US的九位邮
政编码.postal code(也叫ZIP code)的格式如下
<pre class="example">
99999-9999
</pre>
</li>
<li>我们先来看看,"半页"的很容易写出bug的代码
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">isThisAZipCode</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">candidate</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">typeof</span> candidate !== <span style="color: #2aa198;">"string"</span> ||
      candidate.length != 1<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
  <span style="color: #b58900;">}</span>

  <span style="color: #859900; font-weight: bold;">for</span> <span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">n</span> = 0; n &lt; candidate.length; n++<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #268bd2;">c</span> = candidate<span style="color: #268bd2;">[</span>n<span style="color: #268bd2;">]</span>;
    <span style="color: #859900; font-weight: bold;">switch</span><span style="color: #268bd2;">(</span>n<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">{</span>
    <span style="color: #859900; font-weight: bold;">case</span> 0: <span style="color: #859900; font-weight: bold;">case</span> 1: <span style="color: #859900; font-weight: bold;">case</span> 2: <span style="color: #859900; font-weight: bold;">case</span> 3: <span style="color: #859900; font-weight: bold;">case</span> 4:
    <span style="color: #859900; font-weight: bold;">case</span> 6: <span style="color: #859900; font-weight: bold;">case</span> 7: <span style="color: #859900; font-weight: bold;">case</span> 8: <span style="color: #859900; font-weight: bold;">case</span> 9:
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span> c &lt; <span style="color: #2aa198;">'0'</span> || c &gt; <span style="color: #2aa198;">'9'</span><span style="color: #6c71c4;">)</span> <span style="color: #6c71c4;">{</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
      <span style="color: #6c71c4;">}</span>
    <span style="color: #859900; font-weight: bold;">case</span> 5:
      <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #6c71c4;">(</span>c != <span style="color: #2aa198;">'-'</span><span style="color: #6c71c4;">)</span> <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">false</span>;
      <span style="color: #859900; font-weight: bold;">break</span>;
    <span style="color: #268bd2;">}</span>
  <span style="color: #b58900;">}</span>
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">true</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>然后我们再来看看我们的"一行"正则表达式. 高下立判
<div class="org-src-container">

<pre class="src src-js"><span style="color: #859900; font-weight: bold;">function</span> <span style="color: #268bd2;">isThisAZipCode</span><span style="color: #2aa198;">(</span><span style="color: #268bd2;">candidate</span><span style="color: #2aa198;">)</span> <span style="color: #2aa198;">{</span>
  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">/^\d{5}-\d{4}$/</span>.test<span style="color: #b58900;">(</span>candidate<span style="color: #b58900;">)</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
</li>
<li>TODO
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">Chapter 11: Code modularization techniques</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li>目前为止,我们已经了解了javascript的主要特性,比如function, object, collection,
regular expression
</li>
<li>这些特性可以帮助我们解决一个特定的问题, 但是,当我们的代码急剧膨胀的时候,我们
迫切的需要一种方法来帮助我们组织管理代码.
</li>
<li>现代的代码管理系统已经证明,一个大的代码库不利于对代码的理解.所以推荐的方法是
把代码分成相对独立的模块(module),模块间的耦合要松
</li>
<li>如果把object和function看做是我们管理代码的小的单元的话,那么module就是一个比
较大的管理代码的单元
</li>
<li>如果你了解js的话,你会发现js原来在global vairable上面的使用太多了.每当我们在
全局使用var定义一个变量,或者在function里面忘记使用var来定义'局部变量'的时候,
总会产生一个全局变量
</li>
<li>全局变量在软件工程上面被看做是一个anti-pattern,因为代码库任何地方的代码都可
以去更改这个变量
</li>
</ul>
</div>
<div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1">Modularizing code in pre-ES6 JavaScript</h3>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
